<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>SAMRAI: SAMRAI::pdat::ArrayData&lt; TYPE &gt; Class Template Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.7 -->
<div class="tabs">
  <ul>
    <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="namespaces.html"><span>Namespaces</span></a></li>
    <li id="current"><a href="annotated.html"><span>Classes</span></a></li>
    <li><a href="files.html"><span>Files</span></a></li>
    <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
  </ul></div>
<div class="tabs">
  <ul>
    <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
    <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
    <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
  </ul></div>
<div class="nav">
<a class="el" href="namespaceSAMRAI.html">SAMRAI</a>::<a class="el" href="namespaceSAMRAI_1_1pdat.html">pdat</a>::<a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html">ArrayData</a></div>
<h1>SAMRAI::pdat::ArrayData&lt; TYPE &gt; Class Template Reference</h1><!-- doxytag: class="SAMRAI::pdat::ArrayData" -->Class ArrayData&lt;TYPE&gt; is a basic templated array structure defined over the index space of a box (with a specified depth) that provides the support for the various standard array-based patch data subclasses.  
<a href="#_details">More...</a>
<p>
<code>#include &lt;source/SAMRAI/pdat/ArrayData.h&gt;</code>
<p>
<a href="classSAMRAI_1_1pdat_1_1ArrayData-members.html">List of all members.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Types</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef <a class="el" href="classSAMRAI_1_1pdat_1_1ArrayDataIterator.html">ArrayDataIterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html#a81236e34d1a8432a2ec8f1b8dbba0ab">Iterator</a></td></tr>

<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html#8d7105ba88246dd898f0e8c1cb8de25a">ArrayData</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html#0ac3abeccf53bd6acb6a606cc41e526f">ArrayData</a> (const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">hier::Box</a> &amp;box, int depth)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html#b6c570cfb8bac255c4deb8fed4c55978">~ArrayData</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html#16721ea5363e314c4b1084cb07a08243">initializeArray</a> (const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">hier::Box</a> &amp;box, int depth)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html#a1de5f50684118225e51d00cce1ef5b7">isInitialized</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns true when the array has been properly initialized and storage has been allocated; otherwise, return false.  <a href="#a1de5f50684118225e51d00cce1ef5b7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html#c20e9b3e32e6cb1d77e660d9996cf965">undefineData</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">hier::Box</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html#617a92b78721e98451ac103395264a48">getBox</a> () const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html#556e170e3ff39f710525e95241d8f8b2">getDepth</a> () const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html#c0b3c159c4037535ee8513e4e4610c9c">getOffset</a> () const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">TYPE *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html#a1f5262caa564ba1509be0a29a9269c7">getPointer</a> (const int d=0)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">const TYPE *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html#b9088960667dba3281a48140bb85b548">getPointer</a> (const int d=0) const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">TYPE &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html#e4b18dee5f303569aa1349e29c2db943">operator()</a> (const <a class="el" href="classSAMRAI_1_1hier_1_1Index.html">hier::Index</a> &amp;i, const int d)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">const TYPE &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html#8ab94080f044ad960c9949ab8084cbce">operator()</a> (const <a class="el" href="classSAMRAI_1_1hier_1_1Index.html">hier::Index</a> &amp;i, const int d) const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html#a5236d567261cd29c10acafb85cea6bc">copy</a> (const <a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html">ArrayData</a>&lt; TYPE &gt; &amp;src, const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">hier::Box</a> &amp;box)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html#12d5491f610d5eb999937137c97f70c6">copy</a> (const <a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html">ArrayData</a>&lt; TYPE &gt; &amp;src, const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">hier::Box</a> &amp;box, const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a> &amp;src_shift)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html#bdb4a218f3b0bd5e336de05be155459c">copy</a> (const <a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html">ArrayData</a>&lt; TYPE &gt; &amp;src, const <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">hier::BoxContainer</a> &amp;boxes, const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a> &amp;src_shift)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html#7f8298bcb031689648189877f60ef4c4">copyDepth</a> (int dst_depth, const <a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html">ArrayData</a>&lt; TYPE &gt; &amp;src, int src_depth, const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">hier::Box</a> &amp;box)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html#546a49c7a43435719eb23cddf307c75a">sum</a> (const <a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html">ArrayData</a>&lt; TYPE &gt; &amp;src, const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">hier::Box</a> &amp;box)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html#6b4cbf834645f7c3860b27ab2d3671e7">sum</a> (const <a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html">ArrayData</a>&lt; TYPE &gt; &amp;src, const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">hier::Box</a> &amp;box, const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a> &amp;src_shift)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html#c55ad9b3847deda1cd8c4e27ff927515">sum</a> (const <a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html">ArrayData</a>&lt; TYPE &gt; &amp;src, const <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">hier::BoxContainer</a> &amp;boxes, const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a> &amp;src_shift)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html#43dfb9390a244cf1d91e57f8f2a7bbca">getDataStreamSize</a> (const <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">hier::BoxContainer</a> &amp;boxes, const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a> &amp;src_shift) const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html#5749782cdde566714e1a301c6b6ff215">packStream</a> (<a class="el" href="classSAMRAI_1_1tbox_1_1MessageStream.html">tbox::MessageStream</a> &amp;stream, const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">hier::Box</a> &amp;dest_box, const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a> &amp;src_shift) const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html#d887a30457731973f7d81bbf9b51a4f0">packStream</a> (<a class="el" href="classSAMRAI_1_1tbox_1_1MessageStream.html">tbox::MessageStream</a> &amp;stream, const <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">hier::BoxContainer</a> &amp;dest_boxes, const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a> &amp;src_shift) const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html#2772d6ae19bcf06c96c6b61a1d00b092">unpackStream</a> (<a class="el" href="classSAMRAI_1_1tbox_1_1MessageStream.html">tbox::MessageStream</a> &amp;stream, const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">hier::Box</a> &amp;dest_box, const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a> &amp;src_offset)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html#f3f9813305196b6177eb912dc6ee5c4a">unpackStream</a> (<a class="el" href="classSAMRAI_1_1tbox_1_1MessageStream.html">tbox::MessageStream</a> &amp;stream, const <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">hier::BoxContainer</a> &amp;dest_boxes, const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a> &amp;src_offset)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html#c5927e484570420e28cb53ded1e6fd4a">unpackStreamAndSum</a> (<a class="el" href="classSAMRAI_1_1tbox_1_1MessageStream.html">tbox::MessageStream</a> &amp;stream, const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">hier::Box</a> &amp;dest_box, const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a> &amp;src_offset)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html#4b7272aec1daea63a01bb2ea1bc4eef9">unpackStreamAndSum</a> (<a class="el" href="classSAMRAI_1_1tbox_1_1MessageStream.html">tbox::MessageStream</a> &amp;stream, const <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">hier::BoxContainer</a> &amp;dest_boxes, const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a> &amp;src_offset)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html#67ebb8f53913afa73557cf87c1e59c23">fillAll</a> (const TYPE &amp;t)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html#3edb587b90c00e2416a628537bb7d370">fillAll</a> (const TYPE &amp;t, const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">hier::Box</a> &amp;box)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html#0bea85dadac71f1c4916a1ef96cae0ff">fill</a> (const TYPE &amp;t, const int d=0)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html#b6d34044fbf094e5d6232dbb77890f47">fill</a> (const TYPE &amp;t, const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">hier::Box</a> &amp;box, const int d=0)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html#a306965444085da3028e755434aa6914">getFromDatabase</a> (<a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Database.html">tbox::Database</a> &gt; database)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html#bb9500be57784243cad889cb25542e04">putToDatabase</a> (<a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Database.html">tbox::Database</a> &gt; database, bool data_only=false)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html#0819c390b7413ffb06f6f0a4fafd84a3">getSpecializedFromDatabase</a> (<a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Database.html">tbox::Database</a> &gt; database)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html#e19a13ddd22960dfdd9029d350bd02fa">putSpecializedToDatabase</a> (<a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Database.html">tbox::Database</a> &gt; database)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">const <a class="el" href="classSAMRAI_1_1tbox_1_1Dimension.html">tbox::Dimension</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html#b175089d3974fc07c00e68f26d740dfc">getDim</a> () const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html#9212b539cc95d5224c3296f4fd71a1b6">invalidateArray</a> (const <a class="el" href="classSAMRAI_1_1tbox_1_1Dimension.html">tbox::Dimension</a> &amp;dim)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Invalidate an array as opposed to initializing it.  <a href="#9212b539cc95d5224c3296f4fd71a1b6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html#e144e0b8b78e6232516ebb1d27f13706">isValid</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns true if the array is valid.  <a href="#e144e0b8b78e6232516ebb1d27f13706"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Static Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html#788c953e3a9cb5fd90d81014c506ead7">canEstimateStreamSizeFromBox</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">static size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html#106a6f4ed3a59d07ac7bbbfc5b0409b0">getSizeOfData</a> (const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">hier::Box</a> &amp;box, int depth)</td></tr>

<tr><td colspan="2"><br><h2>Friends</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html#de0663646028b48693fec33b8c0ee4cb">tbox::Array&lt; ArrayData&lt; TYPE &gt; &gt;</a></td></tr>

</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
<h3>template&lt;class TYPE&gt;<br>
 class SAMRAI::pdat::ArrayData&lt; TYPE &gt;</h3>

Class ArrayData&lt;TYPE&gt; is a basic templated array structure defined over the index space of a box (with a specified depth) that provides the support for the various standard array-based patch data subclasses. 
<p>
The data storage is in (i,...,k,d) order, where i,...,k indicates spatial indices and the d indicates the component at that location. Memory allocation is in column-major ordering (e.g., Fortran style) so that the leftmost index runs fastest in memory.<p>
The data type TYPE must define a default constructor (that takes no arguments) and also the assignment operator. Note that a number of functions only work for standard built-in types (bool, char, double, float, and int). To use this class with other user-defined types, many of these functions will need to be specialized, especially those that deal with message packing and unpacking. 
<p>
<hr><h2>Member Typedef Documentation</h2>
<a class="anchor" name="a81236e34d1a8432a2ec8f1b8dbba0ab"></a><!-- doxytag: member="SAMRAI::pdat::ArrayData::Iterator" ref="a81236e34d1a8432a2ec8f1b8dbba0ab" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classSAMRAI_1_1pdat_1_1ArrayDataIterator.html">ArrayDataIterator</a> <a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html">SAMRAI::pdat::ArrayData</a>&lt; TYPE &gt;::<a class="el" href="classSAMRAI_1_1pdat_1_1ArrayDataIterator.html">Iterator</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The array data iterator iterates over the elements of a box associated with an <a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html">ArrayData</a> object. This typedef is convenient link to the <a class="el" href="classSAMRAI_1_1pdat_1_1ArrayDataIterator.html">ArrayDataIterator</a> class. 
</div>
</div><p>
<hr><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" name="8d7105ba88246dd898f0e8c1cb8de25a"></a><!-- doxytag: member="SAMRAI::pdat::ArrayData::ArrayData" ref="8d7105ba88246dd898f0e8c1cb8de25a" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html">SAMRAI::pdat::ArrayData</a>&lt; TYPE &gt;::<a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html">ArrayData</a>           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The default constructor creates an empty array data object. The <a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html#16721ea5363e314c4b1084cb07a08243">initializeArray()</a> member function must be called before the array can be used. 
</div>
</div><p>
<a class="anchor" name="0ac3abeccf53bd6acb6a606cc41e526f"></a><!-- doxytag: member="SAMRAI::pdat::ArrayData::ArrayData" ref="0ac3abeccf53bd6acb6a606cc41e526f" args="(const hier::Box &amp;box, int depth)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html">SAMRAI::pdat::ArrayData</a>&lt; TYPE &gt;::<a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html">ArrayData</a>           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">hier::Box</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>box</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>depth</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Construct an array data object.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>box</em>&nbsp;</td><td>Const reference to box object describing the spatial extents of the index space associated with the array data object. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>depth</em>&nbsp;</td><td>Integer number of data values at each spatial location in the array. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="b6c570cfb8bac255c4deb8fed4c55978"></a><!-- doxytag: member="SAMRAI::pdat::ArrayData::~ArrayData" ref="b6c570cfb8bac255c4deb8fed4c55978" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html">SAMRAI::pdat::ArrayData</a>&lt; TYPE &gt;::~<a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html">ArrayData</a>           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The destructor for an array data object releases all memory allocated for the array elements. 
</div>
</div><p>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="788c953e3a9cb5fd90d81014c506ead7"></a><!-- doxytag: member="SAMRAI::pdat::ArrayData::canEstimateStreamSizeFromBox" ref="788c953e3a9cb5fd90d81014c506ead7" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">SAMRAI_INLINE_KEYWORD bool <a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html">SAMRAI::pdat::ArrayData</a>&lt; TYPE &gt;::canEstimateStreamSizeFromBox           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Static member function that returns tru when the amount of buffer space in a message stream can be estimated from box only. For built-in types (bool, char, double, float, int, and dcomplex), this routine returns true. For other data types (template paramters) that may require special handling, a different implementation must be provided. 
</div>
</div><p>
<a class="anchor" name="106a6f4ed3a59d07ac7bbbfc5b0409b0"></a><!-- doxytag: member="SAMRAI::pdat::ArrayData::getSizeOfData" ref="106a6f4ed3a59d07ac7bbbfc5b0409b0" args="(const hier::Box &amp;box, int depth)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">SAMRAI_INLINE_KEYWORD size_t <a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html">SAMRAI::pdat::ArrayData</a>&lt; TYPE &gt;::getSizeOfData           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">hier::Box</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>box</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>depth</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Static member function that returns the amount of memory space needed to store data of given depth on a box.<p>
Note that this function is only defined for the standard data types: bool, char, double, float, int, and dcomplex. It must be provided for other template parameter types.<p>
<dl compact><dt><b>Returns:</b></dt><dd>size_t value indicating the amount of memory space needed for the data.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>box</em>&nbsp;</td><td>Const reference to box object describing the spatial extents of the array data index region of interest. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>depth</em>&nbsp;</td><td>Integer number of data values at each spatial location in the array. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="16721ea5363e314c4b1084cb07a08243"></a><!-- doxytag: member="SAMRAI::pdat::ArrayData::initializeArray" ref="16721ea5363e314c4b1084cb07a08243" args="(const hier::Box &amp;box, int depth)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html">SAMRAI::pdat::ArrayData</a>&lt; TYPE &gt;::initializeArray           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">hier::Box</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>box</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>depth</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Initialize the size of array data and depth. This method is somewhat poorly named as the data is NOT initialized to anything to avoid the performance cost of the data initialization.<p>
Use undefineData to initialize the data.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>box</em>&nbsp;</td><td>Const reference to box object describing the spatial extents of the index space associated with the array data object. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>depth</em>&nbsp;</td><td>Integer number of data values at each spatial location in the array. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="a1de5f50684118225e51d00cce1ef5b7"></a><!-- doxytag: member="SAMRAI::pdat::ArrayData::isInitialized" ref="a1de5f50684118225e51d00cce1ef5b7" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">SAMRAI_INLINE_KEYWORD bool <a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html">SAMRAI::pdat::ArrayData</a>&lt; TYPE &gt;::isInitialized           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns true when the array has been properly initialized and storage has been allocated; otherwise, return false. 
<p>
Note: Only arrays that have been initialized can do anything useful. Initialize an uninitialized array by calling the <a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html#16721ea5363e314c4b1084cb07a08243">initializeArray()</a> method. 
</div>
</div><p>
<a class="anchor" name="c20e9b3e32e6cb1d77e660d9996cf965"></a><!-- doxytag: member="SAMRAI::pdat::ArrayData::undefineData" ref="c20e9b3e32e6cb1d77e660d9996cf965" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html">SAMRAI::pdat::ArrayData</a>&lt; TYPE &gt;::undefineData           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set the array data to an ``undefined'' state appropriate for the data type. For example, for float and double, this means setting data to signaling NaNs that cause a floating point assertion when used in a numerical expression without being set to valid values. 
</div>
</div><p>
<a class="anchor" name="617a92b78721e98451ac103395264a48"></a><!-- doxytag: member="SAMRAI::pdat::ArrayData::getBox" ref="617a92b78721e98451ac103395264a48" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">SAMRAI_INLINE_KEYWORD const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">hier::Box</a> &amp; <a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html">SAMRAI::pdat::ArrayData</a>&lt; TYPE &gt;::getBox           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return the box over which the array is defined. 
</div>
</div><p>
<a class="anchor" name="556e170e3ff39f710525e95241d8f8b2"></a><!-- doxytag: member="SAMRAI::pdat::ArrayData::getDepth" ref="556e170e3ff39f710525e95241d8f8b2" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">SAMRAI_INLINE_KEYWORD int <a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html">SAMRAI::pdat::ArrayData</a>&lt; TYPE &gt;::getDepth           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return the depth (e.g., the number of data values at each spatial location) of this array. 
</div>
</div><p>
<a class="anchor" name="c0b3c159c4037535ee8513e4e4610c9c"></a><!-- doxytag: member="SAMRAI::pdat::ArrayData::getOffset" ref="c0b3c159c4037535ee8513e4e4610c9c" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">SAMRAI_INLINE_KEYWORD int <a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html">SAMRAI::pdat::ArrayData</a>&lt; TYPE &gt;::getOffset           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return the offset (e.g., the number of data values for each depth component) of this array. 
</div>
</div><p>
<a class="anchor" name="a1f5262caa564ba1509be0a29a9269c7"></a><!-- doxytag: member="SAMRAI::pdat::ArrayData::getPointer" ref="a1f5262caa564ba1509be0a29a9269c7" args="(const int d=0)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">SAMRAI_INLINE_KEYWORD TYPE * <a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html">SAMRAI::pdat::ArrayData</a>&lt; TYPE &gt;::getPointer           </td>
          <td>(</td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>d</em> = <code>0</code>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get a non-const pointer to the beginning of the given depth component of this data array. 
</div>
</div><p>
<a class="anchor" name="b9088960667dba3281a48140bb85b548"></a><!-- doxytag: member="SAMRAI::pdat::ArrayData::getPointer" ref="b9088960667dba3281a48140bb85b548" args="(const int d=0) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">SAMRAI_INLINE_KEYWORD const TYPE * <a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html">SAMRAI::pdat::ArrayData</a>&lt; TYPE &gt;::getPointer           </td>
          <td>(</td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>d</em> = <code>0</code>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get a const pointer to the beginning of the given depth component of this data array. 
</div>
</div><p>
<a class="anchor" name="e4b18dee5f303569aa1349e29c2db943"></a><!-- doxytag: member="SAMRAI::pdat::ArrayData::operator()" ref="e4b18dee5f303569aa1349e29c2db943" args="(const hier::Index &amp;i, const int d)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">SAMRAI_INLINE_KEYWORD TYPE &amp; <a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html">SAMRAI::pdat::ArrayData</a>&lt; TYPE &gt;::operator()           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1Index.html">hier::Index</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>d</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return reference to value in this array associated with the given box index and depth component. 
</div>
</div><p>
<a class="anchor" name="8ab94080f044ad960c9949ab8084cbce"></a><!-- doxytag: member="SAMRAI::pdat::ArrayData::operator()" ref="8ab94080f044ad960c9949ab8084cbce" args="(const hier::Index &amp;i, const int d) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">SAMRAI_INLINE_KEYWORD const TYPE &amp; <a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html">SAMRAI::pdat::ArrayData</a>&lt; TYPE &gt;::operator()           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1Index.html">hier::Index</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>d</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return const reference to value in this array associated with the given box index and depth component. 
</div>
</div><p>
<a class="anchor" name="a5236d567261cd29c10acafb85cea6bc"></a><!-- doxytag: member="SAMRAI::pdat::ArrayData::copy" ref="a5236d567261cd29c10acafb85cea6bc" args="(const ArrayData&lt; TYPE &gt; &amp;src, const hier::Box &amp;box)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html">SAMRAI::pdat::ArrayData</a>&lt; TYPE &gt;::copy           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html">ArrayData</a>&lt; TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">hier::Box</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>box</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Copy data from the source array data object to this array data object on the specified index space region.<p>
Note that this routine assumes that the source and destination box regions require no shifting to make them consistent. This routine will intersect the specified box with the source and destination boxes to find the region of intersection.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>src</em>&nbsp;</td><td>Const reference to source array data object. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>box</em>&nbsp;</td><td>Const reference to box object describing the spatial extents of the index space region over which to perform the copy operation. Note: the box is in either the source or destination index space (which are assumed to be the same). </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="12d5491f610d5eb999937137c97f70c6"></a><!-- doxytag: member="SAMRAI::pdat::ArrayData::copy" ref="12d5491f610d5eb999937137c97f70c6" args="(const ArrayData&lt; TYPE &gt; &amp;src, const hier::Box &amp;box, const hier::IntVector &amp;src_shift)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html">SAMRAI::pdat::ArrayData</a>&lt; TYPE &gt;::copy           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html">ArrayData</a>&lt; TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">hier::Box</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>box</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>src_shift</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Copy data from the source array data object to this array data object on the specified index space region.<p>
Note that this routine assumes that the source array box region must be shifted to be consistent with the destination (this) array box region. This routine will intersect the specified box with the destination box and shifted source box to find the region of intersection.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>src</em>&nbsp;</td><td>Const reference to source array data object. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>box</em>&nbsp;</td><td>Const reference to box object describing the spatial extents of the index space region over which to perform the copy operation. Note: the box is in the destination index space. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>src_shift</em>&nbsp;</td><td>Const reference to shift vector used to put the source array data box into the index space region of this array data object. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="bdb4a218f3b0bd5e336de05be155459c"></a><!-- doxytag: member="SAMRAI::pdat::ArrayData::copy" ref="bdb4a218f3b0bd5e336de05be155459c" args="(const ArrayData&lt; TYPE &gt; &amp;src, const hier::BoxContainer &amp;boxes, const hier::IntVector &amp;src_shift)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html">SAMRAI::pdat::ArrayData</a>&lt; TYPE &gt;::copy           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html">ArrayData</a>&lt; TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">hier::BoxContainer</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>boxes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>src_shift</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Copy data from the source array data object to this array data object on the specified index space regions.<p>
Note that this routine assumes that the source array box region must be shifted to be consistent with the destination (this) array box region. This routine will intersect the specified boxes with the destination box and shifted source box to find the regions of intersection.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>src</em>&nbsp;</td><td>Const reference to source array data object. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>boxes</em>&nbsp;</td><td>Const reference to box list describing the spatial extents of the index space regions over which to perform the copy operation. Note: the boxes are in the destination index space. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>src_shift</em>&nbsp;</td><td>Const reference to shift vector used to put the source array data box into the index space region of this array data object. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="7f8298bcb031689648189877f60ef4c4"></a><!-- doxytag: member="SAMRAI::pdat::ArrayData::copyDepth" ref="7f8298bcb031689648189877f60ef4c4" args="(int dst_depth, const ArrayData&lt; TYPE &gt; &amp;src, int src_depth, const hier::Box &amp;box)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html">SAMRAI::pdat::ArrayData</a>&lt; TYPE &gt;::copyDepth           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>dst_depth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html">ArrayData</a>&lt; TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>src_depth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">hier::Box</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>box</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Copy given source depth of source array data object to given destination depth of this array data object on the specified index space region.<p>
Note that this routine assumes that the source and destination box regions require no shifting to make them consistent. This routine will intersect the specified box with the source and destination boxes to find the region of intersection.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dst_depth</em>&nbsp;</td><td>Integer depth of destination array. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>src</em>&nbsp;</td><td>Const reference to source array data object. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>src_depth</em>&nbsp;</td><td>Integer depth of source array. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>box</em>&nbsp;</td><td>Const reference to box object describing the spatial extents of the index space region over which to perform the copy operation. Note: the box is in either the source or destination index space (which are assumed to be the same). </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="546a49c7a43435719eb23cddf307c75a"></a><!-- doxytag: member="SAMRAI::pdat::ArrayData::sum" ref="546a49c7a43435719eb23cddf307c75a" args="(const ArrayData&lt; TYPE &gt; &amp;src, const hier::Box &amp;box)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html">SAMRAI::pdat::ArrayData</a>&lt; TYPE &gt;::sum           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html">ArrayData</a>&lt; TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">hier::Box</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>box</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Add data from the source array data object to this array data object on the specified index space region.<p>
Note that this routine assumes that the source and destination box regions require no shifting to make them consistent. This routine will intersect the specified box with the source and destination boxes to find the region of intersection.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>src</em>&nbsp;</td><td>Const reference to source array data object. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>box</em>&nbsp;</td><td>Const reference to box object describing the spatial extents of the index space region over which to perform the sum operation. Note: the box is in either the source or destination index space (which are assumed to be the same). </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="6b4cbf834645f7c3860b27ab2d3671e7"></a><!-- doxytag: member="SAMRAI::pdat::ArrayData::sum" ref="6b4cbf834645f7c3860b27ab2d3671e7" args="(const ArrayData&lt; TYPE &gt; &amp;src, const hier::Box &amp;box, const hier::IntVector &amp;src_shift)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html">SAMRAI::pdat::ArrayData</a>&lt; TYPE &gt;::sum           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html">ArrayData</a>&lt; TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">hier::Box</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>box</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>src_shift</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Add data from the source array data object to this array data object on the specified index space region.<p>
Note that this routine assumes that the source array box region must be shifted to be consistent with the destination (this) array box region. This routine will intersect the specified box with the destination box and shifted source box to find the region of intersection.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>src</em>&nbsp;</td><td>Const reference to source array data object. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>box</em>&nbsp;</td><td>Const reference to box object describing the spatial extents of the index space region over which to perform the sum operation. Note: the box is in the destination index space. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>src_shift</em>&nbsp;</td><td>Const reference to shift vector used to put the source array data box into the index space region of this array data object. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="c55ad9b3847deda1cd8c4e27ff927515"></a><!-- doxytag: member="SAMRAI::pdat::ArrayData::sum" ref="c55ad9b3847deda1cd8c4e27ff927515" args="(const ArrayData&lt; TYPE &gt; &amp;src, const hier::BoxContainer &amp;boxes, const hier::IntVector &amp;src_shift)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html">SAMRAI::pdat::ArrayData</a>&lt; TYPE &gt;::sum           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html">ArrayData</a>&lt; TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">hier::BoxContainer</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>boxes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>src_shift</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Add data from the source array data object to this array data object on the specified index space regions.<p>
Note that this routine assumes that the source array box region must be shifted to be consistent with the destination (this) array box region. This routine will intersect the specified boxes with the destination box and shifted source box to find the regions of intersection.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>src</em>&nbsp;</td><td>Const reference to source array data object. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>boxes</em>&nbsp;</td><td>Const reference to box list describing the spatial extents of the index space regions over which to perform the sum operation. Note: the boxes are in the destination index space. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>src_shift</em>&nbsp;</td><td>Const reference to shift vector used to put the source array data box into the index space region of this array data object. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="43dfb9390a244cf1d91e57f8f2a7bbca"></a><!-- doxytag: member="SAMRAI::pdat::ArrayData::getDataStreamSize" ref="43dfb9390a244cf1d91e57f8f2a7bbca" args="(const hier::BoxContainer &amp;boxes, const hier::IntVector &amp;src_shift) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">SAMRAI_INLINE_KEYWORD int <a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html">SAMRAI::pdat::ArrayData</a>&lt; TYPE &gt;::getDataStreamSize           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">hier::BoxContainer</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>boxes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>src_shift</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Calculate the number of bytes needed to stream the data living in the specified box domains. This routine is only defined for the built-in types of bool, char, double, float, int, and dcomplex. For all other types, a specialized implementation must be provided.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>boxes</em>&nbsp;</td><td>Const reference to box list describing the spatial extents of the index space regions of interest. Note: the boxes are assumed to be in the index space of this array data object. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>src_shift</em>&nbsp;</td><td>Const reference to vector used to shift the given boxes into the index space region of this array data object. Note: this argument is currently ignored. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="5749782cdde566714e1a301c6b6ff215"></a><!-- doxytag: member="SAMRAI::pdat::ArrayData::packStream" ref="5749782cdde566714e1a301c6b6ff215" args="(tbox::MessageStream &amp;stream, const hier::Box &amp;dest_box, const hier::IntVector &amp;src_shift) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html">SAMRAI::pdat::ArrayData</a>&lt; TYPE &gt;::packStream           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1tbox_1_1MessageStream.html">tbox::MessageStream</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">hier::Box</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>dest_box</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>src_shift</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Pack data living on the specified index region into the stream.<p>
Note that this routine assumes that the given box region must be shifted to be consistent with the source (this) array box region.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>stream</em>&nbsp;</td><td>Reference to stream into which to pack data. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dest_box</em>&nbsp;</td><td>Const reference to box describing the spatial extent of the destination index space region of interest. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>src_shift</em>&nbsp;</td><td>Const reference to vector used to shift the given box into the index space region of this (source) array data object.</td></tr>
  </table>
</dl>
Note: The shifted box must lie completely within the index space of this array data object. When assertion checking is active, the routine will abort if the box is not contained in the index space of this array. 
</div>
</div><p>
<a class="anchor" name="d887a30457731973f7d81bbf9b51a4f0"></a><!-- doxytag: member="SAMRAI::pdat::ArrayData::packStream" ref="d887a30457731973f7d81bbf9b51a4f0" args="(tbox::MessageStream &amp;stream, const hier::BoxContainer &amp;dest_boxes, const hier::IntVector &amp;src_shift) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html">SAMRAI::pdat::ArrayData</a>&lt; TYPE &gt;::packStream           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1tbox_1_1MessageStream.html">tbox::MessageStream</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">hier::BoxContainer</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>dest_boxes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>src_shift</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Pack data living on the specified index regions into the stream.<p>
Note that this routine assumes that the given box regions must be shifted to be consistent with the source (this) array box region.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>stream</em>&nbsp;</td><td>Reference to stream into which to pack data. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dest_boxes</em>&nbsp;</td><td>Const reference to boxes describing the spatial extents of the destination index space regions of interest. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>src_shift</em>&nbsp;</td><td>Const reference to vector used to shift the given boxes into the index space region of this (source) array data object.</td></tr>
  </table>
</dl>
Note: The shifted boxes must lie completely within the index space of this array. If compiled with assertions enabled, the routine will abort if the shifted boxes are not contained in the index space of this array. 
</div>
</div><p>
<a class="anchor" name="2772d6ae19bcf06c96c6b61a1d00b092"></a><!-- doxytag: member="SAMRAI::pdat::ArrayData::unpackStream" ref="2772d6ae19bcf06c96c6b61a1d00b092" args="(tbox::MessageStream &amp;stream, const hier::Box &amp;dest_box, const hier::IntVector &amp;src_offset)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html">SAMRAI::pdat::ArrayData</a>&lt; TYPE &gt;::unpackStream           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1tbox_1_1MessageStream.html">tbox::MessageStream</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">hier::Box</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>dest_box</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>src_offset</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Unpack data from the stream into the index region specified.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>stream</em>&nbsp;</td><td>Reference to stream from which to unpack data. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dest_box</em>&nbsp;</td><td>Const reference to box describing the spatial extent of the destination index space region of interest. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>src_offset</em>&nbsp;</td><td>Const reference to vector used to offset box into the index space region of some (source) array data object. Currently, this argument is ignored.</td></tr>
  </table>
</dl>
Note: The given box must lie completely within the index space of this array data object. When assertion checking is active, the routine will abort if the box is not contained in the index space of this array. 
</div>
</div><p>
<a class="anchor" name="f3f9813305196b6177eb912dc6ee5c4a"></a><!-- doxytag: member="SAMRAI::pdat::ArrayData::unpackStream" ref="f3f9813305196b6177eb912dc6ee5c4a" args="(tbox::MessageStream &amp;stream, const hier::BoxContainer &amp;dest_boxes, const hier::IntVector &amp;src_offset)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html">SAMRAI::pdat::ArrayData</a>&lt; TYPE &gt;::unpackStream           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1tbox_1_1MessageStream.html">tbox::MessageStream</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">hier::BoxContainer</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>dest_boxes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>src_offset</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Unpack data from the stream into the index regions specified.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>stream</em>&nbsp;</td><td>Reference to stream from which to unpack data. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dest_boxes</em>&nbsp;</td><td>Const reference to box list describing the spatial extents of the destination index space regions of interest. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>src_offset</em>&nbsp;</td><td>Const reference to vector used to offset the given boxes into the index space region of some (source) array data object. Currently, this argument is ignored.</td></tr>
  </table>
</dl>
Note: The given boxes must lie completely within the index space of this array data object. When assertion checking is active, the routine will abort if some box is not contained in the index space of this array. 
</div>
</div><p>
<a class="anchor" name="c5927e484570420e28cb53ded1e6fd4a"></a><!-- doxytag: member="SAMRAI::pdat::ArrayData::unpackStreamAndSum" ref="c5927e484570420e28cb53ded1e6fd4a" args="(tbox::MessageStream &amp;stream, const hier::Box &amp;dest_box, const hier::IntVector &amp;src_offset)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html">SAMRAI::pdat::ArrayData</a>&lt; TYPE &gt;::unpackStreamAndSum           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1tbox_1_1MessageStream.html">tbox::MessageStream</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">hier::Box</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>dest_box</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>src_offset</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Unpack data from the stream and add to the array in the index region specified.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>stream</em>&nbsp;</td><td>Reference to stream from which to unpack data. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dest_box</em>&nbsp;</td><td>Const reference to box describing the spatial extent of the destination index space region of interest. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>src_offset</em>&nbsp;</td><td>Const reference to vector used to offset the given box into the index space region of some (source) array data object. Currently, this argument is ignored.</td></tr>
  </table>
</dl>
Note: The given box must lie completely within the index space of this array data object. When assertion checking is active, the routine will abort if the box is not contained in the index space of this array. 
</div>
</div><p>
<a class="anchor" name="4b7272aec1daea63a01bb2ea1bc4eef9"></a><!-- doxytag: member="SAMRAI::pdat::ArrayData::unpackStreamAndSum" ref="4b7272aec1daea63a01bb2ea1bc4eef9" args="(tbox::MessageStream &amp;stream, const hier::BoxContainer &amp;dest_boxes, const hier::IntVector &amp;src_offset)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html">SAMRAI::pdat::ArrayData</a>&lt; TYPE &gt;::unpackStreamAndSum           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1tbox_1_1MessageStream.html">tbox::MessageStream</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">hier::BoxContainer</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>dest_boxes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>src_offset</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Unpack data from the stream and ad to the array in the index region specified.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>stream</em>&nbsp;</td><td>Reference to stream from which to unpack data. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dest_boxes</em>&nbsp;</td><td>Const reference to box list describing the spatial extents of the destination index space regions of interest. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>src_offset</em>&nbsp;</td><td>Const reference to vector used to offset the given boxes into the index space region of some (source) array data object. Currently, this argument is ignored.</td></tr>
  </table>
</dl>
Note: The given boxes must lie completely within the index space of this array. If compiled with assertions enabled, the routine will abort if some box is not contained in the index space of this array. 
</div>
</div><p>
<a class="anchor" name="67ebb8f53913afa73557cf87c1e59c23"></a><!-- doxytag: member="SAMRAI::pdat::ArrayData::fillAll" ref="67ebb8f53913afa73557cf87c1e59c23" args="(const TYPE &amp;t)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html">SAMRAI::pdat::ArrayData</a>&lt; TYPE &gt;::fillAll           </td>
          <td>(</td>
          <td class="paramtype">const TYPE &amp;&nbsp;</td>
          <td class="paramname"> <em>t</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Fill all array values with value t. 
</div>
</div><p>
<a class="anchor" name="3edb587b90c00e2416a628537bb7d370"></a><!-- doxytag: member="SAMRAI::pdat::ArrayData::fillAll" ref="3edb587b90c00e2416a628537bb7d370" args="(const TYPE &amp;t, const hier::Box &amp;box)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html">SAMRAI::pdat::ArrayData</a>&lt; TYPE &gt;::fillAll           </td>
          <td>(</td>
          <td class="paramtype">const TYPE &amp;&nbsp;</td>
          <td class="paramname"> <em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">hier::Box</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>box</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Fill all array values within the box with value t. 
</div>
</div><p>
<a class="anchor" name="0bea85dadac71f1c4916a1ef96cae0ff"></a><!-- doxytag: member="SAMRAI::pdat::ArrayData::fill" ref="0bea85dadac71f1c4916a1ef96cae0ff" args="(const TYPE &amp;t, const int d=0)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html">SAMRAI::pdat::ArrayData</a>&lt; TYPE &gt;::fill           </td>
          <td>(</td>
          <td class="paramtype">const TYPE &amp;&nbsp;</td>
          <td class="paramname"> <em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>d</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Fill all array values associated with depth component d with the value t. 
</div>
</div><p>
<a class="anchor" name="b6d34044fbf094e5d6232dbb77890f47"></a><!-- doxytag: member="SAMRAI::pdat::ArrayData::fill" ref="b6d34044fbf094e5d6232dbb77890f47" args="(const TYPE &amp;t, const hier::Box &amp;box, const int d=0)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html">SAMRAI::pdat::ArrayData</a>&lt; TYPE &gt;::fill           </td>
          <td>(</td>
          <td class="paramtype">const TYPE &amp;&nbsp;</td>
          <td class="paramname"> <em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">hier::Box</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>box</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>d</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Fill all array values associated with depth component d within the box with the value t. 
</div>
</div><p>
<a class="anchor" name="a306965444085da3028e755434aa6914"></a><!-- doxytag: member="SAMRAI::pdat::ArrayData::getFromDatabase" ref="a306965444085da3028e755434aa6914" args="(tbox::Pointer&lt; tbox::Database &gt; database)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html">SAMRAI::pdat::ArrayData</a>&lt; TYPE &gt;::getFromDatabase           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Database.html">tbox::Database</a> &gt;&nbsp;</td>
          <td class="paramname"> <em>database</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Check to make sure that the class version and restart file version are equal. If so, read in data from database. This routine calls <a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html#0819c390b7413ffb06f6f0a4fafd84a3">getSpecializedFromDatabase()</a> to read in the proper data type.<p>
Assertions: database must be a non-null pointer. 
</div>
</div><p>
<a class="anchor" name="bb9500be57784243cad889cb25542e04"></a><!-- doxytag: member="SAMRAI::pdat::ArrayData::putToDatabase" ref="bb9500be57784243cad889cb25542e04" args="(tbox::Pointer&lt; tbox::Database &gt; database, bool data_only=false)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html">SAMRAI::pdat::ArrayData</a>&lt; TYPE &gt;::putToDatabase           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Database.html">tbox::Database</a> &gt;&nbsp;</td>
          <td class="paramname"> <em>database</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>data_only</em> = <code>false</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Write out array data object data to database. This routine calls <a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html#e19a13ddd22960dfdd9029d350bd02fa">putSpecializedToDatabase()</a> to read in the proper data type. The default behavior (boolean argument is false) is to put all data members in database. Otherwise, only the array contents are written out.<p>
Assertions: database must be a non-null pointer. 
</div>
</div><p>
<a class="anchor" name="0819c390b7413ffb06f6f0a4fafd84a3"></a><!-- doxytag: member="SAMRAI::pdat::ArrayData::getSpecializedFromDatabase" ref="0819c390b7413ffb06f6f0a4fafd84a3" args="(tbox::Pointer&lt; tbox::Database &gt; database)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html">SAMRAI::pdat::ArrayData</a>&lt; TYPE &gt;::getSpecializedFromDatabase           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Database.html">tbox::Database</a> &gt;&nbsp;</td>
          <td class="paramname"> <em>database</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Use specialized template method to get the correct behavior when reading in the array of data. 
</div>
</div><p>
<a class="anchor" name="e19a13ddd22960dfdd9029d350bd02fa"></a><!-- doxytag: member="SAMRAI::pdat::ArrayData::putSpecializedToDatabase" ref="e19a13ddd22960dfdd9029d350bd02fa" args="(tbox::Pointer&lt; tbox::Database &gt; database)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html">SAMRAI::pdat::ArrayData</a>&lt; TYPE &gt;::putSpecializedToDatabase           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Database.html">tbox::Database</a> &gt;&nbsp;</td>
          <td class="paramname"> <em>database</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Use specialized template method to get the correct behavior when writing out the array of data. 
</div>
</div><p>
<a class="anchor" name="b175089d3974fc07c00e68f26d740dfc"></a><!-- doxytag: member="SAMRAI::pdat::ArrayData::getDim" ref="b175089d3974fc07c00e68f26d740dfc" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">SAMRAI_INLINE_KEYWORD const <a class="el" href="classSAMRAI_1_1tbox_1_1Dimension.html">tbox::Dimension</a> &amp; <a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html">SAMRAI::pdat::ArrayData</a>&lt; TYPE &gt;::getDim           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return the dimension of this object. 
</div>
</div><p>
<a class="anchor" name="9212b539cc95d5224c3296f4fd71a1b6"></a><!-- doxytag: member="SAMRAI::pdat::ArrayData::invalidateArray" ref="9212b539cc95d5224c3296f4fd71a1b6" args="(const tbox::Dimension &amp;dim)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html">SAMRAI::pdat::ArrayData</a>&lt; TYPE &gt;::invalidateArray           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1tbox_1_1Dimension.html">tbox::Dimension</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>dim</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Invalidate an array as opposed to initializing it. 
<p>
The box associated with the array will be set to empty so intersections will be the empty set. 
</div>
</div><p>
<a class="anchor" name="e144e0b8b78e6232516ebb1d27f13706"></a><!-- doxytag: member="SAMRAI::pdat::ArrayData::isValid" ref="e144e0b8b78e6232516ebb1d27f13706" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">SAMRAI_INLINE_KEYWORD bool <a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html">SAMRAI::pdat::ArrayData</a>&lt; TYPE &gt;::isValid           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns true if the array is valid. 
<p>
Invalid state can be set using the invalidateArray method. 
</div>
</div><p>
<hr><h2>Friends And Related Function Documentation</h2>
<a class="anchor" name="de0663646028b48693fec33b8c0ee4cb"></a><!-- doxytag: member="SAMRAI::pdat::ArrayData::tbox::Array&lt; ArrayData&lt; TYPE &gt; &gt;" ref="de0663646028b48693fec33b8c0ee4cb" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="classSAMRAI_1_1tbox_1_1Array.html">tbox::Array</a>&lt; <a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html">ArrayData</a>&lt; TYPE &gt; &gt;<code> [friend]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<hr>The documentation for this class was generated from the following files:<ul>
<li>source/SAMRAI/pdat/<a class="el" href="ArrayData_8h.html">ArrayData.h</a><li>source/SAMRAI/pdat/<a class="el" href="ArrayData_8C.html">ArrayData.C</a><li>source/SAMRAI/pdat/<a class="el" href="ArrayData_8I.html">ArrayData.I</a></ul>
<hr size="1"><address style="align: right;"><small>Generated on Wed Jan 18 16:05:17 2012 for SAMRAI by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.7 </small></address>
</body>
</html>
