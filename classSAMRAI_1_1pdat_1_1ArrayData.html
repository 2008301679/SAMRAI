<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>SAMRAI: SAMRAI::pdat::ArrayData&lt; TYPE &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath"><a class="el" href="namespaceSAMRAI.html">SAMRAI</a>::<a class="el" href="namespaceSAMRAI_1_1pdat.html">pdat</a>::<a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html">ArrayData</a>
  </div>
</div>
<div class="contents">
<h1>SAMRAI::pdat::ArrayData&lt; TYPE &gt; Class Template Reference</h1><!-- doxytag: class="SAMRAI::pdat::ArrayData" -->
<p>Class ArrayData&lt;TYPE&gt; is a basic templated array structure defined over the index space of a box (with a specified depth) that provides the support for the various standard array-based patch data subclasses.  
<a href="#_details">More...</a></p>

<p><code>#include &lt;source/SAMRAI/pdat/ArrayData.h&gt;</code></p>

<p><a href="classSAMRAI_1_1pdat_1_1ArrayData-members.html">List of all members.</a></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Public Types</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classSAMRAI_1_1pdat_1_1ArrayDataIterator.html">ArrayDataIterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html#a976c6d94322e0d51314326a8b59b1c15">iterator</a></td></tr>
<tr><td colspan="2"><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html#ab85545f64fea9e646fdedf5465a79690">ArrayData</a> (const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">hier::Box</a> &amp;box, unsigned int depth)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html#a35c56024c6c190d0dd8a1d06b3317dc9">~ArrayData</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html#ae1615473899d1b85fef64ff6546163d2">isInitialized</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns true when the array has been properly initialized and storage has been allocated; otherwise, return false.  <a href="#ae1615473899d1b85fef64ff6546163d2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html#ac7a19caf53e71e3f71aff559bdaac39e">undefineData</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">hier::Box</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html#ab00f0a1c318b91276ac540ede5b5cc60">getBox</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">unsigned int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html#a8cdee70250c48be83e9d0fe53c66db0e">getDepth</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html#ad8530fafba1d6f60d058baae4b81eafb">getOffset</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">TYPE *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html#a51f24a9917363c2208e62987e8a01434">getPointer</a> (const unsigned int d=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const TYPE *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html#a827655c7333f29686891d0c4a7a68ded">getPointer</a> (const unsigned int d=0) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">TYPE &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html#abfaf511a5bc1d533cc1fe74e59af1eec">operator()</a> (const <a class="el" href="classSAMRAI_1_1hier_1_1Index.html">hier::Index</a> &amp;i, const unsigned int d)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const TYPE &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html#a043c519055ff49ac7b2ab3e23e5562a5">operator()</a> (const <a class="el" href="classSAMRAI_1_1hier_1_1Index.html">hier::Index</a> &amp;i, const unsigned int d) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html#a1f95dbc4aa63153b64793cff7b5e3245">copy</a> (const <a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html">ArrayData</a>&lt; TYPE &gt; &amp;src, const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">hier::Box</a> &amp;box)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html#a630b971ca04cf416888eb907208dfc0f">copy</a> (const <a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html">ArrayData</a>&lt; TYPE &gt; &amp;src, const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">hier::Box</a> &amp;box, const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a> &amp;src_shift)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html#aa7f4c8540edaa30f7929643fbbf5512f">copy</a> (const <a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html">ArrayData</a>&lt; TYPE &gt; &amp;src, const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">hier::Box</a> &amp;box, const <a class="el" href="classSAMRAI_1_1hier_1_1Transformation.html">hier::Transformation</a> &amp;transformation)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html#ac7d9dd6fe2177de262d9a4d7d37d6701">copy</a> (const <a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html">ArrayData</a>&lt; TYPE &gt; &amp;src, const <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">hier::BoxContainer</a> &amp;boxes, const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a> &amp;src_shift)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html#a61e0cb2479f6d91b2733fce32638194a">copy</a> (const <a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html">ArrayData</a>&lt; TYPE &gt; &amp;src, const <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">hier::BoxContainer</a> &amp;boxes, const <a class="el" href="classSAMRAI_1_1hier_1_1Transformation.html">hier::Transformation</a> &amp;transformation)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html#afdbdce691025dcd126e29a244db79703">copyDepth</a> (unsigned int dst_depth, const <a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html">ArrayData</a>&lt; TYPE &gt; &amp;src, unsigned int src_depth, const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">hier::Box</a> &amp;box)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html#aef60177ead7c3614f062590f7712609f">sum</a> (const <a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html">ArrayData</a>&lt; TYPE &gt; &amp;src, const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">hier::Box</a> &amp;box)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html#af41f9d64e0345c2ac79a2dcb0514d779">sum</a> (const <a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html">ArrayData</a>&lt; TYPE &gt; &amp;src, const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">hier::Box</a> &amp;box, const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a> &amp;src_shift)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html#acfecc435a4deb40a8d854057e80a6ad0">sum</a> (const <a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html">ArrayData</a>&lt; TYPE &gt; &amp;src, const <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">hier::BoxContainer</a> &amp;boxes, const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a> &amp;src_shift)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html#afbc700d1f8df66710c83be31d212b37f">getDataStreamSize</a> (const <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">hier::BoxContainer</a> &amp;boxes, const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a> &amp;src_shift) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html#a6c5415ec52723f7c3e20ce314b2c574c">packStream</a> (<a class="el" href="classSAMRAI_1_1tbox_1_1MessageStream.html">tbox::MessageStream</a> &amp;stream, const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">hier::Box</a> &amp;dest_box, const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a> &amp;src_shift) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html#a0915d10aacd00b27f108354421723ea1">packStream</a> (<a class="el" href="classSAMRAI_1_1tbox_1_1MessageStream.html">tbox::MessageStream</a> &amp;stream, const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">hier::Box</a> &amp;dest_box, const <a class="el" href="classSAMRAI_1_1hier_1_1Transformation.html">hier::Transformation</a> &amp;src_shift) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html#ae9134265a8087de6f6c253715f2ed5d5">packStream</a> (<a class="el" href="classSAMRAI_1_1tbox_1_1MessageStream.html">tbox::MessageStream</a> &amp;stream, const <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">hier::BoxContainer</a> &amp;dest_boxes, const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a> &amp;src_shift) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html#a8019407ee7bd9dcbaaba72c600723762">packStream</a> (<a class="el" href="classSAMRAI_1_1tbox_1_1MessageStream.html">tbox::MessageStream</a> &amp;stream, const <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">hier::BoxContainer</a> &amp;dest_boxes, const <a class="el" href="classSAMRAI_1_1hier_1_1Transformation.html">hier::Transformation</a> &amp;transformation) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html#a00c34907e10e962adb8282b965a6972b">unpackStream</a> (<a class="el" href="classSAMRAI_1_1tbox_1_1MessageStream.html">tbox::MessageStream</a> &amp;stream, const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">hier::Box</a> &amp;dest_box, const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a> &amp;src_offset)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html#a663216993c878358b0f84dc85274c833">unpackStream</a> (<a class="el" href="classSAMRAI_1_1tbox_1_1MessageStream.html">tbox::MessageStream</a> &amp;stream, const <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">hier::BoxContainer</a> &amp;dest_boxes, const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a> &amp;src_offset)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html#abfefa9165703fe930fbf701512b6e039">unpackStreamAndSum</a> (<a class="el" href="classSAMRAI_1_1tbox_1_1MessageStream.html">tbox::MessageStream</a> &amp;stream, const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">hier::Box</a> &amp;dest_box, const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a> &amp;src_offset)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html#a3d2e85ff58edd86fe137912575ded227">unpackStreamAndSum</a> (<a class="el" href="classSAMRAI_1_1tbox_1_1MessageStream.html">tbox::MessageStream</a> &amp;stream, const <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">hier::BoxContainer</a> &amp;dest_boxes, const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a> &amp;src_offset)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html#aa7761b61f741eeee9f8004f94f7df72f">fillAll</a> (const TYPE &amp;t)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html#af027bcf7d6a05db1dc10c1151a1383b9">fillAll</a> (const TYPE &amp;t, const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">hier::Box</a> &amp;box)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html#a1f2c56e4292b31662c0bece4e001a8f5">fill</a> (const TYPE &amp;t, const unsigned int d=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html#acb6dab66a1c885080f69caf657fbb040">fill</a> (const TYPE &amp;t, const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">hier::Box</a> &amp;box, const unsigned int d=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html#a91be5f8fdef47d9c528d64ccaa534014">getFromRestart</a> (const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Database.html">tbox::Database</a> &gt; &amp;restart_db)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html#a8594e2cf67c90729aeb4adf98faabaaf">putToRestart</a> (const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Database.html">tbox::Database</a> &gt; &amp;restart_db) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classSAMRAI_1_1tbox_1_1Dimension.html">tbox::Dimension</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html#a114ecb99a07fdcce73f49cab9ff0b0a4">getDim</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html#afc800893f127830febe13b25b9830b42">isValid</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns true if the array is valid.  <a href="#afc800893f127830febe13b25b9830b42"></a><br/></td></tr>
<tr><td colspan="2"><h2>Static Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html#a054b804e8d0b0970b78b0153ac51a62d">canEstimateStreamSizeFromBox</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html#ac29330cbf66224133871c0d3777a0005">getSizeOfData</a> (const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">hier::Box</a> &amp;box, unsigned int depth)</td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<h3>template&lt;class TYPE&gt;<br/>
 class SAMRAI::pdat::ArrayData&lt; TYPE &gt;</h3>

<p>Class ArrayData&lt;TYPE&gt; is a basic templated array structure defined over the index space of a box (with a specified depth) that provides the support for the various standard array-based patch data subclasses. </p>
<p>The data storage is in (i,...,k,d) order, where i,...,k indicates spatial indices and the d indicates the component at that location. Memory allocation is in column-major ordering (e.g., Fortran style) so that the leftmost index runs fastest in memory.</p>
<p>The data type TYPE must define a default constructor (that takes no arguments) and also the assignment operator. Note that a number of functions only work for standard built-in types (bool, char, double, float, and int). To use this class with other user-defined types, many of these functions will need to be specialized, especially those that deal with message packing and unpacking. </p>
<hr/><h2>Member Typedef Documentation</h2>
<a class="anchor" id="a976c6d94322e0d51314326a8b59b1c15"></a><!-- doxytag: member="SAMRAI::pdat::ArrayData::iterator" ref="a976c6d94322e0d51314326a8b59b1c15" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classSAMRAI_1_1pdat_1_1ArrayDataIterator.html">ArrayDataIterator</a> <a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html">SAMRAI::pdat::ArrayData</a>&lt; TYPE &gt;::<a class="el" href="classSAMRAI_1_1pdat_1_1ArrayDataIterator.html">iterator</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>The array data iterator iterates over the elements of a box associated with an <a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html" title="Class ArrayData&lt;TYPE&gt; is a basic templated array structure defined over the...">ArrayData</a> object. This typedef is convenient link to the <a class="el" href="classSAMRAI_1_1pdat_1_1ArrayDataIterator.html">ArrayDataIterator</a> class. </p>

</div>
</div>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="ab85545f64fea9e646fdedf5465a79690"></a><!-- doxytag: member="SAMRAI::pdat::ArrayData::ArrayData" ref="ab85545f64fea9e646fdedf5465a79690" args="(const hier::Box &amp;box, unsigned int depth)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html">SAMRAI::pdat::ArrayData</a>&lt; TYPE &gt;::<a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html">ArrayData</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">hier::Box</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>box</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>depth</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Construct an array data object.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>box</em>&nbsp;</td><td>Const reference to box object describing the spatial extents of the index space associated with the array data object. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>depth</em>&nbsp;</td><td>Integer number of data values at each spatial location in the array.</td></tr>
  </table>
  </dd>
</dl>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>depth &gt; 0 </dd></dl>

<p>References <a class="el" href="Utilities_8h_source.html#l00110">TBOX_ASSERT</a>, and <a class="el" href="ArrayData_8C_source.html#l01017">SAMRAI::pdat::ArrayData&lt; TYPE &gt;::undefineData()</a>.</p>

</div>
</div>
<a class="anchor" id="a35c56024c6c190d0dd8a1d06b3317dc9"></a><!-- doxytag: member="SAMRAI::pdat::ArrayData::~ArrayData" ref="a35c56024c6c190d0dd8a1d06b3317dc9" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html">SAMRAI::pdat::ArrayData</a>&lt; TYPE &gt;::~<a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html">ArrayData</a> </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>The destructor for an array data object releases all memory allocated for the array elements. </p>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a054b804e8d0b0970b78b0153ac51a62d"></a><!-- doxytag: member="SAMRAI::pdat::ArrayData::canEstimateStreamSizeFromBox" ref="a054b804e8d0b0970b78b0153ac51a62d" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html">SAMRAI::pdat::ArrayData</a>&lt; TYPE &gt;::canEstimateStreamSizeFromBox </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Static member function that returns true when the amount of buffer space in a message stream can be estimated from box only. For built-in types (bool, char, double, float, int, and dcomplex), this routine returns true. For other data types (template paramters) that may require special handling, a different implementation must be provided. </p>

</div>
</div>
<a class="anchor" id="ac29330cbf66224133871c0d3777a0005"></a><!-- doxytag: member="SAMRAI::pdat::ArrayData::getSizeOfData" ref="ac29330cbf66224133871c0d3777a0005" args="(const hier::Box &amp;box, unsigned int depth)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html">SAMRAI::pdat::ArrayData</a>&lt; TYPE &gt;::getSizeOfData </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">hier::Box</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>box</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>depth</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Static member function that returns the amount of memory space needed to store data of given depth on a box.</p>
<p>Note that this function is only defined for the standard data types: bool, char, double, float, int, and dcomplex. It must be provided for other template parameter types.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>size_t value indicating the amount of memory space needed for the data.</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>box</em>&nbsp;</td><td>Const reference to box object describing the spatial extents of the array data index region of interest. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>depth</em>&nbsp;</td><td>Integer number of data values at each spatial location in the array. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="MemoryUtilities_8C_source.html#l00191">SAMRAI::tbox::MemoryUtilities::align()</a>, and <a class="el" href="Box_8h_source.html#l00667">SAMRAI::hier::Box::size()</a>.</p>

</div>
</div>
<a class="anchor" id="ae1615473899d1b85fef64ff6546163d2"></a><!-- doxytag: member="SAMRAI::pdat::ArrayData::isInitialized" ref="ae1615473899d1b85fef64ff6546163d2" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html">SAMRAI::pdat::ArrayData</a>&lt; TYPE &gt;::isInitialized </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns true when the array has been properly initialized and storage has been allocated; otherwise, return false. </p>
<p>Note: Only arrays that have been initialized can do anything useful. </p>

</div>
</div>
<a class="anchor" id="ac7a19caf53e71e3f71aff559bdaac39e"></a><!-- doxytag: member="SAMRAI::pdat::ArrayData::undefineData" ref="ac7a19caf53e71e3f71aff559bdaac39e" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html">SAMRAI::pdat::ArrayData</a>&lt; TYPE &gt;::undefineData </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Set the array data to an ``undefined'' state appropriate for the data type. For example, for float and double, this means setting data to signaling NaNs that cause a floating point assertion when used in a numerical expression without being set to valid values. </p>

<p>References <a class="el" href="ArrayData_8C_source.html#l00831">SAMRAI::pdat::ArrayData&lt; TYPE &gt;::fillAll()</a>.</p>

<p>Referenced by <a class="el" href="ArrayData_8C_source.html#l00073">SAMRAI::pdat::ArrayData&lt; TYPE &gt;::ArrayData()</a>.</p>

</div>
</div>
<a class="anchor" id="ab00f0a1c318b91276ac540ede5b5cc60"></a><!-- doxytag: member="SAMRAI::pdat::ArrayData::getBox" ref="ab00f0a1c318b91276ac540ede5b5cc60" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">hier::Box</a> &amp; <a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html">SAMRAI::pdat::ArrayData</a>&lt; TYPE &gt;::getBox </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the box over which the array is defined. </p>

<p>Referenced by <a class="el" href="ArrayDataNormOpsReal_8C_source.html#l00043">SAMRAI::math::ArrayDataNormOpsReal&lt; TYPE &gt;::abs()</a>, <a class="el" href="ArrayDataNormOpsInteger_8C_source.html#l00036">SAMRAI::math::ArrayDataNormOpsInteger::abs()</a>, <a class="el" href="ArrayDataNormOpsComplex_8C_source.html#l00036">SAMRAI::math::ArrayDataNormOpsComplex::abs()</a>, <a class="el" href="ArrayDataAccess_8h_source.html#l00037">SAMRAI::pdat::ArrayDataAccess::access()</a>, <a class="el" href="ArrayDataAccess_8C_source.html#l00021">SAMRAI::pdat::access()</a>, <a class="el" href="ArrayDataBasicOps_8C_source.html#l00265">SAMRAI::math::ArrayDataBasicOps&lt; TYPE &gt;::add()</a>, <a class="el" href="ArrayDataBasicOps_8C_source.html#l00155">SAMRAI::math::ArrayDataBasicOps&lt; TYPE &gt;::addScalar()</a>, <a class="el" href="ArrayDataBasicOps_8C_source.html#l01090">SAMRAI::math::ArrayDataBasicOps&lt; TYPE &gt;::axmy()</a>, <a class="el" href="ArrayDataBasicOps_8C_source.html#l00965">SAMRAI::math::ArrayDataBasicOps&lt; TYPE &gt;::axpy()</a>, <a class="el" href="ArrayDataMiscellaneousOpsReal_8C_source.html#l00388">SAMRAI::math::ArrayDataMiscellaneousOpsReal&lt; TYPE &gt;::compareToScalar()</a>, <a class="el" href="ArrayDataMiscellaneousOpsReal_8C_source.html#l00268">SAMRAI::math::ArrayDataMiscellaneousOpsReal&lt; TYPE &gt;::compareToScalarWithControlVolume()</a>, <a class="el" href="ArrayDataMiscellaneousOpsReal_8C_source.html#l00165">SAMRAI::math::ArrayDataMiscellaneousOpsReal&lt; TYPE &gt;::computeConstrProdPos()</a>, <a class="el" href="ArrayDataMiscellaneousOpsReal_8C_source.html#l00041">SAMRAI::math::ArrayDataMiscellaneousOpsReal&lt; TYPE &gt;::computeConstrProdPosWithControlVolume()</a>, <a class="el" href="OutersideData_8C_source.html#l00170">SAMRAI::pdat::OutersideData&lt; TYPE &gt;::copy()</a>, <a class="el" href="OuterfaceData_8C_source.html#l00170">SAMRAI::pdat::OuterfaceData&lt; TYPE &gt;::copy()</a>, <a class="el" href="OutersideData_8C_source.html#l00292">SAMRAI::pdat::OutersideData&lt; TYPE &gt;::copyDepth()</a>, <a class="el" href="OuternodeData_8C_source.html#l00347">SAMRAI::pdat::OuternodeData&lt; TYPE &gt;::copyDepth()</a>, <a class="el" href="OuterfaceData_8C_source.html#l00306">SAMRAI::pdat::OuterfaceData&lt; TYPE &gt;::copyDepth()</a>, <a class="el" href="OuteredgeData_8C_source.html#l00363">SAMRAI::pdat::OuteredgeData&lt; TYPE &gt;::copyDepth()</a>, <a class="el" href="OutersideData_8C_source.html#l00322">SAMRAI::pdat::OutersideData&lt; TYPE &gt;::copyDepth2()</a>, <a class="el" href="OuternodeData_8C_source.html#l00377">SAMRAI::pdat::OuternodeData&lt; TYPE &gt;::copyDepth2()</a>, <a class="el" href="OuterfaceData_8C_source.html#l00336">SAMRAI::pdat::OuterfaceData&lt; TYPE &gt;::copyDepth2()</a>, <a class="el" href="OuteredgeData_8C_source.html#l00409">SAMRAI::pdat::OuteredgeData&lt; TYPE &gt;::copyDepth2()</a>, <a class="el" href="ArrayDataBasicOps_8C_source.html#l00612">SAMRAI::math::ArrayDataBasicOps&lt; TYPE &gt;::divide()</a>, <a class="el" href="ArrayDataOperationUtilities_8C_source.html#l00170">SAMRAI::pdat::ArrayDataOperationUtilities&lt; TYPE, OP &gt;::doArrayDataBufferOperationOnBox()</a>, <a class="el" href="ArrayDataOperationUtilities_8C_source.html#l00032">SAMRAI::pdat::ArrayDataOperationUtilities&lt; TYPE, OP &gt;::doArrayDataOperationOnBox()</a>, <a class="el" href="ArrayDataNormOpsReal_8C_source.html#l00957">SAMRAI::math::ArrayDataNormOpsReal&lt; TYPE &gt;::dot()</a>, <a class="el" href="ArrayDataNormOpsComplex_8C_source.html#l00513">SAMRAI::math::ArrayDataNormOpsComplex::dot()</a>, <a class="el" href="ArrayDataNormOpsReal_8C_source.html#l00833">SAMRAI::math::ArrayDataNormOpsReal&lt; TYPE &gt;::dotWithControlVolume()</a>, <a class="el" href="ArrayDataNormOpsComplex_8C_source.html#l00395">SAMRAI::math::ArrayDataNormOpsComplex::dotWithControlVolume()</a>, <a class="el" href="ArrayDataNormOpsReal_8C_source.html#l01058">SAMRAI::math::ArrayDataNormOpsReal&lt; TYPE &gt;::integral()</a>, <a class="el" href="ArrayDataNormOpsComplex_8C_source.html#l00613">SAMRAI::math::ArrayDataNormOpsComplex::integral()</a>, <a class="el" href="ArrayDataNormOpsReal_8C_source.html#l00326">SAMRAI::math::ArrayDataNormOpsReal&lt; TYPE &gt;::L1Norm()</a>, <a class="el" href="ArrayDataNormOpsComplex_8C_source.html#l00314">SAMRAI::math::ArrayDataNormOpsComplex::L1Norm()</a>, <a class="el" href="ArrayDataNormOpsReal_8C_source.html#l00226">SAMRAI::math::ArrayDataNormOpsReal&lt; TYPE &gt;::L1NormWithControlVolume()</a>, <a class="el" href="ArrayDataNormOpsComplex_8C_source.html#l00216">SAMRAI::math::ArrayDataNormOpsComplex::L1NormWithControlVolume()</a>, <a class="el" href="ArrayDataBasicOps_8C_source.html#l00824">SAMRAI::math::ArrayDataBasicOps&lt; TYPE &gt;::linearSum()</a>, <a class="el" href="ArrayDataBasicOps_8C_source.html#l01293">SAMRAI::math::ArrayDataBasicOps&lt; TYPE &gt;::max()</a>, <a class="el" href="ArrayDataNormOpsReal_8C_source.html#l00750">SAMRAI::math::ArrayDataNormOpsReal&lt; TYPE &gt;::maxNorm()</a>, <a class="el" href="ArrayDataNormOpsComplex_8C_source.html#l01024">SAMRAI::math::ArrayDataNormOpsComplex::maxNorm()</a>, <a class="el" href="ArrayDataNormOpsReal_8C_source.html#l00646">SAMRAI::math::ArrayDataNormOpsReal&lt; TYPE &gt;::maxNormWithControlVolume()</a>, <a class="el" href="ArrayDataNormOpsComplex_8C_source.html#l00923">SAMRAI::math::ArrayDataNormOpsComplex::maxNormWithControlVolume()</a>, <a class="el" href="ArrayDataMiscellaneousOpsReal_8C_source.html#l00724">SAMRAI::math::ArrayDataMiscellaneousOpsReal&lt; TYPE &gt;::maxPointwiseDivide()</a>, <a class="el" href="ArrayDataBasicOps_8C_source.html#l01213">SAMRAI::math::ArrayDataBasicOps&lt; TYPE &gt;::min()</a>, <a class="el" href="ArrayDataMiscellaneousOpsReal_8C_source.html#l00828">SAMRAI::math::ArrayDataMiscellaneousOpsReal&lt; TYPE &gt;::minPointwiseDivide()</a>, <a class="el" href="ArrayDataBasicOps_8C_source.html#l00497">SAMRAI::math::ArrayDataBasicOps&lt; TYPE &gt;::multiply()</a>, <a class="el" href="ArrayDataBasicOps_8C_source.html#l00724">SAMRAI::math::ArrayDataBasicOps&lt; TYPE &gt;::reciprocal()</a>, <a class="el" href="SimpleCellRobinBcCoefs_8C_source.html#l00598">SAMRAI::solv::SimpleCellRobinBcCoefs::restoreDirichletData()</a>, <a class="el" href="ArrayDataBasicOps_8C_source.html#l00043">SAMRAI::math::ArrayDataBasicOps&lt; TYPE &gt;::scale()</a>, <a class="el" href="SimpleCellRobinBcCoefs_8C_source.html#l00176">SAMRAI::solv::SimpleCellRobinBcCoefs::setBcCoefs()</a>, <a class="el" href="ArrayDataBasicOps_8C_source.html#l01374">SAMRAI::math::ArrayDataBasicOps&lt; TYPE &gt;::setRandomValues()</a>, <a class="el" href="ArrayDataBasicOps_8C_source.html#l00381">SAMRAI::math::ArrayDataBasicOps&lt; TYPE &gt;::subtract()</a>, <a class="el" href="ArrayDataNormOpsReal_8C_source.html#l00139">SAMRAI::math::ArrayDataNormOpsReal&lt; TYPE &gt;::sumControlVolumes()</a>, <a class="el" href="ArrayDataNormOpsComplex_8C_source.html#l00130">SAMRAI::math::ArrayDataNormOpsComplex::sumControlVolumes()</a>, <a class="el" href="ArrayDataMiscellaneousOpsReal_8C_source.html#l00616">SAMRAI::math::ArrayDataMiscellaneousOpsReal&lt; TYPE &gt;::testReciprocal()</a>, <a class="el" href="ArrayDataMiscellaneousOpsReal_8C_source.html#l00488">SAMRAI::math::ArrayDataMiscellaneousOpsReal&lt; TYPE &gt;::testReciprocalWithControlVolume()</a>, <a class="el" href="ArrayDataNormOpsReal_8C_source.html#l00548">SAMRAI::math::ArrayDataNormOpsReal&lt; TYPE &gt;::weightedL2Norm()</a>, <a class="el" href="ArrayDataNormOpsComplex_8C_source.html#l00826">SAMRAI::math::ArrayDataNormOpsComplex::weightedL2Norm()</a>, <a class="el" href="ArrayDataNormOpsReal_8C_source.html#l00432">SAMRAI::math::ArrayDataNormOpsReal&lt; TYPE &gt;::weightedL2NormWithControlVolume()</a>, and <a class="el" href="ArrayDataNormOpsComplex_8C_source.html#l00711">SAMRAI::math::ArrayDataNormOpsComplex::weightedL2NormWithControlVolume()</a>.</p>

</div>
</div>
<a class="anchor" id="a8cdee70250c48be83e9d0fe53c66db0e"></a><!-- doxytag: member="SAMRAI::pdat::ArrayData::getDepth" ref="a8cdee70250c48be83e9d0fe53c66db0e" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned int <a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html">SAMRAI::pdat::ArrayData</a>&lt; TYPE &gt;::getDepth </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the depth (e.g., the number of data values at each spatial location) of this array. </p>

<p>Referenced by <a class="el" href="ArrayDataNormOpsReal_8C_source.html#l00043">SAMRAI::math::ArrayDataNormOpsReal&lt; TYPE &gt;::abs()</a>, <a class="el" href="ArrayDataNormOpsInteger_8C_source.html#l00036">SAMRAI::math::ArrayDataNormOpsInteger::abs()</a>, <a class="el" href="ArrayDataNormOpsComplex_8C_source.html#l00036">SAMRAI::math::ArrayDataNormOpsComplex::abs()</a>, <a class="el" href="ArrayDataBasicOps_8C_source.html#l00265">SAMRAI::math::ArrayDataBasicOps&lt; TYPE &gt;::add()</a>, <a class="el" href="ArrayDataBasicOps_8C_source.html#l00155">SAMRAI::math::ArrayDataBasicOps&lt; TYPE &gt;::addScalar()</a>, <a class="el" href="ArrayDataBasicOps_8C_source.html#l01090">SAMRAI::math::ArrayDataBasicOps&lt; TYPE &gt;::axmy()</a>, <a class="el" href="ArrayDataBasicOps_8C_source.html#l00965">SAMRAI::math::ArrayDataBasicOps&lt; TYPE &gt;::axpy()</a>, <a class="el" href="ArrayDataMiscellaneousOpsReal_8C_source.html#l00388">SAMRAI::math::ArrayDataMiscellaneousOpsReal&lt; TYPE &gt;::compareToScalar()</a>, <a class="el" href="ArrayDataMiscellaneousOpsReal_8C_source.html#l00268">SAMRAI::math::ArrayDataMiscellaneousOpsReal&lt; TYPE &gt;::compareToScalarWithControlVolume()</a>, <a class="el" href="ArrayDataMiscellaneousOpsReal_8C_source.html#l00165">SAMRAI::math::ArrayDataMiscellaneousOpsReal&lt; TYPE &gt;::computeConstrProdPos()</a>, <a class="el" href="ArrayDataMiscellaneousOpsReal_8C_source.html#l00041">SAMRAI::math::ArrayDataMiscellaneousOpsReal&lt; TYPE &gt;::computeConstrProdPosWithControlVolume()</a>, <a class="el" href="ArrayDataBasicOps_8C_source.html#l00612">SAMRAI::math::ArrayDataBasicOps&lt; TYPE &gt;::divide()</a>, <a class="el" href="ArrayDataOperationUtilities_8C_source.html#l00170">SAMRAI::pdat::ArrayDataOperationUtilities&lt; TYPE, OP &gt;::doArrayDataBufferOperationOnBox()</a>, <a class="el" href="ArrayDataOperationUtilities_8C_source.html#l00032">SAMRAI::pdat::ArrayDataOperationUtilities&lt; TYPE, OP &gt;::doArrayDataOperationOnBox()</a>, <a class="el" href="ArrayDataNormOpsReal_8C_source.html#l00957">SAMRAI::math::ArrayDataNormOpsReal&lt; TYPE &gt;::dot()</a>, <a class="el" href="ArrayDataNormOpsComplex_8C_source.html#l00513">SAMRAI::math::ArrayDataNormOpsComplex::dot()</a>, <a class="el" href="ArrayDataNormOpsReal_8C_source.html#l00833">SAMRAI::math::ArrayDataNormOpsReal&lt; TYPE &gt;::dotWithControlVolume()</a>, <a class="el" href="ArrayDataNormOpsComplex_8C_source.html#l00395">SAMRAI::math::ArrayDataNormOpsComplex::dotWithControlVolume()</a>, <a class="el" href="ArrayDataNormOpsReal_8C_source.html#l01058">SAMRAI::math::ArrayDataNormOpsReal&lt; TYPE &gt;::integral()</a>, <a class="el" href="ArrayDataNormOpsComplex_8C_source.html#l00613">SAMRAI::math::ArrayDataNormOpsComplex::integral()</a>, <a class="el" href="ArrayDataNormOpsReal_8C_source.html#l00326">SAMRAI::math::ArrayDataNormOpsReal&lt; TYPE &gt;::L1Norm()</a>, <a class="el" href="ArrayDataNormOpsComplex_8C_source.html#l00314">SAMRAI::math::ArrayDataNormOpsComplex::L1Norm()</a>, <a class="el" href="ArrayDataNormOpsReal_8C_source.html#l00226">SAMRAI::math::ArrayDataNormOpsReal&lt; TYPE &gt;::L1NormWithControlVolume()</a>, <a class="el" href="ArrayDataNormOpsComplex_8C_source.html#l00216">SAMRAI::math::ArrayDataNormOpsComplex::L1NormWithControlVolume()</a>, <a class="el" href="ArrayDataBasicOps_8C_source.html#l00824">SAMRAI::math::ArrayDataBasicOps&lt; TYPE &gt;::linearSum()</a>, <a class="el" href="ArrayDataBasicOps_8C_source.html#l01293">SAMRAI::math::ArrayDataBasicOps&lt; TYPE &gt;::max()</a>, <a class="el" href="ArrayDataNormOpsReal_8C_source.html#l00750">SAMRAI::math::ArrayDataNormOpsReal&lt; TYPE &gt;::maxNorm()</a>, <a class="el" href="ArrayDataNormOpsComplex_8C_source.html#l01024">SAMRAI::math::ArrayDataNormOpsComplex::maxNorm()</a>, <a class="el" href="ArrayDataNormOpsReal_8C_source.html#l00646">SAMRAI::math::ArrayDataNormOpsReal&lt; TYPE &gt;::maxNormWithControlVolume()</a>, <a class="el" href="ArrayDataNormOpsComplex_8C_source.html#l00923">SAMRAI::math::ArrayDataNormOpsComplex::maxNormWithControlVolume()</a>, <a class="el" href="ArrayDataMiscellaneousOpsReal_8C_source.html#l00724">SAMRAI::math::ArrayDataMiscellaneousOpsReal&lt; TYPE &gt;::maxPointwiseDivide()</a>, <a class="el" href="ArrayDataBasicOps_8C_source.html#l01213">SAMRAI::math::ArrayDataBasicOps&lt; TYPE &gt;::min()</a>, <a class="el" href="ArrayDataMiscellaneousOpsReal_8C_source.html#l00828">SAMRAI::math::ArrayDataMiscellaneousOpsReal&lt; TYPE &gt;::minPointwiseDivide()</a>, <a class="el" href="ArrayDataBasicOps_8C_source.html#l00497">SAMRAI::math::ArrayDataBasicOps&lt; TYPE &gt;::multiply()</a>, <a class="el" href="ArrayDataBasicOps_8C_source.html#l00724">SAMRAI::math::ArrayDataBasicOps&lt; TYPE &gt;::reciprocal()</a>, <a class="el" href="ArrayDataBasicOps_8C_source.html#l00043">SAMRAI::math::ArrayDataBasicOps&lt; TYPE &gt;::scale()</a>, <a class="el" href="ArrayDataBasicOps_8C_source.html#l01374">SAMRAI::math::ArrayDataBasicOps&lt; TYPE &gt;::setRandomValues()</a>, <a class="el" href="ArrayDataBasicOps_8C_source.html#l00381">SAMRAI::math::ArrayDataBasicOps&lt; TYPE &gt;::subtract()</a>, <a class="el" href="ArrayDataNormOpsReal_8C_source.html#l00139">SAMRAI::math::ArrayDataNormOpsReal&lt; TYPE &gt;::sumControlVolumes()</a>, <a class="el" href="ArrayDataNormOpsComplex_8C_source.html#l00130">SAMRAI::math::ArrayDataNormOpsComplex::sumControlVolumes()</a>, <a class="el" href="ArrayDataMiscellaneousOpsReal_8C_source.html#l00616">SAMRAI::math::ArrayDataMiscellaneousOpsReal&lt; TYPE &gt;::testReciprocal()</a>, <a class="el" href="ArrayDataMiscellaneousOpsReal_8C_source.html#l00488">SAMRAI::math::ArrayDataMiscellaneousOpsReal&lt; TYPE &gt;::testReciprocalWithControlVolume()</a>, <a class="el" href="ArrayDataNormOpsReal_8C_source.html#l00548">SAMRAI::math::ArrayDataNormOpsReal&lt; TYPE &gt;::weightedL2Norm()</a>, <a class="el" href="ArrayDataNormOpsComplex_8C_source.html#l00826">SAMRAI::math::ArrayDataNormOpsComplex::weightedL2Norm()</a>, <a class="el" href="ArrayDataNormOpsReal_8C_source.html#l00432">SAMRAI::math::ArrayDataNormOpsReal&lt; TYPE &gt;::weightedL2NormWithControlVolume()</a>, and <a class="el" href="ArrayDataNormOpsComplex_8C_source.html#l00711">SAMRAI::math::ArrayDataNormOpsComplex::weightedL2NormWithControlVolume()</a>.</p>

</div>
</div>
<a class="anchor" id="ad8530fafba1d6f60d058baae4b81eafb"></a><!-- doxytag: member="SAMRAI::pdat::ArrayData::getOffset" ref="ad8530fafba1d6f60d058baae4b81eafb" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html">SAMRAI::pdat::ArrayData</a>&lt; TYPE &gt;::getOffset </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the offset (e.g., the number of data values for each depth component) of this array. </p>

<p>Referenced by <a class="el" href="ArrayDataNormOpsReal_8C_source.html#l00043">SAMRAI::math::ArrayDataNormOpsReal&lt; TYPE &gt;::abs()</a>, <a class="el" href="ArrayDataNormOpsInteger_8C_source.html#l00036">SAMRAI::math::ArrayDataNormOpsInteger::abs()</a>, <a class="el" href="ArrayDataNormOpsComplex_8C_source.html#l00036">SAMRAI::math::ArrayDataNormOpsComplex::abs()</a>, <a class="el" href="ArrayDataBasicOps_8C_source.html#l00265">SAMRAI::math::ArrayDataBasicOps&lt; TYPE &gt;::add()</a>, <a class="el" href="ArrayDataBasicOps_8C_source.html#l00155">SAMRAI::math::ArrayDataBasicOps&lt; TYPE &gt;::addScalar()</a>, <a class="el" href="ArrayDataBasicOps_8C_source.html#l01090">SAMRAI::math::ArrayDataBasicOps&lt; TYPE &gt;::axmy()</a>, <a class="el" href="ArrayDataBasicOps_8C_source.html#l00965">SAMRAI::math::ArrayDataBasicOps&lt; TYPE &gt;::axpy()</a>, <a class="el" href="ArrayDataMiscellaneousOpsReal_8C_source.html#l00388">SAMRAI::math::ArrayDataMiscellaneousOpsReal&lt; TYPE &gt;::compareToScalar()</a>, <a class="el" href="ArrayDataMiscellaneousOpsReal_8C_source.html#l00268">SAMRAI::math::ArrayDataMiscellaneousOpsReal&lt; TYPE &gt;::compareToScalarWithControlVolume()</a>, <a class="el" href="ArrayDataMiscellaneousOpsReal_8C_source.html#l00165">SAMRAI::math::ArrayDataMiscellaneousOpsReal&lt; TYPE &gt;::computeConstrProdPos()</a>, <a class="el" href="ArrayDataMiscellaneousOpsReal_8C_source.html#l00041">SAMRAI::math::ArrayDataMiscellaneousOpsReal&lt; TYPE &gt;::computeConstrProdPosWithControlVolume()</a>, <a class="el" href="ArrayDataBasicOps_8C_source.html#l00612">SAMRAI::math::ArrayDataBasicOps&lt; TYPE &gt;::divide()</a>, <a class="el" href="ArrayDataOperationUtilities_8C_source.html#l00170">SAMRAI::pdat::ArrayDataOperationUtilities&lt; TYPE, OP &gt;::doArrayDataBufferOperationOnBox()</a>, <a class="el" href="ArrayDataOperationUtilities_8C_source.html#l00032">SAMRAI::pdat::ArrayDataOperationUtilities&lt; TYPE, OP &gt;::doArrayDataOperationOnBox()</a>, <a class="el" href="ArrayDataNormOpsReal_8C_source.html#l00957">SAMRAI::math::ArrayDataNormOpsReal&lt; TYPE &gt;::dot()</a>, <a class="el" href="ArrayDataNormOpsComplex_8C_source.html#l00513">SAMRAI::math::ArrayDataNormOpsComplex::dot()</a>, <a class="el" href="ArrayDataNormOpsReal_8C_source.html#l00833">SAMRAI::math::ArrayDataNormOpsReal&lt; TYPE &gt;::dotWithControlVolume()</a>, <a class="el" href="ArrayDataNormOpsComplex_8C_source.html#l00395">SAMRAI::math::ArrayDataNormOpsComplex::dotWithControlVolume()</a>, <a class="el" href="ArrayDataNormOpsReal_8C_source.html#l01058">SAMRAI::math::ArrayDataNormOpsReal&lt; TYPE &gt;::integral()</a>, <a class="el" href="ArrayDataNormOpsComplex_8C_source.html#l00613">SAMRAI::math::ArrayDataNormOpsComplex::integral()</a>, <a class="el" href="ArrayDataNormOpsReal_8C_source.html#l00326">SAMRAI::math::ArrayDataNormOpsReal&lt; TYPE &gt;::L1Norm()</a>, <a class="el" href="ArrayDataNormOpsComplex_8C_source.html#l00314">SAMRAI::math::ArrayDataNormOpsComplex::L1Norm()</a>, <a class="el" href="ArrayDataNormOpsReal_8C_source.html#l00226">SAMRAI::math::ArrayDataNormOpsReal&lt; TYPE &gt;::L1NormWithControlVolume()</a>, <a class="el" href="ArrayDataNormOpsComplex_8C_source.html#l00216">SAMRAI::math::ArrayDataNormOpsComplex::L1NormWithControlVolume()</a>, <a class="el" href="ArrayDataBasicOps_8C_source.html#l00824">SAMRAI::math::ArrayDataBasicOps&lt; TYPE &gt;::linearSum()</a>, <a class="el" href="ArrayDataBasicOps_8C_source.html#l01293">SAMRAI::math::ArrayDataBasicOps&lt; TYPE &gt;::max()</a>, <a class="el" href="ArrayDataNormOpsReal_8C_source.html#l00750">SAMRAI::math::ArrayDataNormOpsReal&lt; TYPE &gt;::maxNorm()</a>, <a class="el" href="ArrayDataNormOpsComplex_8C_source.html#l01024">SAMRAI::math::ArrayDataNormOpsComplex::maxNorm()</a>, <a class="el" href="ArrayDataNormOpsReal_8C_source.html#l00646">SAMRAI::math::ArrayDataNormOpsReal&lt; TYPE &gt;::maxNormWithControlVolume()</a>, <a class="el" href="ArrayDataNormOpsComplex_8C_source.html#l00923">SAMRAI::math::ArrayDataNormOpsComplex::maxNormWithControlVolume()</a>, <a class="el" href="ArrayDataMiscellaneousOpsReal_8C_source.html#l00724">SAMRAI::math::ArrayDataMiscellaneousOpsReal&lt; TYPE &gt;::maxPointwiseDivide()</a>, <a class="el" href="ArrayDataBasicOps_8C_source.html#l01213">SAMRAI::math::ArrayDataBasicOps&lt; TYPE &gt;::min()</a>, <a class="el" href="ArrayDataMiscellaneousOpsReal_8C_source.html#l00828">SAMRAI::math::ArrayDataMiscellaneousOpsReal&lt; TYPE &gt;::minPointwiseDivide()</a>, <a class="el" href="ArrayDataBasicOps_8C_source.html#l00497">SAMRAI::math::ArrayDataBasicOps&lt; TYPE &gt;::multiply()</a>, <a class="el" href="ArrayDataBasicOps_8C_source.html#l00724">SAMRAI::math::ArrayDataBasicOps&lt; TYPE &gt;::reciprocal()</a>, <a class="el" href="ArrayDataBasicOps_8C_source.html#l00043">SAMRAI::math::ArrayDataBasicOps&lt; TYPE &gt;::scale()</a>, <a class="el" href="ArrayDataBasicOps_8C_source.html#l01374">SAMRAI::math::ArrayDataBasicOps&lt; TYPE &gt;::setRandomValues()</a>, <a class="el" href="ArrayDataBasicOps_8C_source.html#l00381">SAMRAI::math::ArrayDataBasicOps&lt; TYPE &gt;::subtract()</a>, <a class="el" href="ArrayDataNormOpsReal_8C_source.html#l00139">SAMRAI::math::ArrayDataNormOpsReal&lt; TYPE &gt;::sumControlVolumes()</a>, <a class="el" href="ArrayDataNormOpsComplex_8C_source.html#l00130">SAMRAI::math::ArrayDataNormOpsComplex::sumControlVolumes()</a>, <a class="el" href="ArrayDataMiscellaneousOpsReal_8C_source.html#l00616">SAMRAI::math::ArrayDataMiscellaneousOpsReal&lt; TYPE &gt;::testReciprocal()</a>, <a class="el" href="ArrayDataMiscellaneousOpsReal_8C_source.html#l00488">SAMRAI::math::ArrayDataMiscellaneousOpsReal&lt; TYPE &gt;::testReciprocalWithControlVolume()</a>, <a class="el" href="ArrayDataNormOpsReal_8C_source.html#l00548">SAMRAI::math::ArrayDataNormOpsReal&lt; TYPE &gt;::weightedL2Norm()</a>, <a class="el" href="ArrayDataNormOpsComplex_8C_source.html#l00826">SAMRAI::math::ArrayDataNormOpsComplex::weightedL2Norm()</a>, <a class="el" href="ArrayDataNormOpsReal_8C_source.html#l00432">SAMRAI::math::ArrayDataNormOpsReal&lt; TYPE &gt;::weightedL2NormWithControlVolume()</a>, and <a class="el" href="ArrayDataNormOpsComplex_8C_source.html#l00711">SAMRAI::math::ArrayDataNormOpsComplex::weightedL2NormWithControlVolume()</a>.</p>

</div>
</div>
<a class="anchor" id="a51f24a9917363c2208e62987e8a01434"></a><!-- doxytag: member="SAMRAI::pdat::ArrayData::getPointer" ref="a51f24a9917363c2208e62987e8a01434" args="(const unsigned int d=0)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">TYPE * <a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html">SAMRAI::pdat::ArrayData</a>&lt; TYPE &gt;::getPointer </td>
          <td>(</td>
          <td class="paramtype">const unsigned int&nbsp;</td>
          <td class="paramname"> <em>d</em> = <code>0</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Get a non-const pointer to the beginning of the given depth component of this data array.</p>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>(d &gt;= 0) &amp;&amp; (d &lt; <a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html#a8cdee70250c48be83e9d0fe53c66db0e">getDepth()</a>) </dd></dl>

<p>References <a class="el" href="Utilities_8h_source.html#l00110">TBOX_ASSERT</a>.</p>

<p>Referenced by <a class="el" href="ArrayDataNormOpsReal_8C_source.html#l00043">SAMRAI::math::ArrayDataNormOpsReal&lt; TYPE &gt;::abs()</a>, <a class="el" href="ArrayDataNormOpsInteger_8C_source.html#l00036">SAMRAI::math::ArrayDataNormOpsInteger::abs()</a>, <a class="el" href="ArrayDataNormOpsComplex_8C_source.html#l00036">SAMRAI::math::ArrayDataNormOpsComplex::abs()</a>, <a class="el" href="ArrayDataAccess_8h_source.html#l00037">SAMRAI::pdat::ArrayDataAccess::access()</a>, <a class="el" href="ArrayDataAccess_8C_source.html#l00021">SAMRAI::pdat::access()</a>, <a class="el" href="ArrayDataBasicOps_8C_source.html#l00265">SAMRAI::math::ArrayDataBasicOps&lt; TYPE &gt;::add()</a>, <a class="el" href="ArrayDataBasicOps_8C_source.html#l00155">SAMRAI::math::ArrayDataBasicOps&lt; TYPE &gt;::addScalar()</a>, <a class="el" href="ArrayDataBasicOps_8C_source.html#l01090">SAMRAI::math::ArrayDataBasicOps&lt; TYPE &gt;::axmy()</a>, <a class="el" href="ArrayDataBasicOps_8C_source.html#l00965">SAMRAI::math::ArrayDataBasicOps&lt; TYPE &gt;::axpy()</a>, <a class="el" href="ArrayDataMiscellaneousOpsReal_8C_source.html#l00388">SAMRAI::math::ArrayDataMiscellaneousOpsReal&lt; TYPE &gt;::compareToScalar()</a>, <a class="el" href="ArrayDataMiscellaneousOpsReal_8C_source.html#l00268">SAMRAI::math::ArrayDataMiscellaneousOpsReal&lt; TYPE &gt;::compareToScalarWithControlVolume()</a>, <a class="el" href="ArrayDataMiscellaneousOpsReal_8C_source.html#l00165">SAMRAI::math::ArrayDataMiscellaneousOpsReal&lt; TYPE &gt;::computeConstrProdPos()</a>, <a class="el" href="ArrayDataMiscellaneousOpsReal_8C_source.html#l00041">SAMRAI::math::ArrayDataMiscellaneousOpsReal&lt; TYPE &gt;::computeConstrProdPosWithControlVolume()</a>, <a class="el" href="ArrayDataBasicOps_8C_source.html#l00612">SAMRAI::math::ArrayDataBasicOps&lt; TYPE &gt;::divide()</a>, <a class="el" href="ArrayDataOperationUtilities_8C_source.html#l00170">SAMRAI::pdat::ArrayDataOperationUtilities&lt; TYPE, OP &gt;::doArrayDataBufferOperationOnBox()</a>, <a class="el" href="ArrayDataOperationUtilities_8C_source.html#l00032">SAMRAI::pdat::ArrayDataOperationUtilities&lt; TYPE, OP &gt;::doArrayDataOperationOnBox()</a>, <a class="el" href="ArrayDataNormOpsReal_8C_source.html#l00957">SAMRAI::math::ArrayDataNormOpsReal&lt; TYPE &gt;::dot()</a>, <a class="el" href="ArrayDataNormOpsComplex_8C_source.html#l00513">SAMRAI::math::ArrayDataNormOpsComplex::dot()</a>, <a class="el" href="ArrayDataNormOpsReal_8C_source.html#l00833">SAMRAI::math::ArrayDataNormOpsReal&lt; TYPE &gt;::dotWithControlVolume()</a>, <a class="el" href="ArrayDataNormOpsComplex_8C_source.html#l00395">SAMRAI::math::ArrayDataNormOpsComplex::dotWithControlVolume()</a>, <a class="el" href="ArrayDataNormOpsReal_8C_source.html#l01058">SAMRAI::math::ArrayDataNormOpsReal&lt; TYPE &gt;::integral()</a>, <a class="el" href="ArrayDataNormOpsComplex_8C_source.html#l00613">SAMRAI::math::ArrayDataNormOpsComplex::integral()</a>, <a class="el" href="ArrayDataNormOpsReal_8C_source.html#l00326">SAMRAI::math::ArrayDataNormOpsReal&lt; TYPE &gt;::L1Norm()</a>, <a class="el" href="ArrayDataNormOpsComplex_8C_source.html#l00314">SAMRAI::math::ArrayDataNormOpsComplex::L1Norm()</a>, <a class="el" href="ArrayDataNormOpsReal_8C_source.html#l00226">SAMRAI::math::ArrayDataNormOpsReal&lt; TYPE &gt;::L1NormWithControlVolume()</a>, <a class="el" href="ArrayDataNormOpsComplex_8C_source.html#l00216">SAMRAI::math::ArrayDataNormOpsComplex::L1NormWithControlVolume()</a>, <a class="el" href="ArrayDataBasicOps_8C_source.html#l00824">SAMRAI::math::ArrayDataBasicOps&lt; TYPE &gt;::linearSum()</a>, <a class="el" href="ArrayDataBasicOps_8C_source.html#l01293">SAMRAI::math::ArrayDataBasicOps&lt; TYPE &gt;::max()</a>, <a class="el" href="ArrayDataNormOpsReal_8C_source.html#l00750">SAMRAI::math::ArrayDataNormOpsReal&lt; TYPE &gt;::maxNorm()</a>, <a class="el" href="ArrayDataNormOpsComplex_8C_source.html#l01024">SAMRAI::math::ArrayDataNormOpsComplex::maxNorm()</a>, <a class="el" href="ArrayDataNormOpsReal_8C_source.html#l00646">SAMRAI::math::ArrayDataNormOpsReal&lt; TYPE &gt;::maxNormWithControlVolume()</a>, <a class="el" href="ArrayDataNormOpsComplex_8C_source.html#l00923">SAMRAI::math::ArrayDataNormOpsComplex::maxNormWithControlVolume()</a>, <a class="el" href="ArrayDataMiscellaneousOpsReal_8C_source.html#l00724">SAMRAI::math::ArrayDataMiscellaneousOpsReal&lt; TYPE &gt;::maxPointwiseDivide()</a>, <a class="el" href="ArrayDataBasicOps_8C_source.html#l01213">SAMRAI::math::ArrayDataBasicOps&lt; TYPE &gt;::min()</a>, <a class="el" href="ArrayDataMiscellaneousOpsReal_8C_source.html#l00828">SAMRAI::math::ArrayDataMiscellaneousOpsReal&lt; TYPE &gt;::minPointwiseDivide()</a>, <a class="el" href="ArrayDataBasicOps_8C_source.html#l00497">SAMRAI::math::ArrayDataBasicOps&lt; TYPE &gt;::multiply()</a>, <a class="el" href="ArrayDataBasicOps_8C_source.html#l00724">SAMRAI::math::ArrayDataBasicOps&lt; TYPE &gt;::reciprocal()</a>, <a class="el" href="ArrayDataBasicOps_8C_source.html#l00043">SAMRAI::math::ArrayDataBasicOps&lt; TYPE &gt;::scale()</a>, <a class="el" href="ArrayDataBasicOps_8C_source.html#l01374">SAMRAI::math::ArrayDataBasicOps&lt; TYPE &gt;::setRandomValues()</a>, <a class="el" href="ArrayDataBasicOps_8C_source.html#l00381">SAMRAI::math::ArrayDataBasicOps&lt; TYPE &gt;::subtract()</a>, <a class="el" href="ArrayDataNormOpsReal_8C_source.html#l00139">SAMRAI::math::ArrayDataNormOpsReal&lt; TYPE &gt;::sumControlVolumes()</a>, <a class="el" href="ArrayDataNormOpsComplex_8C_source.html#l00130">SAMRAI::math::ArrayDataNormOpsComplex::sumControlVolumes()</a>, <a class="el" href="ArrayDataMiscellaneousOpsReal_8C_source.html#l00616">SAMRAI::math::ArrayDataMiscellaneousOpsReal&lt; TYPE &gt;::testReciprocal()</a>, <a class="el" href="ArrayDataMiscellaneousOpsReal_8C_source.html#l00488">SAMRAI::math::ArrayDataMiscellaneousOpsReal&lt; TYPE &gt;::testReciprocalWithControlVolume()</a>, <a class="el" href="ArrayDataNormOpsReal_8C_source.html#l00548">SAMRAI::math::ArrayDataNormOpsReal&lt; TYPE &gt;::weightedL2Norm()</a>, <a class="el" href="ArrayDataNormOpsComplex_8C_source.html#l00826">SAMRAI::math::ArrayDataNormOpsComplex::weightedL2Norm()</a>, <a class="el" href="ArrayDataNormOpsReal_8C_source.html#l00432">SAMRAI::math::ArrayDataNormOpsReal&lt; TYPE &gt;::weightedL2NormWithControlVolume()</a>, and <a class="el" href="ArrayDataNormOpsComplex_8C_source.html#l00711">SAMRAI::math::ArrayDataNormOpsComplex::weightedL2NormWithControlVolume()</a>.</p>

</div>
</div>
<a class="anchor" id="a827655c7333f29686891d0c4a7a68ded"></a><!-- doxytag: member="SAMRAI::pdat::ArrayData::getPointer" ref="a827655c7333f29686891d0c4a7a68ded" args="(const unsigned int d=0) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const TYPE * <a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html">SAMRAI::pdat::ArrayData</a>&lt; TYPE &gt;::getPointer </td>
          <td>(</td>
          <td class="paramtype">const unsigned int&nbsp;</td>
          <td class="paramname"> <em>d</em> = <code>0</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Get a const pointer to the beginning of the given depth component of this data array.</p>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>(d &gt;= 0) &amp;&amp; (d &lt; <a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html#a8cdee70250c48be83e9d0fe53c66db0e">getDepth()</a>) </dd></dl>

<p>References <a class="el" href="Utilities_8h_source.html#l00110">TBOX_ASSERT</a>.</p>

</div>
</div>
<a class="anchor" id="abfaf511a5bc1d533cc1fe74e59af1eec"></a><!-- doxytag: member="SAMRAI::pdat::ArrayData::operator()" ref="abfaf511a5bc1d533cc1fe74e59af1eec" args="(const hier::Index &amp;i, const unsigned int d)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">TYPE &amp; <a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html">SAMRAI::pdat::ArrayData</a>&lt; TYPE &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1Index.html">hier::Index</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&nbsp;</td>
          <td class="paramname"> <em>d</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return reference to value in this array associated with the given box index and depth component.</p>
<dl class="pre"><dt><b>Precondition:</b></dt><dd><a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html#a114ecb99a07fdcce73f49cab9ff0b0a4">getDim()</a> == i.getDim() </dd>
<dd>
(d &gt;= 0) &amp;&amp; (d &lt; <a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html#a8cdee70250c48be83e9d0fe53c66db0e">getDepth()</a>) </dd></dl>

<p>References <a class="el" href="Utilities_8h_source.html#l00110">TBOX_ASSERT</a>, and <a class="el" href="Utilities_8h_source.html#l00182">TBOX_ASSERT_OBJDIM_EQUALITY2</a>.</p>

</div>
</div>
<a class="anchor" id="a043c519055ff49ac7b2ab3e23e5562a5"></a><!-- doxytag: member="SAMRAI::pdat::ArrayData::operator()" ref="a043c519055ff49ac7b2ab3e23e5562a5" args="(const hier::Index &amp;i, const unsigned int d) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const TYPE &amp; <a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html">SAMRAI::pdat::ArrayData</a>&lt; TYPE &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1Index.html">hier::Index</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&nbsp;</td>
          <td class="paramname"> <em>d</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return const reference to value in this array associated with the given box index and depth component.</p>
<dl class="pre"><dt><b>Precondition:</b></dt><dd><a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html#a114ecb99a07fdcce73f49cab9ff0b0a4">getDim()</a> == i.getDim() </dd>
<dd>
(d &gt;= 0) &amp;&amp; (d &lt; <a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html#a8cdee70250c48be83e9d0fe53c66db0e">getDepth()</a>) </dd></dl>

<p>References <a class="el" href="Utilities_8h_source.html#l00110">TBOX_ASSERT</a>, and <a class="el" href="Utilities_8h_source.html#l00182">TBOX_ASSERT_OBJDIM_EQUALITY2</a>.</p>

</div>
</div>
<a class="anchor" id="a1f95dbc4aa63153b64793cff7b5e3245"></a><!-- doxytag: member="SAMRAI::pdat::ArrayData::copy" ref="a1f95dbc4aa63153b64793cff7b5e3245" args="(const ArrayData&lt; TYPE &gt; &amp;src, const hier::Box &amp;box)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html">SAMRAI::pdat::ArrayData</a>&lt; TYPE &gt;::copy </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html">ArrayData</a>&lt; TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">hier::Box</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>box</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Copy data from the source array data object to this array data object on the specified index space region.</p>
<p>Note that this routine assumes that the source and destination box regions require no shifting to make them consistent. This routine will intersect the specified box with the source and destination boxes to find the region of intersection.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>src</em>&nbsp;</td><td>Const reference to source array data object. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>box</em>&nbsp;</td><td>Const reference to box object describing the spatial extents of the index space region over which to perform the copy operation. Note: the box is in either the source or destination index space (which are assumed to be the same).</td></tr>
  </table>
  </dd>
</dl>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>(<a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html#a114ecb99a07fdcce73f49cab9ff0b0a4">getDim()</a> == src.getDim()) &amp;&amp; (<a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html#a114ecb99a07fdcce73f49cab9ff0b0a4">getDim()</a> == box.getDim()) </dd></dl>

<p>References <a class="el" href="Box_8h_source.html#l00613">SAMRAI::hier::Box::empty()</a>, <a class="el" href="Box_8h_source.html#l01313">SAMRAI::hier::Box::getDim()</a>, <a class="el" href="Box_8h_source.html#l00767">SAMRAI::hier::Box::isSpatiallyEqual()</a>, and <a class="el" href="Utilities_8h_source.html#l00187">TBOX_ASSERT_OBJDIM_EQUALITY3</a>.</p>

<p>Referenced by <a class="el" href="ArrayDataBasicOps_8C_source.html#l00155">SAMRAI::math::ArrayDataBasicOps&lt; TYPE &gt;::addScalar()</a>, <a class="el" href="ArrayDataBasicOps_8C_source.html#l00965">SAMRAI::math::ArrayDataBasicOps&lt; TYPE &gt;::axpy()</a>, <a class="el" href="SimpleCellRobinBcCoefs_8C_source.html#l00513">SAMRAI::solv::SimpleCellRobinBcCoefs::cacheDirichletData()</a>, <a class="el" href="OutersideData_8C_source.html#l00170">SAMRAI::pdat::OutersideData&lt; TYPE &gt;::copy()</a>, <a class="el" href="OuterfaceData_8C_source.html#l00170">SAMRAI::pdat::OuterfaceData&lt; TYPE &gt;::copy()</a>, <a class="el" href="ArrayData_8C_source.html#l00257">SAMRAI::pdat::ArrayData&lt; TYPE &gt;::copy()</a>, and <a class="el" href="ArrayDataBasicOps_8C_source.html#l00043">SAMRAI::math::ArrayDataBasicOps&lt; TYPE &gt;::scale()</a>.</p>

</div>
</div>
<a class="anchor" id="a630b971ca04cf416888eb907208dfc0f"></a><!-- doxytag: member="SAMRAI::pdat::ArrayData::copy" ref="a630b971ca04cf416888eb907208dfc0f" args="(const ArrayData&lt; TYPE &gt; &amp;src, const hier::Box &amp;box, const hier::IntVector &amp;src_shift)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html">SAMRAI::pdat::ArrayData</a>&lt; TYPE &gt;::copy </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html">ArrayData</a>&lt; TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">hier::Box</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>box</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>src_shift</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Copy data from the source array data object to this array data object on the specified index space region.</p>
<p>Note that this routine assumes that the source array box region must be shifted to be consistent with the destination (this) array box region. This routine will intersect the specified box with the destination box and shifted source box to find the region of intersection.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>src</em>&nbsp;</td><td>Const reference to source array data object. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>box</em>&nbsp;</td><td>Const reference to box object describing the spatial extents of the index space region over which to perform the copy operation. Note: the box is in the destination index space. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>src_shift</em>&nbsp;</td><td>Const reference to shift vector used to put the source array data box into the index space region of this array data object. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="ArrayData_8C_source.html#l00196">SAMRAI::pdat::ArrayData&lt; TYPE &gt;::copy()</a>, <a class="el" href="Box_8h_source.html#l00613">SAMRAI::hier::Box::empty()</a>, <a class="el" href="Box_8h_source.html#l01313">SAMRAI::hier::Box::getDim()</a>, <a class="el" href="IntVector_8h_source.html#l01130">SAMRAI::hier::IntVector::getZero()</a>, and <a class="el" href="Box_8h_source.html#l01084">SAMRAI::hier::Box::shift()</a>.</p>

</div>
</div>
<a class="anchor" id="aa7f4c8540edaa30f7929643fbbf5512f"></a><!-- doxytag: member="SAMRAI::pdat::ArrayData::copy" ref="aa7f4c8540edaa30f7929643fbbf5512f" args="(const ArrayData&lt; TYPE &gt; &amp;src, const hier::Box &amp;box, const hier::Transformation &amp;transformation)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html">SAMRAI::pdat::ArrayData</a>&lt; TYPE &gt;::copy </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html">ArrayData</a>&lt; TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">hier::Box</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>box</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1Transformation.html">hier::Transformation</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>transformation</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>References <a class="el" href="ArrayData_8C_source.html#l00196">SAMRAI::pdat::ArrayData&lt; TYPE &gt;::copy()</a>, <a class="el" href="Box_8h_source.html#l00613">SAMRAI::hier::Box::empty()</a>, <a class="el" href="Transformation_8h_source.html#l00214">SAMRAI::hier::Transformation::getBeginBlock()</a>, <a class="el" href="Box_8h_source.html#l01313">SAMRAI::hier::Box::getDim()</a>, <a class="el" href="Transformation_8h_source.html#l00222">SAMRAI::hier::Transformation::getEndBlock()</a>, <a class="el" href="Transformation_8h_source.html#l00158">SAMRAI::hier::Transformation::getOffset()</a>, <a class="el" href="Transformation_8h_source.html#l00149">SAMRAI::hier::Transformation::getRotation()</a>, <a class="el" href="IntVector_8h_source.html#l01130">SAMRAI::hier::IntVector::getZero()</a>, <a class="el" href="Transformation_8h_source.html#l00065">SAMRAI::hier::Transformation::NO_ROTATE</a>, and <a class="el" href="Transformation_8C_source.html#l00078">SAMRAI::hier::Transformation::transform()</a>.</p>

</div>
</div>
<a class="anchor" id="ac7d9dd6fe2177de262d9a4d7d37d6701"></a><!-- doxytag: member="SAMRAI::pdat::ArrayData::copy" ref="ac7d9dd6fe2177de262d9a4d7d37d6701" args="(const ArrayData&lt; TYPE &gt; &amp;src, const hier::BoxContainer &amp;boxes, const hier::IntVector &amp;src_shift)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html">SAMRAI::pdat::ArrayData</a>&lt; TYPE &gt;::copy </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html">ArrayData</a>&lt; TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">hier::BoxContainer</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>boxes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>src_shift</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Copy data from the source array data object to this array data object on the specified index space regions.</p>
<p>Note that this routine assumes that the source array box region must be shifted to be consistent with the destination (this) array box region. This routine will intersect the specified boxes with the destination box and shifted source box to find the regions of intersection.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>src</em>&nbsp;</td><td>Const reference to source array data object. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>boxes</em>&nbsp;</td><td>Const reference to box list describing the spatial extents of the index space regions over which to perform the copy operation. Note: the boxes are in the destination index space. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>src_shift</em>&nbsp;</td><td>Const reference to shift vector used to put the source array data box into the index space region of this array data object. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="BoxContainer_8h_source.html#l00706">SAMRAI::hier::BoxContainer::begin()</a>, <a class="el" href="ArrayData_8C_source.html#l00196">SAMRAI::pdat::ArrayData&lt; TYPE &gt;::copy()</a>, and <a class="el" href="BoxContainer_8h_source.html#l00717">SAMRAI::hier::BoxContainer::end()</a>.</p>

</div>
</div>
<a class="anchor" id="a61e0cb2479f6d91b2733fce32638194a"></a><!-- doxytag: member="SAMRAI::pdat::ArrayData::copy" ref="a61e0cb2479f6d91b2733fce32638194a" args="(const ArrayData&lt; TYPE &gt; &amp;src, const hier::BoxContainer &amp;boxes, const hier::Transformation &amp;transformation)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html">SAMRAI::pdat::ArrayData</a>&lt; TYPE &gt;::copy </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html">ArrayData</a>&lt; TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">hier::BoxContainer</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>boxes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1Transformation.html">hier::Transformation</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>transformation</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>References <a class="el" href="BoxContainer_8h_source.html#l00706">SAMRAI::hier::BoxContainer::begin()</a>, <a class="el" href="ArrayData_8C_source.html#l00196">SAMRAI::pdat::ArrayData&lt; TYPE &gt;::copy()</a>, and <a class="el" href="BoxContainer_8h_source.html#l00717">SAMRAI::hier::BoxContainer::end()</a>.</p>

</div>
</div>
<a class="anchor" id="afdbdce691025dcd126e29a244db79703"></a><!-- doxytag: member="SAMRAI::pdat::ArrayData::copyDepth" ref="afdbdce691025dcd126e29a244db79703" args="(unsigned int dst_depth, const ArrayData&lt; TYPE &gt; &amp;src, unsigned int src_depth, const hier::Box &amp;box)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html">SAMRAI::pdat::ArrayData</a>&lt; TYPE &gt;::copyDepth </td>
          <td>(</td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>dst_depth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html">ArrayData</a>&lt; TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>src_depth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">hier::Box</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>box</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Copy given source depth of source array data object to given destination depth of this array data object on the specified index space region.</p>
<p>Note that this routine assumes that the source and destination box regions require no shifting to make them consistent. This routine will intersect the specified box with the source and destination boxes to find the region of intersection.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dst_depth</em>&nbsp;</td><td>Integer depth of destination array. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>src</em>&nbsp;</td><td>Const reference to source array data object. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>src_depth</em>&nbsp;</td><td>Integer depth of source array. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>box</em>&nbsp;</td><td>Const reference to box object describing the spatial extents of the index space region over which to perform the copy operation. Note: the box is in either the source or destination index space (which are assumed to be the same).</td></tr>
  </table>
  </dd>
</dl>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>(0 &lt;= dst_depth) &amp;&amp; (dst_depth &lt;= <a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html#a8cdee70250c48be83e9d0fe53c66db0e">getDepth()</a>)) </dd>
<dd>
(0 &lt;= src_depth) &amp;&amp; (src_depth &lt;= src.getDepth()) </dd></dl>

<p>References <a class="el" href="Box_8h_source.html#l00613">SAMRAI::hier::Box::empty()</a>, <a class="el" href="Box_8h_source.html#l01313">SAMRAI::hier::Box::getDim()</a>, <a class="el" href="Box_8h_source.html#l00767">SAMRAI::hier::Box::isSpatiallyEqual()</a>, and <a class="el" href="Utilities_8h_source.html#l00110">TBOX_ASSERT</a>.</p>

<p>Referenced by <a class="el" href="OutersideData_8C_source.html#l00292">SAMRAI::pdat::OutersideData&lt; TYPE &gt;::copyDepth()</a>, <a class="el" href="OuternodeData_8C_source.html#l00347">SAMRAI::pdat::OuternodeData&lt; TYPE &gt;::copyDepth()</a>, <a class="el" href="OuterfaceData_8C_source.html#l00306">SAMRAI::pdat::OuterfaceData&lt; TYPE &gt;::copyDepth()</a>, <a class="el" href="OuteredgeData_8C_source.html#l00363">SAMRAI::pdat::OuteredgeData&lt; TYPE &gt;::copyDepth()</a>, <a class="el" href="OutersideData_8C_source.html#l00322">SAMRAI::pdat::OutersideData&lt; TYPE &gt;::copyDepth2()</a>, <a class="el" href="OuternodeData_8C_source.html#l00377">SAMRAI::pdat::OuternodeData&lt; TYPE &gt;::copyDepth2()</a>, <a class="el" href="OuterfaceData_8C_source.html#l00336">SAMRAI::pdat::OuterfaceData&lt; TYPE &gt;::copyDepth2()</a>, and <a class="el" href="OuteredgeData_8C_source.html#l00409">SAMRAI::pdat::OuteredgeData&lt; TYPE &gt;::copyDepth2()</a>.</p>

</div>
</div>
<a class="anchor" id="aef60177ead7c3614f062590f7712609f"></a><!-- doxytag: member="SAMRAI::pdat::ArrayData::sum" ref="aef60177ead7c3614f062590f7712609f" args="(const ArrayData&lt; TYPE &gt; &amp;src, const hier::Box &amp;box)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html">SAMRAI::pdat::ArrayData</a>&lt; TYPE &gt;::sum </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html">ArrayData</a>&lt; TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">hier::Box</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>box</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Add data from the source array data object to this array data object on the specified index space region.</p>
<p>Note that this routine assumes that the source and destination box regions require no shifting to make them consistent. This routine will intersect the specified box with the source and destination boxes to find the region of intersection.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>src</em>&nbsp;</td><td>Const reference to source array data object. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>box</em>&nbsp;</td><td>Const reference to box object describing the spatial extents of the index space region over which to perform the sum operation. Note: the box is in either the source or destination index space (which are assumed to be the same). </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="Box_8h_source.html#l00613">SAMRAI::hier::Box::empty()</a>, <a class="el" href="Box_8h_source.html#l01313">SAMRAI::hier::Box::getDim()</a>, and <a class="el" href="Box_8h_source.html#l00767">SAMRAI::hier::Box::isSpatiallyEqual()</a>.</p>

<p>Referenced by <a class="el" href="ArrayData_8C_source.html#l00517">SAMRAI::pdat::ArrayData&lt; TYPE &gt;::sum()</a>.</p>

</div>
</div>
<a class="anchor" id="af41f9d64e0345c2ac79a2dcb0514d779"></a><!-- doxytag: member="SAMRAI::pdat::ArrayData::sum" ref="af41f9d64e0345c2ac79a2dcb0514d779" args="(const ArrayData&lt; TYPE &gt; &amp;src, const hier::Box &amp;box, const hier::IntVector &amp;src_shift)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html">SAMRAI::pdat::ArrayData</a>&lt; TYPE &gt;::sum </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html">ArrayData</a>&lt; TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">hier::Box</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>box</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>src_shift</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Add data from the source array data object to this array data object on the specified index space region.</p>
<p>Note that this routine assumes that the source array box region must be shifted to be consistent with the destination (this) array box region. This routine will intersect the specified box with the destination box and shifted source box to find the region of intersection.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>src</em>&nbsp;</td><td>Const reference to source array data object. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>box</em>&nbsp;</td><td>Const reference to box object describing the spatial extents of the index space region over which to perform the sum operation. Note: the box is in the destination index space. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>src_shift</em>&nbsp;</td><td>Const reference to shift vector used to put the source array data box into the index space region of this array data object. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="Box_8h_source.html#l00613">SAMRAI::hier::Box::empty()</a>, <a class="el" href="Box_8h_source.html#l01313">SAMRAI::hier::Box::getDim()</a>, <a class="el" href="IntVector_8h_source.html#l01130">SAMRAI::hier::IntVector::getZero()</a>, <a class="el" href="Box_8h_source.html#l01084">SAMRAI::hier::Box::shift()</a>, and <a class="el" href="ArrayData_8C_source.html#l00457">SAMRAI::pdat::ArrayData&lt; TYPE &gt;::sum()</a>.</p>

</div>
</div>
<a class="anchor" id="acfecc435a4deb40a8d854057e80a6ad0"></a><!-- doxytag: member="SAMRAI::pdat::ArrayData::sum" ref="acfecc435a4deb40a8d854057e80a6ad0" args="(const ArrayData&lt; TYPE &gt; &amp;src, const hier::BoxContainer &amp;boxes, const hier::IntVector &amp;src_shift)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html">SAMRAI::pdat::ArrayData</a>&lt; TYPE &gt;::sum </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html">ArrayData</a>&lt; TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">hier::BoxContainer</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>boxes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>src_shift</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Add data from the source array data object to this array data object on the specified index space regions.</p>
<p>Note that this routine assumes that the source array box region must be shifted to be consistent with the destination (this) array box region. This routine will intersect the specified boxes with the destination box and shifted source box to find the regions of intersection.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>src</em>&nbsp;</td><td>Const reference to source array data object. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>boxes</em>&nbsp;</td><td>Const reference to box list describing the spatial extents of the index space regions over which to perform the sum operation. Note: the boxes are in the destination index space. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>src_shift</em>&nbsp;</td><td>Const reference to shift vector used to put the source array data box into the index space region of this array data object. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="BoxContainer_8h_source.html#l00706">SAMRAI::hier::BoxContainer::begin()</a>, <a class="el" href="BoxContainer_8h_source.html#l00717">SAMRAI::hier::BoxContainer::end()</a>, and <a class="el" href="ArrayData_8C_source.html#l00457">SAMRAI::pdat::ArrayData&lt; TYPE &gt;::sum()</a>.</p>

</div>
</div>
<a class="anchor" id="afbc700d1f8df66710c83be31d212b37f"></a><!-- doxytag: member="SAMRAI::pdat::ArrayData::getDataStreamSize" ref="afbc700d1f8df66710c83be31d212b37f" args="(const hier::BoxContainer &amp;boxes, const hier::IntVector &amp;src_shift) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html">SAMRAI::pdat::ArrayData</a>&lt; TYPE &gt;::getDataStreamSize </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">hier::BoxContainer</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>boxes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>src_shift</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Calculate the number of bytes needed to stream the data living in the specified box domains. This routine is only defined for the built-in types of bool, char, double, float, int, and dcomplex. For all other types, a specialized implementation must be provided.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>boxes</em>&nbsp;</td><td>Const reference to box list describing the spatial extents of the index space regions of interest. Note: the boxes are assumed to be in the index space of this array data object. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>src_shift</em>&nbsp;</td><td>Const reference to vector used to shift the given boxes into the index space region of this array data object. Note: this argument is currently ignored.</td></tr>
  </table>
  </dd>
</dl>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>(<a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html#a114ecb99a07fdcce73f49cab9ff0b0a4">getDim()</a> == src_shift.getDim()) </dd></dl>

<p>References <a class="el" href="BoxContainer_8C_source.html#l01523">SAMRAI::hier::BoxContainer::getTotalSizeOfBoxes()</a>, <a class="el" href="Utilities_8h_source.html#l00050">NULL_USE</a>, <a class="el" href="Utilities_8h_source.html#l00182">TBOX_ASSERT_OBJDIM_EQUALITY2</a>, and <a class="el" href="Utilities_8h_source.html#l00060">TBOX_ERROR</a>.</p>

</div>
</div>
<a class="anchor" id="a6c5415ec52723f7c3e20ce314b2c574c"></a><!-- doxytag: member="SAMRAI::pdat::ArrayData::packStream" ref="a6c5415ec52723f7c3e20ce314b2c574c" args="(tbox::MessageStream &amp;stream, const hier::Box &amp;dest_box, const hier::IntVector &amp;src_shift) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html">SAMRAI::pdat::ArrayData</a>&lt; TYPE &gt;::packStream </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1tbox_1_1MessageStream.html">tbox::MessageStream</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">hier::Box</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>dest_box</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>src_shift</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Pack data living on the specified index region into the stream.</p>
<p>Note that this routine assumes that the given box region must be shifted to be consistent with the source (this) array box region.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>stream</em>&nbsp;</td><td>Reference to stream into which to pack data. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dest_box</em>&nbsp;</td><td>Const reference to box describing the spatial extent of the destination index space region of interest. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>src_shift</em>&nbsp;</td><td>Const reference to vector used to shift the given box into the index space region of this (source) array data object.</td></tr>
  </table>
  </dd>
</dl>
<p>Note: The shifted box must lie completely within the index space of this array data object. When assertion checking is active, the routine will abort if the shifted box is not contained in the index space of this array. </p>

<p>References <a class="el" href="MessageStream_8h_source.html#l00187">SAMRAI::tbox::MessageStream::pack()</a>, <a class="el" href="Box_8h_source.html#l01084">SAMRAI::hier::Box::shift()</a>, and <a class="el" href="Box_8h_source.html#l00667">SAMRAI::hier::Box::size()</a>.</p>

</div>
</div>
<a class="anchor" id="a0915d10aacd00b27f108354421723ea1"></a><!-- doxytag: member="SAMRAI::pdat::ArrayData::packStream" ref="a0915d10aacd00b27f108354421723ea1" args="(tbox::MessageStream &amp;stream, const hier::Box &amp;dest_box, const hier::Transformation &amp;src_shift) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html">SAMRAI::pdat::ArrayData</a>&lt; TYPE &gt;::packStream </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1tbox_1_1MessageStream.html">tbox::MessageStream</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">hier::Box</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>dest_box</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1Transformation.html">hier::Transformation</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>src_shift</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>References <a class="el" href="Transformation_8C_source.html#l00097">SAMRAI::hier::Transformation::inverseTransform()</a>, <a class="el" href="MessageStream_8h_source.html#l00187">SAMRAI::tbox::MessageStream::pack()</a>, and <a class="el" href="Box_8h_source.html#l00667">SAMRAI::hier::Box::size()</a>.</p>

</div>
</div>
<a class="anchor" id="ae9134265a8087de6f6c253715f2ed5d5"></a><!-- doxytag: member="SAMRAI::pdat::ArrayData::packStream" ref="ae9134265a8087de6f6c253715f2ed5d5" args="(tbox::MessageStream &amp;stream, const hier::BoxContainer &amp;dest_boxes, const hier::IntVector &amp;src_shift) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html">SAMRAI::pdat::ArrayData</a>&lt; TYPE &gt;::packStream </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1tbox_1_1MessageStream.html">tbox::MessageStream</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">hier::BoxContainer</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>dest_boxes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>src_shift</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Pack data living on the specified index regions into the stream.</p>
<p>Note that this routine assumes that the given box regions must be shifted to be consistent with the source (this) array box region.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>stream</em>&nbsp;</td><td>Reference to stream into which to pack data. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dest_boxes</em>&nbsp;</td><td>Const reference to boxes describing the spatial extents of the destination index space regions of interest. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>src_shift</em>&nbsp;</td><td>Const reference to vector used to shift the given boxes into the index space region of this (source) array data object.</td></tr>
  </table>
  </dd>
</dl>
<p>Note: The shifted boxes must lie completely within the index space of this array. If compiled with assertions enabled, the routine will abort if the shifted boxes are not contained in the index space of this array. </p>

<p>References <a class="el" href="BoxContainer_8h_source.html#l00706">SAMRAI::hier::BoxContainer::begin()</a>, <a class="el" href="BoxContainer_8h_source.html#l00717">SAMRAI::hier::BoxContainer::end()</a>, <a class="el" href="BoxContainer_8C_source.html#l01523">SAMRAI::hier::BoxContainer::getTotalSizeOfBoxes()</a>, <a class="el" href="MessageStream_8h_source.html#l00187">SAMRAI::tbox::MessageStream::pack()</a>, <a class="el" href="Box_8h_source.html#l01084">SAMRAI::hier::Box::shift()</a>, and <a class="el" href="Utilities_8h_source.html#l00110">TBOX_ASSERT</a>.</p>

</div>
</div>
<a class="anchor" id="a8019407ee7bd9dcbaaba72c600723762"></a><!-- doxytag: member="SAMRAI::pdat::ArrayData::packStream" ref="a8019407ee7bd9dcbaaba72c600723762" args="(tbox::MessageStream &amp;stream, const hier::BoxContainer &amp;dest_boxes, const hier::Transformation &amp;transformation) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html">SAMRAI::pdat::ArrayData</a>&lt; TYPE &gt;::packStream </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1tbox_1_1MessageStream.html">tbox::MessageStream</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">hier::BoxContainer</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>dest_boxes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1Transformation.html">hier::Transformation</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>transformation</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>References <a class="el" href="BoxContainer_8h_source.html#l00706">SAMRAI::hier::BoxContainer::begin()</a>, <a class="el" href="BoxContainer_8h_source.html#l00717">SAMRAI::hier::BoxContainer::end()</a>, <a class="el" href="BoxContainer_8C_source.html#l01523">SAMRAI::hier::BoxContainer::getTotalSizeOfBoxes()</a>, <a class="el" href="Transformation_8C_source.html#l00097">SAMRAI::hier::Transformation::inverseTransform()</a>, <a class="el" href="MessageStream_8h_source.html#l00187">SAMRAI::tbox::MessageStream::pack()</a>, and <a class="el" href="Utilities_8h_source.html#l00110">TBOX_ASSERT</a>.</p>

</div>
</div>
<a class="anchor" id="a00c34907e10e962adb8282b965a6972b"></a><!-- doxytag: member="SAMRAI::pdat::ArrayData::unpackStream" ref="a00c34907e10e962adb8282b965a6972b" args="(tbox::MessageStream &amp;stream, const hier::Box &amp;dest_box, const hier::IntVector &amp;src_offset)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html">SAMRAI::pdat::ArrayData</a>&lt; TYPE &gt;::unpackStream </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1tbox_1_1MessageStream.html">tbox::MessageStream</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">hier::Box</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>dest_box</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>src_offset</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Unpack data from the stream into the index region specified.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>stream</em>&nbsp;</td><td>Reference to stream from which to unpack data. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dest_box</em>&nbsp;</td><td>Const reference to box describing the spatial extent of the destination index space region of interest. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>src_offset</em>&nbsp;</td><td>Const reference to vector used to offset box into the index space region of some (source) array data object. Currently, this argument is ignored.</td></tr>
  </table>
  </dd>
</dl>
<p>Note: The given box must lie completely within the index space of this array data object. When assertion checking is active, the routine will abort if the box is not contained in the index space of this array. </p>

<p>References <a class="el" href="Utilities_8h_source.html#l00050">NULL_USE</a>, <a class="el" href="Box_8h_source.html#l00667">SAMRAI::hier::Box::size()</a>, and <a class="el" href="MessageStream_8h_source.html#l00247">SAMRAI::tbox::MessageStream::unpack()</a>.</p>

</div>
</div>
<a class="anchor" id="a663216993c878358b0f84dc85274c833"></a><!-- doxytag: member="SAMRAI::pdat::ArrayData::unpackStream" ref="a663216993c878358b0f84dc85274c833" args="(tbox::MessageStream &amp;stream, const hier::BoxContainer &amp;dest_boxes, const hier::IntVector &amp;src_offset)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html">SAMRAI::pdat::ArrayData</a>&lt; TYPE &gt;::unpackStream </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1tbox_1_1MessageStream.html">tbox::MessageStream</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">hier::BoxContainer</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>dest_boxes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>src_offset</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Unpack data from the stream into the index regions specified.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>stream</em>&nbsp;</td><td>Reference to stream from which to unpack data. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dest_boxes</em>&nbsp;</td><td>Const reference to box list describing the spatial extents of the destination index space regions of interest. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>src_offset</em>&nbsp;</td><td>Const reference to vector used to offset the given boxes into the index space region of some (source) array data object. Currently, this argument is ignored.</td></tr>
  </table>
  </dd>
</dl>
<p>Note: The given boxes must lie completely within the index space of this array data object. When assertion checking is active, the routine will abort if some box is not contained in the index space of this array. </p>

<p>References <a class="el" href="BoxContainer_8h_source.html#l00706">SAMRAI::hier::BoxContainer::begin()</a>, <a class="el" href="BoxContainer_8h_source.html#l00717">SAMRAI::hier::BoxContainer::end()</a>, <a class="el" href="BoxContainer_8C_source.html#l01523">SAMRAI::hier::BoxContainer::getTotalSizeOfBoxes()</a>, <a class="el" href="Utilities_8h_source.html#l00050">NULL_USE</a>, <a class="el" href="Utilities_8h_source.html#l00110">TBOX_ASSERT</a>, and <a class="el" href="MessageStream_8h_source.html#l00247">SAMRAI::tbox::MessageStream::unpack()</a>.</p>

</div>
</div>
<a class="anchor" id="abfefa9165703fe930fbf701512b6e039"></a><!-- doxytag: member="SAMRAI::pdat::ArrayData::unpackStreamAndSum" ref="abfefa9165703fe930fbf701512b6e039" args="(tbox::MessageStream &amp;stream, const hier::Box &amp;dest_box, const hier::IntVector &amp;src_offset)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html">SAMRAI::pdat::ArrayData</a>&lt; TYPE &gt;::unpackStreamAndSum </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1tbox_1_1MessageStream.html">tbox::MessageStream</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">hier::Box</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>dest_box</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>src_offset</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Unpack data from the stream and add to the array in the index region specified.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>stream</em>&nbsp;</td><td>Reference to stream from which to unpack data. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dest_box</em>&nbsp;</td><td>Const reference to box describing the spatial extent of the destination index space region of interest. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>src_offset</em>&nbsp;</td><td>Const reference to vector used to offset the given box into the index space region of some (source) array data object. Currently, this argument is ignored.</td></tr>
  </table>
  </dd>
</dl>
<p>Note: The given box must lie completely within the index space of this array data object. When assertion checking is active, the routine will abort if the box is not contained in the index space of this array. </p>

<p>References <a class="el" href="Utilities_8h_source.html#l00050">NULL_USE</a>, <a class="el" href="Box_8h_source.html#l00667">SAMRAI::hier::Box::size()</a>, and <a class="el" href="MessageStream_8h_source.html#l00247">SAMRAI::tbox::MessageStream::unpack()</a>.</p>

</div>
</div>
<a class="anchor" id="a3d2e85ff58edd86fe137912575ded227"></a><!-- doxytag: member="SAMRAI::pdat::ArrayData::unpackStreamAndSum" ref="a3d2e85ff58edd86fe137912575ded227" args="(tbox::MessageStream &amp;stream, const hier::BoxContainer &amp;dest_boxes, const hier::IntVector &amp;src_offset)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html">SAMRAI::pdat::ArrayData</a>&lt; TYPE &gt;::unpackStreamAndSum </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1tbox_1_1MessageStream.html">tbox::MessageStream</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">hier::BoxContainer</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>dest_boxes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>src_offset</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Unpack data from the stream and ad to the array in the index region specified.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>stream</em>&nbsp;</td><td>Reference to stream from which to unpack data. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dest_boxes</em>&nbsp;</td><td>Const reference to box list describing the spatial extents of the destination index space regions of interest. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>src_offset</em>&nbsp;</td><td>Const reference to vector used to offset the given boxes into the index space region of some (source) array data object. Currently, this argument is ignored.</td></tr>
  </table>
  </dd>
</dl>
<p>Note: The given boxes must lie completely within the index space of this array. If compiled with assertions enabled, the routine will abort if some box is not contained in the index space of this array. </p>

<p>References <a class="el" href="BoxContainer_8h_source.html#l00706">SAMRAI::hier::BoxContainer::begin()</a>, <a class="el" href="BoxContainer_8h_source.html#l00717">SAMRAI::hier::BoxContainer::end()</a>, <a class="el" href="BoxContainer_8C_source.html#l01523">SAMRAI::hier::BoxContainer::getTotalSizeOfBoxes()</a>, <a class="el" href="Utilities_8h_source.html#l00050">NULL_USE</a>, <a class="el" href="Utilities_8h_source.html#l00110">TBOX_ASSERT</a>, and <a class="el" href="MessageStream_8h_source.html#l00247">SAMRAI::tbox::MessageStream::unpack()</a>.</p>

</div>
</div>
<a class="anchor" id="aa7761b61f741eeee9f8004f94f7df72f"></a><!-- doxytag: member="SAMRAI::pdat::ArrayData::fillAll" ref="aa7761b61f741eeee9f8004f94f7df72f" args="(const TYPE &amp;t)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html">SAMRAI::pdat::ArrayData</a>&lt; TYPE &gt;::fillAll </td>
          <td>(</td>
          <td class="paramtype">const TYPE &amp;&nbsp;</td>
          <td class="paramname"> <em>t</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Fill all array values with value t. </p>

<p>References <a class="el" href="Box_8h_source.html#l00613">SAMRAI::hier::Box::empty()</a>.</p>

<p>Referenced by <a class="el" href="ArrayDataBasicOps_8C_source.html#l00824">SAMRAI::math::ArrayDataBasicOps&lt; TYPE &gt;::linearSum()</a>, <a class="el" href="ArrayDataBasicOps_8C_source.html#l00043">SAMRAI::math::ArrayDataBasicOps&lt; TYPE &gt;::scale()</a>, and <a class="el" href="ArrayData_8C_source.html#l01017">SAMRAI::pdat::ArrayData&lt; TYPE &gt;::undefineData()</a>.</p>

</div>
</div>
<a class="anchor" id="af027bcf7d6a05db1dc10c1151a1383b9"></a><!-- doxytag: member="SAMRAI::pdat::ArrayData::fillAll" ref="af027bcf7d6a05db1dc10c1151a1383b9" args="(const TYPE &amp;t, const hier::Box &amp;box)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html">SAMRAI::pdat::ArrayData</a>&lt; TYPE &gt;::fillAll </td>
          <td>(</td>
          <td class="paramtype">const TYPE &amp;&nbsp;</td>
          <td class="paramname"> <em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">hier::Box</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>box</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Fill all array values within the box with value t. </p>

<p>References <a class="el" href="ArrayData_8C_source.html#l00856">SAMRAI::pdat::ArrayData&lt; TYPE &gt;::fill()</a>.</p>

</div>
</div>
<a class="anchor" id="a1f2c56e4292b31662c0bece4e001a8f5"></a><!-- doxytag: member="SAMRAI::pdat::ArrayData::fill" ref="a1f2c56e4292b31662c0bece4e001a8f5" args="(const TYPE &amp;t, const unsigned int d=0)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html">SAMRAI::pdat::ArrayData</a>&lt; TYPE &gt;::fill </td>
          <td>(</td>
          <td class="paramtype">const TYPE &amp;&nbsp;</td>
          <td class="paramname"> <em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&nbsp;</td>
          <td class="paramname"> <em>d</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Fill all array values associated with depth component d with the value t.</p>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>(d &gt;= 0) &amp;&amp; (d &lt; <a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html#a8cdee70250c48be83e9d0fe53c66db0e">getDepth()</a>) </dd></dl>

<p>References <a class="el" href="Box_8h_source.html#l00613">SAMRAI::hier::Box::empty()</a>, and <a class="el" href="Utilities_8h_source.html#l00110">TBOX_ASSERT</a>.</p>

<p>Referenced by <a class="el" href="ArrayData_8C_source.html#l00845">SAMRAI::pdat::ArrayData&lt; TYPE &gt;::fillAll()</a>.</p>

</div>
</div>
<a class="anchor" id="acb6dab66a1c885080f69caf657fbb040"></a><!-- doxytag: member="SAMRAI::pdat::ArrayData::fill" ref="acb6dab66a1c885080f69caf657fbb040" args="(const TYPE &amp;t, const hier::Box &amp;box, const unsigned int d=0)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html">SAMRAI::pdat::ArrayData</a>&lt; TYPE &gt;::fill </td>
          <td>(</td>
          <td class="paramtype">const TYPE &amp;&nbsp;</td>
          <td class="paramname"> <em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">hier::Box</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>box</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&nbsp;</td>
          <td class="paramname"> <em>d</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Fill all array values associated with depth component d within the box with the value t.</p>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>(d &gt;= 0) &amp;&amp; (d &lt; <a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html#a8cdee70250c48be83e9d0fe53c66db0e">getDepth()</a>) </dd></dl>

<p>References <a class="el" href="Box_8h_source.html#l00613">SAMRAI::hier::Box::empty()</a>, <a class="el" href="Box_8h_source.html#l01313">SAMRAI::hier::Box::getDim()</a>, <a class="el" href="Dimension_8h_source.html#l00136">SAMRAI::tbox::Dimension::getValue()</a>, <a class="el" href="Box_8h_source.html#l00495">SAMRAI::hier::Box::lower()</a>, <a class="el" href="Box_8h_source.html#l00636">SAMRAI::hier::Box::numberCells()</a>, <a class="el" href="Box_8h_source.html#l00693">SAMRAI::hier::Box::offset()</a>, <a class="el" href="Box_8h_source.html#l00667">SAMRAI::hier::Box::size()</a>, and <a class="el" href="Utilities_8h_source.html#l00110">TBOX_ASSERT</a>.</p>

</div>
</div>
<a class="anchor" id="a91be5f8fdef47d9c528d64ccaa534014"></a><!-- doxytag: member="SAMRAI::pdat::ArrayData::getFromRestart" ref="a91be5f8fdef47d9c528d64ccaa534014" args="(const boost::shared_ptr&lt; tbox::Database &gt; &amp;restart_db)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html">SAMRAI::pdat::ArrayData</a>&lt; TYPE &gt;::getFromRestart </td>
          <td>(</td>
          <td class="paramtype">const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Database.html">tbox::Database</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>restart_db</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Check to make sure that the class version and restart file version are equal. If so, read in data from restart database.</p>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>restart_db </dd></dl>

<p>References <a class="el" href="Utilities_8h_source.html#l00110">TBOX_ASSERT</a>, and <a class="el" href="Utilities_8h_source.html#l00060">TBOX_ERROR</a>.</p>

</div>
</div>
<a class="anchor" id="a8594e2cf67c90729aeb4adf98faabaaf"></a><!-- doxytag: member="SAMRAI::pdat::ArrayData::putToRestart" ref="a8594e2cf67c90729aeb4adf98faabaaf" args="(const boost::shared_ptr&lt; tbox::Database &gt; &amp;restart_db) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html">SAMRAI::pdat::ArrayData</a>&lt; TYPE &gt;::putToRestart </td>
          <td>(</td>
          <td class="paramtype">const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Database.html">tbox::Database</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>restart_db</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Write out array data object data to restart database.</p>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>restart_db </dd></dl>

<p>References <a class="el" href="Utilities_8h_source.html#l00110">TBOX_ASSERT</a>.</p>

</div>
</div>
<a class="anchor" id="a114ecb99a07fdcce73f49cab9ff0b0a4"></a><!-- doxytag: member="SAMRAI::pdat::ArrayData::getDim" ref="a114ecb99a07fdcce73f49cab9ff0b0a4" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classSAMRAI_1_1tbox_1_1Dimension.html">tbox::Dimension</a> &amp; <a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html">SAMRAI::pdat::ArrayData</a>&lt; TYPE &gt;::getDim </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the dimension of this object. </p>

<p>References <a class="el" href="Box_8h_source.html#l01313">SAMRAI::hier::Box::getDim()</a>.</p>

<p>Referenced by <a class="el" href="ArrayDataNormOpsReal_8C_source.html#l00043">SAMRAI::math::ArrayDataNormOpsReal&lt; TYPE &gt;::abs()</a>, <a class="el" href="ArrayDataNormOpsInteger_8C_source.html#l00036">SAMRAI::math::ArrayDataNormOpsInteger::abs()</a>, <a class="el" href="ArrayDataNormOpsComplex_8C_source.html#l00036">SAMRAI::math::ArrayDataNormOpsComplex::abs()</a>, <a class="el" href="ArrayDataBasicOps_8C_source.html#l00265">SAMRAI::math::ArrayDataBasicOps&lt; TYPE &gt;::add()</a>, <a class="el" href="ArrayDataBasicOps_8C_source.html#l00155">SAMRAI::math::ArrayDataBasicOps&lt; TYPE &gt;::addScalar()</a>, <a class="el" href="ArrayDataBasicOps_8C_source.html#l01090">SAMRAI::math::ArrayDataBasicOps&lt; TYPE &gt;::axmy()</a>, <a class="el" href="ArrayDataBasicOps_8C_source.html#l00965">SAMRAI::math::ArrayDataBasicOps&lt; TYPE &gt;::axpy()</a>, <a class="el" href="ArrayDataMiscellaneousOpsReal_8C_source.html#l00388">SAMRAI::math::ArrayDataMiscellaneousOpsReal&lt; TYPE &gt;::compareToScalar()</a>, <a class="el" href="ArrayDataMiscellaneousOpsReal_8C_source.html#l00268">SAMRAI::math::ArrayDataMiscellaneousOpsReal&lt; TYPE &gt;::compareToScalarWithControlVolume()</a>, <a class="el" href="ArrayDataMiscellaneousOpsReal_8C_source.html#l00165">SAMRAI::math::ArrayDataMiscellaneousOpsReal&lt; TYPE &gt;::computeConstrProdPos()</a>, <a class="el" href="ArrayDataMiscellaneousOpsReal_8C_source.html#l00041">SAMRAI::math::ArrayDataMiscellaneousOpsReal&lt; TYPE &gt;::computeConstrProdPosWithControlVolume()</a>, <a class="el" href="ArrayDataBasicOps_8C_source.html#l00612">SAMRAI::math::ArrayDataBasicOps&lt; TYPE &gt;::divide()</a>, <a class="el" href="ArrayDataOperationUtilities_8C_source.html#l00170">SAMRAI::pdat::ArrayDataOperationUtilities&lt; TYPE, OP &gt;::doArrayDataBufferOperationOnBox()</a>, <a class="el" href="ArrayDataOperationUtilities_8C_source.html#l00032">SAMRAI::pdat::ArrayDataOperationUtilities&lt; TYPE, OP &gt;::doArrayDataOperationOnBox()</a>, <a class="el" href="ArrayDataNormOpsReal_8C_source.html#l00957">SAMRAI::math::ArrayDataNormOpsReal&lt; TYPE &gt;::dot()</a>, <a class="el" href="ArrayDataNormOpsComplex_8C_source.html#l00513">SAMRAI::math::ArrayDataNormOpsComplex::dot()</a>, <a class="el" href="ArrayDataNormOpsReal_8C_source.html#l00833">SAMRAI::math::ArrayDataNormOpsReal&lt; TYPE &gt;::dotWithControlVolume()</a>, <a class="el" href="ArrayDataNormOpsComplex_8C_source.html#l00395">SAMRAI::math::ArrayDataNormOpsComplex::dotWithControlVolume()</a>, <a class="el" href="ArrayDataNormOpsReal_8C_source.html#l01058">SAMRAI::math::ArrayDataNormOpsReal&lt; TYPE &gt;::integral()</a>, <a class="el" href="ArrayDataNormOpsComplex_8C_source.html#l00613">SAMRAI::math::ArrayDataNormOpsComplex::integral()</a>, <a class="el" href="ArrayDataNormOpsReal_8C_source.html#l00326">SAMRAI::math::ArrayDataNormOpsReal&lt; TYPE &gt;::L1Norm()</a>, <a class="el" href="ArrayDataNormOpsComplex_8C_source.html#l00314">SAMRAI::math::ArrayDataNormOpsComplex::L1Norm()</a>, <a class="el" href="ArrayDataNormOpsReal_8C_source.html#l00226">SAMRAI::math::ArrayDataNormOpsReal&lt; TYPE &gt;::L1NormWithControlVolume()</a>, <a class="el" href="ArrayDataNormOpsComplex_8C_source.html#l00216">SAMRAI::math::ArrayDataNormOpsComplex::L1NormWithControlVolume()</a>, <a class="el" href="ArrayDataBasicOps_8C_source.html#l00824">SAMRAI::math::ArrayDataBasicOps&lt; TYPE &gt;::linearSum()</a>, <a class="el" href="ArrayDataBasicOps_8C_source.html#l01293">SAMRAI::math::ArrayDataBasicOps&lt; TYPE &gt;::max()</a>, <a class="el" href="ArrayDataNormOpsReal_8C_source.html#l00750">SAMRAI::math::ArrayDataNormOpsReal&lt; TYPE &gt;::maxNorm()</a>, <a class="el" href="ArrayDataNormOpsComplex_8C_source.html#l01024">SAMRAI::math::ArrayDataNormOpsComplex::maxNorm()</a>, <a class="el" href="ArrayDataNormOpsReal_8C_source.html#l00646">SAMRAI::math::ArrayDataNormOpsReal&lt; TYPE &gt;::maxNormWithControlVolume()</a>, <a class="el" href="ArrayDataNormOpsComplex_8C_source.html#l00923">SAMRAI::math::ArrayDataNormOpsComplex::maxNormWithControlVolume()</a>, <a class="el" href="ArrayDataMiscellaneousOpsReal_8C_source.html#l00724">SAMRAI::math::ArrayDataMiscellaneousOpsReal&lt; TYPE &gt;::maxPointwiseDivide()</a>, <a class="el" href="ArrayDataBasicOps_8C_source.html#l01213">SAMRAI::math::ArrayDataBasicOps&lt; TYPE &gt;::min()</a>, <a class="el" href="ArrayDataMiscellaneousOpsReal_8C_source.html#l00828">SAMRAI::math::ArrayDataMiscellaneousOpsReal&lt; TYPE &gt;::minPointwiseDivide()</a>, <a class="el" href="ArrayDataBasicOps_8C_source.html#l00497">SAMRAI::math::ArrayDataBasicOps&lt; TYPE &gt;::multiply()</a>, <a class="el" href="ArrayDataBasicOps_8C_source.html#l00724">SAMRAI::math::ArrayDataBasicOps&lt; TYPE &gt;::reciprocal()</a>, <a class="el" href="ArrayDataBasicOps_8C_source.html#l00043">SAMRAI::math::ArrayDataBasicOps&lt; TYPE &gt;::scale()</a>, <a class="el" href="ArrayDataBasicOps_8C_source.html#l01374">SAMRAI::math::ArrayDataBasicOps&lt; TYPE &gt;::setRandomValues()</a>, <a class="el" href="ArrayDataBasicOps_8C_source.html#l00381">SAMRAI::math::ArrayDataBasicOps&lt; TYPE &gt;::subtract()</a>, <a class="el" href="ArrayDataNormOpsReal_8C_source.html#l00139">SAMRAI::math::ArrayDataNormOpsReal&lt; TYPE &gt;::sumControlVolumes()</a>, <a class="el" href="ArrayDataNormOpsComplex_8C_source.html#l00130">SAMRAI::math::ArrayDataNormOpsComplex::sumControlVolumes()</a>, <a class="el" href="ArrayDataMiscellaneousOpsReal_8C_source.html#l00616">SAMRAI::math::ArrayDataMiscellaneousOpsReal&lt; TYPE &gt;::testReciprocal()</a>, <a class="el" href="ArrayDataMiscellaneousOpsReal_8C_source.html#l00488">SAMRAI::math::ArrayDataMiscellaneousOpsReal&lt; TYPE &gt;::testReciprocalWithControlVolume()</a>, <a class="el" href="ArrayDataNormOpsReal_8C_source.html#l00548">SAMRAI::math::ArrayDataNormOpsReal&lt; TYPE &gt;::weightedL2Norm()</a>, <a class="el" href="ArrayDataNormOpsComplex_8C_source.html#l00826">SAMRAI::math::ArrayDataNormOpsComplex::weightedL2Norm()</a>, <a class="el" href="ArrayDataNormOpsReal_8C_source.html#l00432">SAMRAI::math::ArrayDataNormOpsReal&lt; TYPE &gt;::weightedL2NormWithControlVolume()</a>, and <a class="el" href="ArrayDataNormOpsComplex_8C_source.html#l00711">SAMRAI::math::ArrayDataNormOpsComplex::weightedL2NormWithControlVolume()</a>.</p>

</div>
</div>
<a class="anchor" id="afc800893f127830febe13b25b9830b42"></a><!-- doxytag: member="SAMRAI::pdat::ArrayData::isValid" ref="afc800893f127830febe13b25b9830b42" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html">SAMRAI::pdat::ArrayData</a>&lt; TYPE &gt;::isValid </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns true if the array is valid. </p>

<p>References <a class="el" href="Box_8h_source.html#l00613">SAMRAI::hier::Box::empty()</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>source/SAMRAI/pdat/<a class="el" href="ArrayData_8h.html">ArrayData.h</a></li>
<li>source/SAMRAI/pdat/<a class="el" href="ArrayData_8C.html">ArrayData.C</a></li>
</ul>
</div>
<hr size="1"/><address style="text-align: right;"><small>Generated on 5 Jun 2015 for SAMRAI by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.1 </small></address>
</body>
</html>
