<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>SAMRAI: SAMRAI::pdat::ArrayData&lt; TYPE &gt; Class Template Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.7 -->
<div class="tabs">
  <ul>
    <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="namespaces.html"><span>Namespaces</span></a></li>
    <li id="current"><a href="annotated.html"><span>Classes</span></a></li>
    <li><a href="files.html"><span>Files</span></a></li>
    <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
  </ul></div>
<div class="tabs">
  <ul>
    <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
    <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
    <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
  </ul></div>
<div class="nav">
<a class="el" href="namespaceSAMRAI.html">SAMRAI</a>::<a class="el" href="namespaceSAMRAI_1_1pdat.html">pdat</a>::<a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html">ArrayData</a></div>
<h1>SAMRAI::pdat::ArrayData&lt; TYPE &gt; Class Template Reference</h1><!-- doxytag: class="SAMRAI::pdat::ArrayData" -->Class ArrayData&lt;TYPE&gt; is a basic templated array structure defined over the index space of a box (with a specified depth) that provides the support for the various standard array-based patch data subclasses.  
<a href="#_details">More...</a>
<p>
<code>#include &lt;source/SAMRAI/pdat/ArrayData.h&gt;</code>
<p>
<a href="classSAMRAI_1_1pdat_1_1ArrayData-members.html">List of all members.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Types</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef <a class="el" href="classSAMRAI_1_1pdat_1_1ArrayDataIterator.html">ArrayDataIterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html#cac0e33301deefb57ade39df9c3ecaca">iterator</a></td></tr>

<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html#0ac3abeccf53bd6acb6a606cc41e526f">ArrayData</a> (const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">hier::Box</a> &amp;box, int depth)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html#b6c570cfb8bac255c4deb8fed4c55978">~ArrayData</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html#b4318fbc760311b3c14c73d93f2c7c59">isInitialized</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns true when the array has been properly initialized and storage has been allocated; otherwise, return false.  <a href="#b4318fbc760311b3c14c73d93f2c7c59"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html#c20e9b3e32e6cb1d77e660d9996cf965">undefineData</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">hier::Box</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html#29f97ea75451c60712e64b9215773a96">getBox</a> () const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html#be7b6878cb94103ca94864007da52c99">getDepth</a> () const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html#93dbf297e06a9a32ac59df030abf5bf2">getOffset</a> () const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">TYPE *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html#c820551fccdb19950185335ebafcff87">getPointer</a> (const int d=0)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">const TYPE *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html#04be6f16030ddd073a66f5210946783a">getPointer</a> (const int d=0) const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">TYPE &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html#739d3b820ac2cda78a61cc6c6a7e0a89">operator()</a> (const <a class="el" href="classSAMRAI_1_1hier_1_1Index.html">hier::Index</a> &amp;i, const int d)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">const TYPE &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html#3042a210780a3fa58320ce17f96f8eb1">operator()</a> (const <a class="el" href="classSAMRAI_1_1hier_1_1Index.html">hier::Index</a> &amp;i, const int d) const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html#a5236d567261cd29c10acafb85cea6bc">copy</a> (const <a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html">ArrayData</a>&lt; TYPE &gt; &amp;src, const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">hier::Box</a> &amp;box)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html#12d5491f610d5eb999937137c97f70c6">copy</a> (const <a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html">ArrayData</a>&lt; TYPE &gt; &amp;src, const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">hier::Box</a> &amp;box, const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a> &amp;src_shift)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html#11831ebfb394916a2ac9705077ae08cf">copy</a> (const <a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html">ArrayData</a>&lt; TYPE &gt; &amp;src, const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">hier::Box</a> &amp;box, const <a class="el" href="classSAMRAI_1_1hier_1_1Transformation.html">hier::Transformation</a> &amp;transformation)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html#bdb4a218f3b0bd5e336de05be155459c">copy</a> (const <a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html">ArrayData</a>&lt; TYPE &gt; &amp;src, const <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">hier::BoxContainer</a> &amp;boxes, const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a> &amp;src_shift)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html#ed10a27282596877bdf68529da88d5aa">copy</a> (const <a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html">ArrayData</a>&lt; TYPE &gt; &amp;src, const <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">hier::BoxContainer</a> &amp;boxes, const <a class="el" href="classSAMRAI_1_1hier_1_1Transformation.html">hier::Transformation</a> &amp;transformation)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html#7f8298bcb031689648189877f60ef4c4">copyDepth</a> (int dst_depth, const <a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html">ArrayData</a>&lt; TYPE &gt; &amp;src, int src_depth, const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">hier::Box</a> &amp;box)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html#546a49c7a43435719eb23cddf307c75a">sum</a> (const <a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html">ArrayData</a>&lt; TYPE &gt; &amp;src, const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">hier::Box</a> &amp;box)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html#6b4cbf834645f7c3860b27ab2d3671e7">sum</a> (const <a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html">ArrayData</a>&lt; TYPE &gt; &amp;src, const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">hier::Box</a> &amp;box, const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a> &amp;src_shift)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html#c55ad9b3847deda1cd8c4e27ff927515">sum</a> (const <a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html">ArrayData</a>&lt; TYPE &gt; &amp;src, const <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">hier::BoxContainer</a> &amp;boxes, const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a> &amp;src_shift)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html#5a748be82196866323fad6ad02c0a186">getDataStreamSize</a> (const <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">hier::BoxContainer</a> &amp;boxes, const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a> &amp;src_shift) const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html#5749782cdde566714e1a301c6b6ff215">packStream</a> (<a class="el" href="classSAMRAI_1_1tbox_1_1MessageStream.html">tbox::MessageStream</a> &amp;stream, const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">hier::Box</a> &amp;dest_box, const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a> &amp;src_shift) const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html#dc5a4a458f5128892904c9abbe79e5e7">packStream</a> (<a class="el" href="classSAMRAI_1_1tbox_1_1MessageStream.html">tbox::MessageStream</a> &amp;stream, const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">hier::Box</a> &amp;dest_box, const <a class="el" href="classSAMRAI_1_1hier_1_1Transformation.html">hier::Transformation</a> &amp;src_shift) const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html#d887a30457731973f7d81bbf9b51a4f0">packStream</a> (<a class="el" href="classSAMRAI_1_1tbox_1_1MessageStream.html">tbox::MessageStream</a> &amp;stream, const <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">hier::BoxContainer</a> &amp;dest_boxes, const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a> &amp;src_shift) const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html#e9e56df114a30b50764d6d9cfa0e2e5e">packStream</a> (<a class="el" href="classSAMRAI_1_1tbox_1_1MessageStream.html">tbox::MessageStream</a> &amp;stream, const <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">hier::BoxContainer</a> &amp;dest_boxes, const <a class="el" href="classSAMRAI_1_1hier_1_1Transformation.html">hier::Transformation</a> &amp;transformation) const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html#2772d6ae19bcf06c96c6b61a1d00b092">unpackStream</a> (<a class="el" href="classSAMRAI_1_1tbox_1_1MessageStream.html">tbox::MessageStream</a> &amp;stream, const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">hier::Box</a> &amp;dest_box, const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a> &amp;src_offset)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html#f3f9813305196b6177eb912dc6ee5c4a">unpackStream</a> (<a class="el" href="classSAMRAI_1_1tbox_1_1MessageStream.html">tbox::MessageStream</a> &amp;stream, const <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">hier::BoxContainer</a> &amp;dest_boxes, const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a> &amp;src_offset)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html#c5927e484570420e28cb53ded1e6fd4a">unpackStreamAndSum</a> (<a class="el" href="classSAMRAI_1_1tbox_1_1MessageStream.html">tbox::MessageStream</a> &amp;stream, const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">hier::Box</a> &amp;dest_box, const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a> &amp;src_offset)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html#4b7272aec1daea63a01bb2ea1bc4eef9">unpackStreamAndSum</a> (<a class="el" href="classSAMRAI_1_1tbox_1_1MessageStream.html">tbox::MessageStream</a> &amp;stream, const <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">hier::BoxContainer</a> &amp;dest_boxes, const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a> &amp;src_offset)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html#67ebb8f53913afa73557cf87c1e59c23">fillAll</a> (const TYPE &amp;t)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html#3edb587b90c00e2416a628537bb7d370">fillAll</a> (const TYPE &amp;t, const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">hier::Box</a> &amp;box)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html#0bea85dadac71f1c4916a1ef96cae0ff">fill</a> (const TYPE &amp;t, const int d=0)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html#b6d34044fbf094e5d6232dbb77890f47">fill</a> (const TYPE &amp;t, const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">hier::Box</a> &amp;box, const int d=0)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html#f60d247d45b5fb1ea7442a58f727e5ea">getFromRestart</a> (const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Database.html">tbox::Database</a> &gt; &amp;restart_db)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html#ab0d1aafe2f112679e6ab39d9537b73f">putToRestart</a> (const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Database.html">tbox::Database</a> &gt; &amp;restart_db) const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">const <a class="el" href="classSAMRAI_1_1tbox_1_1Dimension.html">tbox::Dimension</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html#7e8f40d516754c80f1fb194c5c5b1554">getDim</a> () const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html#9217a0351e823009c41570d277a868d4">isValid</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns true if the array is valid.  <a href="#9217a0351e823009c41570d277a868d4"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Static Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html#9e8fa3c7b93aed94646003c5aa26e084">canEstimateStreamSizeFromBox</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">static size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html#d04c744d6bf2832f3f7bc21849793fd5">getSizeOfData</a> (const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">hier::Box</a> &amp;box, int depth)</td></tr>

</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
<h3>template&lt;class TYPE&gt;<br>
 class SAMRAI::pdat::ArrayData&lt; TYPE &gt;</h3>

Class ArrayData&lt;TYPE&gt; is a basic templated array structure defined over the index space of a box (with a specified depth) that provides the support for the various standard array-based patch data subclasses. 
<p>
The data storage is in (i,...,k,d) order, where i,...,k indicates spatial indices and the d indicates the component at that location. Memory allocation is in column-major ordering (e.g., Fortran style) so that the leftmost index runs fastest in memory.<p>
The data type TYPE must define a default constructor (that takes no arguments) and also the assignment operator. Note that a number of functions only work for standard built-in types (bool, char, double, float, and int). To use this class with other user-defined types, many of these functions will need to be specialized, especially those that deal with message packing and unpacking. 
<p>
<hr><h2>Member Typedef Documentation</h2>
<a class="anchor" name="cac0e33301deefb57ade39df9c3ecaca"></a><!-- doxytag: member="SAMRAI::pdat::ArrayData::iterator" ref="cac0e33301deefb57ade39df9c3ecaca" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classSAMRAI_1_1pdat_1_1ArrayDataIterator.html">ArrayDataIterator</a> <a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html">SAMRAI::pdat::ArrayData</a>&lt; TYPE &gt;::<a class="el" href="classSAMRAI_1_1pdat_1_1ArrayDataIterator.html">iterator</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The array data iterator iterates over the elements of a box associated with an <a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html">ArrayData</a> object. This typedef is convenient link to the <a class="el" href="classSAMRAI_1_1pdat_1_1ArrayDataIterator.html">ArrayDataIterator</a> class. 
</div>
</div><p>
<hr><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" name="0ac3abeccf53bd6acb6a606cc41e526f"></a><!-- doxytag: member="SAMRAI::pdat::ArrayData::ArrayData" ref="0ac3abeccf53bd6acb6a606cc41e526f" args="(const hier::Box &amp;box, int depth)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html">SAMRAI::pdat::ArrayData</a>&lt; TYPE &gt;::<a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html">ArrayData</a>           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">hier::Box</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>box</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>depth</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Construct an array data object.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>box</em>&nbsp;</td><td>Const reference to box object describing the spatial extents of the index space associated with the array data object. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>depth</em>&nbsp;</td><td>Integer number of data values at each spatial location in the array.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Precondition:</b></dt><dd>depth &gt; 0 </dd></dl>

</div>
</div><p>
<a class="anchor" name="b6c570cfb8bac255c4deb8fed4c55978"></a><!-- doxytag: member="SAMRAI::pdat::ArrayData::~ArrayData" ref="b6c570cfb8bac255c4deb8fed4c55978" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html">SAMRAI::pdat::ArrayData</a>&lt; TYPE &gt;::~<a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html">ArrayData</a>           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The destructor for an array data object releases all memory allocated for the array elements. 
</div>
</div><p>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="9e8fa3c7b93aed94646003c5aa26e084"></a><!-- doxytag: member="SAMRAI::pdat::ArrayData::canEstimateStreamSizeFromBox" ref="9e8fa3c7b93aed94646003c5aa26e084" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html">SAMRAI::pdat::ArrayData</a>&lt; TYPE &gt;::canEstimateStreamSizeFromBox           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Static member function that returns true when the amount of buffer space in a message stream can be estimated from box only. For built-in types (bool, char, double, float, int, and dcomplex), this routine returns true. For other data types (template paramters) that may require special handling, a different implementation must be provided. 
</div>
</div><p>
<a class="anchor" name="d04c744d6bf2832f3f7bc21849793fd5"></a><!-- doxytag: member="SAMRAI::pdat::ArrayData::getSizeOfData" ref="d04c744d6bf2832f3f7bc21849793fd5" args="(const hier::Box &amp;box, int depth)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html">SAMRAI::pdat::ArrayData</a>&lt; TYPE &gt;::getSizeOfData           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">hier::Box</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>box</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>depth</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Static member function that returns the amount of memory space needed to store data of given depth on a box.<p>
Note that this function is only defined for the standard data types: bool, char, double, float, int, and dcomplex. It must be provided for other template parameter types.<p>
<dl compact><dt><b>Returns:</b></dt><dd>size_t value indicating the amount of memory space needed for the data.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>box</em>&nbsp;</td><td>Const reference to box object describing the spatial extents of the array data index region of interest. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>depth</em>&nbsp;</td><td>Integer number of data values at each spatial location in the array. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="b4318fbc760311b3c14c73d93f2c7c59"></a><!-- doxytag: member="SAMRAI::pdat::ArrayData::isInitialized" ref="b4318fbc760311b3c14c73d93f2c7c59" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html">SAMRAI::pdat::ArrayData</a>&lt; TYPE &gt;::isInitialized           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns true when the array has been properly initialized and storage has been allocated; otherwise, return false. 
<p>
Note: Only arrays that have been initialized can do anything useful. 
</div>
</div><p>
<a class="anchor" name="c20e9b3e32e6cb1d77e660d9996cf965"></a><!-- doxytag: member="SAMRAI::pdat::ArrayData::undefineData" ref="c20e9b3e32e6cb1d77e660d9996cf965" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html">SAMRAI::pdat::ArrayData</a>&lt; TYPE &gt;::undefineData           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set the array data to an ``undefined'' state appropriate for the data type. For example, for float and double, this means setting data to signaling NaNs that cause a floating point assertion when used in a numerical expression without being set to valid values. 
</div>
</div><p>
<a class="anchor" name="29f97ea75451c60712e64b9215773a96"></a><!-- doxytag: member="SAMRAI::pdat::ArrayData::getBox" ref="29f97ea75451c60712e64b9215773a96" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">hier::Box</a> &amp; <a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html">SAMRAI::pdat::ArrayData</a>&lt; TYPE &gt;::getBox           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return the box over which the array is defined. 
</div>
</div><p>
<a class="anchor" name="be7b6878cb94103ca94864007da52c99"></a><!-- doxytag: member="SAMRAI::pdat::ArrayData::getDepth" ref="be7b6878cb94103ca94864007da52c99" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html">SAMRAI::pdat::ArrayData</a>&lt; TYPE &gt;::getDepth           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return the depth (e.g., the number of data values at each spatial location) of this array. 
</div>
</div><p>
<a class="anchor" name="93dbf297e06a9a32ac59df030abf5bf2"></a><!-- doxytag: member="SAMRAI::pdat::ArrayData::getOffset" ref="93dbf297e06a9a32ac59df030abf5bf2" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html">SAMRAI::pdat::ArrayData</a>&lt; TYPE &gt;::getOffset           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return the offset (e.g., the number of data values for each depth component) of this array. 
</div>
</div><p>
<a class="anchor" name="c820551fccdb19950185335ebafcff87"></a><!-- doxytag: member="SAMRAI::pdat::ArrayData::getPointer" ref="c820551fccdb19950185335ebafcff87" args="(const int d=0)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">TYPE * <a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html">SAMRAI::pdat::ArrayData</a>&lt; TYPE &gt;::getPointer           </td>
          <td>(</td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>d</em> = <code>0</code>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get a non-const pointer to the beginning of the given depth component of this data array.<p>
<dl compact><dt><b>Precondition:</b></dt><dd>(d &gt;= 0) &amp;&amp; (d &lt; <a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html#be7b6878cb94103ca94864007da52c99">getDepth()</a>) </dd></dl>

</div>
</div><p>
<a class="anchor" name="04be6f16030ddd073a66f5210946783a"></a><!-- doxytag: member="SAMRAI::pdat::ArrayData::getPointer" ref="04be6f16030ddd073a66f5210946783a" args="(const int d=0) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const TYPE * <a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html">SAMRAI::pdat::ArrayData</a>&lt; TYPE &gt;::getPointer           </td>
          <td>(</td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>d</em> = <code>0</code>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get a const pointer to the beginning of the given depth component of this data array.<p>
<dl compact><dt><b>Precondition:</b></dt><dd>(d &gt;= 0) &amp;&amp; (d &lt; <a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html#be7b6878cb94103ca94864007da52c99">getDepth()</a>) </dd></dl>

</div>
</div><p>
<a class="anchor" name="739d3b820ac2cda78a61cc6c6a7e0a89"></a><!-- doxytag: member="SAMRAI::pdat::ArrayData::operator()" ref="739d3b820ac2cda78a61cc6c6a7e0a89" args="(const hier::Index &amp;i, const int d)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">TYPE &amp; <a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html">SAMRAI::pdat::ArrayData</a>&lt; TYPE &gt;::operator()           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1Index.html">hier::Index</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>d</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return reference to value in this array associated with the given box index and depth component.<p>
<dl compact><dt><b>Precondition:</b></dt><dd><a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html#7e8f40d516754c80f1fb194c5c5b1554">getDim()</a> == i.getDim() <p>
(d &gt;= 0) &amp;&amp; (d &lt; <a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html#be7b6878cb94103ca94864007da52c99">getDepth()</a>) </dd></dl>

</div>
</div><p>
<a class="anchor" name="3042a210780a3fa58320ce17f96f8eb1"></a><!-- doxytag: member="SAMRAI::pdat::ArrayData::operator()" ref="3042a210780a3fa58320ce17f96f8eb1" args="(const hier::Index &amp;i, const int d) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const TYPE &amp; <a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html">SAMRAI::pdat::ArrayData</a>&lt; TYPE &gt;::operator()           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1Index.html">hier::Index</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>d</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return const reference to value in this array associated with the given box index and depth component.<p>
<dl compact><dt><b>Precondition:</b></dt><dd><a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html#7e8f40d516754c80f1fb194c5c5b1554">getDim()</a> == i.getDim() <p>
(d &gt;= 0) &amp;&amp; (d &lt; <a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html#be7b6878cb94103ca94864007da52c99">getDepth()</a>) </dd></dl>

</div>
</div><p>
<a class="anchor" name="a5236d567261cd29c10acafb85cea6bc"></a><!-- doxytag: member="SAMRAI::pdat::ArrayData::copy" ref="a5236d567261cd29c10acafb85cea6bc" args="(const ArrayData&lt; TYPE &gt; &amp;src, const hier::Box &amp;box)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html">SAMRAI::pdat::ArrayData</a>&lt; TYPE &gt;::copy           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html">ArrayData</a>&lt; TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">hier::Box</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>box</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Copy data from the source array data object to this array data object on the specified index space region.<p>
Note that this routine assumes that the source and destination box regions require no shifting to make them consistent. This routine will intersect the specified box with the source and destination boxes to find the region of intersection.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>src</em>&nbsp;</td><td>Const reference to source array data object. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>box</em>&nbsp;</td><td>Const reference to box object describing the spatial extents of the index space region over which to perform the copy operation. Note: the box is in either the source or destination index space (which are assumed to be the same).</td></tr>
  </table>
</dl>
<dl compact><dt><b>Precondition:</b></dt><dd>(<a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html#7e8f40d516754c80f1fb194c5c5b1554">getDim()</a> == src.getDim()) &amp;&amp; (<a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html#7e8f40d516754c80f1fb194c5c5b1554">getDim()</a> == box.getDim()) </dd></dl>

</div>
</div><p>
<a class="anchor" name="12d5491f610d5eb999937137c97f70c6"></a><!-- doxytag: member="SAMRAI::pdat::ArrayData::copy" ref="12d5491f610d5eb999937137c97f70c6" args="(const ArrayData&lt; TYPE &gt; &amp;src, const hier::Box &amp;box, const hier::IntVector &amp;src_shift)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html">SAMRAI::pdat::ArrayData</a>&lt; TYPE &gt;::copy           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html">ArrayData</a>&lt; TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">hier::Box</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>box</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>src_shift</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Copy data from the source array data object to this array data object on the specified index space region.<p>
Note that this routine assumes that the source array box region must be shifted to be consistent with the destination (this) array box region. This routine will intersect the specified box with the destination box and shifted source box to find the region of intersection.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>src</em>&nbsp;</td><td>Const reference to source array data object. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>box</em>&nbsp;</td><td>Const reference to box object describing the spatial extents of the index space region over which to perform the copy operation. Note: the box is in the destination index space. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>src_shift</em>&nbsp;</td><td>Const reference to shift vector used to put the source array data box into the index space region of this array data object. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="11831ebfb394916a2ac9705077ae08cf"></a><!-- doxytag: member="SAMRAI::pdat::ArrayData::copy" ref="11831ebfb394916a2ac9705077ae08cf" args="(const ArrayData&lt; TYPE &gt; &amp;src, const hier::Box &amp;box, const hier::Transformation &amp;transformation)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html">SAMRAI::pdat::ArrayData</a>&lt; TYPE &gt;::copy           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html">ArrayData</a>&lt; TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">hier::Box</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>box</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1Transformation.html">hier::Transformation</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>transformation</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="bdb4a218f3b0bd5e336de05be155459c"></a><!-- doxytag: member="SAMRAI::pdat::ArrayData::copy" ref="bdb4a218f3b0bd5e336de05be155459c" args="(const ArrayData&lt; TYPE &gt; &amp;src, const hier::BoxContainer &amp;boxes, const hier::IntVector &amp;src_shift)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html">SAMRAI::pdat::ArrayData</a>&lt; TYPE &gt;::copy           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html">ArrayData</a>&lt; TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">hier::BoxContainer</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>boxes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>src_shift</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Copy data from the source array data object to this array data object on the specified index space regions.<p>
Note that this routine assumes that the source array box region must be shifted to be consistent with the destination (this) array box region. This routine will intersect the specified boxes with the destination box and shifted source box to find the regions of intersection.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>src</em>&nbsp;</td><td>Const reference to source array data object. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>boxes</em>&nbsp;</td><td>Const reference to box list describing the spatial extents of the index space regions over which to perform the copy operation. Note: the boxes are in the destination index space. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>src_shift</em>&nbsp;</td><td>Const reference to shift vector used to put the source array data box into the index space region of this array data object. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="ed10a27282596877bdf68529da88d5aa"></a><!-- doxytag: member="SAMRAI::pdat::ArrayData::copy" ref="ed10a27282596877bdf68529da88d5aa" args="(const ArrayData&lt; TYPE &gt; &amp;src, const hier::BoxContainer &amp;boxes, const hier::Transformation &amp;transformation)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html">SAMRAI::pdat::ArrayData</a>&lt; TYPE &gt;::copy           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html">ArrayData</a>&lt; TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">hier::BoxContainer</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>boxes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1Transformation.html">hier::Transformation</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>transformation</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="7f8298bcb031689648189877f60ef4c4"></a><!-- doxytag: member="SAMRAI::pdat::ArrayData::copyDepth" ref="7f8298bcb031689648189877f60ef4c4" args="(int dst_depth, const ArrayData&lt; TYPE &gt; &amp;src, int src_depth, const hier::Box &amp;box)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html">SAMRAI::pdat::ArrayData</a>&lt; TYPE &gt;::copyDepth           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>dst_depth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html">ArrayData</a>&lt; TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>src_depth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">hier::Box</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>box</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Copy given source depth of source array data object to given destination depth of this array data object on the specified index space region.<p>
Note that this routine assumes that the source and destination box regions require no shifting to make them consistent. This routine will intersect the specified box with the source and destination boxes to find the region of intersection.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dst_depth</em>&nbsp;</td><td>Integer depth of destination array. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>src</em>&nbsp;</td><td>Const reference to source array data object. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>src_depth</em>&nbsp;</td><td>Integer depth of source array. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>box</em>&nbsp;</td><td>Const reference to box object describing the spatial extents of the index space region over which to perform the copy operation. Note: the box is in either the source or destination index space (which are assumed to be the same).</td></tr>
  </table>
</dl>
<dl compact><dt><b>Precondition:</b></dt><dd>(0 &lt;= dst_depth) &amp;&amp; (dst_depth &lt;= <a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html#be7b6878cb94103ca94864007da52c99">getDepth()</a>)) <p>
(0 &lt;= src_depth) &amp;&amp; (src_depth &lt;= src.getDepth()) </dd></dl>

</div>
</div><p>
<a class="anchor" name="546a49c7a43435719eb23cddf307c75a"></a><!-- doxytag: member="SAMRAI::pdat::ArrayData::sum" ref="546a49c7a43435719eb23cddf307c75a" args="(const ArrayData&lt; TYPE &gt; &amp;src, const hier::Box &amp;box)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html">SAMRAI::pdat::ArrayData</a>&lt; TYPE &gt;::sum           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html">ArrayData</a>&lt; TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">hier::Box</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>box</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Add data from the source array data object to this array data object on the specified index space region.<p>
Note that this routine assumes that the source and destination box regions require no shifting to make them consistent. This routine will intersect the specified box with the source and destination boxes to find the region of intersection.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>src</em>&nbsp;</td><td>Const reference to source array data object. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>box</em>&nbsp;</td><td>Const reference to box object describing the spatial extents of the index space region over which to perform the sum operation. Note: the box is in either the source or destination index space (which are assumed to be the same). </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="6b4cbf834645f7c3860b27ab2d3671e7"></a><!-- doxytag: member="SAMRAI::pdat::ArrayData::sum" ref="6b4cbf834645f7c3860b27ab2d3671e7" args="(const ArrayData&lt; TYPE &gt; &amp;src, const hier::Box &amp;box, const hier::IntVector &amp;src_shift)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html">SAMRAI::pdat::ArrayData</a>&lt; TYPE &gt;::sum           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html">ArrayData</a>&lt; TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">hier::Box</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>box</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>src_shift</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Add data from the source array data object to this array data object on the specified index space region.<p>
Note that this routine assumes that the source array box region must be shifted to be consistent with the destination (this) array box region. This routine will intersect the specified box with the destination box and shifted source box to find the region of intersection.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>src</em>&nbsp;</td><td>Const reference to source array data object. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>box</em>&nbsp;</td><td>Const reference to box object describing the spatial extents of the index space region over which to perform the sum operation. Note: the box is in the destination index space. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>src_shift</em>&nbsp;</td><td>Const reference to shift vector used to put the source array data box into the index space region of this array data object. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="c55ad9b3847deda1cd8c4e27ff927515"></a><!-- doxytag: member="SAMRAI::pdat::ArrayData::sum" ref="c55ad9b3847deda1cd8c4e27ff927515" args="(const ArrayData&lt; TYPE &gt; &amp;src, const hier::BoxContainer &amp;boxes, const hier::IntVector &amp;src_shift)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html">SAMRAI::pdat::ArrayData</a>&lt; TYPE &gt;::sum           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html">ArrayData</a>&lt; TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">hier::BoxContainer</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>boxes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>src_shift</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Add data from the source array data object to this array data object on the specified index space regions.<p>
Note that this routine assumes that the source array box region must be shifted to be consistent with the destination (this) array box region. This routine will intersect the specified boxes with the destination box and shifted source box to find the regions of intersection.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>src</em>&nbsp;</td><td>Const reference to source array data object. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>boxes</em>&nbsp;</td><td>Const reference to box list describing the spatial extents of the index space regions over which to perform the sum operation. Note: the boxes are in the destination index space. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>src_shift</em>&nbsp;</td><td>Const reference to shift vector used to put the source array data box into the index space region of this array data object. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="5a748be82196866323fad6ad02c0a186"></a><!-- doxytag: member="SAMRAI::pdat::ArrayData::getDataStreamSize" ref="5a748be82196866323fad6ad02c0a186" args="(const hier::BoxContainer &amp;boxes, const hier::IntVector &amp;src_shift) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html">SAMRAI::pdat::ArrayData</a>&lt; TYPE &gt;::getDataStreamSize           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">hier::BoxContainer</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>boxes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>src_shift</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Calculate the number of bytes needed to stream the data living in the specified box domains. This routine is only defined for the built-in types of bool, char, double, float, int, and dcomplex. For all other types, a specialized implementation must be provided.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>boxes</em>&nbsp;</td><td>Const reference to box list describing the spatial extents of the index space regions of interest. Note: the boxes are assumed to be in the index space of this array data object. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>src_shift</em>&nbsp;</td><td>Const reference to vector used to shift the given boxes into the index space region of this array data object. Note: this argument is currently ignored.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Precondition:</b></dt><dd>(<a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html#7e8f40d516754c80f1fb194c5c5b1554">getDim()</a> == src_shift.getDim()) </dd></dl>

</div>
</div><p>
<a class="anchor" name="5749782cdde566714e1a301c6b6ff215"></a><!-- doxytag: member="SAMRAI::pdat::ArrayData::packStream" ref="5749782cdde566714e1a301c6b6ff215" args="(tbox::MessageStream &amp;stream, const hier::Box &amp;dest_box, const hier::IntVector &amp;src_shift) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html">SAMRAI::pdat::ArrayData</a>&lt; TYPE &gt;::packStream           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1tbox_1_1MessageStream.html">tbox::MessageStream</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">hier::Box</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>dest_box</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>src_shift</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Pack data living on the specified index region into the stream.<p>
Note that this routine assumes that the given box region must be shifted to be consistent with the source (this) array box region.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>stream</em>&nbsp;</td><td>Reference to stream into which to pack data. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dest_box</em>&nbsp;</td><td>Const reference to box describing the spatial extent of the destination index space region of interest. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>src_shift</em>&nbsp;</td><td>Const reference to vector used to shift the given box into the index space region of this (source) array data object.</td></tr>
  </table>
</dl>
Note: The shifted box must lie completely within the index space of this array data object. When assertion checking is active, the routine will abort if the shifted box is not contained in the index space of this array. 
</div>
</div><p>
<a class="anchor" name="dc5a4a458f5128892904c9abbe79e5e7"></a><!-- doxytag: member="SAMRAI::pdat::ArrayData::packStream" ref="dc5a4a458f5128892904c9abbe79e5e7" args="(tbox::MessageStream &amp;stream, const hier::Box &amp;dest_box, const hier::Transformation &amp;src_shift) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html">SAMRAI::pdat::ArrayData</a>&lt; TYPE &gt;::packStream           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1tbox_1_1MessageStream.html">tbox::MessageStream</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">hier::Box</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>dest_box</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1Transformation.html">hier::Transformation</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>src_shift</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="d887a30457731973f7d81bbf9b51a4f0"></a><!-- doxytag: member="SAMRAI::pdat::ArrayData::packStream" ref="d887a30457731973f7d81bbf9b51a4f0" args="(tbox::MessageStream &amp;stream, const hier::BoxContainer &amp;dest_boxes, const hier::IntVector &amp;src_shift) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html">SAMRAI::pdat::ArrayData</a>&lt; TYPE &gt;::packStream           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1tbox_1_1MessageStream.html">tbox::MessageStream</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">hier::BoxContainer</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>dest_boxes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>src_shift</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Pack data living on the specified index regions into the stream.<p>
Note that this routine assumes that the given box regions must be shifted to be consistent with the source (this) array box region.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>stream</em>&nbsp;</td><td>Reference to stream into which to pack data. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dest_boxes</em>&nbsp;</td><td>Const reference to boxes describing the spatial extents of the destination index space regions of interest. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>src_shift</em>&nbsp;</td><td>Const reference to vector used to shift the given boxes into the index space region of this (source) array data object.</td></tr>
  </table>
</dl>
Note: The shifted boxes must lie completely within the index space of this array. If compiled with assertions enabled, the routine will abort if the shifted boxes are not contained in the index space of this array. 
</div>
</div><p>
<a class="anchor" name="e9e56df114a30b50764d6d9cfa0e2e5e"></a><!-- doxytag: member="SAMRAI::pdat::ArrayData::packStream" ref="e9e56df114a30b50764d6d9cfa0e2e5e" args="(tbox::MessageStream &amp;stream, const hier::BoxContainer &amp;dest_boxes, const hier::Transformation &amp;transformation) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html">SAMRAI::pdat::ArrayData</a>&lt; TYPE &gt;::packStream           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1tbox_1_1MessageStream.html">tbox::MessageStream</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">hier::BoxContainer</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>dest_boxes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1Transformation.html">hier::Transformation</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>transformation</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="2772d6ae19bcf06c96c6b61a1d00b092"></a><!-- doxytag: member="SAMRAI::pdat::ArrayData::unpackStream" ref="2772d6ae19bcf06c96c6b61a1d00b092" args="(tbox::MessageStream &amp;stream, const hier::Box &amp;dest_box, const hier::IntVector &amp;src_offset)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html">SAMRAI::pdat::ArrayData</a>&lt; TYPE &gt;::unpackStream           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1tbox_1_1MessageStream.html">tbox::MessageStream</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">hier::Box</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>dest_box</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>src_offset</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Unpack data from the stream into the index region specified.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>stream</em>&nbsp;</td><td>Reference to stream from which to unpack data. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dest_box</em>&nbsp;</td><td>Const reference to box describing the spatial extent of the destination index space region of interest. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>src_offset</em>&nbsp;</td><td>Const reference to vector used to offset box into the index space region of some (source) array data object. Currently, this argument is ignored.</td></tr>
  </table>
</dl>
Note: The given box must lie completely within the index space of this array data object. When assertion checking is active, the routine will abort if the box is not contained in the index space of this array. 
</div>
</div><p>
<a class="anchor" name="f3f9813305196b6177eb912dc6ee5c4a"></a><!-- doxytag: member="SAMRAI::pdat::ArrayData::unpackStream" ref="f3f9813305196b6177eb912dc6ee5c4a" args="(tbox::MessageStream &amp;stream, const hier::BoxContainer &amp;dest_boxes, const hier::IntVector &amp;src_offset)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html">SAMRAI::pdat::ArrayData</a>&lt; TYPE &gt;::unpackStream           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1tbox_1_1MessageStream.html">tbox::MessageStream</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">hier::BoxContainer</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>dest_boxes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>src_offset</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Unpack data from the stream into the index regions specified.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>stream</em>&nbsp;</td><td>Reference to stream from which to unpack data. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dest_boxes</em>&nbsp;</td><td>Const reference to box list describing the spatial extents of the destination index space regions of interest. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>src_offset</em>&nbsp;</td><td>Const reference to vector used to offset the given boxes into the index space region of some (source) array data object. Currently, this argument is ignored.</td></tr>
  </table>
</dl>
Note: The given boxes must lie completely within the index space of this array data object. When assertion checking is active, the routine will abort if some box is not contained in the index space of this array. 
</div>
</div><p>
<a class="anchor" name="c5927e484570420e28cb53ded1e6fd4a"></a><!-- doxytag: member="SAMRAI::pdat::ArrayData::unpackStreamAndSum" ref="c5927e484570420e28cb53ded1e6fd4a" args="(tbox::MessageStream &amp;stream, const hier::Box &amp;dest_box, const hier::IntVector &amp;src_offset)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html">SAMRAI::pdat::ArrayData</a>&lt; TYPE &gt;::unpackStreamAndSum           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1tbox_1_1MessageStream.html">tbox::MessageStream</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">hier::Box</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>dest_box</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>src_offset</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Unpack data from the stream and add to the array in the index region specified.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>stream</em>&nbsp;</td><td>Reference to stream from which to unpack data. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dest_box</em>&nbsp;</td><td>Const reference to box describing the spatial extent of the destination index space region of interest. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>src_offset</em>&nbsp;</td><td>Const reference to vector used to offset the given box into the index space region of some (source) array data object. Currently, this argument is ignored.</td></tr>
  </table>
</dl>
Note: The given box must lie completely within the index space of this array data object. When assertion checking is active, the routine will abort if the box is not contained in the index space of this array. 
</div>
</div><p>
<a class="anchor" name="4b7272aec1daea63a01bb2ea1bc4eef9"></a><!-- doxytag: member="SAMRAI::pdat::ArrayData::unpackStreamAndSum" ref="4b7272aec1daea63a01bb2ea1bc4eef9" args="(tbox::MessageStream &amp;stream, const hier::BoxContainer &amp;dest_boxes, const hier::IntVector &amp;src_offset)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html">SAMRAI::pdat::ArrayData</a>&lt; TYPE &gt;::unpackStreamAndSum           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1tbox_1_1MessageStream.html">tbox::MessageStream</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">hier::BoxContainer</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>dest_boxes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>src_offset</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Unpack data from the stream and ad to the array in the index region specified.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>stream</em>&nbsp;</td><td>Reference to stream from which to unpack data. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dest_boxes</em>&nbsp;</td><td>Const reference to box list describing the spatial extents of the destination index space regions of interest. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>src_offset</em>&nbsp;</td><td>Const reference to vector used to offset the given boxes into the index space region of some (source) array data object. Currently, this argument is ignored.</td></tr>
  </table>
</dl>
Note: The given boxes must lie completely within the index space of this array. If compiled with assertions enabled, the routine will abort if some box is not contained in the index space of this array. 
</div>
</div><p>
<a class="anchor" name="67ebb8f53913afa73557cf87c1e59c23"></a><!-- doxytag: member="SAMRAI::pdat::ArrayData::fillAll" ref="67ebb8f53913afa73557cf87c1e59c23" args="(const TYPE &amp;t)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html">SAMRAI::pdat::ArrayData</a>&lt; TYPE &gt;::fillAll           </td>
          <td>(</td>
          <td class="paramtype">const TYPE &amp;&nbsp;</td>
          <td class="paramname"> <em>t</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Fill all array values with value t. 
</div>
</div><p>
<a class="anchor" name="3edb587b90c00e2416a628537bb7d370"></a><!-- doxytag: member="SAMRAI::pdat::ArrayData::fillAll" ref="3edb587b90c00e2416a628537bb7d370" args="(const TYPE &amp;t, const hier::Box &amp;box)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html">SAMRAI::pdat::ArrayData</a>&lt; TYPE &gt;::fillAll           </td>
          <td>(</td>
          <td class="paramtype">const TYPE &amp;&nbsp;</td>
          <td class="paramname"> <em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">hier::Box</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>box</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Fill all array values within the box with value t. 
</div>
</div><p>
<a class="anchor" name="0bea85dadac71f1c4916a1ef96cae0ff"></a><!-- doxytag: member="SAMRAI::pdat::ArrayData::fill" ref="0bea85dadac71f1c4916a1ef96cae0ff" args="(const TYPE &amp;t, const int d=0)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html">SAMRAI::pdat::ArrayData</a>&lt; TYPE &gt;::fill           </td>
          <td>(</td>
          <td class="paramtype">const TYPE &amp;&nbsp;</td>
          <td class="paramname"> <em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>d</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Fill all array values associated with depth component d with the value t.<p>
<dl compact><dt><b>Precondition:</b></dt><dd>(d &gt;= 0) &amp;&amp; (d &lt; <a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html#be7b6878cb94103ca94864007da52c99">getDepth()</a>) </dd></dl>

</div>
</div><p>
<a class="anchor" name="b6d34044fbf094e5d6232dbb77890f47"></a><!-- doxytag: member="SAMRAI::pdat::ArrayData::fill" ref="b6d34044fbf094e5d6232dbb77890f47" args="(const TYPE &amp;t, const hier::Box &amp;box, const int d=0)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html">SAMRAI::pdat::ArrayData</a>&lt; TYPE &gt;::fill           </td>
          <td>(</td>
          <td class="paramtype">const TYPE &amp;&nbsp;</td>
          <td class="paramname"> <em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">hier::Box</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>box</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>d</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Fill all array values associated with depth component d within the box with the value t.<p>
<dl compact><dt><b>Precondition:</b></dt><dd>(d &gt;= 0) &amp;&amp; (d &lt; <a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html#be7b6878cb94103ca94864007da52c99">getDepth()</a>) </dd></dl>

</div>
</div><p>
<a class="anchor" name="f60d247d45b5fb1ea7442a58f727e5ea"></a><!-- doxytag: member="SAMRAI::pdat::ArrayData::getFromRestart" ref="f60d247d45b5fb1ea7442a58f727e5ea" args="(const boost::shared_ptr&lt; tbox::Database &gt; &amp;restart_db)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html">SAMRAI::pdat::ArrayData</a>&lt; TYPE &gt;::getFromRestart           </td>
          <td>(</td>
          <td class="paramtype">const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Database.html">tbox::Database</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>restart_db</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Check to make sure that the class version and restart file version are equal. If so, read in data from restart database.<p>
<dl compact><dt><b>Precondition:</b></dt><dd>restart_db </dd></dl>

</div>
</div><p>
<a class="anchor" name="ab0d1aafe2f112679e6ab39d9537b73f"></a><!-- doxytag: member="SAMRAI::pdat::ArrayData::putToRestart" ref="ab0d1aafe2f112679e6ab39d9537b73f" args="(const boost::shared_ptr&lt; tbox::Database &gt; &amp;restart_db) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html">SAMRAI::pdat::ArrayData</a>&lt; TYPE &gt;::putToRestart           </td>
          <td>(</td>
          <td class="paramtype">const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Database.html">tbox::Database</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>restart_db</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Write out array data object data to restart database.<p>
<dl compact><dt><b>Precondition:</b></dt><dd>restart_db </dd></dl>

</div>
</div><p>
<a class="anchor" name="7e8f40d516754c80f1fb194c5c5b1554"></a><!-- doxytag: member="SAMRAI::pdat::ArrayData::getDim" ref="7e8f40d516754c80f1fb194c5c5b1554" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classSAMRAI_1_1tbox_1_1Dimension.html">tbox::Dimension</a> &amp; <a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html">SAMRAI::pdat::ArrayData</a>&lt; TYPE &gt;::getDim           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return the dimension of this object. 
</div>
</div><p>
<a class="anchor" name="9217a0351e823009c41570d277a868d4"></a><!-- doxytag: member="SAMRAI::pdat::ArrayData::isValid" ref="9217a0351e823009c41570d277a868d4" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html">SAMRAI::pdat::ArrayData</a>&lt; TYPE &gt;::isValid           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns true if the array is valid. 
<p>

</div>
</div><p>
<hr>The documentation for this class was generated from the following files:<ul>
<li>source/SAMRAI/pdat/<a class="el" href="ArrayData_8h.html">ArrayData.h</a><li>source/SAMRAI/pdat/<a class="el" href="ArrayData_8C.html">ArrayData.C</a></ul>
<hr size="1"><address style="align: right;"><small>Generated on Mon Oct 15 15:43:56 2012 for SAMRAI by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.7 </small></address>
</body>
</html>
