<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>SAMRAI: SAMRAI::xfer::RefineAlgorithm Class Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.7 -->
<div class="tabs">
  <ul>
    <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="namespaces.html"><span>Namespaces</span></a></li>
    <li id="current"><a href="annotated.html"><span>Classes</span></a></li>
    <li><a href="files.html"><span>Files</span></a></li>
    <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
  </ul></div>
<div class="tabs">
  <ul>
    <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
    <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
    <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
  </ul></div>
<div class="nav">
<a class="el" href="namespaceSAMRAI.html">SAMRAI</a>::<a class="el" href="namespaceSAMRAI_1_1xfer.html">xfer</a>::<a class="el" href="classSAMRAI_1_1xfer_1_1RefineAlgorithm.html">RefineAlgorithm</a></div>
<h1>SAMRAI::xfer::RefineAlgorithm Class Reference</h1><!-- doxytag: class="SAMRAI::xfer::RefineAlgorithm" -->Class <a class="el" href="classSAMRAI_1_1xfer_1_1RefineAlgorithm.html">RefineAlgorithm</a> encapsulates the AMR communication pattern to refine data to, copy data to, or fill physical boundary data on any destination patch level.  
<a href="#_details">More...</a>
<p>
<code>#include &lt;source/SAMRAI/xfer/RefineAlgorithm.h&gt;</code>
<p>
<a href="classSAMRAI_1_1xfer_1_1RefineAlgorithm-members.html">List of all members.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1xfer_1_1RefineAlgorithm.html#aafec51a3a066ae0769bd955975d7c51">RefineAlgorithm</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Construct a refinement algorithm and initialize its basic state.  <a href="#aafec51a3a066ae0769bd955975d7c51"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1xfer_1_1RefineAlgorithm.html#2b849c00d8ff26f2af7e0b925ec68acf">~RefineAlgorithm</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The destructor releases all internal storage.  <a href="#2b849c00d8ff26f2af7e0b925ec68acf"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1xfer_1_1RefineAlgorithm.html#fd3bb4415268e02f228e4a612e75b899">registerRefine</a> (const int dst, const int src, const int scratch, const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1hier_1_1RefineOperator.html">hier::RefineOperator</a> &gt; &amp;oprefine, const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1VariableFillPattern.html">VariableFillPattern</a> &gt; &amp;var_fill_pattern=boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1VariableFillPattern.html">VariableFillPattern</a> &gt;())</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Register a refine operation with the refine algorithm object.  <a href="#fd3bb4415268e02f228e4a612e75b899"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1xfer_1_1RefineAlgorithm.html#97a280e274c359276c54213a37289858">registerRefine</a> (const int dst, const int src, const int src_told, const int src_tnew, const int scratch, const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1hier_1_1RefineOperator.html">hier::RefineOperator</a> &gt; &amp;oprefine, const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1hier_1_1TimeInterpolateOperator.html">hier::TimeInterpolateOperator</a> &gt; &amp;optime, const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1VariableFillPattern.html">VariableFillPattern</a> &gt; &amp;var_fill_pattern=boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1VariableFillPattern.html">VariableFillPattern</a> &gt;())</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Register a refine operation with the refine algorithm object.  <a href="#97a280e274c359276c54213a37289858"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1RefineSchedule.html">RefineSchedule</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1xfer_1_1RefineAlgorithm.html#325d85c3c9b231750ecfee55fed96920">createSchedule</a> (const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchLevel.html">hier::PatchLevel</a> &gt; &amp;level, <a class="el" href="classSAMRAI_1_1xfer_1_1RefinePatchStrategy.html">RefinePatchStrategy</a> *patch_strategy=0, const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1RefineTransactionFactory.html">RefineTransactionFactory</a> &gt; &amp;transaction_factory=boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1RefineTransactionFactory.html">RefineTransactionFactory</a> &gt;())</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a communication schedule for communicating data within a single level.  <a href="#325d85c3c9b231750ecfee55fed96920"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1RefineSchedule.html">RefineSchedule</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1xfer_1_1RefineAlgorithm.html#706e890f2fcfb824db279211cd8d7243">createSchedule</a> (const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1PatchLevelFillPattern.html">PatchLevelFillPattern</a> &gt; &amp;fill_pattern, const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchLevel.html">hier::PatchLevel</a> &gt; &amp;level, <a class="el" href="classSAMRAI_1_1xfer_1_1RefinePatchStrategy.html">RefinePatchStrategy</a> *patch_strategy=0, const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1RefineTransactionFactory.html">RefineTransactionFactory</a> &gt; &amp;transaction_factory=boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1RefineTransactionFactory.html">RefineTransactionFactory</a> &gt;())</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1RefineSchedule.html">RefineSchedule</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1xfer_1_1RefineAlgorithm.html#3de1d5d9bcdbdc4f830c44683dc45c74">createSchedule</a> (const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchLevel.html">hier::PatchLevel</a> &gt; &amp;dst_level, const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchLevel.html">hier::PatchLevel</a> &gt; &amp;src_level, <a class="el" href="classSAMRAI_1_1xfer_1_1RefinePatchStrategy.html">RefinePatchStrategy</a> *patch_strategy=0, bool use_time_interpolation=false, const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1RefineTransactionFactory.html">RefineTransactionFactory</a> &gt; &amp;transaction_factory=boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1RefineTransactionFactory.html">RefineTransactionFactory</a> &gt;())</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a communication schedule that communicates data between two levels that are at the same level of resolution.  <a href="#3de1d5d9bcdbdc4f830c44683dc45c74"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1RefineSchedule.html">RefineSchedule</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1xfer_1_1RefineAlgorithm.html#7bf2840d2d67c3782b9fcc599a56082c">createSchedule</a> (const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1PatchLevelFillPattern.html">PatchLevelFillPattern</a> &gt; &amp;fill_pattern, const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchLevel.html">hier::PatchLevel</a> &gt; &amp;dst_level, const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchLevel.html">hier::PatchLevel</a> &gt; &amp;src_level, <a class="el" href="classSAMRAI_1_1xfer_1_1RefinePatchStrategy.html">RefinePatchStrategy</a> *patch_strategy=0, bool use_time_interpolation=false, const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1RefineTransactionFactory.html">RefineTransactionFactory</a> &gt; &amp;transaction_factory=boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1RefineTransactionFactory.html">RefineTransactionFactory</a> &gt;())</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Same as the above, except with fill_pattern specified.  <a href="#7bf2840d2d67c3782b9fcc599a56082c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1RefineSchedule.html">RefineSchedule</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1xfer_1_1RefineAlgorithm.html#62a8e6d712cd1dcbfd2881ff32443c3f">createSchedule</a> (const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchLevel.html">hier::PatchLevel</a> &gt; &amp;level, const int next_coarser_level, const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchHierarchy.html">hier::PatchHierarchy</a> &gt; &amp;hierarchy, <a class="el" href="classSAMRAI_1_1xfer_1_1RefinePatchStrategy.html">RefinePatchStrategy</a> *patch_strategy=0, bool use_time_interpolation=false, const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1RefineTransactionFactory.html">RefineTransactionFactory</a> &gt; &amp;transaction_factory=boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1RefineTransactionFactory.html">RefineTransactionFactory</a> &gt;())</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a communication schedule that communicates data within a single level and interpolates data from coarser hierarchy levels where needed.  <a href="#62a8e6d712cd1dcbfd2881ff32443c3f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1RefineSchedule.html">RefineSchedule</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1xfer_1_1RefineAlgorithm.html#ae44301e0cdc8d514828327e743322c9">createSchedule</a> (const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1PatchLevelFillPattern.html">PatchLevelFillPattern</a> &gt; &amp;fill_pattern, const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchLevel.html">hier::PatchLevel</a> &gt; &amp;level, const int next_coarser_level, const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchHierarchy.html">hier::PatchHierarchy</a> &gt; &amp;hierarchy, <a class="el" href="classSAMRAI_1_1xfer_1_1RefinePatchStrategy.html">RefinePatchStrategy</a> *patch_strategy=0, bool use_time_interpolation=false, const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1RefineTransactionFactory.html">RefineTransactionFactory</a> &gt; &amp;transaction_factory=boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1RefineTransactionFactory.html">RefineTransactionFactory</a> &gt;())</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Same as the above, except with fill_pattern specified.  <a href="#ae44301e0cdc8d514828327e743322c9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1RefineSchedule.html">RefineSchedule</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1xfer_1_1RefineAlgorithm.html#2e7de2ae777856d753608e91660cfe68">createSchedule</a> (const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchLevel.html">hier::PatchLevel</a> &gt; &amp;dst_level, const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchLevel.html">hier::PatchLevel</a> &gt; &amp;src_level, const int next_coarser_level, const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchHierarchy.html">hier::PatchHierarchy</a> &gt; &amp;hierarchy, <a class="el" href="classSAMRAI_1_1xfer_1_1RefinePatchStrategy.html">RefinePatchStrategy</a> *patch_strategy=0, bool use_time_interpolation=false, const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1RefineTransactionFactory.html">RefineTransactionFactory</a> &gt; &amp;transaction_factory=boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1RefineTransactionFactory.html">RefineTransactionFactory</a> &gt;())</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a communication schedule that communicates data from a source level to a destination level and interpolates data from coarser hierarchy levels where needed.  <a href="#2e7de2ae777856d753608e91660cfe68"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1RefineSchedule.html">RefineSchedule</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1xfer_1_1RefineAlgorithm.html#314a6e480efebefe9d01220063928fc3">createSchedule</a> (const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1PatchLevelFillPattern.html">PatchLevelFillPattern</a> &gt; &amp;fill_pattern, const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchLevel.html">hier::PatchLevel</a> &gt; &amp;dst_level, const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchLevel.html">hier::PatchLevel</a> &gt; &amp;src_level, const int next_coarser_level, const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchHierarchy.html">hier::PatchHierarchy</a> &gt; &amp;hierarchy, <a class="el" href="classSAMRAI_1_1xfer_1_1RefinePatchStrategy.html">RefinePatchStrategy</a> *patch_strategy=0, bool use_time_interpolation=false, const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1RefineTransactionFactory.html">RefineTransactionFactory</a> &gt; &amp;transaction_factory=boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1RefineTransactionFactory.html">RefineTransactionFactory</a> &gt;())</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Same as the above, except with fill_pattern specified.  <a href="#314a6e480efebefe9d01220063928fc3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1xfer_1_1RefineAlgorithm.html#bd560f15ac217f0070c15f87501e7199">checkConsistency</a> (const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1RefineSchedule.html">RefineSchedule</a> &gt; &amp;schedule) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Given a previously-generated refine schedule, check for consistency with this refine algorithm object to see whether a call to <a class="el" href="classSAMRAI_1_1xfer_1_1RefineAlgorithm.html#1d18cbc13d62b71a2c2f1f88cff5b5c8">resetSchedule()</a> is a valid operation.  <a href="#bd560f15ac217f0070c15f87501e7199"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1xfer_1_1RefineAlgorithm.html#1d18cbc13d62b71a2c2f1f88cff5b5c8">resetSchedule</a> (const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1RefineSchedule.html">RefineSchedule</a> &gt; &amp;schedule) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Given a previously-generated refine schedule, reconfigure it to peform the communication operations registered with THIS refine algorithm object.  <a href="#1d18cbc13d62b71a2c2f1f88cff5b5c8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1RefineClasses.html">RefineClasses</a> &gt; &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1xfer_1_1RefineAlgorithm.html#56d8f1a9ad70d70f5c01d7ed3d941e5e">getEquivalenceClasses</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the refine equivalence classes used in the algorithm.  <a href="#56d8f1a9ad70d70f5c01d7ed3d941e5e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1xfer_1_1RefineAlgorithm.html#a8480311b130572ae2e07a144c4233db">setEquivalenceClasses</a> (const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1RefineClasses.html">RefineClasses</a> &gt; &amp;refine_classes)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the pointer to the refine equivalence classes to be equal to the given argument.  <a href="#a8480311b130572ae2e07a144c4233db"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1xfer_1_1RefineAlgorithm.html#a1366c45c1deb33db86d8a526fa0e5c8">printClassData</a> (std::ostream &amp;stream) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Print the refine algorithm state to the specified data stream.  <a href="#a1366c45c1deb33db86d8a526fa0e5c8"></a><br></td></tr>
</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
Class <a class="el" href="classSAMRAI_1_1xfer_1_1RefineAlgorithm.html">RefineAlgorithm</a> encapsulates the AMR communication pattern to refine data to, copy data to, or fill physical boundary data on any destination patch level. 
<p>
The basic procedure for moving data follows three steps:<p>
<ul>
<li>
interpolate data (spatial and possibly temporal) from coarser levels </li>
<li>
copy data from the same level of refinement </li>
<li>
fill physical boundary conditions regions </li>
</ul>
<p>
Each data communication procedure generally consists of three parts: an algorithm, a schedule, and a patch strategy. The algorithm describes the patch data components and time and space interpolation operations, but is independent of the configuration of the patches in an AMR hierarchy. Patch data items and their associated spatial and time interpolation operators are registered with an instantiation of this algorithm class. To generate the communication dependencies for a particular patch hierarchy configuration, the algorithm creates a refine schedule based on the state of a given hierarchy and the information in the algorithm. The schedule can then perform the communication operations that move data to the destination patch level using the associated operators. User-defined operations (such as filling physical boundaries and special interpolation procedures) are provided through a refine patch strategy object. User-defined interpolation operations can be written using the interfaces in <a class="el" href="classSAMRAI_1_1xfer_1_1RefinePatchStrategy.html">RefinePatchStrategy</a> for preprocessRefine() and postProcessRefine().<p>
In general, source data is copied into the designated scratch data for temporary processing. The scratch space must contain sufficient ghost cells to accommodate the stencil width of the given interpolation operators and any physical boundary data that must be filled. The scratch storage is copied into the destination data space at the end of the communication process. Thus, copy operations between source, scratch, and destination patch data objects must be defined.<p>
In general, the destination and scratch data components may be the same (assuming that the scratch component has a sufficient ghost cells width). The source and scratch components SHOULD NOT be the same, since the interiors of the source space could be changed by the use of the scratch data as temporary work space.<p>
It is the user's responsibility to register valid operations with the refine algorithm so that the data communication can occur. In particular, communication operations (e.g., data refinement, data copy, etc.) are performed in the order that items are registered for refinement with a refine algorithm object. Thus, order of registration must repect any dependencies among patch data communicated. Also, users who use the preprocessRefine() and postProcessRefine() operations in the patch strategy object must make sure that all data that is needed in those operations are registered with the <a class="el" href="classSAMRAI_1_1xfer_1_1RefineAlgorithm.html">RefineAlgorithm</a> using <a class="el" href="classSAMRAI_1_1xfer_1_1RefineAlgorithm.html#fd3bb4415268e02f228e4a612e75b899">registerRefine()</a> whether or not the data is to be refined.<p>
Typical usage of a refine algorithm to perform inter-patch communication on an AMR hierarchy involves four steps:<p>
<ul>
<li>
Construct a refine algorithm object. </li>
<li>
Register refine operations with the refine algorithm. Using the <a class="el" href="classSAMRAI_1_1xfer_1_1RefineAlgorithm.html#fd3bb4415268e02f228e4a612e75b899">registerRefine()</a> methods(s), one provides source and destination patch data information, as well as time and space interpolation operators as needed. Two <a class="el" href="classSAMRAI_1_1xfer_1_1RefineAlgorithm.html#fd3bb4415268e02f228e4a612e75b899">registerRefine()</a> methods appear in this class; one supports time interpolation, one does not. </li>
<li>
After all operations are registered with the algorithm, one creates a communication schedule using one of the <a class="el" href="classSAMRAI_1_1xfer_1_1RefineAlgorithm.html#325d85c3c9b231750ecfee55fed96920">createSchedule()</a> methods. These methods are distinguished by the resulting data communication pattern (e.g., interpatch communication on a single level, between two different levels at the same grid resolution, interpolation of data between different AMR hierarchy levels, etc.) Note that when creating a communication schedule, a concrete instance of a <a class="el" href="classSAMRAI_1_1xfer_1_1RefinePatchStrategy.html">RefinePatchStrategy</a> object may be required to supply physical boundary conditions as well as user-defined spatial data interpolation operations. </li>
<li>
Invoke the fillData() method in the communication schedule to perform the data transfers. </li>
</ul>
<p>
Note that each refine schedule created by a refine algorithm remains valid as long as the patches involved in the communication process do not change; thus, they can be used for multiple data communication cycles.<p>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classSAMRAI_1_1xfer_1_1RefineSchedule.html">xfer::RefineSchedule</a> <p>
<a class="el" href="classSAMRAI_1_1xfer_1_1RefinePatchStrategy.html">xfer::RefinePatchStrategy</a> <p>
<a class="el" href="classSAMRAI_1_1xfer_1_1RefineClasses.html">xfer::RefineClasses</a> </dd></dl>

<p>
<hr><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" name="aafec51a3a066ae0769bd955975d7c51"></a><!-- doxytag: member="SAMRAI::xfer::RefineAlgorithm::RefineAlgorithm" ref="aafec51a3a066ae0769bd955975d7c51" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SAMRAI::xfer::RefineAlgorithm::RefineAlgorithm           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Construct a refinement algorithm and initialize its basic state. 
<p>
Refinement operations must be registered with this algorithm before it can do anything useful. See the <a class="el" href="classSAMRAI_1_1xfer_1_1RefineAlgorithm.html#fd3bb4415268e02f228e4a612e75b899">registerRefine()</a> routines for details 
</div>
</div><p>
<a class="anchor" name="2b849c00d8ff26f2af7e0b925ec68acf"></a><!-- doxytag: member="SAMRAI::xfer::RefineAlgorithm::~RefineAlgorithm" ref="2b849c00d8ff26f2af7e0b925ec68acf" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SAMRAI::xfer::RefineAlgorithm::~RefineAlgorithm           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The destructor releases all internal storage. 
<p>

</div>
</div><p>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="fd3bb4415268e02f228e4a612e75b899"></a><!-- doxytag: member="SAMRAI::xfer::RefineAlgorithm::registerRefine" ref="fd3bb4415268e02f228e4a612e75b899" args="(const int dst, const int src, const int scratch, const boost::shared_ptr&lt; hier::RefineOperator &gt; &amp;oprefine, const boost::shared_ptr&lt; VariableFillPattern &gt; &amp;var_fill_pattern=boost::shared_ptr&lt; VariableFillPattern &gt;())" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::xfer::RefineAlgorithm::registerRefine           </td>
          <td>(</td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>scratch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1hier_1_1RefineOperator.html">hier::RefineOperator</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>oprefine</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1VariableFillPattern.html">VariableFillPattern</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>var_fill_pattern</em> = <code>boost::shared_ptr&lt;&nbsp;<a class="el" href="classSAMRAI_1_1xfer_1_1VariableFillPattern.html">VariableFillPattern</a>&nbsp;&gt;()</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Register a refine operation with the refine algorithm object. 
<p>
This method does not support time interpolation. Data values will be moved from the source data to the destination data using scratch data as a temporary work space. The scratch data must have sufficient ghost cells to cover the required operator stencil width and any needed physical boundary ghost cells.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>dst</em>&nbsp;</td><td>Patch data index filled on the destination level. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>src</em>&nbsp;</td><td>Patch data index for source data. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>scratch</em>&nbsp;</td><td>Patch data index for temporary work space data. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>oprefine</em>&nbsp;</td><td>Refinement operator. This may be a null pointer. In this case, refinement must be handled by the refine patch strategy member functions. See the comments for <a class="el" href="classSAMRAI_1_1xfer_1_1RefinePatchStrategy.html#57207582e1411612c159f0629963a793">RefinePatchStrategy::preprocessRefine()</a> and <a class="el" href="classSAMRAI_1_1xfer_1_1RefinePatchStrategy.html#5f9968834fafcaa4ef777893e1300205">RefinePatchStrategy::postprocessRefine()</a>. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>var_fill_pattern</em>&nbsp;</td><td>boost::shared_ptr to the variable fill pattern, which can be used to restrict the filling of data to a specific stencil. If the NULL default is used, then class <a class="el" href="classSAMRAI_1_1xfer_1_1BoxGeometryVariableFillPattern.html">BoxGeometryVariableFillPattern</a> will be used internally.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Precondition:</b></dt><dd>!d_schedule_created </dd></dl>

</div>
</div><p>
<a class="anchor" name="97a280e274c359276c54213a37289858"></a><!-- doxytag: member="SAMRAI::xfer::RefineAlgorithm::registerRefine" ref="97a280e274c359276c54213a37289858" args="(const int dst, const int src, const int src_told, const int src_tnew, const int scratch, const boost::shared_ptr&lt; hier::RefineOperator &gt; &amp;oprefine, const boost::shared_ptr&lt; hier::TimeInterpolateOperator &gt; &amp;optime, const boost::shared_ptr&lt; VariableFillPattern &gt; &amp;var_fill_pattern=boost::shared_ptr&lt; VariableFillPattern &gt;())" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::xfer::RefineAlgorithm::registerRefine           </td>
          <td>(</td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>src_told</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>src_tnew</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>scratch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1hier_1_1RefineOperator.html">hier::RefineOperator</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>oprefine</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1hier_1_1TimeInterpolateOperator.html">hier::TimeInterpolateOperator</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>optime</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1VariableFillPattern.html">VariableFillPattern</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>var_fill_pattern</em> = <code>boost::shared_ptr&lt;&nbsp;<a class="el" href="classSAMRAI_1_1xfer_1_1VariableFillPattern.html">VariableFillPattern</a>&nbsp;&gt;()</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Register a refine operation with the refine algorithm object. 
<p>
This method supports time interpolation. Time interpolation will take place between the old and new source data components on coarser levels. On the destination level, data will be moved from the source data to the destination data using scratch data as a temporary work space. The scratch data must have sufficient ghost cells to cover the required operator stencil width and any needed physical boundary ghost cells.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>dst</em>&nbsp;</td><td>Patch data index filled on the destination level. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>src</em>&nbsp;</td><td>Patch data index for source data. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>src_told</em>&nbsp;</td><td>Patch data index for old data used in time interpolation. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>src_tnew</em>&nbsp;</td><td>Patch data index for new data used in time interpolation. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>scratch</em>&nbsp;</td><td>Patch data index for temporary work space data. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>oprefine</em>&nbsp;</td><td>Refinement operator. This may be a null pointer. In this case, refinement must be handled by the refine patch strategy member functions. See the comments for <a class="el" href="classSAMRAI_1_1xfer_1_1RefinePatchStrategy.html#57207582e1411612c159f0629963a793">RefinePatchStrategy::preprocessRefine()</a> and <a class="el" href="classSAMRAI_1_1xfer_1_1RefinePatchStrategy.html#5f9968834fafcaa4ef777893e1300205">RefinePatchStrategy::postprocessRefine()</a>. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>optime</em>&nbsp;</td><td>Time interpolation operator. This pointer may not be null. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>var_fill_pattern</em>&nbsp;</td><td>boost::shared_ptr to the variable fill pattern, which can be used to restrict the filling of data to a specific stencil. If the NULL default is used, then class <a class="el" href="classSAMRAI_1_1xfer_1_1BoxGeometryVariableFillPattern.html">BoxGeometryVariableFillPattern</a> will be used internally.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Precondition:</b></dt><dd>optime <p>
!d_schedule_created </dd></dl>

</div>
</div><p>
<a class="anchor" name="325d85c3c9b231750ecfee55fed96920"></a><!-- doxytag: member="SAMRAI::xfer::RefineAlgorithm::createSchedule" ref="325d85c3c9b231750ecfee55fed96920" args="(const boost::shared_ptr&lt; hier::PatchLevel &gt; &amp;level, RefinePatchStrategy *patch_strategy=0, const boost::shared_ptr&lt; RefineTransactionFactory &gt; &amp;transaction_factory=boost::shared_ptr&lt; RefineTransactionFactory &gt;())" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1RefineSchedule.html">RefineSchedule</a> &gt; SAMRAI::xfer::RefineAlgorithm::createSchedule           </td>
          <td>(</td>
          <td class="paramtype">const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchLevel.html">hier::PatchLevel</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1xfer_1_1RefinePatchStrategy.html">RefinePatchStrategy</a> *&nbsp;</td>
          <td class="paramname"> <em>patch_strategy</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1RefineTransactionFactory.html">RefineTransactionFactory</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>transaction_factory</em> = <code>boost::shared_ptr&lt;&nbsp;<a class="el" href="classSAMRAI_1_1xfer_1_1RefineTransactionFactory.html">RefineTransactionFactory</a>&nbsp;&gt;()</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Create a communication schedule for communicating data within a single level. 
<p>
The schedule will communicate data from the interiors of the source data into the interior and ghosts of the destination data on the the same level where those sources and destinations overlap.<p>
Neither time nor spatial interpolation is performed.<p>
Note that the schedule remains valid as long as the level does not change; thus, it can be used for multiple data communication cycles cycles.<p>
<dl compact><dt><b>Returns:</b></dt><dd>boost::shared_ptr to refine schedule that performs the data transfers.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>level</em>&nbsp;</td><td>Level on which communication occurs. This pointer cannot be null. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>patch_strategy</em>&nbsp;</td><td>Optional pointer to a refine patch strategy that provides user-defined physical boundary filling operations. If this patch strategy is null (default state), then no physical boundary filling is performed. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>transaction_factory</em>&nbsp;</td><td>Optional boost::shared_ptr to a refine transaction factory that creates data transactions for the schedule. If this pointer is null (default state), then a <a class="el" href="classSAMRAI_1_1xfer_1_1StandardRefineTransactionFactory.html">StandardRefineTransactionFactory</a> object will be used.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Precondition:</b></dt><dd>level </dd></dl>

</div>
</div><p>
<a class="anchor" name="706e890f2fcfb824db279211cd8d7243"></a><!-- doxytag: member="SAMRAI::xfer::RefineAlgorithm::createSchedule" ref="706e890f2fcfb824db279211cd8d7243" args="(const boost::shared_ptr&lt; PatchLevelFillPattern &gt; &amp;fill_pattern, const boost::shared_ptr&lt; hier::PatchLevel &gt; &amp;level, RefinePatchStrategy *patch_strategy=0, const boost::shared_ptr&lt; RefineTransactionFactory &gt; &amp;transaction_factory=boost::shared_ptr&lt; RefineTransactionFactory &gt;())" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1RefineSchedule.html">RefineSchedule</a> &gt; SAMRAI::xfer::RefineAlgorithm::createSchedule           </td>
          <td>(</td>
          <td class="paramtype">const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1PatchLevelFillPattern.html">PatchLevelFillPattern</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>fill_pattern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchLevel.html">hier::PatchLevel</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1xfer_1_1RefinePatchStrategy.html">RefinePatchStrategy</a> *&nbsp;</td>
          <td class="paramname"> <em>patch_strategy</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1RefineTransactionFactory.html">RefineTransactionFactory</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>transaction_factory</em> = <code>boost::shared_ptr&lt;&nbsp;<a class="el" href="classSAMRAI_1_1xfer_1_1RefineTransactionFactory.html">RefineTransactionFactory</a>&nbsp;&gt;()</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="3de1d5d9bcdbdc4f830c44683dc45c74"></a><!-- doxytag: member="SAMRAI::xfer::RefineAlgorithm::createSchedule" ref="3de1d5d9bcdbdc4f830c44683dc45c74" args="(const boost::shared_ptr&lt; hier::PatchLevel &gt; &amp;dst_level, const boost::shared_ptr&lt; hier::PatchLevel &gt; &amp;src_level, RefinePatchStrategy *patch_strategy=0, bool use_time_interpolation=false, const boost::shared_ptr&lt; RefineTransactionFactory &gt; &amp;transaction_factory=boost::shared_ptr&lt; RefineTransactionFactory &gt;())" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1RefineSchedule.html">RefineSchedule</a> &gt; SAMRAI::xfer::RefineAlgorithm::createSchedule           </td>
          <td>(</td>
          <td class="paramtype">const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchLevel.html">hier::PatchLevel</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>dst_level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchLevel.html">hier::PatchLevel</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>src_level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1xfer_1_1RefinePatchStrategy.html">RefinePatchStrategy</a> *&nbsp;</td>
          <td class="paramname"> <em>patch_strategy</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>use_time_interpolation</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1RefineTransactionFactory.html">RefineTransactionFactory</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>transaction_factory</em> = <code>boost::shared_ptr&lt;&nbsp;<a class="el" href="classSAMRAI_1_1xfer_1_1RefineTransactionFactory.html">RefineTransactionFactory</a>&nbsp;&gt;()</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Create a communication schedule that communicates data between two levels that are at the same level of resolution. 
<p>
Data will be communicated from the interiors of the source data on the source level into the interior and ghosts of the destination data on a destination level where those sources and destinations overlap.<p>
Note that both levels must reside in the same AMR hierarchy index space, or in index spaces that represent the same level of mesh refinement. No spatial interpolation is performed.<p>
In certain rare cases it may be desired to use this schedule to perform time interpolation, in which case the use_time_interpolation optional argument should be set to true.<p>
Note that the schedule remains valid as long as the levels do not change; thus, it can be used for multiple data communication cycles.<p>
<dl compact><dt><b>Returns:</b></dt><dd>boost::shared_ptr to refine schedule that performs the data transfers.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>dst_level</em>&nbsp;</td><td>boost::shared_ptr to destination level; cannot be null. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>src_level</em>&nbsp;</td><td>boost::shared_ptr to source level; cannot be null. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>patch_strategy</em>&nbsp;</td><td>boost::shared_ptr to a refine patch strategy that provides user-defined physical boundary filling operations. If this patch strategy is null (default state), then no physical boundary filling is performed. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>use_time_interpolation</em>&nbsp;</td><td>Flag to create the schedule with the ability to perform time interpolation. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>transaction_factory</em>&nbsp;</td><td>boost::shared_ptr to a refine transaction factory that creates data transactions for the schedule. If this pointer is null (default state), then a <a class="el" href="classSAMRAI_1_1xfer_1_1StandardRefineTransactionFactory.html">StandardRefineTransactionFactory</a> object will be used.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Precondition:</b></dt><dd>dst_level <p>
src_level <p>
dst_level-&gt;getDim() == src_level-&gt;getDim() </dd></dl>

</div>
</div><p>
<a class="anchor" name="7bf2840d2d67c3782b9fcc599a56082c"></a><!-- doxytag: member="SAMRAI::xfer::RefineAlgorithm::createSchedule" ref="7bf2840d2d67c3782b9fcc599a56082c" args="(const boost::shared_ptr&lt; PatchLevelFillPattern &gt; &amp;fill_pattern, const boost::shared_ptr&lt; hier::PatchLevel &gt; &amp;dst_level, const boost::shared_ptr&lt; hier::PatchLevel &gt; &amp;src_level, RefinePatchStrategy *patch_strategy=0, bool use_time_interpolation=false, const boost::shared_ptr&lt; RefineTransactionFactory &gt; &amp;transaction_factory=boost::shared_ptr&lt; RefineTransactionFactory &gt;())" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1RefineSchedule.html">RefineSchedule</a> &gt; SAMRAI::xfer::RefineAlgorithm::createSchedule           </td>
          <td>(</td>
          <td class="paramtype">const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1PatchLevelFillPattern.html">PatchLevelFillPattern</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>fill_pattern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchLevel.html">hier::PatchLevel</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>dst_level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchLevel.html">hier::PatchLevel</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>src_level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1xfer_1_1RefinePatchStrategy.html">RefinePatchStrategy</a> *&nbsp;</td>
          <td class="paramname"> <em>patch_strategy</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>use_time_interpolation</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1RefineTransactionFactory.html">RefineTransactionFactory</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>transaction_factory</em> = <code>boost::shared_ptr&lt;&nbsp;<a class="el" href="classSAMRAI_1_1xfer_1_1RefineTransactionFactory.html">RefineTransactionFactory</a>&nbsp;&gt;()</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Same as the above, except with fill_pattern specified. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>fill_pattern</em>&nbsp;</td><td>Indicates which parts of the destination level to fill. See <a class="el" href="classSAMRAI_1_1xfer_1_1RefineSchedule.html">RefineSchedule</a> for available patterns. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>dst_level</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>src_level</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>patch_strategy</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>use_time_interpolation</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>transaction_factory</em>&nbsp;</td><td></td></tr>
  </table>
</dl>
<dl compact><dt><b>Precondition:</b></dt><dd>dst_level <p>
src_level <p>
dst_level-&gt;getDim() == src_level-&gt;getDim() </dd></dl>

</div>
</div><p>
<a class="anchor" name="62a8e6d712cd1dcbfd2881ff32443c3f"></a><!-- doxytag: member="SAMRAI::xfer::RefineAlgorithm::createSchedule" ref="62a8e6d712cd1dcbfd2881ff32443c3f" args="(const boost::shared_ptr&lt; hier::PatchLevel &gt; &amp;level, const int next_coarser_level, const boost::shared_ptr&lt; hier::PatchHierarchy &gt; &amp;hierarchy, RefinePatchStrategy *patch_strategy=0, bool use_time_interpolation=false, const boost::shared_ptr&lt; RefineTransactionFactory &gt; &amp;transaction_factory=boost::shared_ptr&lt; RefineTransactionFactory &gt;())" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1RefineSchedule.html">RefineSchedule</a> &gt; SAMRAI::xfer::RefineAlgorithm::createSchedule           </td>
          <td>(</td>
          <td class="paramtype">const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchLevel.html">hier::PatchLevel</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>next_coarser_level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchHierarchy.html">hier::PatchHierarchy</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>hierarchy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1xfer_1_1RefinePatchStrategy.html">RefinePatchStrategy</a> *&nbsp;</td>
          <td class="paramname"> <em>patch_strategy</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>use_time_interpolation</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1RefineTransactionFactory.html">RefineTransactionFactory</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>transaction_factory</em> = <code>boost::shared_ptr&lt;&nbsp;<a class="el" href="classSAMRAI_1_1xfer_1_1RefineTransactionFactory.html">RefineTransactionFactory</a>&nbsp;&gt;()</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Create a communication schedule that communicates data within a single level and interpolates data from coarser hierarchy levels where needed. 
<p>
Data will be communicated from the interiors of the source data on on the given level to the interiors and ghosts of destination data on the same level where those sources and destinations overlap. Where they do not overlap, data will be interpolated from source data on coarser levels in the patch hierarchy.<p>
Data is time interpolated between old and new sources on coarser levels when and where time interpolation is needed and copied from the source components on the patch level into the destination components otherwise.<p>
In certain rare cases in may be necessary to perform time interpolation between old and new sources on the given patch level. In this case the optional argument use_time_interpolation should be set to true. Regardless of the value of this argument, time interpolation on coarser levels will always occur whenever needed.<p>
Note that the next coarser level number must correspond to a level in the hierarchy that represents a region of coarser index space than the destination level.<p>
Note that the schedule remains valid as long as the levels involved in its creation do not change; thus, it can be used for multiple data communication cycles.<p>
<dl compact><dt><b>Returns:</b></dt><dd>boost::shared_ptr to refine schedule that performs the data transfers.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>level</em>&nbsp;</td><td>boost::shared_ptr to destination level; cannot be null. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>next_coarser_level</em>&nbsp;</td><td>Level number of next coarser patch level in the patch hierarchy relative to the destination level. Note that when the destination level has number zero (i.e., the coarsest level), this value should value should be &lt; 0. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>hierarchy</em>&nbsp;</td><td>boost::shared_ptr to patch hierarchy from which data to fill level should come. This pointer may be null only when the next_coarser_level is &lt; 0. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>patch_strategy</em>&nbsp;</td><td>boost::shared_ptr to a refine patch strategy that provides user-defined physical boundary filling operations and user-defined spatial interpolation operations. If this patch strategy is null (default state), then no physical boundary filling or user-defined interpolation is performed. Note that this may cause problems if the interpolation stencils require physical boundary data on the coarser levels. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>use_time_interpolation</em>&nbsp;</td><td>Boolean flag to create the schedule the ability to perform time interpolation on the destination level. Default is no time interpolation (false). </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>transaction_factory</em>&nbsp;</td><td>boost::shared_ptr to a refine transaction factory that creates data transactions for the schedule. If this pointer is null (default state), then a <a class="el" href="classSAMRAI_1_1xfer_1_1StandardRefineTransactionFactory.html">StandardRefineTransactionFactory</a> object will be used.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Precondition:</b></dt><dd>level <p>
(next_coarser_level == -1) || hierarchy <p>
!hierarchy || (level-&gt;getDim() == hierarchy-&gt;getDim()) </dd></dl>

</div>
</div><p>
<a class="anchor" name="ae44301e0cdc8d514828327e743322c9"></a><!-- doxytag: member="SAMRAI::xfer::RefineAlgorithm::createSchedule" ref="ae44301e0cdc8d514828327e743322c9" args="(const boost::shared_ptr&lt; PatchLevelFillPattern &gt; &amp;fill_pattern, const boost::shared_ptr&lt; hier::PatchLevel &gt; &amp;level, const int next_coarser_level, const boost::shared_ptr&lt; hier::PatchHierarchy &gt; &amp;hierarchy, RefinePatchStrategy *patch_strategy=0, bool use_time_interpolation=false, const boost::shared_ptr&lt; RefineTransactionFactory &gt; &amp;transaction_factory=boost::shared_ptr&lt; RefineTransactionFactory &gt;())" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1RefineSchedule.html">RefineSchedule</a> &gt; SAMRAI::xfer::RefineAlgorithm::createSchedule           </td>
          <td>(</td>
          <td class="paramtype">const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1PatchLevelFillPattern.html">PatchLevelFillPattern</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>fill_pattern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchLevel.html">hier::PatchLevel</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>next_coarser_level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchHierarchy.html">hier::PatchHierarchy</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>hierarchy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1xfer_1_1RefinePatchStrategy.html">RefinePatchStrategy</a> *&nbsp;</td>
          <td class="paramname"> <em>patch_strategy</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>use_time_interpolation</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1RefineTransactionFactory.html">RefineTransactionFactory</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>transaction_factory</em> = <code>boost::shared_ptr&lt;&nbsp;<a class="el" href="classSAMRAI_1_1xfer_1_1RefineTransactionFactory.html">RefineTransactionFactory</a>&nbsp;&gt;()</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Same as the above, except with fill_pattern specified. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>fill_pattern</em>&nbsp;</td><td>Indicates which parts of the destination level to fill. See <a class="el" href="classSAMRAI_1_1xfer_1_1RefineSchedule.html">RefineSchedule</a> for available patterns. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>level</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>next_coarser_level</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>hierarchy</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>patch_strategy</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>use_time_interpolation</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>transaction_factory</em>&nbsp;</td><td></td></tr>
  </table>
</dl>
<dl compact><dt><b>Precondition:</b></dt><dd>level <p>
(next_coarser_level == -1) || hierarchy <p>
!hierarchy || (level-&gt;getDim() == hierarchy-&gt;getDim()) </dd></dl>

</div>
</div><p>
<a class="anchor" name="2e7de2ae777856d753608e91660cfe68"></a><!-- doxytag: member="SAMRAI::xfer::RefineAlgorithm::createSchedule" ref="2e7de2ae777856d753608e91660cfe68" args="(const boost::shared_ptr&lt; hier::PatchLevel &gt; &amp;dst_level, const boost::shared_ptr&lt; hier::PatchLevel &gt; &amp;src_level, const int next_coarser_level, const boost::shared_ptr&lt; hier::PatchHierarchy &gt; &amp;hierarchy, RefinePatchStrategy *patch_strategy=0, bool use_time_interpolation=false, const boost::shared_ptr&lt; RefineTransactionFactory &gt; &amp;transaction_factory=boost::shared_ptr&lt; RefineTransactionFactory &gt;())" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1RefineSchedule.html">RefineSchedule</a> &gt; SAMRAI::xfer::RefineAlgorithm::createSchedule           </td>
          <td>(</td>
          <td class="paramtype">const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchLevel.html">hier::PatchLevel</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>dst_level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchLevel.html">hier::PatchLevel</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>src_level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>next_coarser_level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchHierarchy.html">hier::PatchHierarchy</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>hierarchy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1xfer_1_1RefinePatchStrategy.html">RefinePatchStrategy</a> *&nbsp;</td>
          <td class="paramname"> <em>patch_strategy</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>use_time_interpolation</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1RefineTransactionFactory.html">RefineTransactionFactory</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>transaction_factory</em> = <code>boost::shared_ptr&lt;&nbsp;<a class="el" href="classSAMRAI_1_1xfer_1_1RefineTransactionFactory.html">RefineTransactionFactory</a>&nbsp;&gt;()</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Create a communication schedule that communicates data from a source level to a destination level and interpolates data from coarser hierarchy levels where needed. 
<p>
Data will be communicated from the interiors of the source data on on the source level to the interiors and ghosts of destination data on the destination level where those sources and destinations overlap. Where they do not overlap, data will be interpolated from source data on coarser levels in the patch hierarchy.<p>
Data is time interpolated between old and new sources on coarser levels when and where time interpolation is needed and copied from the source components on the source level into the destination components otherwise.<p>
This form of schedule construction is typically used after regridding (where the source level is the patch level being replaced by the destination level in the patch hierarchy) or when the data on destination patch level is to be overwritten by data interpolated from coarser levels in the patch hierarchy. In the first case, data on the destination level will be copied from the source level in regions where those two levels overlap and filled with interpolated values from the hierarchy elsewhere. In the latter case, the source level pointer may be null. Then, data on the destination level will be filled using interpolated data from coarser hierarchy levels.<p>
In certain rare cases in may be desired to perform time interpolation between old and new sources onto the destination level. In this case the optional argument use_time_interpolation should be set to true. Regardless of the value of this argument, time interpolation on coarser levels will always occur whenever needed.<p>
Note that when the source level pointer is non-null, the index spaces of the source and destination levels must be aligned with one another.<p>
Note that the schedule remains valid as long as the levels involved in its creation do not change; thus, it can be used for multiple data communication cycles.<p>
<dl compact><dt><b>Returns:</b></dt><dd>boost::shared_ptr to refine schedule that performs the data transfers.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>dst_level</em>&nbsp;</td><td>boost::shared_ptr to destination level; cannot be null. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>src_level</em>&nbsp;</td><td>boost::shared_ptr to source level. This pointer may be null. In this case, data on the destination level will be filled only using interpolated data from coarser hierarchy levels. When this pointer is not null, the source level must live in the same AMR hierarchy index space as the destination level. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>next_coarser_level</em>&nbsp;</td><td>Level number of next coarser patch level in the patch hierarchy relative to the destination level. Note that when the destination level has number zero (i.e., the coarsest level), this value should value should be &lt; 0. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>hierarchy</em>&nbsp;</td><td>boost::shared_ptr to patch hierarchy from which data to fill level should come. This pointer may be null only when the next_coarser_level is &lt; 0. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>patch_strategy</em>&nbsp;</td><td>boost::shared_ptr to a refine patch strategy that provides user-defined physical boundary filling operations and user-defined spatial interpolation operations. If this patch strategy is null (default state), then no physical boundary filling or user-defined interpolation is performed. Note that this may cause problems if the interpolation stencils require physical boundary data on the coarser levels. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>use_time_interpolation</em>&nbsp;</td><td>Boolean flag to create the schedule the ability to perform time interpolation on the destination level. Default is no time interpolation (false). </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>transaction_factory</em>&nbsp;</td><td>boost::shared_ptr to a refine transaction factory that creates data transactions for the schedule. If this pointer is null (default state), then a <a class="el" href="classSAMRAI_1_1xfer_1_1StandardRefineTransactionFactory.html">StandardRefineTransactionFactory</a> object will be used.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Precondition:</b></dt><dd>dst_level <p>
(next_coarser_level == -1) || hierarchy <p>
!src_level || (dst_level-&gt;getDim() == src_level-&gt;getDim()) <p>
!hierarchy || (dst_level-&gt;getDim() == hierarchy-&gt;getDim()) </dd></dl>

</div>
</div><p>
<a class="anchor" name="314a6e480efebefe9d01220063928fc3"></a><!-- doxytag: member="SAMRAI::xfer::RefineAlgorithm::createSchedule" ref="314a6e480efebefe9d01220063928fc3" args="(const boost::shared_ptr&lt; PatchLevelFillPattern &gt; &amp;fill_pattern, const boost::shared_ptr&lt; hier::PatchLevel &gt; &amp;dst_level, const boost::shared_ptr&lt; hier::PatchLevel &gt; &amp;src_level, const int next_coarser_level, const boost::shared_ptr&lt; hier::PatchHierarchy &gt; &amp;hierarchy, RefinePatchStrategy *patch_strategy=0, bool use_time_interpolation=false, const boost::shared_ptr&lt; RefineTransactionFactory &gt; &amp;transaction_factory=boost::shared_ptr&lt; RefineTransactionFactory &gt;())" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1RefineSchedule.html">RefineSchedule</a> &gt; SAMRAI::xfer::RefineAlgorithm::createSchedule           </td>
          <td>(</td>
          <td class="paramtype">const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1PatchLevelFillPattern.html">PatchLevelFillPattern</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>fill_pattern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchLevel.html">hier::PatchLevel</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>dst_level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchLevel.html">hier::PatchLevel</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>src_level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>next_coarser_level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchHierarchy.html">hier::PatchHierarchy</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>hierarchy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1xfer_1_1RefinePatchStrategy.html">RefinePatchStrategy</a> *&nbsp;</td>
          <td class="paramname"> <em>patch_strategy</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>use_time_interpolation</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1RefineTransactionFactory.html">RefineTransactionFactory</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>transaction_factory</em> = <code>boost::shared_ptr&lt;&nbsp;<a class="el" href="classSAMRAI_1_1xfer_1_1RefineTransactionFactory.html">RefineTransactionFactory</a>&nbsp;&gt;()</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Same as the above, except with fill_pattern specified. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>fill_pattern</em>&nbsp;</td><td>Indicates which parts of the destination level to fill. See <a class="el" href="classSAMRAI_1_1xfer_1_1RefineSchedule.html">RefineSchedule</a> for available patterns. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>dst_level</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>src_level</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>next_coarser_level</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>hierarchy</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>patch_strategy</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>use_time_interpolation</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>transaction_factory</em>&nbsp;</td><td></td></tr>
  </table>
</dl>
<dl compact><dt><b>Precondition:</b></dt><dd>dst_level <p>
(next_coarser_level == -1) || hierarchy <p>
!src_level || (dst_level-&gt;getDim() == src_level-&gt;getDim()) <p>
!hierarchy || (dst_level-&gt;getDim() == hierarchy-&gt;getDim()) </dd></dl>

</div>
</div><p>
<a class="anchor" name="bd560f15ac217f0070c15f87501e7199"></a><!-- doxytag: member="SAMRAI::xfer::RefineAlgorithm::checkConsistency" ref="bd560f15ac217f0070c15f87501e7199" args="(const boost::shared_ptr&lt; RefineSchedule &gt; &amp;schedule) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SAMRAI::xfer::RefineAlgorithm::checkConsistency           </td>
          <td>(</td>
          <td class="paramtype">const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1RefineSchedule.html">RefineSchedule</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>schedule</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Given a previously-generated refine schedule, check for consistency with this refine algorithm object to see whether a call to <a class="el" href="classSAMRAI_1_1xfer_1_1RefineAlgorithm.html#1d18cbc13d62b71a2c2f1f88cff5b5c8">resetSchedule()</a> is a valid operation. 
<p>
Consistency means that the number of operations registered must be the same and the source and destination patch data items and operators must have identical characteristics (i.e., data centering, ghost cell widths, stencil requirements, etc.). However, the specific source, destination patch data ids and refine operators can be different. The specific time interpolation operators and variable fill patterns must be the same. See <a class="el" href="classSAMRAI_1_1xfer_1_1RefineClasses.html#2256baa3b41a906b25735ca22107737a">RefineClasses::classesMatch()</a> for more details.<p>
<dl compact><dt><b>Returns:</b></dt><dd>true if schedule reset is valid; false otherwise.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>schedule</em>&nbsp;</td><td>boost::shared_ptr to refine schedule, which cannot be null.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Precondition:</b></dt><dd>schedule </dd></dl>

</div>
</div><p>
<a class="anchor" name="1d18cbc13d62b71a2c2f1f88cff5b5c8"></a><!-- doxytag: member="SAMRAI::xfer::RefineAlgorithm::resetSchedule" ref="1d18cbc13d62b71a2c2f1f88cff5b5c8" args="(const boost::shared_ptr&lt; RefineSchedule &gt; &amp;schedule) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::xfer::RefineAlgorithm::resetSchedule           </td>
          <td>(</td>
          <td class="paramtype">const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1RefineSchedule.html">RefineSchedule</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>schedule</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Given a previously-generated refine schedule, reconfigure it to peform the communication operations registered with THIS refine algorithm object. 
<p>
That is, the schedule will be transformed so that it will function as though this refine algorithm created it. Note that the set of operations registered with this refine algorithm must be essentially the same as those registered with the refine algorithm that created the schedule originally, and this is enforced using a call to <a class="el" href="classSAMRAI_1_1xfer_1_1RefineAlgorithm.html#bd560f15ac217f0070c15f87501e7199">checkConsistency()</a>. An error will result if the schedule is not consistent with this <a class="el" href="classSAMRAI_1_1xfer_1_1RefineAlgorithm.html">RefineAlgorithm</a> object according to the criteria in <a class="el" href="classSAMRAI_1_1xfer_1_1RefineAlgorithm.html#bd560f15ac217f0070c15f87501e7199">checkConsistency()</a>.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>schedule</em>&nbsp;</td><td>boost::shared_ptr to refine schedule, which cannot be null.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Precondition:</b></dt><dd>schedule <p>
d_refine_classes-&gt;classesMatch(schedule-&gt;<a class="el" href="classSAMRAI_1_1xfer_1_1RefineAlgorithm.html#56d8f1a9ad70d70f5c01d7ed3d941e5e">getEquivalenceClasses()</a>) </dd></dl>

</div>
</div><p>
<a class="anchor" name="56d8f1a9ad70d70f5c01d7ed3d941e5e"></a><!-- doxytag: member="SAMRAI::xfer::RefineAlgorithm::getEquivalenceClasses" ref="56d8f1a9ad70d70f5c01d7ed3d941e5e" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const boost::shared_ptr&lt;<a class="el" href="classSAMRAI_1_1xfer_1_1RefineClasses.html">RefineClasses</a>&gt;&amp; SAMRAI::xfer::RefineAlgorithm::getEquivalenceClasses           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return the refine equivalence classes used in the algorithm. 
<p>

</div>
</div><p>
<a class="anchor" name="a8480311b130572ae2e07a144c4233db"></a><!-- doxytag: member="SAMRAI::xfer::RefineAlgorithm::setEquivalenceClasses" ref="a8480311b130572ae2e07a144c4233db" args="(const boost::shared_ptr&lt; RefineClasses &gt; &amp;refine_classes)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::xfer::RefineAlgorithm::setEquivalenceClasses           </td>
          <td>(</td>
          <td class="paramtype">const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1RefineClasses.html">RefineClasses</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>refine_classes</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set the pointer to the refine equivalence classes to be equal to the given argument. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>refine_classes</em>&nbsp;</td><td>A pointer to refine equivalence classes </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="a1366c45c1deb33db86d8a526fa0e5c8"></a><!-- doxytag: member="SAMRAI::xfer::RefineAlgorithm::printClassData" ref="a1366c45c1deb33db86d8a526fa0e5c8" args="(std::ostream &amp;stream) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::xfer::RefineAlgorithm::printClassData           </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&nbsp;</td>
          <td class="paramname"> <em>stream</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Print the refine algorithm state to the specified data stream. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>stream</em>&nbsp;</td><td>Output data stream. </td></tr>
  </table>
</dl>

</div>
</div><p>
<hr>The documentation for this class was generated from the following files:<ul>
<li>source/SAMRAI/xfer/<a class="el" href="RefineAlgorithm_8h.html">RefineAlgorithm.h</a><li>source/SAMRAI/xfer/<a class="el" href="RefineAlgorithm_8C.html">RefineAlgorithm.C</a></ul>
<hr size="1"><address style="align: right;"><small>Generated on 10 Jan 2014 for SAMRAI by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.7 </small></address>
</body>
</html>
