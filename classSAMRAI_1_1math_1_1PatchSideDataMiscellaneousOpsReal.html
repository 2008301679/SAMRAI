<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>SAMRAI: SAMRAI::math::PatchSideDataMiscellaneousOpsReal&lt; TYPE &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath"><a class="el" href="namespaceSAMRAI.html">SAMRAI</a>::<a class="el" href="namespaceSAMRAI_1_1math.html">math</a>::<a class="el" href="classSAMRAI_1_1math_1_1PatchSideDataMiscellaneousOpsReal.html">PatchSideDataMiscellaneousOpsReal</a>
  </div>
</div>
<div class="contents">
<h1>SAMRAI::math::PatchSideDataMiscellaneousOpsReal&lt; TYPE &gt; Class Template Reference</h1><!-- doxytag: class="SAMRAI::math::PatchSideDataMiscellaneousOpsReal" -->
<p><code>#include &lt;source/SAMRAI/math/PatchSideDataMiscellaneousOpsReal.h&gt;</code></p>
<div class="dynheader">
Inheritance diagram for SAMRAI::math::PatchSideDataMiscellaneousOpsReal&lt; TYPE &gt;:</div>
<div class="dynsection">
 <div class="center">
  <img src="classSAMRAI_1_1math_1_1PatchSideDataMiscellaneousOpsReal.gif" usemap="#SAMRAI::math::PatchSideDataMiscellaneousOpsReal&lt; TYPE &gt;_map" alt=""/>
  <map id="SAMRAI::math::PatchSideDataMiscellaneousOpsReal&lt; TYPE &gt;_map" name="SAMRAI::math::PatchSideDataMiscellaneousOpsReal&lt; TYPE &gt;_map">
<area href="classSAMRAI_1_1math_1_1PatchSideDataOpsReal.html" alt="SAMRAI::math::PatchSideDataOpsReal&lt; TYPE &gt;" shape="rect" coords="0,56,366,80"/>
</map>
 </div>
</div>

<p><a href="classSAMRAI_1_1math_1_1PatchSideDataMiscellaneousOpsReal-members.html">List of all members.</a></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1math_1_1PatchSideDataMiscellaneousOpsReal.html#a2349f9633018895f52ed44083034c505">PatchSideDataMiscellaneousOpsReal</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1math_1_1PatchSideDataMiscellaneousOpsReal.html#acfb1b2bb4b7a9f87f24b2f1e557112fe">~PatchSideDataMiscellaneousOpsReal</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1math_1_1PatchSideDataMiscellaneousOpsReal.html#a836f0e9c72c3c9033f9ae64518ca73f5">computeConstrProdPos</a> (const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1pdat_1_1SideData.html">pdat::SideData</a>&lt; TYPE &gt; &gt; &amp;data1, const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1pdat_1_1SideData.html">pdat::SideData</a>&lt; TYPE &gt; &gt; &amp;data2, const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">hier::Box</a> &amp;box, const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1pdat_1_1SideData.html">pdat::SideData</a>&lt; double &gt; &gt; &amp;cvol=boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1pdat_1_1SideData.html">pdat::SideData</a>&lt; double &gt; &gt;()) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1math_1_1PatchSideDataMiscellaneousOpsReal.html#a7ee5b696290188413f372cf5af2666f5">compareToScalar</a> (const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1pdat_1_1SideData.html">pdat::SideData</a>&lt; TYPE &gt; &gt; &amp;dst, const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1pdat_1_1SideData.html">pdat::SideData</a>&lt; TYPE &gt; &gt; &amp;src, const TYPE &amp;alpha, const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">hier::Box</a> &amp;box, const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1pdat_1_1SideData.html">pdat::SideData</a>&lt; double &gt; &gt; &amp;cvol=boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1pdat_1_1SideData.html">pdat::SideData</a>&lt; double &gt; &gt;()) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1math_1_1PatchSideDataMiscellaneousOpsReal.html#a3cf5587dee022b30c4e15ca092d3cdf2">testReciprocal</a> (const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1pdat_1_1SideData.html">pdat::SideData</a>&lt; TYPE &gt; &gt; &amp;dst, const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1pdat_1_1SideData.html">pdat::SideData</a>&lt; TYPE &gt; &gt; &amp;src, const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">hier::Box</a> &amp;box, const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1pdat_1_1SideData.html">pdat::SideData</a>&lt; double &gt; &gt; &amp;cvol=boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1pdat_1_1SideData.html">pdat::SideData</a>&lt; double &gt; &gt;()) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">TYPE&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1math_1_1PatchSideDataMiscellaneousOpsReal.html#a62f541862849621e921cd7666b3ec95c">maxPointwiseDivide</a> (const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1pdat_1_1SideData.html">pdat::SideData</a>&lt; TYPE &gt; &gt; &amp;numer, const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1pdat_1_1SideData.html">pdat::SideData</a>&lt; TYPE &gt; &gt; &amp;denom, const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">hier::Box</a> &amp;box) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute max of "conditional" quotients of two arrays.  <a href="#a62f541862849621e921cd7666b3ec95c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">TYPE&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1math_1_1PatchSideDataMiscellaneousOpsReal.html#a7c8365de99f53326b81bc53ea7a8dcd9">minPointwiseDivide</a> (const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1pdat_1_1SideData.html">pdat::SideData</a>&lt; TYPE &gt; &gt; &amp;numer, const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1pdat_1_1SideData.html">pdat::SideData</a>&lt; TYPE &gt; &gt; &amp;denom, const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">hier::Box</a> &amp;box) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute min of quotients of two arrays.  <a href="#a7c8365de99f53326b81bc53ea7a8dcd9"></a><br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<h3>template&lt;class TYPE&gt;<br/>
 class SAMRAI::math::PatchSideDataMiscellaneousOpsReal&lt; TYPE &gt;</h3>

<p>Class <a class="el" href="classSAMRAI_1_1math_1_1PatchSideDataMiscellaneousOpsReal.html">PatchSideDataMiscellaneousOpsReal</a> provides access to a collection of operations that may be applied to numerical side-centered patch data of type double and float. The primary intent of this class is to provide the interface to these operations for the class <a class="el" href="classSAMRAI_1_1math_1_1PatchSideDataOpsReal.html">PatchSideDataOpsReal</a> which provides access to a more complete set of operations that may be used to manipulate side-centered patch data. Each member function accepts a box argument indicating the region of index space on which the operation should be performed. The operation will be performed on the intersection of this box and those boxes corresponding to the patch data objects. Also, each operation allows an additional side-centered patch data object to be used to represent a control volume that weights the contribution of each data entry in the given norm calculation. Note that the control volume patch data must be of type double and have side-centered geometry (i.e., the same as the data itself). The use of control volumes is important when these operations are used in vector kernels where the data resides over multiple levels of spatial resolution in an AMR hierarchy. If the control volume is not given in the function call, it will be ignored in the calculation. Also, note that the depth of the control volume patch data object must be either 1 or be equal to the depth of the other data objects.</p>
<p>Since these operations are used only by the vector kernels for the KINSOL and CVODE solver packages at this time, they are intended to be instantiated for the standard built-in types double and float (since those solvers only treat double and float data). To extend this class to other data types or to include other operations, the member functions must be specialized or the new operations must be added.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classSAMRAI_1_1math_1_1ArrayDataMiscellaneousOpsReal.html">math::ArrayDataMiscellaneousOpsReal</a> </dd></dl>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a2349f9633018895f52ed44083034c505"></a><!-- doxytag: member="SAMRAI::math::PatchSideDataMiscellaneousOpsReal::PatchSideDataMiscellaneousOpsReal" ref="a2349f9633018895f52ed44083034c505" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSAMRAI_1_1math_1_1PatchSideDataMiscellaneousOpsReal.html">SAMRAI::math::PatchSideDataMiscellaneousOpsReal</a>&lt; TYPE &gt;::<a class="el" href="classSAMRAI_1_1math_1_1PatchSideDataMiscellaneousOpsReal.html">PatchSideDataMiscellaneousOpsReal</a> </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Empty constructor and destructor. </p>

</div>
</div>
<a class="anchor" id="acfb1b2bb4b7a9f87f24b2f1e557112fe"></a><!-- doxytag: member="SAMRAI::math::PatchSideDataMiscellaneousOpsReal::~PatchSideDataMiscellaneousOpsReal" ref="acfb1b2bb4b7a9f87f24b2f1e557112fe" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSAMRAI_1_1math_1_1PatchSideDataMiscellaneousOpsReal.html">SAMRAI::math::PatchSideDataMiscellaneousOpsReal</a>&lt; TYPE &gt;::~<a class="el" href="classSAMRAI_1_1math_1_1PatchSideDataMiscellaneousOpsReal.html">PatchSideDataMiscellaneousOpsReal</a> </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a836f0e9c72c3c9033f9ae64518ca73f5"></a><!-- doxytag: member="SAMRAI::math::PatchSideDataMiscellaneousOpsReal::computeConstrProdPos" ref="a836f0e9c72c3c9033f9ae64518ca73f5" args="(const boost::shared_ptr&lt; pdat::SideData&lt; TYPE &gt; &gt; &amp;data1, const boost::shared_ptr&lt; pdat::SideData&lt; TYPE &gt; &gt; &amp;data2, const hier::Box &amp;box, const boost::shared_ptr&lt; pdat::SideData&lt; double &gt; &gt; &amp;cvol=boost::shared_ptr&lt; pdat::SideData&lt; double &gt; &gt;()) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classSAMRAI_1_1math_1_1PatchSideDataMiscellaneousOpsReal.html">SAMRAI::math::PatchSideDataMiscellaneousOpsReal</a>&lt; TYPE &gt;::computeConstrProdPos </td>
          <td>(</td>
          <td class="paramtype">const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1pdat_1_1SideData.html">pdat::SideData</a>&lt; TYPE &gt; &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>data1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1pdat_1_1SideData.html">pdat::SideData</a>&lt; TYPE &gt; &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>data2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">hier::Box</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>box</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1pdat_1_1SideData.html">pdat::SideData</a>&lt; double &gt; &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>cvol</em> = <code>boost::shared_ptr&lt;<a class="el" href="classSAMRAI_1_1pdat_1_1SideData.html">pdat::SideData</a>&lt;double&gt;&nbsp;&gt;()</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return 1 if <img class="formulaInl" alt="$\|data2_i\| > 0$" src="form_6.png"/> and <img class="formulaInl" alt="$data1_i * data2_i \leq 0$" src="form_7.png"/>, for any <img class="formulaInl" alt="$i$" src="form_8.png"/> in the index region, where <img class="formulaInl" alt="$cvol_i > 0$" src="form_9.png"/>. Otherwise return 0. If the control volume is NULL, all values in the index set are used.</p>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>data1 &amp;&amp; data2 </dd>
<dd>
data1-&gt;getDirectionVector() == data2-&gt;getDirectionVector() </dd>
<dd>
!cvol || (data1-&gt;getDirectionVector() == <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html#ae3a617a75e07fe76870445a62e09193f" title="Return the component-wise minimum of two integer vector objects.">hier::IntVector::min</a>(data1-&gt;getDirectionVector(), cvol-&gt;getDirectionVector())) </dd></dl>

<p>References <a class="el" href="IntVector_8h_source.html#l00608">SAMRAI::hier::IntVector::min()</a>, <a class="el" href="Utilities_8h_source.html#l00110">TBOX_ASSERT</a>, and <a class="el" href="SideGeometry_8C_source.html#l00195">SAMRAI::pdat::SideGeometry::toSideBox()</a>.</p>

</div>
</div>
<a class="anchor" id="a7ee5b696290188413f372cf5af2666f5"></a><!-- doxytag: member="SAMRAI::math::PatchSideDataMiscellaneousOpsReal::compareToScalar" ref="a7ee5b696290188413f372cf5af2666f5" args="(const boost::shared_ptr&lt; pdat::SideData&lt; TYPE &gt; &gt; &amp;dst, const boost::shared_ptr&lt; pdat::SideData&lt; TYPE &gt; &gt; &amp;src, const TYPE &amp;alpha, const hier::Box &amp;box, const boost::shared_ptr&lt; pdat::SideData&lt; double &gt; &gt; &amp;cvol=boost::shared_ptr&lt; pdat::SideData&lt; double &gt; &gt;()) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSAMRAI_1_1math_1_1PatchSideDataMiscellaneousOpsReal.html">SAMRAI::math::PatchSideDataMiscellaneousOpsReal</a>&lt; TYPE &gt;::compareToScalar </td>
          <td>(</td>
          <td class="paramtype">const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1pdat_1_1SideData.html">pdat::SideData</a>&lt; TYPE &gt; &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1pdat_1_1SideData.html">pdat::SideData</a>&lt; TYPE &gt; &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TYPE &amp;&nbsp;</td>
          <td class="paramname"> <em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">hier::Box</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>box</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1pdat_1_1SideData.html">pdat::SideData</a>&lt; double &gt; &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>cvol</em> = <code>boost::shared_ptr&lt;<a class="el" href="classSAMRAI_1_1pdat_1_1SideData.html">pdat::SideData</a>&lt;double&gt;&nbsp;&gt;()</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Wherever <img class="formulaInl" alt="$cvol_i > 0$" src="form_9.png"/> in the index region, set <img class="formulaInl" alt="$dst_i = 1$" src="form_10.png"/> if <img class="formulaInl" alt="$\|src_i\| > \alpha$" src="form_11.png"/>, and <img class="formulaInl" alt="$dst_i = 0$" src="form_12.png"/> otherwise. If the control volume is NULL, all values in the index set are considered.</p>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>dst &amp;&amp; src </dd>
<dd>
dst-&gt;getDirectionVector() == src-&gt;getDirectionVector() </dd>
<dd>
!cvol || (dst-&gt;getDirectionVector() == <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html#ae3a617a75e07fe76870445a62e09193f" title="Return the component-wise minimum of two integer vector objects.">hier::IntVector::min</a>(dst-&gt;getDirectionVector(), cvol-&gt;getDirectionVector())) </dd></dl>

<p>References <a class="el" href="IntVector_8h_source.html#l00608">SAMRAI::hier::IntVector::min()</a>, <a class="el" href="Utilities_8h_source.html#l00110">TBOX_ASSERT</a>, and <a class="el" href="SideGeometry_8C_source.html#l00195">SAMRAI::pdat::SideGeometry::toSideBox()</a>.</p>

</div>
</div>
<a class="anchor" id="a3cf5587dee022b30c4e15ca092d3cdf2"></a><!-- doxytag: member="SAMRAI::math::PatchSideDataMiscellaneousOpsReal::testReciprocal" ref="a3cf5587dee022b30c4e15ca092d3cdf2" args="(const boost::shared_ptr&lt; pdat::SideData&lt; TYPE &gt; &gt; &amp;dst, const boost::shared_ptr&lt; pdat::SideData&lt; TYPE &gt; &gt; &amp;src, const hier::Box &amp;box, const boost::shared_ptr&lt; pdat::SideData&lt; double &gt; &gt; &amp;cvol=boost::shared_ptr&lt; pdat::SideData&lt; double &gt; &gt;()) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classSAMRAI_1_1math_1_1PatchSideDataMiscellaneousOpsReal.html">SAMRAI::math::PatchSideDataMiscellaneousOpsReal</a>&lt; TYPE &gt;::testReciprocal </td>
          <td>(</td>
          <td class="paramtype">const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1pdat_1_1SideData.html">pdat::SideData</a>&lt; TYPE &gt; &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1pdat_1_1SideData.html">pdat::SideData</a>&lt; TYPE &gt; &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">hier::Box</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>box</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1pdat_1_1SideData.html">pdat::SideData</a>&lt; double &gt; &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>cvol</em> = <code>boost::shared_ptr&lt;<a class="el" href="classSAMRAI_1_1pdat_1_1SideData.html">pdat::SideData</a>&lt;double&gt;&nbsp;&gt;()</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Wherever <img class="formulaInl" alt="$cvol_i > 0$" src="form_9.png"/> in the index region, set <img class="formulaInl" alt="$dst_i = 1/src_i$" src="form_13.png"/> if <img class="formulaInl" alt="$src_i \neq 0$" src="form_14.png"/>, and <img class="formulaInl" alt="$dst_i = 0$" src="form_12.png"/> otherwise. If <img class="formulaInl" alt="$dst_i = 0$" src="form_12.png"/> anywhere, 0 is the return value. Otherwise 1 is returned. If the control volume all values in the index set are considered.</p>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>dst &amp;&amp; src </dd>
<dd>
dst-&gt;getDirectionVector() == src-&gt;getDirectionVector() </dd>
<dd>
!cvol || (dst-&gt;getDirectionVector() == <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html#ae3a617a75e07fe76870445a62e09193f" title="Return the component-wise minimum of two integer vector objects.">hier::IntVector::min</a>(dst-&gt;getDirectionVector(), cvol-&gt;getDirectionVector())) </dd></dl>

<p>References <a class="el" href="IntVector_8h_source.html#l00608">SAMRAI::hier::IntVector::min()</a>, <a class="el" href="Utilities_8h_source.html#l00110">TBOX_ASSERT</a>, and <a class="el" href="SideGeometry_8C_source.html#l00195">SAMRAI::pdat::SideGeometry::toSideBox()</a>.</p>

</div>
</div>
<a class="anchor" id="a62f541862849621e921cd7666b3ec95c"></a><!-- doxytag: member="SAMRAI::math::PatchSideDataMiscellaneousOpsReal::maxPointwiseDivide" ref="a62f541862849621e921cd7666b3ec95c" args="(const boost::shared_ptr&lt; pdat::SideData&lt; TYPE &gt; &gt; &amp;numer, const boost::shared_ptr&lt; pdat::SideData&lt; TYPE &gt; &gt; &amp;denom, const hier::Box &amp;box) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">TYPE <a class="el" href="classSAMRAI_1_1math_1_1PatchSideDataMiscellaneousOpsReal.html">SAMRAI::math::PatchSideDataMiscellaneousOpsReal</a>&lt; TYPE &gt;::maxPointwiseDivide </td>
          <td>(</td>
          <td class="paramtype">const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1pdat_1_1SideData.html">pdat::SideData</a>&lt; TYPE &gt; &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>numer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1pdat_1_1SideData.html">pdat::SideData</a>&lt; TYPE &gt; &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>denom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">hier::Box</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>box</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compute max of "conditional" quotients of two arrays. </p>
<p>Return the maximum of pointwise "conditional" quotients of the numerator and denominator.</p>
<p>The "conditional" quotient is defined as |numerator/denominator| where the denominator is nonzero. Otherwise, it is defined as |numerator|.</p>
<p><b>Note:</b> This method is currently intended to support the PETSc-2.1.6 vector wrapper only. Please do not use it!</p>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>numer &amp;&amp; denom </dd></dl>

<p>References <a class="el" href="Utilities_8h_source.html#l00110">TBOX_ASSERT</a>, and <a class="el" href="SideGeometry_8C_source.html#l00195">SAMRAI::pdat::SideGeometry::toSideBox()</a>.</p>

</div>
</div>
<a class="anchor" id="a7c8365de99f53326b81bc53ea7a8dcd9"></a><!-- doxytag: member="SAMRAI::math::PatchSideDataMiscellaneousOpsReal::minPointwiseDivide" ref="a7c8365de99f53326b81bc53ea7a8dcd9" args="(const boost::shared_ptr&lt; pdat::SideData&lt; TYPE &gt; &gt; &amp;numer, const boost::shared_ptr&lt; pdat::SideData&lt; TYPE &gt; &gt; &amp;denom, const hier::Box &amp;box) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">TYPE <a class="el" href="classSAMRAI_1_1math_1_1PatchSideDataMiscellaneousOpsReal.html">SAMRAI::math::PatchSideDataMiscellaneousOpsReal</a>&lt; TYPE &gt;::minPointwiseDivide </td>
          <td>(</td>
          <td class="paramtype">const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1pdat_1_1SideData.html">pdat::SideData</a>&lt; TYPE &gt; &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>numer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1pdat_1_1SideData.html">pdat::SideData</a>&lt; TYPE &gt; &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>denom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">hier::Box</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>box</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compute min of quotients of two arrays. </p>
<p>Return the minimum of pointwise quotients of the numerator and denominator.</p>
<p>The quotient is defined as (numerator/denominator) where the denominator is nonzero. When the denominator is zero, the entry is skipped. If the denominator is always zero, the value of tbox::IEEE::getFLT_MAX() is returned (see <a class="el" href="structSAMRAI_1_1tbox_1_1IEEE.html">SAMRAI::tbox::IEEE</a>).</p>
<p><b>Note:</b> This method is currently intended to support the SUNDIALS vector wrapper only. Please do not use it!</p>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>numer &amp;&amp; denom </dd></dl>

<p>References <a class="el" href="Utilities_8h_source.html#l00110">TBOX_ASSERT</a>, and <a class="el" href="SideGeometry_8C_source.html#l00195">SAMRAI::pdat::SideGeometry::toSideBox()</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>source/SAMRAI/math/<a class="el" href="PatchSideDataMiscellaneousOpsReal_8h.html">PatchSideDataMiscellaneousOpsReal.h</a></li>
<li>source/SAMRAI/math/<a class="el" href="PatchSideDataMiscellaneousOpsReal_8C.html">PatchSideDataMiscellaneousOpsReal.C</a></li>
</ul>
</div>
<hr size="1"/><address style="text-align: right;"><small>Generated on 8 Oct 2014 for SAMRAI by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.1 </small></address>
</body>
</html>
