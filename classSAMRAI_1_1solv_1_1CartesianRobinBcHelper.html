<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>SAMRAI: SAMRAI::solv::CartesianRobinBcHelper Class Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.7 -->
<div class="tabs">
  <ul>
    <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="namespaces.html"><span>Namespaces</span></a></li>
    <li id="current"><a href="annotated.html"><span>Classes</span></a></li>
    <li><a href="files.html"><span>Files</span></a></li>
    <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
  </ul></div>
<div class="tabs">
  <ul>
    <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
    <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
    <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
  </ul></div>
<div class="nav">
<a class="el" href="namespaceSAMRAI.html">SAMRAI</a>::<a class="el" href="namespaceSAMRAI_1_1solv.html">solv</a>::<a class="el" href="classSAMRAI_1_1solv_1_1CartesianRobinBcHelper.html">CartesianRobinBcHelper</a></div>
<h1>SAMRAI::solv::CartesianRobinBcHelper Class Reference</h1><!-- doxytag: class="SAMRAI::solv::CartesianRobinBcHelper" --><!-- doxytag: inherits="SAMRAI::xfer::RefinePatchStrategy" -->Helper utility for setting Robin boundary conditions.  
<a href="#_details">More...</a>
<p>
<code>#include &lt;source/SAMRAI/solv/CartesianRobinBcHelper.h&gt;</code>
<p>
<p>Inheritance diagram for SAMRAI::solv::CartesianRobinBcHelper:
<p><center><img src="classSAMRAI_1_1solv_1_1CartesianRobinBcHelper.png" usemap="#SAMRAI::solv::CartesianRobinBcHelper_map" border="0" alt=""></center>
<map name="SAMRAI::solv::CartesianRobinBcHelper_map">
<area href="classSAMRAI_1_1xfer_1_1RefinePatchStrategy.html" alt="SAMRAI::xfer::RefinePatchStrategy" shape="rect" coords="0,0,234,24">
</map>
<a href="classSAMRAI_1_1solv_1_1CartesianRobinBcHelper-members.html">List of all members.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1CartesianRobinBcHelper.html#5b35a1d32576ceac5129c88de74747d4">CartesianRobinBcHelper</a> (const <a class="el" href="classSAMRAI_1_1tbox_1_1Dimension.html">tbox::Dimension</a> &amp;dim, std::string object_name=std::string(), <a class="el" href="classSAMRAI_1_1solv_1_1RobinBcCoefStrategy.html">RobinBcCoefStrategy</a> *coef_strategy=NULL)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Constructor using.  <a href="#5b35a1d32576ceac5129c88de74747d4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1CartesianRobinBcHelper.html#3dc75529ca1a47fb5bfe5376b30e7c91">~CartesianRobinBcHelper</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Destructor.  <a href="#3dc75529ca1a47fb5bfe5376b30e7c91"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">const std::string &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1CartesianRobinBcHelper.html#6b01eb9d1284523dec2147a12da6bfb9">getObjectName</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the name of this object.  <a href="#6b01eb9d1284523dec2147a12da6bfb9"></a><br></td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1CartesianRobinBcHelper.html#036d4b480f37ed811e36650ea76f73c5">setPhysicalBoundaryConditions</a> (<a class="el" href="classSAMRAI_1_1hier_1_1Patch.html">hier::Patch</a> &amp;patch, const double fill_time, const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a> &amp;ghost_width_to_fill)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Pure virtual function interface for physical boundary filling.  <a href="#036d4b480f37ed811e36650ea76f73c5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1CartesianRobinBcHelper.html#ccc4c66735dbad0976c556b6a38c9cac">getRefineOpStencilWidth</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return maximum stencil width needed for user-defined data refinement operations performed by this object.  <a href="#ccc4c66735dbad0976c556b6a38c9cac"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1CartesianRobinBcHelper.html#f9cfae649ce238deb28b990c8b4e98d5">preprocessRefineBoxes</a> (<a class="el" href="classSAMRAI_1_1hier_1_1Patch.html">hier::Patch</a> &amp;fine, const <a class="el" href="classSAMRAI_1_1hier_1_1Patch.html">hier::Patch</a> &amp;coarse, const <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">hier::BoxContainer</a> &amp;fine_boxes, const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a> &amp;ratio)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1CartesianRobinBcHelper.html#fa142e52689d375d2b150cf1da41e19d">preprocessRefine</a> (<a class="el" href="classSAMRAI_1_1hier_1_1Patch.html">hier::Patch</a> &amp;fine, const <a class="el" href="classSAMRAI_1_1hier_1_1Patch.html">hier::Patch</a> &amp;coarse, const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">hier::Box</a> &amp;fine_box, const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a> &amp;ratio)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Perform user-defined patch data refinement operations.  <a href="#fa142e52689d375d2b150cf1da41e19d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1CartesianRobinBcHelper.html#1dfc4a230436ca86b243e438c121c306">postprocessRefineBoxes</a> (<a class="el" href="classSAMRAI_1_1hier_1_1Patch.html">hier::Patch</a> &amp;fine, const <a class="el" href="classSAMRAI_1_1hier_1_1Patch.html">hier::Patch</a> &amp;coarse, const <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">hier::BoxContainer</a> &amp;fine_boxes, const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a> &amp;ratio)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1CartesianRobinBcHelper.html#ef8ff23d92caeba0c5da381834d09e8e">postprocessRefine</a> (<a class="el" href="classSAMRAI_1_1hier_1_1Patch.html">hier::Patch</a> &amp;fine, const <a class="el" href="classSAMRAI_1_1hier_1_1Patch.html">hier::Patch</a> &amp;coarse, const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">hier::Box</a> &amp;fine_box, const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a> &amp;ratio)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Perform user-defined patch data refinement operations.  <a href="#ef8ff23d92caeba0c5da381834d09e8e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1CartesianRobinBcHelper.html#4413a7b1133fa54f4aac158a1fb1ea01">fillSingularityBoundaryConditions</a> (<a class="el" href="classSAMRAI_1_1hier_1_1Patch.html">hier::Patch</a> &amp;patch, const <a class="el" href="classSAMRAI_1_1hier_1_1PatchLevel.html">hier::PatchLevel</a> &amp;encon_level, const <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">hier::Connector</a> &amp;dst_to_encon, const double fill_time, const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">hier::Box</a> &amp;fill_box, const <a class="el" href="classSAMRAI_1_1hier_1_1BoundaryBox.html">hier::BoundaryBox</a> &amp;boundary_box, const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1hier_1_1BaseGridGeometry.html">hier::BaseGridGeometry</a> &gt; &amp;grid_geometry)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the ghost data at a multiblock singularity.  <a href="#4413a7b1133fa54f4aac158a1fb1ea01"></a><br></td></tr>
<tr><td colspan="2"><div class="groupHeader">Functions to set boundary condition values</div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1CartesianRobinBcHelper.html#f53f3ff119ee35deb172b754036e97cd">setBoundaryValuesInCells</a> (<a class="el" href="classSAMRAI_1_1hier_1_1Patch.html">hier::Patch</a> &amp;patch, const double fill_time, const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a> &amp;ghost_width_to_fill, int target_data_id, bool homogeneous_bc=false) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the physical boundary condition by setting the value of the first ghost cells.  <a href="#f53f3ff119ee35deb172b754036e97cd"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1CartesianRobinBcHelper.html#89eaee6f890849483d2c0c76c83f5c70">setBoundaryValuesInCells</a> (<a class="el" href="classSAMRAI_1_1hier_1_1PatchLevel.html">hier::PatchLevel</a> &amp;level, const double fill_time, const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a> &amp;ghost_width_to_fill, int target_data_id, bool homogeneous_bc=false) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set ghost cells for an entire level.  <a href="#89eaee6f890849483d2c0c76c83f5c70"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1CartesianRobinBcHelper.html#2c660902ebe5ec7ceb0bd20cd0f94a37">setBoundaryValuesAtNodes</a> (<a class="el" href="classSAMRAI_1_1hier_1_1Patch.html">hier::Patch</a> &amp;patch, const double fill_time, int target_data_id, bool homogeneous_bc=false) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the physical boundary condition by setting the value of the boundary nodes.  <a href="#2c660902ebe5ec7ceb0bd20cd0f94a37"></a><br></td></tr>
<tr><td colspan="2"><div class="groupHeader">Ways to provide the Robin bc coefficients</div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1CartesianRobinBcHelper.html#e6b71cf54673067fea231f3b22d9db10">setCoefImplementation</a> (const <a class="el" href="classSAMRAI_1_1solv_1_1RobinBcCoefStrategy.html">RobinBcCoefStrategy</a> *coef_strategy)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Provide an implementation of the <a class="el" href="classSAMRAI_1_1solv_1_1RobinBcCoefStrategy.html">RobinBcCoefStrategy</a> for determining the boundary coefficients.  <a href="#e6b71cf54673067fea231f3b22d9db10"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1CartesianRobinBcHelper.html#2e8d5023ea0ca0a7ef92ab5d9d762f6c">setTargetDataId</a> (int target_data_id)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the data id that should be filled when setting physical boundary conditions.  <a href="#2e8d5023ea0ca0a7ef92ab5d9d762f6c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1CartesianRobinBcHelper.html#b6b727954fc252b2b90a512379856cad">setHomogeneousBc</a> (bool homogeneous_bc)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set whether boundary filling should assume homogeneous conditions.  <a href="#b6b727954fc252b2b90a512379856cad"></a><br></td></tr>
</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
Helper utility for setting Robin boundary conditions. 
<p>
This class is intended as a helper for performing the tedious task of setting boundary values for scalar quantities for the general case of boundary conditions known as the Robin boundary condition.<p>
It uses the Robin boundary condition coefficients specified by a <a class="el" href="classSAMRAI_1_1solv_1_1RobinBcCoefStrategy.html">RobinBcCoefStrategy</a> object to determine the boundary value to set. The exact value set depends on the allignment of the data and is derived from various discrete approximations of the Robin formula. This class currently supports cell-centered alignment and will support node-centered alignment in the future.<p>
See <a class="el" href="classSAMRAI_1_1solv_1_1RobinBcCoefStrategy.html">RobinBcCoefStrategy</a> for the description of the Robin boundary condition.<p>
This class inherits and implements virtual functions from <a class="el" href="classSAMRAI_1_1xfer_1_1RefinePatchStrategy.html">xfer::RefinePatchStrategy</a> so it may be used to help create communication schedules if desired. 
<p>
<hr><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" name="5b35a1d32576ceac5129c88de74747d4"></a><!-- doxytag: member="SAMRAI::solv::CartesianRobinBcHelper::CartesianRobinBcHelper" ref="5b35a1d32576ceac5129c88de74747d4" args="(const tbox::Dimension &amp;dim, std::string object_name=std::string(), RobinBcCoefStrategy *coef_strategy=NULL)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SAMRAI::solv::CartesianRobinBcHelper::CartesianRobinBcHelper           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1tbox_1_1Dimension.html">tbox::Dimension</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>dim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&nbsp;</td>
          <td class="paramname"> <em>object_name</em> = <code>std::string()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1solv_1_1RobinBcCoefStrategy.html">RobinBcCoefStrategy</a> *&nbsp;</td>
          <td class="paramname"> <em>coef_strategy</em> = <code>NULL</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Constructor using. 
<p>
Requires a concrete implementation of <a class="el" href="classSAMRAI_1_1solv_1_1RobinBcCoefStrategy.html">RobinBcCoefStrategy</a>.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dim</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>object_name</em>&nbsp;</td><td>Name of the object, for general referencing. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>coef_strategy</em>&nbsp;</td><td>Coefficients strategy being helped. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="3dc75529ca1a47fb5bfe5376b30e7c91"></a><!-- doxytag: member="SAMRAI::solv::CartesianRobinBcHelper::~CartesianRobinBcHelper" ref="3dc75529ca1a47fb5bfe5376b30e7c91" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual SAMRAI::solv::CartesianRobinBcHelper::~CartesianRobinBcHelper           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Destructor. 
<p>

</div>
</div><p>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="036d4b480f37ed811e36650ea76f73c5"></a><!-- doxytag: member="SAMRAI::solv::CartesianRobinBcHelper::setPhysicalBoundaryConditions" ref="036d4b480f37ed811e36650ea76f73c5" args="(hier::Patch &amp;patch, const double fill_time, const hier::IntVector &amp;ghost_width_to_fill)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void SAMRAI::solv::CartesianRobinBcHelper::setPhysicalBoundaryConditions           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1hier_1_1Patch.html">hier::Patch</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>patch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>fill_time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>ghost_width_to_fill</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Pure virtual function interface for physical boundary filling. 
<p>
Set data in ghost regions at patch boundaries that touch the physical domain boundary. The specific data values set in physical boundary ghost regions are determined by the boundary conditions needed by the user application. The patch data components that should be set in this function correspond to the "scratch" components specified in calls to the registerRefine() function in the RefineAlgorithm class.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>patch</em>&nbsp;</td><td>Patch on which to fill boundary data. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>fill_time</em>&nbsp;</td><td>Simulation time for boundary filling. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>ghost_width_to_fill</em>&nbsp;</td><td>Maximum ghost width to fill over all registered scratch components. </td></tr>
  </table>
</dl>

<p>
Implements <a class="el" href="classSAMRAI_1_1xfer_1_1RefinePatchStrategy.html#428a5d166ab97a9ce9c8344685817b26">SAMRAI::xfer::RefinePatchStrategy</a>.
</div>
</div><p>
<a class="anchor" name="ccc4c66735dbad0976c556b6a38c9cac"></a><!-- doxytag: member="SAMRAI::solv::CartesianRobinBcHelper::getRefineOpStencilWidth" ref="ccc4c66735dbad0976c556b6a38c9cac" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a> SAMRAI::solv::CartesianRobinBcHelper::getRefineOpStencilWidth           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return maximum stencil width needed for user-defined data refinement operations performed by this object. 
<p>
This is needed to determine the correct interpolatin data dependencies and to ensure that the data has a sufficient amount of ghost width.<p>
For any user-defined interpolation operations implemented in the preprocess or postprocess methods, return the maximum stencil needed on a coarse patch to refine data to a fine patch. 
<p>
Implements <a class="el" href="classSAMRAI_1_1xfer_1_1RefinePatchStrategy.html#ac3c39692c90393a6748ea7a4f52facd">SAMRAI::xfer::RefinePatchStrategy</a>.
</div>
</div><p>
<a class="anchor" name="f9cfae649ce238deb28b990c8b4e98d5"></a><!-- doxytag: member="SAMRAI::solv::CartesianRobinBcHelper::preprocessRefineBoxes" ref="f9cfae649ce238deb28b990c8b4e98d5" args="(hier::Patch &amp;fine, const hier::Patch &amp;coarse, const hier::BoxContainer &amp;fine_boxes, const hier::IntVector &amp;ratio)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void SAMRAI::solv::CartesianRobinBcHelper::preprocessRefineBoxes           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1hier_1_1Patch.html">hier::Patch</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>fine</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1Patch.html">hier::Patch</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>coarse</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">hier::BoxContainer</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>fine_boxes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>ratio</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Perform user-defined patch data refinement operations on a list of boxes.<p>
This member function is called before standard refining operations (expressed using concrete subclasses of the RefineOperator base class).<p>
The default implementation of this virtual function loops over the box list and calls the <a class="el" href="classSAMRAI_1_1solv_1_1CartesianRobinBcHelper.html#fa142e52689d375d2b150cf1da41e19d">preprocessRefine()</a> method for a single box.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>fine</em>&nbsp;</td><td>Fine patch containing destination data. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>coarse</em>&nbsp;</td><td>Coarse patch containing source data. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>fine_boxes</em>&nbsp;</td><td>List of box regions on fine patch into which data is refined. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>ratio</em>&nbsp;</td><td>Refinement ratio between coarse and fine patches. </td></tr>
  </table>
</dl>

<p>
Reimplemented from <a class="el" href="classSAMRAI_1_1xfer_1_1RefinePatchStrategy.html#b7ecf070476c948a6bf2f4e26f904bc0">SAMRAI::xfer::RefinePatchStrategy</a>.
</div>
</div><p>
<a class="anchor" name="fa142e52689d375d2b150cf1da41e19d"></a><!-- doxytag: member="SAMRAI::solv::CartesianRobinBcHelper::preprocessRefine" ref="fa142e52689d375d2b150cf1da41e19d" args="(hier::Patch &amp;fine, const hier::Patch &amp;coarse, const hier::Box &amp;fine_box, const hier::IntVector &amp;ratio)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void SAMRAI::solv::CartesianRobinBcHelper::preprocessRefine           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1hier_1_1Patch.html">hier::Patch</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>fine</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1Patch.html">hier::Patch</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>coarse</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">hier::Box</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>fine_box</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>ratio</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Perform user-defined patch data refinement operations. 
<p>
This member function is called before standard refine operations (expressed using concrete subclasses of the RefineOperator base class). The preprocess function must refine data from the scratch components on the coarse patch into the scratch components of the fine patch on the specified fine box region. Recall that the scratch components are specified in calls to the registerRefine() function in the RefineAlgorithm class.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>fine</em>&nbsp;</td><td>Fine patch containing destination data. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>coarse</em>&nbsp;</td><td>Coarse patch containing source data. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>fine_box</em>&nbsp;</td><td>Box region on fine patch into which data is refined. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>ratio</em>&nbsp;</td><td>Refinement ratio between coarse and fine patches. </td></tr>
  </table>
</dl>

<p>
Implements <a class="el" href="classSAMRAI_1_1xfer_1_1RefinePatchStrategy.html#c5d1588459650fb4ff5f7c5dd66ece46">SAMRAI::xfer::RefinePatchStrategy</a>.
</div>
</div><p>
<a class="anchor" name="1dfc4a230436ca86b243e438c121c306"></a><!-- doxytag: member="SAMRAI::solv::CartesianRobinBcHelper::postprocessRefineBoxes" ref="1dfc4a230436ca86b243e438c121c306" args="(hier::Patch &amp;fine, const hier::Patch &amp;coarse, const hier::BoxContainer &amp;fine_boxes, const hier::IntVector &amp;ratio)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void SAMRAI::solv::CartesianRobinBcHelper::postprocessRefineBoxes           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1hier_1_1Patch.html">hier::Patch</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>fine</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1Patch.html">hier::Patch</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>coarse</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">hier::BoxContainer</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>fine_boxes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>ratio</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Perform user-defined patch data refinement operations on a list of boxes.<p>
This member function is called after standard refining operations (expressed using concrete subclasses of the RefineOperator base class).<p>
The default implementation of this virtual function loops over the box list and calls the <a class="el" href="classSAMRAI_1_1solv_1_1CartesianRobinBcHelper.html#ef8ff23d92caeba0c5da381834d09e8e">postprocessRefine()</a> method for a single box.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>fine</em>&nbsp;</td><td>Fine patch containing destination data. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>coarse</em>&nbsp;</td><td>Coarse patch containing source data. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>fine_boxes</em>&nbsp;</td><td>List of box regions on fine patch into which data is refined. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>ratio</em>&nbsp;</td><td>Refinement ratio between coarse and fine patches. </td></tr>
  </table>
</dl>

<p>
Reimplemented from <a class="el" href="classSAMRAI_1_1xfer_1_1RefinePatchStrategy.html#c5250bd18bb4200f7f89741d6493fad6">SAMRAI::xfer::RefinePatchStrategy</a>.
</div>
</div><p>
<a class="anchor" name="ef8ff23d92caeba0c5da381834d09e8e"></a><!-- doxytag: member="SAMRAI::solv::CartesianRobinBcHelper::postprocessRefine" ref="ef8ff23d92caeba0c5da381834d09e8e" args="(hier::Patch &amp;fine, const hier::Patch &amp;coarse, const hier::Box &amp;fine_box, const hier::IntVector &amp;ratio)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void SAMRAI::solv::CartesianRobinBcHelper::postprocessRefine           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1hier_1_1Patch.html">hier::Patch</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>fine</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1Patch.html">hier::Patch</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>coarse</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">hier::Box</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>fine_box</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>ratio</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Perform user-defined patch data refinement operations. 
<p>
This member function is called after standard refine operations (expressed using concrete subclasses of the RefineOperator base class). The preprocess function must refine data from the scratch components on the coarse patch into the scratch components of the fine patch on the specified fine box region. Recall that the scratch components are specified in calls to the registerRefine() function in the RefineAlgorithm class.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>fine</em>&nbsp;</td><td>Fine patch containing destination data. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>coarse</em>&nbsp;</td><td>Coarse patch containing source data. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>fine_box</em>&nbsp;</td><td>Box region on fine patch into which data is refined. *</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>ratio</em>&nbsp;</td><td>Refinement ratio between coarse and fine patches. </td></tr>
  </table>
</dl>

<p>
Implements <a class="el" href="classSAMRAI_1_1xfer_1_1RefinePatchStrategy.html#bd5a91534d2cd570b23e679555e4cf27">SAMRAI::xfer::RefinePatchStrategy</a>.
</div>
</div><p>
<a class="anchor" name="4413a7b1133fa54f4aac158a1fb1ea01"></a><!-- doxytag: member="SAMRAI::solv::CartesianRobinBcHelper::fillSingularityBoundaryConditions" ref="4413a7b1133fa54f4aac158a1fb1ea01" args="(hier::Patch &amp;patch, const hier::PatchLevel &amp;encon_level, const hier::Connector &amp;dst_to_encon, const double fill_time, const hier::Box &amp;fill_box, const hier::BoundaryBox &amp;boundary_box, const boost::shared_ptr&lt; hier::BaseGridGeometry &gt; &amp;grid_geometry)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void SAMRAI::solv::CartesianRobinBcHelper::fillSingularityBoundaryConditions           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1hier_1_1Patch.html">hier::Patch</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>patch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1PatchLevel.html">hier::PatchLevel</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>encon_level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">hier::Connector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>dst_to_encon</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>fill_time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">hier::Box</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>fill_box</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1BoundaryBox.html">hier::BoundaryBox</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>boundary_box</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1hier_1_1BaseGridGeometry.html">hier::BaseGridGeometry</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>grid_geometry</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set the ghost data at a multiblock singularity. 
<p>
This virtual method allows for a user-defined implemenation to fill ghost data at ghost regions located at reduced or enhanced connectivity multiblock singularities. The method is virtual so that it need not be overridden in single-block applications. The encon_level and dst_to_encon arguments may be ignored if the patch touches no enhanced connectivity singularities.<p>
The patches in encon level are in the coordinate system of the blocks where they originated, not in that of the destination patch, so the filling operation must take into account the transformation between blocks.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>patch</em>&nbsp;</td><td>The patch containing the data to be filled </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>encon_level</em>&nbsp;</td><td>Level representing enhanced connectivity ghost regions </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dst_to_encon</em>&nbsp;</td><td>Connector from destination level to encon_level </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>fill_time</em>&nbsp;</td><td>Simulation time at which data is filled </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>fill_box</em>&nbsp;</td><td>Box covering maximum amount of ghost cells to be filled </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>boundary_box</em>&nbsp;</td><td>BoundaryBox describing location of singularity in relation to patch </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>grid_geometry</em>&nbsp;</td><td></td></tr>
  </table>
</dl>

<p>
Reimplemented from <a class="el" href="classSAMRAI_1_1xfer_1_1RefinePatchStrategy.html#3aae5c61f8c70809a01cf8471d1cd702">SAMRAI::xfer::RefinePatchStrategy</a>.
</div>
</div><p>
<a class="anchor" name="f53f3ff119ee35deb172b754036e97cd"></a><!-- doxytag: member="SAMRAI::solv::CartesianRobinBcHelper::setBoundaryValuesInCells" ref="f53f3ff119ee35deb172b754036e97cd" args="(hier::Patch &amp;patch, const double fill_time, const hier::IntVector &amp;ghost_width_to_fill, int target_data_id, bool homogeneous_bc=false) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::solv::CartesianRobinBcHelper::setBoundaryValuesInCells           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1hier_1_1Patch.html">hier::Patch</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>patch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>fill_time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>ghost_width_to_fill</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>target_data_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>homogeneous_bc</em> = <code>false</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set the physical boundary condition by setting the value of the first ghost cells. 
<p>
This function has an interface similar to the virtual function <a class="el" href="classSAMRAI_1_1xfer_1_1RefinePatchStrategy.html#428a5d166ab97a9ce9c8344685817b26">xfer::RefinePatchStrategy::setPhysicalBoundaryConditions()</a>, and it may be used to help implement that function, but it does not serve the same purpose. The primary differences are:<ol type=1>
<li>It specializes to cell-centered variables.</li><li>Only one ghost cell width is filled. Setting a Robin boundary condition for cell-centered quantities requires only one ghost cell to be set. (More ghost cells can be filled by continuing the linear distribution of data beyond the first cell, but that is not implemented at this time.)</li><li>User must specify the index of the data whose ghost cells need to be filled. This index is used to determine the variable for which to set the boundary coefficients and to get the data to be set.</li></ol>
<p>
This function calls RobinBcStrategy::setBcCoefs() to get the coefficients, then it sets the values in the first ghost cell on the boundary.<p>
To determine the value for the ghost cell, a <em>linear</em> approximation in the direction normal to the boundary is assumed. We write the following discrete approximations: <p class="formulaDsp">
<img class="formulaDsp" alt="\[ u_b = \frac{ u_i + u_o }{2} \]" src="form_46.png">
<p>
 <p class="formulaDsp">
<img class="formulaDsp" alt="\[ [u_n]_b = \frac{ u_o - u_i }{h} \]" src="form_47.png">
<p>
 where the subscript b stands for the the boundary, i stands for the first cell inside the boundary and o stands for the first cell outside the boundary and h is the grid spacing normal to the boundary. Applying this to the Robin formula gives <p class="formulaDsp">
<img class="formulaDsp" alt="\[ u_o = \frac{ h\gamma + u_i( \beta - \frac{h}{2} \alpha ) } { \beta + \frac{h}{2} \alpha } \]" src="form_48.png">
<p>
 or equivalently <p class="formulaDsp">
<img class="formulaDsp" alt="\[ u_o = \frac{ hg + u_i (1-a(1+\frac{h}{2})) }{ 1-a(1-\frac{h}{2}) } \]" src="form_49.png">
<p>
<p>
After setting the edge (face in 3D) boundary conditions, linear approximations are used to set the boundary conditions of higher boundary types (nodes in 2D, edges and nodes in 3D).<p>
In some cases, the calling function wants to set the boundary condition homogeneously, with g=0. This is useful in problems where the the solution of the homogeneous problem is required in solving the inhomogeneous problem. This function respects such requests specified through the argument <code>homogeneous_bc</code>. 
</div>
</div><p>
<a class="anchor" name="89eaee6f890849483d2c0c76c83f5c70"></a><!-- doxytag: member="SAMRAI::solv::CartesianRobinBcHelper::setBoundaryValuesInCells" ref="89eaee6f890849483d2c0c76c83f5c70" args="(hier::PatchLevel &amp;level, const double fill_time, const hier::IntVector &amp;ghost_width_to_fill, int target_data_id, bool homogeneous_bc=false) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::solv::CartesianRobinBcHelper::setBoundaryValuesInCells           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1hier_1_1PatchLevel.html">hier::PatchLevel</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>fill_time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>ghost_width_to_fill</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>target_data_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>homogeneous_bc</em> = <code>false</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set ghost cells for an entire level. 
<p>
Loop through all patches on the given level and call setBoundaryValuesInCells(<a class="el" href="classSAMRAI_1_1hier_1_1Patch.html">hier::Patch</a> &amp;patch, const double fill_time , const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a> &amp;ghost_width_to_fill , int target_data_id , bool homogeneous_bc=false ) for each.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>level</em>&nbsp;</td><td>PatchLevel on which to set boundary condition </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>fill_time</em>&nbsp;</td><td>Solution time corresponding to filling </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ghost_width_to_fill</em>&nbsp;</td><td>Max ghost width requiring fill </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>target_data_id</em>&nbsp;</td><td><a class="el" href="classSAMRAI_1_1hier_1_1Patch.html">hier::Patch</a> data index of data to be set. This data must be a cell-centered double. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>homogeneous_bc</em>&nbsp;</td><td>Set a homogeneous boundary condition. This means g=0 for the boundary. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="2c660902ebe5ec7ceb0bd20cd0f94a37"></a><!-- doxytag: member="SAMRAI::solv::CartesianRobinBcHelper::setBoundaryValuesAtNodes" ref="2c660902ebe5ec7ceb0bd20cd0f94a37" args="(hier::Patch &amp;patch, const double fill_time, int target_data_id, bool homogeneous_bc=false) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::solv::CartesianRobinBcHelper::setBoundaryValuesAtNodes           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1hier_1_1Patch.html">hier::Patch</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>patch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>fill_time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>target_data_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>homogeneous_bc</em> = <code>false</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set the physical boundary condition by setting the value of the boundary nodes. 
<p>
This function is not yet implemented!<p>
There are some decisions that must be made before the implementation can be written.<ol type=1>
<li>Do we set the values on the boundary or one cell away from the boundary?</li><li>What is the discrete formulation we should use to compute the value to be set?</li></ol>
<p>
This function has an interface similar to the virtual function <a class="el" href="classSAMRAI_1_1xfer_1_1RefinePatchStrategy.html#428a5d166ab97a9ce9c8344685817b26">xfer::RefinePatchStrategy::setPhysicalBoundaryConditions()</a>, and it may be used to help implement that function, but it does not serve the same purpose. The primary differences are:<ol type=1>
<li>It specializes to node-centered variables.</li><li>User must specify the index of the data whose ghost cells need to be filled. This index is used to determine the variable for which to set the boundary coefficients and to get the data to be set.</li></ol>
<p>
This function calls RobinBcStrategy::setBcCoefs() to get the coefficients, then it sets the values at the boundary nodes.<p>
In some cases, the calling function wants to set the boundary condition homogeneously, with g=0. This is useful in problems where the the solution of the homogeneous problem is required to solving the inhomogeneous problem. This function respects such requests specified through the argument <code>homogeneous_bc</code>.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>patch</em>&nbsp;</td><td><a class="el" href="classSAMRAI_1_1hier_1_1Patch.html">hier::Patch</a> on which to set boundary condition </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>fill_time</em>&nbsp;</td><td>Solution time corresponding to filling </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>target_data_id</em>&nbsp;</td><td><a class="el" href="classSAMRAI_1_1hier_1_1Patch.html">hier::Patch</a> data index of data to be set. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>homogeneous_bc</em>&nbsp;</td><td>Set a homogeneous boundary condition. This means g=0 for the boundary. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="e6b71cf54673067fea231f3b22d9db10"></a><!-- doxytag: member="SAMRAI::solv::CartesianRobinBcHelper::setCoefImplementation" ref="e6b71cf54673067fea231f3b22d9db10" args="(const RobinBcCoefStrategy *coef_strategy)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::solv::CartesianRobinBcHelper::setCoefImplementation           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1solv_1_1RobinBcCoefStrategy.html">RobinBcCoefStrategy</a> *&nbsp;</td>
          <td class="paramname"> <em>coef_strategy</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Provide an implementation of the <a class="el" href="classSAMRAI_1_1solv_1_1RobinBcCoefStrategy.html">RobinBcCoefStrategy</a> for determining the boundary coefficients. 
<p>
Provide the implementation that can be used to set the Robin bc coefficients.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>coef_strategy</em>&nbsp;</td><td>Pointer to a concrete inmplementation of the coefficient strategy. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="2e8d5023ea0ca0a7ef92ab5d9d762f6c"></a><!-- doxytag: member="SAMRAI::solv::CartesianRobinBcHelper::setTargetDataId" ref="2e8d5023ea0ca0a7ef92ab5d9d762f6c" args="(int target_data_id)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::solv::CartesianRobinBcHelper::setTargetDataId           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>target_data_id</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set the data id that should be filled when setting physical boundary conditions. 
<p>
When setPhysicalBoundaryConditions is called, the data specified will be set. This information is required because the it is not passed in through the argument list of setPhysicalBounaryConditions. 
</div>
</div><p>
<a class="anchor" name="b6b727954fc252b2b90a512379856cad"></a><!-- doxytag: member="SAMRAI::solv::CartesianRobinBcHelper::setHomogeneousBc" ref="b6b727954fc252b2b90a512379856cad" args="(bool homogeneous_bc)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::solv::CartesianRobinBcHelper::setHomogeneousBc           </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>homogeneous_bc</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set whether boundary filling should assume homogeneous conditions. 
<p>
In certain circumstances, only the value of a is needed, while the value of g is temporarily not required and taken to be zero. (An example is in setting the boundary condition for error value in an iterative method.) In such cases, use this function to set a flag that will cause a null pointer to be given to setBcCoefs() to indicate that fact. 
</div>
</div><p>
<a class="anchor" name="6b01eb9d1284523dec2147a12da6bfb9"></a><!-- doxytag: member="SAMRAI::solv::CartesianRobinBcHelper::getObjectName" ref="6b01eb9d1284523dec2147a12da6bfb9" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::string&amp; SAMRAI::solv::CartesianRobinBcHelper::getObjectName           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the name of this object. 
<p>
<dl compact><dt><b>Returns:</b></dt><dd>The name of this object. </dd></dl>

</div>
</div><p>
<hr>The documentation for this class was generated from the following file:<ul>
<li>source/SAMRAI/solv/<a class="el" href="CartesianRobinBcHelper_8h.html">CartesianRobinBcHelper.h</a></ul>
<hr size="1"><address style="align: right;"><small>Generated on Thu Jun 21 13:42:58 2012 for SAMRAI by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.7 </small></address>
</body>
</html>
