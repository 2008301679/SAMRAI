<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>SAMRAI: SAMRAI::mesh::TagAndInitializeStrategy Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath"><a class="el" href="namespaceSAMRAI.html">SAMRAI</a>::<a class="el" href="namespaceSAMRAI_1_1mesh.html">mesh</a>::<a class="el" href="classSAMRAI_1_1mesh_1_1TagAndInitializeStrategy.html">TagAndInitializeStrategy</a>
  </div>
</div>
<div class="contents">
<h1>SAMRAI::mesh::TagAndInitializeStrategy Class Reference</h1><!-- doxytag: class="SAMRAI::mesh::TagAndInitializeStrategy" -->
<p><code>#include &lt;source/SAMRAI/mesh/TagAndInitializeStrategy.h&gt;</code></p>
<div class="dynheader">
Inheritance diagram for SAMRAI::mesh::TagAndInitializeStrategy:</div>
<div class="dynsection">
 <div class="center">
  <img src="classSAMRAI_1_1mesh_1_1TagAndInitializeStrategy.gif" usemap="#SAMRAI::mesh::TagAndInitializeStrategy_map" alt=""/>
  <map id="SAMRAI::mesh::TagAndInitializeStrategy_map" name="SAMRAI::mesh::TagAndInitializeStrategy_map">
<area href="classSAMRAI_1_1mesh_1_1StandardTagAndInitialize.html" alt="SAMRAI::mesh::StandardTagAndInitialize" shape="rect" coords="0,56,241,80"/>
</map>
 </div>
</div>

<p><a href="classSAMRAI_1_1mesh_1_1TagAndInitializeStrategy-members.html">List of all members.</a></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1mesh_1_1TagAndInitializeStrategy.html#a448364155474657dda09e5f5fabda75f">TagAndInitializeStrategy</a> (const std::string &amp;object_name)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1mesh_1_1TagAndInitializeStrategy.html#a0881bc7aed70fbc3a4b243b0604eeaf6">~TagAndInitializeStrategy</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1mesh_1_1TagAndInitializeStrategy.html#a95ad532f2a490d9818aa224abd206417">getUserSuppliedRefineBoxes</a> (<a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">hier::BoxContainer</a> &amp;refine_boxes, const int level_number, const int cycle, const double time)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1mesh_1_1TagAndInitializeStrategy.html#adcd8c213a5eea947f067e87fec50dcb6">resetRefineBoxes</a> (const <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">hier::BoxContainer</a> &amp;refine_boxes, const int level_number)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1mesh_1_1TagAndInitializeStrategy.html#a129f0fc0d092df0f3da5886d4f44f6e1">initializeLevelData</a> (const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchHierarchy.html">hier::PatchHierarchy</a> &gt; &amp;hierarchy, const int level_number, const double init_data_time, const bool can_be_refined, const bool initial_time, const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchLevel.html">hier::PatchLevel</a> &gt; &amp;old_level=boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchLevel.html">hier::PatchLevel</a> &gt;(), const bool allocate_data=true)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1mesh_1_1TagAndInitializeStrategy.html#a58a9c2633af59ef28ab6fecf0761dd46">resetHierarchyConfiguration</a> (const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchHierarchy.html">hier::PatchHierarchy</a> &gt; &amp;hierarchy, const int coarsest_level, const int finest_level)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1mesh_1_1TagAndInitializeStrategy.html#aff973d31fc926e369ca0b76c06ebff98">tagCellsForRefinement</a> (const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchHierarchy.html">hier::PatchHierarchy</a> &gt; &amp;hierarchy, const int level_number, const int regrid_cycle, const double regrid_time, const int tag_index, const bool initial_time, const bool coarsest_sync_level, const bool can_be_refined=true, const double regrid_start_time=0.)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1mesh_1_1TagAndInitializeStrategy.html#a45ad4c95abe2e7eb06a6b156504aaea5">preprocessErrorEstimation</a> (const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchHierarchy.html">hier::PatchHierarchy</a> &gt; &amp;hierarchy, const int level_number, const int cycle, const double regrid_time, const double regrid_start_time, const bool initial_time)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1mesh_1_1TagAndInitializeStrategy.html#a446fc5d9ea037b3897068469a768fe6f">usesTimeIntegration</a> (int cycle, double time)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1mesh_1_1TagAndInitializeStrategy.html#a2c4202c39c0f978d4b910063298da219">everUsesTimeIntegration</a> () const =0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1mesh_1_1TagAndInitializeStrategy.html#a967073f61726ab146b080cf95ec8c781">coarsestLevelBoxesOK</a> (const <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">hier::BoxContainer</a> &amp;boxes) const =0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1mesh_1_1TagAndInitializeStrategy.html#abc0948d08ac24bb58fab8aae9428fa08">getErrorCoarsenRatio</a> () const =0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1mesh_1_1TagAndInitializeStrategy.html#a200d85a2f21b0e7707b6b5a7c735d267">checkCoarsenRatios</a> (const std::vector&lt; <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a> &gt; &amp;ratio_to_coarser)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1mesh_1_1TagAndInitializeStrategy.html#a69bfb31615a8383d51c36993f0cf33b1">refineUserBoxInputOnly</a> (int cycle, double time)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const std::string &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1mesh_1_1TagAndInitializeStrategy.html#a5caddcecc07da768fae619b02b55c5f9">getObjectName</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1mesh_1_1TagAndInitializeStrategy.html#a39746df2fc2b547a4f461a2227ae2bc0">processHierarchyBeforeAddingNewLevel</a> (const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchHierarchy.html">hier::PatchHierarchy</a> &gt; &amp;hierarchy, const int level_number, const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">hier::BoxLevel</a> &gt; &amp;new_box_level)=0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Process a hierarchy before swapping old and new levels during regrid.  <a href="#a39746df2fc2b547a4f461a2227ae2bc0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1mesh_1_1TagAndInitializeStrategy.html#a56ebcc4ed40bb2f6b6a89b3e7ce7af2e">processLevelBeforeRemoval</a> (const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchHierarchy.html">hier::PatchHierarchy</a> &gt; &amp;hierarchy, const int level_number, const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchLevel.html">hier::PatchLevel</a> &gt; &amp;old_level=boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchLevel.html">hier::PatchLevel</a> &gt;())=0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Process a level before it is removed from the hierarchy during regrid.  <a href="#a56ebcc4ed40bb2f6b6a89b3e7ce7af2e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1mesh_1_1TagAndInitializeStrategy.html#aff33558a785e385e9127844b138dce03">checkUserTagData</a> (const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchHierarchy.html">hier::PatchHierarchy</a> &gt; &amp;hierarchy, const int level_number, const int regrid_cycle, const double regrid_time, const int tag_index)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Check the tags on a tagged level.  <a href="#aff33558a785e385e9127844b138dce03"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1mesh_1_1TagAndInitializeStrategy.html#aa8346054e46d5ca9af2354e69fe06a81">checkNewLevelTagData</a> (const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchHierarchy.html">hier::PatchHierarchy</a> &gt; &amp;hierarchy, const int level_number, const int tag_index)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Check the tags on a newly-created level.  <a href="#aa8346054e46d5ca9af2354e69fe06a81"></a><br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>Class <a class="el" href="classSAMRAI_1_1mesh_1_1TagAndInitializeStrategy.html">TagAndInitializeStrategy</a> is a base class that defines a Strategy pattern interface for level initialization and cell tagging routines that are needed by the adaptive meshing algorithms provided by the class <a class="el" href="classSAMRAI_1_1mesh_1_1GriddingAlgorithm.html" title="Class GriddingAlgorithm manages AMR patch hierarchy construction operations in SAMRAI...">GriddingAlgorithm</a>. The class defines an interface to construct refined regions based on a user-supplied set of boxes, but its main role is to provide interfaces for level initialization and cell tagging operations.</p>
<p>All methods defined by this class with the exception of getObjectName are abstract and must be supplied by a concrete sub-class of this base class.</p>
<p>If user supplied refine boxes are used, they may be supplied through input as defined by specific, concrete sub-classes of this base class. Alternatively, they may be supplied through the "resetRefineBoxes()" method.</p>
<p>The virtual methods in this class may place constraints on the patch hierarchy by the particular error estimation procedure in use. Those constraints and operations must be honored in the concrete subclass implementations of these methods. The constraints are discussed in the method descriptions below.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classSAMRAI_1_1mesh_1_1GriddingAlgorithm.html" title="Class GriddingAlgorithm manages AMR patch hierarchy construction operations in SAMRAI...">GriddingAlgorithm</a> </dd></dl>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a448364155474657dda09e5f5fabda75f"></a><!-- doxytag: member="SAMRAI::mesh::TagAndInitializeStrategy::TagAndInitializeStrategy" ref="a448364155474657dda09e5f5fabda75f" args="(const std::string &amp;object_name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SAMRAI::mesh::TagAndInitializeStrategy::TagAndInitializeStrategy </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>object_name</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Empty constructor for <a class="el" href="classSAMRAI_1_1mesh_1_1TagAndInitializeStrategy.html">TagAndInitializeStrategy</a>. </p>

</div>
</div>
<a class="anchor" id="a0881bc7aed70fbc3a4b243b0604eeaf6"></a><!-- doxytag: member="SAMRAI::mesh::TagAndInitializeStrategy::~TagAndInitializeStrategy" ref="a0881bc7aed70fbc3a4b243b0604eeaf6" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SAMRAI::mesh::TagAndInitializeStrategy::~TagAndInitializeStrategy </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Empty destructor for <a class="el" href="classSAMRAI_1_1mesh_1_1TagAndInitializeStrategy.html">TagAndInitializeStrategy</a>. </p>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a95ad532f2a490d9818aa224abd206417"></a><!-- doxytag: member="SAMRAI::mesh::TagAndInitializeStrategy::getUserSuppliedRefineBoxes" ref="a95ad532f2a490d9818aa224abd206417" args="(hier::BoxContainer &amp;refine_boxes, const int level_number, const int cycle, const double time)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool SAMRAI::mesh::TagAndInitializeStrategy::getUserSuppliedRefineBoxes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">hier::BoxContainer</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>refine_boxes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>level_number</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>cycle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>time</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return user supplied set of refine boxes for specified level number and time. The boolean return value specifies whether the boxes have been reset from the last time this method was called. If they have been reset, it returns true. If they are unchanged, it returns false. </p>

<p>Implemented in <a class="el" href="classSAMRAI_1_1mesh_1_1StandardTagAndInitialize.html#ab8e5446ce4ce447c5bbe4cc31756498f">SAMRAI::mesh::StandardTagAndInitialize</a>.</p>

</div>
</div>
<a class="anchor" id="adcd8c213a5eea947f067e87fec50dcb6"></a><!-- doxytag: member="SAMRAI::mesh::TagAndInitializeStrategy::resetRefineBoxes" ref="adcd8c213a5eea947f067e87fec50dcb6" args="(const hier::BoxContainer &amp;refine_boxes, const int level_number)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void SAMRAI::mesh::TagAndInitializeStrategy::resetRefineBoxes </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">hier::BoxContainer</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>refine_boxes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>level_number</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Reset the static refine boxes for the specified level number in the hierarchy. The level number must be greater than or equal to zero. </p>

<p>Implemented in <a class="el" href="classSAMRAI_1_1mesh_1_1StandardTagAndInitialize.html#ab68fd34ae965ff9b744734a72327c16d">SAMRAI::mesh::StandardTagAndInitialize</a>.</p>

</div>
</div>
<a class="anchor" id="a129f0fc0d092df0f3da5886d4f44f6e1"></a><!-- doxytag: member="SAMRAI::mesh::TagAndInitializeStrategy::initializeLevelData" ref="a129f0fc0d092df0f3da5886d4f44f6e1" args="(const boost::shared_ptr&lt; hier::PatchHierarchy &gt; &amp;hierarchy, const int level_number, const double init_data_time, const bool can_be_refined, const bool initial_time, const boost::shared_ptr&lt; hier::PatchLevel &gt; &amp;old_level=boost::shared_ptr&lt; hier::PatchLevel &gt;(), const bool allocate_data=true)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void SAMRAI::mesh::TagAndInitializeStrategy::initializeLevelData </td>
          <td>(</td>
          <td class="paramtype">const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchHierarchy.html">hier::PatchHierarchy</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>hierarchy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>level_number</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>init_data_time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&nbsp;</td>
          <td class="paramname"> <em>can_be_refined</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&nbsp;</td>
          <td class="paramname"> <em>initial_time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchLevel.html">hier::PatchLevel</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>old_level</em> = <code>boost::shared_ptr&lt;&nbsp;<a class="el" href="classSAMRAI_1_1hier_1_1PatchLevel.html">hier::PatchLevel</a>&nbsp;&gt;()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&nbsp;</td>
          <td class="paramname"> <em>allocate_data</em> = <code>true</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Initialize data on a new level after it is inserted into an AMR patch hierarchy by the gridding algorithm. The level number indicates that of the new level. The old_level pointer corresponds to the level that resided in the hierarchy before the level with the specified number was introduced. If this pointer is null, there was no level in the hierarchy prior to the call and the data on the new level is set by interpolating data from coarser levels in the hierarchy. Otherwise, the the new level is initialized by interpolating data from coarser levels and copying data from the old level before it is destroyed.</p>
<p>The boolean argument initial_time indicates whether the integration time corresponds to the initial simulation time. If true, the level should be initialized with initial simulation values. Otherwise, it should be assumed that the simulation time is at some point after the start of the simulation. This information is provided since the initialization of the data may be different in each of those circumstances. In any case, the double "time" value is the current simulation time for the level. The can_be_refined boolean argument indicates whether the level is the finest allowable level in the hierarchy. This flag is included since data management on the finest level may be different than other levels in the hierarchy in some cases.</p>
<p>The last two (optional) arguments specify an old level from which the data may be used to initialize data on this level, and a flag that indicates whether data on the initialized level must first be allocated. The allocate_data argument is used in cases where one wishes to simply reset data to an initialized state on a level that has already been allocated. </p>

<p>Implemented in <a class="el" href="classSAMRAI_1_1mesh_1_1StandardTagAndInitialize.html#a58203fcd701433280821f37e7202c4eb">SAMRAI::mesh::StandardTagAndInitialize</a>.</p>

</div>
</div>
<a class="anchor" id="a58a9c2633af59ef28ab6fecf0761dd46"></a><!-- doxytag: member="SAMRAI::mesh::TagAndInitializeStrategy::resetHierarchyConfiguration" ref="a58a9c2633af59ef28ab6fecf0761dd46" args="(const boost::shared_ptr&lt; hier::PatchHierarchy &gt; &amp;hierarchy, const int coarsest_level, const int finest_level)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void SAMRAI::mesh::TagAndInitializeStrategy::resetHierarchyConfiguration </td>
          <td>(</td>
          <td class="paramtype">const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchHierarchy.html">hier::PatchHierarchy</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>hierarchy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>coarsest_level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>finest_level</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>After hierarchy levels have changed and data has been initialized on the new levels, this routine can be used to reset any information needed by the solution method that is particular to the hierarchy configuration. For example, the solution procedure may cache communication schedules to amortize the cost of data movement on the AMR patch hierarchy. This function will be called by the gridding algorithm after the initialization occurs so that the algorithm-specific subclass can reset such things. Also, if the solution method must make the solution consistent across multiple levels after the hierarchy is changed, this process may be invoked by this routine. Of course the details of these processes are determined by the particular solution methods in use.</p>
<p>The level number arguments indicate the coarsest and finest levels in the current hierarchy configuration that have changed. It should be assumed that all intermediate levels have changed as well. </p>

<p>Implemented in <a class="el" href="classSAMRAI_1_1mesh_1_1StandardTagAndInitialize.html#aa6d152fe6848d4726af682f3e250d12d">SAMRAI::mesh::StandardTagAndInitialize</a>.</p>

</div>
</div>
<a class="anchor" id="aff973d31fc926e369ca0b76c06ebff98"></a><!-- doxytag: member="SAMRAI::mesh::TagAndInitializeStrategy::tagCellsForRefinement" ref="aff973d31fc926e369ca0b76c06ebff98" args="(const boost::shared_ptr&lt; hier::PatchHierarchy &gt; &amp;hierarchy, const int level_number, const int regrid_cycle, const double regrid_time, const int tag_index, const bool initial_time, const bool coarsest_sync_level, const bool can_be_refined=true, const double regrid_start_time=0.)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void SAMRAI::mesh::TagAndInitializeStrategy::tagCellsForRefinement </td>
          <td>(</td>
          <td class="paramtype">const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchHierarchy.html">hier::PatchHierarchy</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>hierarchy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>level_number</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>regrid_cycle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>regrid_time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>tag_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&nbsp;</td>
          <td class="paramname"> <em>initial_time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&nbsp;</td>
          <td class="paramname"> <em>coarsest_sync_level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&nbsp;</td>
          <td class="paramname"> <em>can_be_refined</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>regrid_start_time</em> = <code>0.</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Set integer tags to "one" on the given level to identify where refinement of that level should occur. The index is that of the cell-centered integer tag array on each patch. The boolean argument initial_time indicates whether cells are being tagged at initialization time, or at some later time during the calculation. If it is false, it should be assumed that the error estimation process is being invoked at some later time after the AMR hierarchy was initially constructed. This information is provided since application of the error estimator may be different in each of those circumstances.</p>
<p>The cell-tagging operation may use time advancement to determine tag regions. The argument coarsest_sync_level provides information for the tagging method to coordinate time advance with an integrator. When time integration is used during regridding, this value is true if the level is the coarsest level involved in level synchronization immediately preceeding the regrid process; otherwise it is false. If time advancement is not used, this argument are ignored.</p>
<p>The boolean can_be_refined is used to coordinate data reset operations with the time integrator when time-dependent regridding is used. This is provided since data may be managed differently on the finest hierarchy level than on coarser levels. </p>

<p>Implemented in <a class="el" href="classSAMRAI_1_1mesh_1_1StandardTagAndInitialize.html#af30e191b1a04a9e221ab409d896160dd">SAMRAI::mesh::StandardTagAndInitialize</a>.</p>

</div>
</div>
<a class="anchor" id="a45ad4c95abe2e7eb06a6b156504aaea5"></a><!-- doxytag: member="SAMRAI::mesh::TagAndInitializeStrategy::preprocessErrorEstimation" ref="a45ad4c95abe2e7eb06a6b156504aaea5" args="(const boost::shared_ptr&lt; hier::PatchHierarchy &gt; &amp;hierarchy, const int level_number, const int cycle, const double regrid_time, const double regrid_start_time, const bool initial_time)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void SAMRAI::mesh::TagAndInitializeStrategy::preprocessErrorEstimation </td>
          <td>(</td>
          <td class="paramtype">const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchHierarchy.html">hier::PatchHierarchy</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>hierarchy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>level_number</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>cycle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>regrid_time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>regrid_start_time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&nbsp;</td>
          <td class="paramname"> <em>initial_time</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Certain cases may require pre-processing of error estimation data before tagging cells, which is handled by this method. For example, Richardson extrapolation may require advances of data in time before the error estimation procedure is implemented.</p>
<p>The level number indicates the level in which pre-process steps are applied, time is the time at which the operation is performed (generally the regrid time), and the boolean argument indicates whether the operation is performed at the initial time. </p>

<p>Implemented in <a class="el" href="classSAMRAI_1_1mesh_1_1StandardTagAndInitialize.html#a36c7119a796fcfc768995ce469f88339">SAMRAI::mesh::StandardTagAndInitialize</a>.</p>

</div>
</div>
<a class="anchor" id="a446fc5d9ea037b3897068469a768fe6f"></a><!-- doxytag: member="SAMRAI::mesh::TagAndInitializeStrategy::usesTimeIntegration" ref="a446fc5d9ea037b3897068469a768fe6f" args="(int cycle, double time)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool SAMRAI::mesh::TagAndInitializeStrategy::usesTimeIntegration </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>cycle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>time</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return true if regridding process advances the data using some time integration procedure at the supplied cycle or time; otherwise, return false. </p>

<p>Implemented in <a class="el" href="classSAMRAI_1_1mesh_1_1StandardTagAndInitialize.html#a2deb77bd55c0b4945b727dfbbbbbf0b8">SAMRAI::mesh::StandardTagAndInitialize</a>.</p>

</div>
</div>
<a class="anchor" id="a2c4202c39c0f978d4b910063298da219"></a><!-- doxytag: member="SAMRAI::mesh::TagAndInitializeStrategy::everUsesTimeIntegration" ref="a2c4202c39c0f978d4b910063298da219" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool SAMRAI::mesh::TagAndInitializeStrategy::everUsesTimeIntegration </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return true if regridding process advances the data using some time integration procedure at any cycle or time; otherwise, return false. </p>

<p>Implemented in <a class="el" href="classSAMRAI_1_1mesh_1_1StandardTagAndInitialize.html#a5e036116adceeffc3351ce0de0798ae3">SAMRAI::mesh::StandardTagAndInitialize</a>.</p>

</div>
</div>
<a class="anchor" id="a967073f61726ab146b080cf95ec8c781"></a><!-- doxytag: member="SAMRAI::mesh::TagAndInitializeStrategy::coarsestLevelBoxesOK" ref="a967073f61726ab146b080cf95ec8c781" args="(const hier::BoxContainer &amp;boxes) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool SAMRAI::mesh::TagAndInitializeStrategy::coarsestLevelBoxesOK </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">hier::BoxContainer</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>boxes</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return true if boxes for coarsest hierarchy level are not appropriate for gridding strategy. Otherwise, return false. If false is returned, it is useful to provide a detailed explanatory message describing the problems with the boxes. </p>

<p>Implemented in <a class="el" href="classSAMRAI_1_1mesh_1_1StandardTagAndInitialize.html#af53f4c1917212a5843340f9bea138c21">SAMRAI::mesh::StandardTagAndInitialize</a>.</p>

</div>
</div>
<a class="anchor" id="abc0948d08ac24bb58fab8aae9428fa08"></a><!-- doxytag: member="SAMRAI::mesh::TagAndInitializeStrategy::getErrorCoarsenRatio" ref="abc0948d08ac24bb58fab8aae9428fa08" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int SAMRAI::mesh::TagAndInitializeStrategy::getErrorCoarsenRatio </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return ratio by which level may be coarsened during the error estimation process. Generally, this is needed by the gridding algorithm class so that the new patch levels that it constructs can be coarsened properly (if needed) during the error estimation process. </p>

<p>Implemented in <a class="el" href="classSAMRAI_1_1mesh_1_1StandardTagAndInitialize.html#ac900e49b9cb97cd38c9fbd6afe751f60">SAMRAI::mesh::StandardTagAndInitialize</a>.</p>

</div>
</div>
<a class="anchor" id="a200d85a2f21b0e7707b6b5a7c735d267"></a><!-- doxytag: member="SAMRAI::mesh::TagAndInitializeStrategy::checkCoarsenRatios" ref="a200d85a2f21b0e7707b6b5a7c735d267" args="(const std::vector&lt; hier::IntVector &gt; &amp;ratio_to_coarser)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void SAMRAI::mesh::TagAndInitializeStrategy::checkCoarsenRatios </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>ratio_to_coarser</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Check ratios between hierarchy levels against any constraints that may be required for the error estimation scheme. </p>

<p>Implemented in <a class="el" href="classSAMRAI_1_1mesh_1_1StandardTagAndInitialize.html#af319c46f151789db160679aaa64b9f63">SAMRAI::mesh::StandardTagAndInitialize</a>.</p>

</div>
</div>
<a class="anchor" id="a69bfb31615a8383d51c36993f0cf33b1"></a><!-- doxytag: member="SAMRAI::mesh::TagAndInitializeStrategy::refineUserBoxInputOnly" ref="a69bfb31615a8383d51c36993f0cf33b1" args="(int cycle, double time)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool SAMRAI::mesh::TagAndInitializeStrategy::refineUserBoxInputOnly </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>cycle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>time</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return whether refinement is being performed using ONLY user-supplied refine boxes. If any method is used that invokes tagging, this will return false. </p>

<p>Implemented in <a class="el" href="classSAMRAI_1_1mesh_1_1StandardTagAndInitialize.html#a179f9053507ab09c44cb85c026c8c338">SAMRAI::mesh::StandardTagAndInitialize</a>.</p>

</div>
</div>
<a class="anchor" id="a5caddcecc07da768fae619b02b55c5f9"></a><!-- doxytag: member="SAMRAI::mesh::TagAndInitializeStrategy::getObjectName" ref="a5caddcecc07da768fae619b02b55c5f9" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::string&amp; SAMRAI::mesh::TagAndInitializeStrategy::getObjectName </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns the object name. </p>

</div>
</div>
<a class="anchor" id="a39746df2fc2b547a4f461a2227ae2bc0"></a><!-- doxytag: member="SAMRAI::mesh::TagAndInitializeStrategy::processHierarchyBeforeAddingNewLevel" ref="a39746df2fc2b547a4f461a2227ae2bc0" args="(const boost::shared_ptr&lt; hier::PatchHierarchy &gt; &amp;hierarchy, const int level_number, const boost::shared_ptr&lt; hier::BoxLevel &gt; &amp;new_box_level)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void SAMRAI::mesh::TagAndInitializeStrategy::processHierarchyBeforeAddingNewLevel </td>
          <td>(</td>
          <td class="paramtype">const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchHierarchy.html">hier::PatchHierarchy</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>hierarchy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>level_number</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">hier::BoxLevel</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>new_box_level</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Process a hierarchy before swapping old and new levels during regrid. </p>
<p>During regrid, if user code needs to do any application-specific operations on the PatchHierarchy before a new level is added or an old level is swapped for a new level, this method provides a callback for the user to define such operations. The PatchHierarchy is provided in its state with the old level, if it exists, still in place, while new BoxLevel is also provided so that the user code can know the boxes that will make up the new level.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hierarchy</em>&nbsp;</td><td>The PatchHierarchy being modified. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>level_number</em>&nbsp;</td><td>The number of the PatchLevel in hierarchy being added or regridded. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>new_box_level</em>&nbsp;</td><td>BoxLevel containing the boxes for the new level </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classSAMRAI_1_1mesh_1_1StandardTagAndInitialize.html#a234fd28ed6cc943173ccd18ad3de7c6e">SAMRAI::mesh::StandardTagAndInitialize</a>.</p>

</div>
</div>
<a class="anchor" id="a56ebcc4ed40bb2f6b6a89b3e7ce7af2e"></a><!-- doxytag: member="SAMRAI::mesh::TagAndInitializeStrategy::processLevelBeforeRemoval" ref="a56ebcc4ed40bb2f6b6a89b3e7ce7af2e" args="(const boost::shared_ptr&lt; hier::PatchHierarchy &gt; &amp;hierarchy, const int level_number, const boost::shared_ptr&lt; hier::PatchLevel &gt; &amp;old_level=boost::shared_ptr&lt; hier::PatchLevel &gt;())=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void SAMRAI::mesh::TagAndInitializeStrategy::processLevelBeforeRemoval </td>
          <td>(</td>
          <td class="paramtype">const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchHierarchy.html">hier::PatchHierarchy</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>hierarchy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>level_number</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchLevel.html">hier::PatchLevel</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>old_level</em> = <code>boost::shared_ptr&lt;&nbsp;<a class="el" href="classSAMRAI_1_1hier_1_1PatchLevel.html">hier::PatchLevel</a>&nbsp;&gt;()</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Process a level before it is removed from the hierarchy during regrid. </p>
<p>In some cases user code may wish to process a PatchLevel before it is removed from the hierarchy. For example, data may exist only on a given PatchLevel such as the finest level. If that level were to be removed before this data is moved off of it then the data will be lost. This method is a user defined callback used by <a class="el" href="classSAMRAI_1_1mesh_1_1GriddingAlgorithm.html" title="Class GriddingAlgorithm manages AMR patch hierarchy construction operations in SAMRAI...">GriddingAlgorithm</a> when a PatchLevel is to be removed. The callback performs any user actions on the level about to be removed. It is implemented by classes derived from <a class="el" href="classSAMRAI_1_1mesh_1_1StandardTagAndInitStrategy.html">StandardTagAndInitStrategy</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hierarchy</em>&nbsp;</td><td>The PatchHierarchy being modified. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>level_number</em>&nbsp;</td><td>The number of the PatchLevel in hierarchy about to be removed. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>old_level</em>&nbsp;</td><td>The level in hierarchy about to be removed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classSAMRAI_1_1mesh_1_1GriddingAlgorithm.html" title="Class GriddingAlgorithm manages AMR patch hierarchy construction operations in SAMRAI...">GriddingAlgorithm</a> </dd>
<dd>
<a class="el" href="classSAMRAI_1_1mesh_1_1StandardTagAndInitStrategy.html">StandardTagAndInitStrategy</a> </dd></dl>

<p>Implemented in <a class="el" href="classSAMRAI_1_1mesh_1_1StandardTagAndInitialize.html#ac4b7d24d3a0b74b8470efead57f0b425">SAMRAI::mesh::StandardTagAndInitialize</a>.</p>

</div>
</div>
<a class="anchor" id="aff33558a785e385e9127844b138dce03"></a><!-- doxytag: member="SAMRAI::mesh::TagAndInitializeStrategy::checkUserTagData" ref="aff33558a785e385e9127844b138dce03" args="(const boost::shared_ptr&lt; hier::PatchHierarchy &gt; &amp;hierarchy, const int level_number, const int regrid_cycle, const double regrid_time, const int tag_index)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void SAMRAI::mesh::TagAndInitializeStrategy::checkUserTagData </td>
          <td>(</td>
          <td class="paramtype">const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchHierarchy.html">hier::PatchHierarchy</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>hierarchy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>level_number</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>regrid_cycle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>regrid_time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>tag_index</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Check the tags on a tagged level. </p>
<p>This virtual interface provides application code a callback that allows for checking the values held in user tag PatchData. The tag data will contain the tags created by application code in tagCellsForRefinement as well as any tags added internally by the <a class="el" href="classSAMRAI_1_1mesh_1_1GriddingAlgorithm.html" title="Class GriddingAlgorithm manages AMR patch hierarchy construction operations in SAMRAI...">GriddingAlgorithm</a> (for example, buffering).</p>
<p>A no-op implementation is provided so that only applications that want to use this method need to implement it.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>hierarchy</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>level_number</em>&nbsp;</td><td>Level number of the tagged level </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>regrid_cycle</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>regrid_time</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>tag_index</em>&nbsp;</td><td>Patch data index for user tags </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classSAMRAI_1_1mesh_1_1StandardTagAndInitialize.html#ae7a9eaa1764fcd1910916cb64f16152a">SAMRAI::mesh::StandardTagAndInitialize</a>.</p>

<p>References <a class="el" href="Utilities_8h_source.html#l00050">NULL_USE</a>.</p>

</div>
</div>
<a class="anchor" id="aa8346054e46d5ca9af2354e69fe06a81"></a><!-- doxytag: member="SAMRAI::mesh::TagAndInitializeStrategy::checkNewLevelTagData" ref="aa8346054e46d5ca9af2354e69fe06a81" args="(const boost::shared_ptr&lt; hier::PatchHierarchy &gt; &amp;hierarchy, const int level_number, const int tag_index)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void SAMRAI::mesh::TagAndInitializeStrategy::checkNewLevelTagData </td>
          <td>(</td>
          <td class="paramtype">const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchHierarchy.html">hier::PatchHierarchy</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>hierarchy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>level_number</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>tag_index</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Check the tags on a newly-created level. </p>
<p>This virtual interface provides application code a callback that allow for checking tag values that have been saved on a new level that has been created during initialization or regridding. The tag values will be the values of the user tags on the coarser level, constant-refined onto the cells of the new level.</p>
<p>A no-op implementation is provided so that only applications that want to use this method need to implement it.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>hierarchy</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>level_number</em>&nbsp;</td><td>Level number of the new level </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>tag_index</em>&nbsp;</td><td>Patch data index for the new tags. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classSAMRAI_1_1mesh_1_1StandardTagAndInitialize.html#a0cc6a1ff0983b71b164525aa7c476149">SAMRAI::mesh::StandardTagAndInitialize</a>.</p>

<p>References <a class="el" href="Utilities_8h_source.html#l00050">NULL_USE</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>source/SAMRAI/mesh/<a class="el" href="TagAndInitializeStrategy_8h.html">TagAndInitializeStrategy.h</a></li>
<li>source/SAMRAI/mesh/<a class="el" href="TagAndInitializeStrategy_8C.html">TagAndInitializeStrategy.C</a></li>
</ul>
</div>
<hr size="1"/><address style="text-align: right;"><small>Generated on 21 Jan 2016 for SAMRAI by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.1 </small></address>
</body>
</html>
