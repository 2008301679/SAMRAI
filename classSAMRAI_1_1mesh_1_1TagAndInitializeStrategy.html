<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>SAMRAI: SAMRAI::mesh::TagAndInitializeStrategy Class Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.7 -->
<div class="tabs">
  <ul>
    <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="namespaces.html"><span>Namespaces</span></a></li>
    <li id="current"><a href="annotated.html"><span>Classes</span></a></li>
    <li><a href="files.html"><span>Files</span></a></li>
    <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
  </ul></div>
<div class="tabs">
  <ul>
    <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
    <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
    <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
  </ul></div>
<div class="nav">
<a class="el" href="namespaceSAMRAI.html">SAMRAI</a>::<a class="el" href="namespaceSAMRAI_1_1mesh.html">mesh</a>::<a class="el" href="classSAMRAI_1_1mesh_1_1TagAndInitializeStrategy.html">TagAndInitializeStrategy</a></div>
<h1>SAMRAI::mesh::TagAndInitializeStrategy Class Reference</h1><!-- doxytag: class="SAMRAI::mesh::TagAndInitializeStrategy" --><code>#include &lt;source/SAMRAI/mesh/TagAndInitializeStrategy.h&gt;</code>
<p>
<p>Inheritance diagram for SAMRAI::mesh::TagAndInitializeStrategy:
<p><center><img src="classSAMRAI_1_1mesh_1_1TagAndInitializeStrategy.png" usemap="#SAMRAI::mesh::TagAndInitializeStrategy_map" border="0" alt=""></center>
<map name="SAMRAI::mesh::TagAndInitializeStrategy_map">
<area href="classSAMRAI_1_1mesh_1_1StandardTagAndInitialize.html" alt="SAMRAI::mesh::StandardTagAndInitialize" shape="rect" coords="0,56,241,80">
</map>
<a href="classSAMRAI_1_1mesh_1_1TagAndInitializeStrategy-members.html">List of all members.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1mesh_1_1TagAndInitializeStrategy.html#851556e2955487606f3b251bf0cc1da3">TagAndInitializeStrategy</a> (const <a class="el" href="classSAMRAI_1_1tbox_1_1Dimension.html">tbox::Dimension</a> &amp;dim, const std::string &amp;object_name)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1mesh_1_1TagAndInitializeStrategy.html#d0c2ae664ab72b3189466ba80dcbf78b">~TagAndInitializeStrategy</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1mesh_1_1TagAndInitializeStrategy.html#4f27653ac9f93e5c786619477d83c47d">getUserSuppliedRefineBoxes</a> (<a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">hier::BoxContainer</a> &amp;refine_boxes, const int level_number, const double time)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1mesh_1_1TagAndInitializeStrategy.html#51289984d464b415e6c2eb490d3dc5e9">resetRefineBoxes</a> (const <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">hier::BoxContainer</a> &amp;refine_boxes, const int level_number)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1mesh_1_1TagAndInitializeStrategy.html#5469402af829dc611491b532f10c8373">initializeLevelData</a> (const <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchHierarchy.html">hier::PatchHierarchy</a> &gt; hierarchy, const int level_number, const double init_data_time, const bool can_be_refined, const bool initial_time, const <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchLevel.html">hier::PatchLevel</a> &gt; old_level=<a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchLevel.html">hier::PatchLevel</a> &gt;(NULL), const bool allocate_data=true)=0</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1mesh_1_1TagAndInitializeStrategy.html#8726e9d47089519dc96c7f60fe85d5f6">resetHierarchyConfiguration</a> (const <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchHierarchy.html">hier::PatchHierarchy</a> &gt; hierarchy, const int coarsest_level, const int finest_level)=0</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1mesh_1_1TagAndInitializeStrategy.html#68598fdcc9722675cbc91ec8e5dbff13">tagCellsForRefinement</a> (const <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchHierarchy.html">hier::PatchHierarchy</a> &gt; hierarchy, const int level_number, const double error_data_time, const int tag_index, const bool initial_time, const bool coarsest_sync_level, const bool can_be_refined=true, const double regrid_start_time=0.)=0</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1mesh_1_1TagAndInitializeStrategy.html#55f48c415ff91eb2116747f9a575129c">preprocessErrorEstimation</a> (const <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchHierarchy.html">hier::PatchHierarchy</a> &gt; hierarchy, const int level_number, const double regrid_time, const double regrid_start_time, const bool initial_time)=0</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1mesh_1_1TagAndInitializeStrategy.html#f4538967ed8d64c0dc0cf16258433e50">usesTimeIntegration</a> () const =0</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1mesh_1_1TagAndInitializeStrategy.html#a1d900010c5faafb5efc2c6c4e7d0285">coarsestLevelBoxesOK</a> (const <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">hier::BoxContainer</a> &amp;boxes) const =0</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1mesh_1_1TagAndInitializeStrategy.html#4359c4a0a4afbfafc2d5de6a5f565ffe">getErrorCoarsenRatio</a> () const =0</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1mesh_1_1TagAndInitializeStrategy.html#8a4ff2059aae80bf0fa72f1d753f089c">checkCoarsenRatios</a> (const <a class="el" href="classSAMRAI_1_1tbox_1_1Array.html">tbox::Array</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a> &gt; &amp;ratio_to_coarser)=0</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1mesh_1_1TagAndInitializeStrategy.html#334bd9f56a82d870233167b6e8f9ee67">refineUserBoxInputOnly</a> () const =0</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1mesh_1_1TagAndInitializeStrategy.html#ab75c31f1017bc056738d5ae20364fe3">getFromInput</a> (<a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Database.html">tbox::Database</a> &gt; db)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">const <a class="el" href="classSAMRAI_1_1tbox_1_1Dimension.html">tbox::Dimension</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1mesh_1_1TagAndInitializeStrategy.html#60ac697c49e8ace4c5e6736fe25a96d3">getDim</a> () const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">const std::string &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1mesh_1_1TagAndInitializeStrategy.html#9e826b794eeed8f13c9f1f5c9a63ac0d">getObjectName</a> () const </td></tr>

</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
Class <a class="el" href="classSAMRAI_1_1mesh_1_1TagAndInitializeStrategy.html">TagAndInitializeStrategy</a> is a base class that defines a Strategy pattern interface for level initialization and cell tagging routines that are needed by the adaptive meshing algorithms provided by the class <a class="el" href="classSAMRAI_1_1mesh_1_1GriddingAlgorithm.html">GriddingAlgorithm</a>. The class maintains functionality to construct refined regions based on a user-supplied set of boxes, but its main role is to provide interfaces for level initialization and cell tagging operations.<p>
The operations that identify mesh cells for refinement or initialize data on a new hierarchy level are problem-specific and must be supplied by a concrete sub-class of this base class.<p>
If user supplied refine boxes are used, they may be supplied through input. Alternatively, they may be supplied through the "resetRefineBoxes()" method. If they are supplied through input, the format is as follows:<p>
<ul>
<li><b>RefineBoxes</b> input section describing the refine boxes for each level.<ul>
<li><b>level_0</b> input section providing the <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">hier::Box</a> arrays describing where user-specified refinement is to occur on Level 0.</li><li><b>level_1</b> input section providing the <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">hier::Box</a> arrays describing where user-specified refinement is to occur on Level 1. <b></b>. . .</li><li><b>level_n</b> input section providing the <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">hier::Box</a> arrays describing where user-specified refinement is to occur on Level N.</li></ul>
</li></ul>
<p>
For each level, the input section can have the following entries:<p>
<ul>
<li><b>times</b> = optional entry, a double array specifying times at which a particular set of boxes is to be used as a region of refinement.</li><li><b>cycles</b> = optional entry, an integer array specifying regrid cycles at which a particular set of boxes is to be used as a region of refinement.</li><li><b>boxes_0</b> = box array specifying refine boxes for element 0 of the times or cycles array.</li><li><b>boxes_1</b> = box array specifying refine boxes for element 1 of the times or cycles array.</li><li><b>boxes_n</b> = box array specifying refine boxes for element n of the times or cycles array.</li></ul>
<p>
The <b>times</b> and <b>cycles</b> entries are optional. If neither is provided, a uniform set of refine boxes specified in the boxes_0 entry will be used over the entire calculation. If no boxes_0 entry is provided, no refinement will occur on that level.<p>
If both <b>times</b> or <b>cycles</b> entries are supplied, the times entry takes precedence so the cycles entry is ignored. The particular box array chosen during regridding is determined by a ``greater-than'' convention. That is, if boxes are accessed at regridding time t, where t is greater-than the specified times[n] entry, then the array given for boxes_n is used. Otherwise, the corresponding previous box array that satisfies the criteria is used. The same convention is followed for regridding cycles. To avoid errant behavior, the times and cycles entries should always be supplied in increasing order.<p>
The <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">hier::BoxContainer</a> entries withing each level's input section must be of the form ``boxes_n'' (where n is the corresponds to the elements of the times or cycles array), or the input parser will ignore the entry. If there is no ``boxes_n'' entry corresponding to element n of the times or cycles array, then no refinement will occur on that level at the given time or cycle.<p>
A sample input file entry might look like:<p>
<div class="fragment"><pre class="fragment"> *
 *    RefineBoxes {
 *       level_0 {
 *          cycles = 0, 10
 *          boxes_0 = [(5,5),(9,9)],[(12,15),(18,19)]
 *          boxes_1 = [(7,7),(11,11)],[(14,17),(20,21)]
 *       }
 *       level_1 {
 *          times  = 0., 0.05, 0.10
 *          boxes_0 = [(25,30),(29,35)]
 *          boxes_1 = [(30,35),(34,40)]
 *          boxes_2 = [(35,40),(39,45)]
 *       }
 *       level_2 {
 *          boxes_0 = [(60,70),(70,80)]
 *       }
 *    }
 * </pre></div><p>
The virtual methods in this class may place constraints on the patch hierarchy by the particluar error estimation procedure in use. Those constraints and operations must be honored in the concrete subclass implementations of these methods. The constraints are discussed in the method descriptions below.<p>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classSAMRAI_1_1mesh_1_1GriddingAlgorithm.html">mesh::GriddingAlgorithm</a> </dd></dl>

<p>
<hr><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" name="851556e2955487606f3b251bf0cc1da3"></a><!-- doxytag: member="SAMRAI::mesh::TagAndInitializeStrategy::TagAndInitializeStrategy" ref="851556e2955487606f3b251bf0cc1da3" args="(const tbox::Dimension &amp;dim, const std::string &amp;object_name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SAMRAI::mesh::TagAndInitializeStrategy::TagAndInitializeStrategy           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1tbox_1_1Dimension.html">tbox::Dimension</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>dim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>object_name</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Empty constructor for <a class="el" href="classSAMRAI_1_1mesh_1_1TagAndInitializeStrategy.html">TagAndInitializeStrategy</a>. 
</div>
</div><p>
<a class="anchor" name="d0c2ae664ab72b3189466ba80dcbf78b"></a><!-- doxytag: member="SAMRAI::mesh::TagAndInitializeStrategy::~TagAndInitializeStrategy" ref="d0c2ae664ab72b3189466ba80dcbf78b" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SAMRAI::mesh::TagAndInitializeStrategy::~TagAndInitializeStrategy           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Empty destructor for <a class="el" href="classSAMRAI_1_1mesh_1_1TagAndInitializeStrategy.html">TagAndInitializeStrategy</a>. 
</div>
</div><p>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="4f27653ac9f93e5c786619477d83c47d"></a><!-- doxytag: member="SAMRAI::mesh::TagAndInitializeStrategy::getUserSuppliedRefineBoxes" ref="4f27653ac9f93e5c786619477d83c47d" args="(hier::BoxContainer &amp;refine_boxes, const int level_number, const double time)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SAMRAI::mesh::TagAndInitializeStrategy::getUserSuppliedRefineBoxes           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">hier::BoxContainer</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>refine_boxes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>level_number</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>time</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return user supplied set of refine boxes for specified level number and time. The boolean return value specifies whether the boxes have been reset from the last time this method was called. If they have been reset, it returns true. If they are unchanged, it returns false. 
</div>
</div><p>
<a class="anchor" name="51289984d464b415e6c2eb490d3dc5e9"></a><!-- doxytag: member="SAMRAI::mesh::TagAndInitializeStrategy::resetRefineBoxes" ref="51289984d464b415e6c2eb490d3dc5e9" args="(const hier::BoxContainer &amp;refine_boxes, const int level_number)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::mesh::TagAndInitializeStrategy::resetRefineBoxes           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">hier::BoxContainer</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>refine_boxes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>level_number</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Reset the static refine boxes for the specified level number in the hierarchy. The level number must be greater than or equal to zero. 
</div>
</div><p>
<a class="anchor" name="5469402af829dc611491b532f10c8373"></a><!-- doxytag: member="SAMRAI::mesh::TagAndInitializeStrategy::initializeLevelData" ref="5469402af829dc611491b532f10c8373" args="(const tbox::Pointer&lt; hier::PatchHierarchy &gt; hierarchy, const int level_number, const double init_data_time, const bool can_be_refined, const bool initial_time, const tbox::Pointer&lt; hier::PatchLevel &gt; old_level=tbox::Pointer&lt; hier::PatchLevel &gt;(NULL), const bool allocate_data=true)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void SAMRAI::mesh::TagAndInitializeStrategy::initializeLevelData           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchHierarchy.html">hier::PatchHierarchy</a> &gt;&nbsp;</td>
          <td class="paramname"> <em>hierarchy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>level_number</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>init_data_time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&nbsp;</td>
          <td class="paramname"> <em>can_be_refined</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&nbsp;</td>
          <td class="paramname"> <em>initial_time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchLevel.html">hier::PatchLevel</a> &gt;&nbsp;</td>
          <td class="paramname"> <em>old_level</em> = <code><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt;&nbsp;<a class="el" href="classSAMRAI_1_1hier_1_1PatchLevel.html">hier::PatchLevel</a>&nbsp;&gt;(NULL)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&nbsp;</td>
          <td class="paramname"> <em>allocate_data</em> = <code>true</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Initialize data on a new level after it is inserted into an AMR patch hierarchy by the gridding algorithm. The level number indicates that of the new level. The old_level pointer corresponds to the level that resided in the hierarchy before the level with the specified number was introduced. If this pointer is null, there was no level in the hierarchy prior to the call and the data on the new level is set by interpolating data from coarser levels in the hierarchy. Otherwise, the the new level is initialized by interpolating data from coarser levels and copying data from the old level before it is destroyed.<p>
The boolean argument initial_time indicates whether the integration time corresponds to the initial simulation time. If true, the level should be initialized with initial simulation values. Otherwise, it should be assumed that the simulation time is at some point after the start of the simulation. This information is provided since the initialization of the data may be different in each of those circumstances. In any case, the double "time" value is the current simulation time for the level. The can_be_refined boolean argument indicates whether the level is the finest allowable level in the hierarchy. This flag is included since data management on the finest level may be different than other levels in the hierarchy in some cases.<p>
The last two (optional) arguments specify an old level from which the data may be used to initialize data on this level, and a flag that indicates whether data on the initialized level must first be allocated. The allocate_data argument is used in cases where one wishes to simply reset data to an initialized state on a level that has already been allocated. 
<p>
Implemented in <a class="el" href="classSAMRAI_1_1mesh_1_1StandardTagAndInitialize.html#96f01ee0ea7bd58805101efaab8d739f">SAMRAI::mesh::StandardTagAndInitialize</a>.
</div>
</div><p>
<a class="anchor" name="8726e9d47089519dc96c7f60fe85d5f6"></a><!-- doxytag: member="SAMRAI::mesh::TagAndInitializeStrategy::resetHierarchyConfiguration" ref="8726e9d47089519dc96c7f60fe85d5f6" args="(const tbox::Pointer&lt; hier::PatchHierarchy &gt; hierarchy, const int coarsest_level, const int finest_level)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void SAMRAI::mesh::TagAndInitializeStrategy::resetHierarchyConfiguration           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchHierarchy.html">hier::PatchHierarchy</a> &gt;&nbsp;</td>
          <td class="paramname"> <em>hierarchy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>coarsest_level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>finest_level</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
After hierarchy levels have changed and data has been initialized on the new levels, this routine can be used to reset any information needed by the solution method that is particular to the hierarchy configuration. For example, the solution procedure may cache communication schedules to amortize the cost of data movement on the AMR patch hierarchy. This function will be called by the gridding algorithm after the initialization occurs so that the algorithm-specific subclass can reset such things. Also, if the solution method must make the solution consistent across multiple levels after the hierarchy is changed, this process may be invoked by this routine. Of course the details of these processes are determined by the particular solution methods in use.<p>
The level number arguments indicate the coarsest and finest levels in the current hierarchy configuration that have changed. It should be assumed that all intermediate levels have changed as well. 
<p>
Implemented in <a class="el" href="classSAMRAI_1_1mesh_1_1StandardTagAndInitialize.html#dbc8775e5d2f5335007891b93d95071c">SAMRAI::mesh::StandardTagAndInitialize</a>.
</div>
</div><p>
<a class="anchor" name="68598fdcc9722675cbc91ec8e5dbff13"></a><!-- doxytag: member="SAMRAI::mesh::TagAndInitializeStrategy::tagCellsForRefinement" ref="68598fdcc9722675cbc91ec8e5dbff13" args="(const tbox::Pointer&lt; hier::PatchHierarchy &gt; hierarchy, const int level_number, const double error_data_time, const int tag_index, const bool initial_time, const bool coarsest_sync_level, const bool can_be_refined=true, const double regrid_start_time=0.)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void SAMRAI::mesh::TagAndInitializeStrategy::tagCellsForRefinement           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchHierarchy.html">hier::PatchHierarchy</a> &gt;&nbsp;</td>
          <td class="paramname"> <em>hierarchy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>level_number</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>error_data_time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>tag_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&nbsp;</td>
          <td class="paramname"> <em>initial_time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&nbsp;</td>
          <td class="paramname"> <em>coarsest_sync_level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&nbsp;</td>
          <td class="paramname"> <em>can_be_refined</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>regrid_start_time</em> = <code>0.</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set integer tags to "one" on the given level to identify where refinement of that level should occur. The index is that of the cell-centered integer tag array on each patch. The boolean argument initial_time indicates whether cells are being tagged at initialization time, or at some later time during the calculation. If it is false, it should be assumed that the error estimation process is being invoked at some later time after the AMR hierarchy was initially constructed. This information is provided since application of the error estimator may be different in each of those circumstances.<p>
The cell-tagging operation may use time advancement to determine tag regions. The argument coarsest_sync_level provides information for the tagging method to coordinate time advance with an integrator. When time integration is used during regridding, this value is true if the level is the coarsest level involved in level synchronization immediately preceeding the regrid process; otherwise it is false. If time advancement is not used, this argument are ignored.<p>
The boolean can_be_refined is used to coordinate data reset operations with the time integrator when time-dependent regridding is used. This is provided since data may be managed differently on the finest hierarchy level than on coarser levels. 
<p>
Implemented in <a class="el" href="classSAMRAI_1_1mesh_1_1StandardTagAndInitialize.html#71cb4062eb56d7dc8d385e0862eadda2">SAMRAI::mesh::StandardTagAndInitialize</a>.
</div>
</div><p>
<a class="anchor" name="55f48c415ff91eb2116747f9a575129c"></a><!-- doxytag: member="SAMRAI::mesh::TagAndInitializeStrategy::preprocessErrorEstimation" ref="55f48c415ff91eb2116747f9a575129c" args="(const tbox::Pointer&lt; hier::PatchHierarchy &gt; hierarchy, const int level_number, const double regrid_time, const double regrid_start_time, const bool initial_time)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void SAMRAI::mesh::TagAndInitializeStrategy::preprocessErrorEstimation           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchHierarchy.html">hier::PatchHierarchy</a> &gt;&nbsp;</td>
          <td class="paramname"> <em>hierarchy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>level_number</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>regrid_time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>regrid_start_time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&nbsp;</td>
          <td class="paramname"> <em>initial_time</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Certain cases may require pre-processing of error estimation data before tagging cells, which is handled by this method. For example, Richardson extrapolation may require advances of data in time before the error estimation procedure is implemented.<p>
The level number indicates the level in which pre-process steps are applied, time is the time at which the operation is performed (generally the regrid time), and the boolean argument indicates whether the operation is performed at the initial time. 
<p>
Implemented in <a class="el" href="classSAMRAI_1_1mesh_1_1StandardTagAndInitialize.html#694f1e444e31fbebac07b0b61f556efb">SAMRAI::mesh::StandardTagAndInitialize</a>.
</div>
</div><p>
<a class="anchor" name="f4538967ed8d64c0dc0cf16258433e50"></a><!-- doxytag: member="SAMRAI::mesh::TagAndInitializeStrategy::usesTimeIntegration" ref="f4538967ed8d64c0dc0cf16258433e50" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool SAMRAI::mesh::TagAndInitializeStrategy::usesTimeIntegration           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return true if regridding process advances the data using some time integration procedure; otherwise, return false. 
<p>
Implemented in <a class="el" href="classSAMRAI_1_1mesh_1_1StandardTagAndInitialize.html#8536bedec72c52438dbef8d42932553e">SAMRAI::mesh::StandardTagAndInitialize</a>.
</div>
</div><p>
<a class="anchor" name="a1d900010c5faafb5efc2c6c4e7d0285"></a><!-- doxytag: member="SAMRAI::mesh::TagAndInitializeStrategy::coarsestLevelBoxesOK" ref="a1d900010c5faafb5efc2c6c4e7d0285" args="(const hier::BoxContainer &amp;boxes) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool SAMRAI::mesh::TagAndInitializeStrategy::coarsestLevelBoxesOK           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">hier::BoxContainer</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>boxes</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return true if boxes for coarsest hierarchy level are not appropriate for gridding strategy. Otherwise, return false. If false is returned, it is useful to provide a detailed explanatory message describing the problems with the boxes. 
<p>
Implemented in <a class="el" href="classSAMRAI_1_1mesh_1_1StandardTagAndInitialize.html#27726ae7a200aecb74ac1ebaed1b4540">SAMRAI::mesh::StandardTagAndInitialize</a>.
</div>
</div><p>
<a class="anchor" name="4359c4a0a4afbfafc2d5de6a5f565ffe"></a><!-- doxytag: member="SAMRAI::mesh::TagAndInitializeStrategy::getErrorCoarsenRatio" ref="4359c4a0a4afbfafc2d5de6a5f565ffe" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int SAMRAI::mesh::TagAndInitializeStrategy::getErrorCoarsenRatio           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return ratio by which level may be coarsened during the error estimation process. Generally, this is needed by the gridding algorithm class so that the new patch levels that it constructs can be coarsened properly (if needed) during the error estimation process. 
<p>
Implemented in <a class="el" href="classSAMRAI_1_1mesh_1_1StandardTagAndInitialize.html#bfec66b75a55c559f8718203a58f3fff">SAMRAI::mesh::StandardTagAndInitialize</a>.
</div>
</div><p>
<a class="anchor" name="8a4ff2059aae80bf0fa72f1d753f089c"></a><!-- doxytag: member="SAMRAI::mesh::TagAndInitializeStrategy::checkCoarsenRatios" ref="8a4ff2059aae80bf0fa72f1d753f089c" args="(const tbox::Array&lt; hier::IntVector &gt; &amp;ratio_to_coarser)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void SAMRAI::mesh::TagAndInitializeStrategy::checkCoarsenRatios           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1tbox_1_1Array.html">tbox::Array</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>ratio_to_coarser</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Check ratios between hierarchy levels against any constraints that may be required for the error estimation scheme. 
<p>
Implemented in <a class="el" href="classSAMRAI_1_1mesh_1_1StandardTagAndInitialize.html#f13c83e518e62495ba9402f96a8a7bd4">SAMRAI::mesh::StandardTagAndInitialize</a>.
</div>
</div><p>
<a class="anchor" name="334bd9f56a82d870233167b6e8f9ee67"></a><!-- doxytag: member="SAMRAI::mesh::TagAndInitializeStrategy::refineUserBoxInputOnly" ref="334bd9f56a82d870233167b6e8f9ee67" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool SAMRAI::mesh::TagAndInitializeStrategy::refineUserBoxInputOnly           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return whether refinement is being performed using ONLY user-supplied refine boxes. If any method is used that invokes tagging, this will return false. 
<p>
Implemented in <a class="el" href="classSAMRAI_1_1mesh_1_1StandardTagAndInitialize.html#966ff63d9270d272d6e4be78b081c113">SAMRAI::mesh::StandardTagAndInitialize</a>.
</div>
</div><p>
<a class="anchor" name="ab75c31f1017bc056738d5ae20364fe3"></a><!-- doxytag: member="SAMRAI::mesh::TagAndInitializeStrategy::getFromInput" ref="ab75c31f1017bc056738d5ae20364fe3" args="(tbox::Pointer&lt; tbox::Database &gt; db)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::mesh::TagAndInitializeStrategy::getFromInput           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Database.html">tbox::Database</a> &gt;&nbsp;</td>
          <td class="paramname"> <em>db</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Read user supplied refine boxes from the provided database. The database must be non-null, or an unrecoverable assertion will be thrown. 
<p>
Reimplemented in <a class="el" href="classSAMRAI_1_1mesh_1_1StandardTagAndInitialize.html#bbe10b79558c95c7171e593a6fe735f8">SAMRAI::mesh::StandardTagAndInitialize</a>.
</div>
</div><p>
<a class="anchor" name="60ac697c49e8ace4c5e6736fe25a96d3"></a><!-- doxytag: member="SAMRAI::mesh::TagAndInitializeStrategy::getDim" ref="60ac697c49e8ace4c5e6736fe25a96d3" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classSAMRAI_1_1tbox_1_1Dimension.html">tbox::Dimension</a> &amp; SAMRAI::mesh::TagAndInitializeStrategy::getDim           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return the dimension of this object. 
</div>
</div><p>
<a class="anchor" name="9e826b794eeed8f13c9f1f5c9a63ac0d"></a><!-- doxytag: member="SAMRAI::mesh::TagAndInitializeStrategy::getObjectName" ref="9e826b794eeed8f13c9f1f5c9a63ac0d" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SAMRAI_INLINE_KEYWORD const std::string &amp; SAMRAI::mesh::TagAndInitializeStrategy::getObjectName           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the object name. 
</div>
</div><p>
<hr>The documentation for this class was generated from the following files:<ul>
<li>source/SAMRAI/mesh/<a class="el" href="TagAndInitializeStrategy_8h.html">TagAndInitializeStrategy.h</a><li>source/SAMRAI/mesh/<a class="el" href="TagAndInitializeStrategy_8C.html">TagAndInitializeStrategy.C</a><li>source/SAMRAI/mesh/<a class="el" href="TagAndInitializeStrategy_8I.html">TagAndInitializeStrategy.I</a></ul>
<hr size="1"><address style="align: right;"><small>Generated on Wed Jan 18 16:05:17 2012 for SAMRAI by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.7 </small></address>
</body>
</html>
