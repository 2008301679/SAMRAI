/*************************************************************************
 *
 * This file is part of the SAMRAI distribution.  For full copyright
 * information, see COPYRIGHT and COPYING.LESSER.
 *
 * Copyright:     (c) 1997-2013 Lawrence Livermore National Security, LLC
 * Description:   Utilitiy for breaking boxes during partitioning.
 *
 ************************************************************************/

#ifndef included_mesh_BalanceBoxBreaker_C
#define included_mesh_BalanceBoxBreaker_C

#include "SAMRAI/mesh/BalanceBoxBreaker.h"

#include "SAMRAI/hier/BoxUtilities.h"
#include "SAMRAI/mesh/BalanceUtilities.h"
#include "SAMRAI/tbox/Utilities.h"
#include "SAMRAI/tbox/TimerManager.h"

#if !defined(__BGL_FAMILY__) && defined(__xlC__)
/*
 * Suppress XLC warnings
 */
#pragma report(disable, CPPC5334)
#pragma report(disable, CPPC5328)
#endif

namespace SAMRAI {
namespace mesh {


// Round a to the nearest higher integer divisible by b.  This should work even for a < 0.
#define ROUND_TO_HI(a,b) ((a)-((((a)%(b))-(b))%(b)))
// Round a to the nearest lower integer divisible by b.  This should work even for a < 0.
#define ROUND_TO_LO(a,b) ((a)-((((a)%(b))+(b))%(b)))


BalanceBoxBreaker::BalanceBoxBreaker(
   const PartitioningParams &pparams,
   bool print_break_steps )
   : d_pparams(&pparams),
     d_print_break_steps(print_break_steps)
{
   setTimers();
}


BalanceBoxBreaker::BalanceBoxBreaker( const BalanceBoxBreaker &other )
   : d_pparams(other.d_pparams),
     d_print_break_steps(other.d_print_break_steps),
     t_break_off_load(other.t_break_off_load),
     t_find_bad_cuts(other.t_find_bad_cuts)
{
}


/*
 *************************************************************************
 * Master method for breaking off a load.
 *
 * Try different heuristics and pick the "best" way to break off a
 * load.  The best is defined as the one with the lowest combined
 * penalty.
 *
 * This method always return a breakage if at all possible, without
 * considering whether the break should be used.  For example,
 * requesting breakage of 1 cell in a 100x100 box might return a
 * breakage of a 100-cells sliver!
 *
 * Return whether a successful break was made.
 *************************************************************************
 */
bool
BalanceBoxBreaker::breakOffLoad(
   std::vector<hier::Box>& breakoff,
   std::vector<hier::Box>& leftover,
   double& brk_load,
   const hier::Box& box,
   double ideal_load_to_break,
   double low_load,
   double high_load,
   double threshold_width ) const
{
   TBOX_ASSERT(ideal_load_to_break > 0);

   /*
    * NOTE: We need in this method a way to weigh the
    * value of proximity to the ideal breakoff vs the
    * increased area of the cuts.  However, the weight
    * given to area-optimized cuts should be considered
    * only with real application performance data.
    *
    * NOTE: We can compute the amount of new box boundaries
    * generated by computing the box boundary before and
    * after, and subtracting.  Easier than reconstructing
    * the cuts from the box definitions.
    *
    * NOTE: We should weight negatively the production of
    * high surface-to-volume boxes.
    */

   t_break_off_load->start();

   breakoff.clear();
   leftover.clear();


   /*
    * To avoid repeated computations of bad cuts,
    * we precompute bad_cuts here to provide to
    * methods that actually use the information.
    */
   std::vector<std::vector<bool> > bad_cuts(box.getDim().getValue());
   t_find_bad_cuts->start();
   hier::BoxUtilities::findBadCutPoints(
      bad_cuts,
      box,
      d_pparams->getDomainBoxes(box.getBlockId()),
      d_pparams->getBadInterval());
   t_find_bad_cuts->stop();

   // Penalty for not transfering ideal load.
   brk_load = 0;
   double best_balance_penalty = computeBalancePenalty(ideal_load_to_break);
   double best_width_score = computeWidthScore( box.numberCells(), threshold_width );

   if (d_print_break_steps) {
      tbox::plog.unsetf(std::ios::fixed | std::ios::scientific);
      tbox::plog.precision(6);
      tbox::plog << "      pre-break imbalance: " << ideal_load_to_break
                 << " balance penalty: " << best_balance_penalty
                 << " width score: " << best_width_score
                 << " threshold_width: " << threshold_width
                 << std::endl;
   }

   /*
    * Try planar break.
    */

   TrialBreak planar_trial( *d_pparams, threshold_width );
   double planar_brk_load = 0;
   int planar_acceptance_flags[4] = {0,0,0,0};
   double planar_balance_penalty = best_balance_penalty;
   double planar_width_score = best_width_score;
   bool planar_break_found = false;

   {

      planar_break_found = breakOffLoad_planar(
         planar_trial,
            planar_trial.d_breakoff,
            planar_trial.d_leftover,
            planar_brk_load,
            box,
            ideal_load_to_break,
            low_load,
            high_load,
            bad_cuts );

      if (planar_break_found) {

         if (d_print_break_steps) {
            // Should move this if-block into breakOffLoad_planar.
            tbox::plog.unsetf(std::ios::fixed | std::ios::scientific);
            tbox::plog.precision(6);
            tbox::plog << "      breakOffLoad_planar broke off "
                       << planar_brk_load << " / " << ideal_load_to_break
                       << " from " << box << '|'
                       << box.numberCells() << '|'
                       << box.size() << " into "
                       << planar_trial.d_breakoff.size()
                       << " breakoff: ";
            for (std::vector<hier::Box>::const_iterator bi =
                    planar_trial.d_breakoff.begin();
                 bi != planar_trial.d_breakoff.end();
                 ++bi) {
               tbox::plog << " " << *bi << '|' << bi->numberCells() << '|'
                          << bi->size();
            }
            tbox::plog << "\n        and " << planar_trial.d_leftover.size()
                       << " leftover boxes:";
            for (std::vector<hier::Box>::const_iterator bi =
                    planar_trial.d_leftover.begin();
                 bi != planar_trial.d_leftover.end();
                 ++bi) {
               tbox::plog << " " << *bi << '|' << bi->numberCells() << '|'
                          << bi->size();
            }
            tbox::plog << "\n        imbalance: "
                       << (planar_brk_load - ideal_load_to_break)
                       << std::endl;
         }

         planar_balance_penalty = computeBalancePenalty(
               static_cast<double>(planar_brk_load - ideal_load_to_break));
         planar_width_score =
            computeWidthScore(planar_trial.d_breakoff, threshold_width) *
            computeWidthScore(planar_trial.d_leftover, threshold_width);

         BalanceUtilities::compareLoads(
            planar_acceptance_flags, brk_load, planar_brk_load,
            ideal_load_to_break, low_load, high_load, *d_pparams );

         if (d_print_break_steps) {
            tbox::plog << " planar_balance_penalty: " << planar_balance_penalty
                       << " planar_width_score: " << planar_width_score
                       << std::endl;
            tbox::plog << "      planar_acceptance_flags:"
                       << "  " << planar_acceptance_flags[0]
                       << "  " << planar_acceptance_flags[1]
                       << "  " << planar_acceptance_flags[2]
                       << "  " << planar_acceptance_flags[3]
                       << std::endl;
         }

      } else {
         if (d_print_break_steps) {
            tbox::plog << "      breakOffLoad_planar could not break "
                       << ideal_load_to_break << " from " << box
                       << '/' << box.numberCells()
                       << '/' << box.numberCells().getProduct()
                       << std::endl;
         }
      }

   }

   /*
    * Try cubic break.
    */

   TrialBreak cubic_trial( *d_pparams, threshold_width );
   double cubic_brk_load = 0;
   int cubic_acceptance_flags[4] = {0,0,0,0};
   double cubic_balance_penalty = best_balance_penalty;
   double cubic_width_score = best_width_score;
   bool cubic_break_found = false;

   {

      cubic_break_found = breakOffLoad_cubic(
         cubic_trial,
            cubic_trial.d_breakoff,
            cubic_trial.d_leftover,
            cubic_brk_load,
            box,
            ideal_load_to_break,
            low_load,
            high_load,
            bad_cuts );

      if (cubic_break_found) {

         if (d_print_break_steps) {
            // Should move this if-block into breakOffLoad_cubic.
            tbox::plog.unsetf(std::ios::fixed | std::ios::scientific);
            tbox::plog.precision(6);
            tbox::plog << "      breakOffLoad_cubic broke off "
                       << cubic_brk_load << " / " << ideal_load_to_break
                       << " from " << box << '|'
                       << box.numberCells() << '|'
                       << box.size() << " into "
                       << cubic_trial.d_breakoff.size()
                       << " breakoff: ";
            for (std::vector<hier::Box>::const_iterator bi =
                    cubic_trial.d_breakoff.begin();
                 bi != cubic_trial.d_breakoff.end();
                 ++bi) {
               tbox::plog << " " << *bi << '|' << bi->numberCells() << '|'
                          << bi->size();
            }
            tbox::plog << "\n        and " << cubic_trial.d_leftover.size()
                       << " leftover boxes:";
            for (std::vector<hier::Box>::const_iterator bi =
                    cubic_trial.d_leftover.begin();
                 bi != cubic_trial.d_leftover.end();
                 ++bi) {
               tbox::plog << " " << *bi << '|' << bi->numberCells() << '|'
                          << bi->size();
            }
            tbox::plog << "\n        imbalance: "
                       << (cubic_brk_load - ideal_load_to_break)
                       << std::endl;
         }

         cubic_balance_penalty = computeBalancePenalty(
            static_cast<double>(cubic_brk_load - ideal_load_to_break));
         cubic_width_score =
            computeWidthScore(cubic_trial.d_breakoff, threshold_width) *
            computeWidthScore(cubic_trial.d_leftover, threshold_width);

         BalanceUtilities::compareLoads(
            cubic_acceptance_flags, brk_load, cubic_brk_load,
            ideal_load_to_break, low_load, high_load, *d_pparams );

         if (d_print_break_steps) {
            tbox::plog << " cubic_balance_penalty: " << cubic_balance_penalty
                       << " cubic_width_score: " << cubic_width_score
                       << std::endl;
            tbox::plog << "      Break evaluation:"
                       << "  " << cubic_acceptance_flags[0]
                       << "  " << cubic_acceptance_flags[1]
                       << "  " << cubic_acceptance_flags[2]
                       << "  " << cubic_acceptance_flags[3]
                       << std::endl;
         }

      } else {
         if (d_print_break_steps) {
            tbox::plog << "      breakOffLoad_cubic could not break "
                       << ideal_load_to_break << " from " << box
                       << '/' << box.numberCells()
                       << '/' << box.numberCells().getProduct()
                       << std::endl;
         }
      }

   }

   /*
    * Decide whether to take planar or cubic results.  If both are
    * in-range, pick the one with the best width score.  If only one
    * is in-range, pick that one.  If none are in range but both are
    * better than not breaking, chose the one with better overall
    * improvement.  If only one is better than not breaking, choose
    * that one.  Else, choose none.
    */
   char choice = '\0';
   if ( planar_acceptance_flags[3] && cubic_acceptance_flags[3] ) {
      choice = ( planar_width_score >= cubic_width_score ) ? 'p' : 'c';
   }
   else if ( planar_acceptance_flags[3] ) {
      choice = 'p';
   }
   else if ( cubic_acceptance_flags[3] ) {
      choice = 'c';
   }
   else if ( planar_acceptance_flags[2] && cubic_acceptance_flags[2] ) {
      int acceptance_flags[4] = {0,0,0,0};
      choice = BalanceUtilities::compareLoads(
         acceptance_flags, planar_brk_load, cubic_brk_load,
         ideal_load_to_break, low_load, high_load, *d_pparams ) ? 'c' : 'p';
   }
   else if ( planar_acceptance_flags[2] ) {
      choice = 'p';
   }
   else if ( cubic_acceptance_flags[2] ) {
      choice = 'c';
   }

   if ( choice == 'p' ) {
      if (d_print_break_steps) {
         tbox::plog << "      Choosing planar break result."
                    << "  " << planar_trial.d_breakoff.size() << " boxes broken off."
                    << "  " << planar_trial.d_leftover.size() << " boxes leftover."
                    << std::endl;
      }
      breakoff.swap(planar_trial.d_breakoff);
      leftover.swap(planar_trial.d_leftover);
      brk_load = planar_brk_load;
   }
   else if ( choice == 'c' ) {
      if (d_print_break_steps) {
         tbox::plog << "      Choosing cubic break result."
                    << "  " << cubic_trial.d_breakoff.size() << " boxes broken off."
                    << "  " << cubic_trial.d_leftover.size() << " boxes leftover."
                    << std::endl;
      }
      breakoff.swap(cubic_trial.d_breakoff);
      leftover.swap(cubic_trial.d_leftover);
      brk_load = cubic_brk_load;
   }
   else {
      if (d_print_break_steps) {
         tbox::plog << "      choosing no cut result."
                    << std::endl;
      }
   }

   t_break_off_load->stop();

   return (choice != '0');
}



/*
 *************************************************************************
 * Break off a load from a box by making a single planar cut across
 * the box's longest direction.
 *
 * Currently assuming uniform load of one unit per cell.
 *
 * Return whether a successful break was made.
 *************************************************************************
 */
bool
BalanceBoxBreaker::breakOffLoad_planar(
   TrialBreak &trial,
   std::vector<hier::Box>& breakoff,
   std::vector<hier::Box>& leftover,
   double& brk_load,
   const hier::Box& box,
   double ideal_brk_load,
   double low_load,
   double high_load,
   const std::vector<std::vector<bool> >& bad_cuts ) const
{

   const tbox::Dimension dim(box.getDim());

   if (d_print_break_steps) {
      tbox::plog << "      breakOffLoad_planar attempting to break "
                 << ideal_brk_load << " from Box "
                 << box << box.numberCells() << '|' << box.size()
                 << " min_size=" << d_pparams->getMinBoxSize() << std::endl;
   }

   breakoff.clear();
   leftover.clear();

   const hier::IntVector& box_dims = box.numberCells();

   const int box_vol = box_dims.getProduct();

   if (box_vol <= ideal_brk_load) {
      // Easy: break off everything.
      breakoff.push_back(box);
      brk_load = box_vol;
      if (d_print_break_steps) {
         tbox::plog << "      breakOffLoad_planar broke off entire Box "
                    << box
                    << std::endl;
      }
      return true;
   }

   /*
    * Determine ordering of box_dims from shortest to longest.
    */
   hier::IntVector sorted_dirs(dim);
   sorted_dirs.sortIntVector(box_dims);

   hier::Box best_breakoff_box(dim);
   hier::Box best_leftover_box(dim);
   best_breakoff_box.setBlockId(box.getBlockId());
   best_leftover_box.setBlockId(box.getBlockId());
   brk_load = 0;

   int break_acceptance_flags[4] = {0,0,0,0};
   bool sufficient_brk_load = false;

   for (int d = box.getDim().getValue() - 1; d >= 0 && !sufficient_brk_load; --d) {

      /*
       * Search directions from longest to shortest because we prefer
       * to break across longer directions.
       */
      const int brk_dir = sorted_dirs(d);

      const int brk_area = box_vol / box_dims(brk_dir);

      const std::vector<bool>& bad = bad_cuts[brk_dir];

      const double ideal_cut_length = double(ideal_brk_load)/brk_area;

      /*
       * Try 4 different cuts for direction brk_dir:
       * upper/lower: should we break off the upper end or lower end of the box.
       * hi/lo: should we round the break plane to the high or low side.
       *
       * plane refers to the index of the mesh line where the cut is.
       *
       * offset refers to a cut plane index relative to the box's lower corner.
       */

      // Ideal cut planes, not necessarily coincident with a grid line.
      const double ideal_upper_cut_offset = box.numberCells(brk_dir) - ideal_cut_length;
      const double ideal_lower_cut_offset = ideal_cut_length;

      // Compute valid cut planes on high and low sides of upper cut plane.
      int lo_upper_cut_plane = box.lower()(brk_dir) + int(ideal_upper_cut_offset);
      int hi_upper_cut_plane = box.lower()(brk_dir) + int(ideal_upper_cut_offset) + 1;
      lo_upper_cut_plane = ROUND_TO_LO(lo_upper_cut_plane, d_pparams->getCutFactor()(brk_dir));
      hi_upper_cut_plane = ROUND_TO_HI(hi_upper_cut_plane, d_pparams->getCutFactor()(brk_dir));
      while ( lo_upper_cut_plane > box.lower()(brk_dir)   && bad[lo_upper_cut_plane-box.lower()(brk_dir)] ) { lo_upper_cut_plane -= d_pparams->getCutFactor()(brk_dir); }
      while ( hi_upper_cut_plane < box.upper()(brk_dir)+1 && bad[hi_upper_cut_plane-box.lower()(brk_dir)] ) { hi_upper_cut_plane += d_pparams->getCutFactor()(brk_dir); }

      // Compute valid cut planes on high and low sides of lower cut plane.
      int lo_lower_cut_plane = box.lower()(brk_dir) + int(ideal_lower_cut_offset);
      int hi_lower_cut_plane = box.lower()(brk_dir) + int(ideal_lower_cut_offset) + 1;
      lo_lower_cut_plane = ROUND_TO_LO(lo_lower_cut_plane, d_pparams->getCutFactor()(brk_dir));
      hi_lower_cut_plane = ROUND_TO_HI(hi_lower_cut_plane, d_pparams->getCutFactor()(brk_dir));
      while ( lo_lower_cut_plane > box.lower()(brk_dir)   && bad[lo_lower_cut_plane-box.lower()(brk_dir)] ) { lo_lower_cut_plane -= d_pparams->getCutFactor()(brk_dir); }
      while ( hi_lower_cut_plane < box.upper()(brk_dir)+1 && bad[hi_lower_cut_plane-box.lower()(brk_dir)] ) { hi_lower_cut_plane += d_pparams->getCutFactor()(brk_dir); }


      if ( lo_lower_cut_plane - box.lower()(brk_dir) > d_pparams->getMinBoxSize()(brk_dir) &&
           box.upper()(brk_dir)+1 - lo_lower_cut_plane > d_pparams->getMinBoxSize()(brk_dir) ) {

         const int lo_lower_cut_vol = brk_area*( lo_lower_cut_plane - box.lower()(brk_dir) );

         if ( BalanceUtilities::compareLoads(
                 break_acceptance_flags, brk_load,
                 lo_lower_cut_vol, ideal_brk_load,
                 low_load, high_load, *d_pparams ) ) {
            brk_load = lo_lower_cut_vol;
            best_breakoff_box = best_leftover_box = box;
            best_breakoff_box.upper()(brk_dir) = lo_lower_cut_plane - 1;
            best_leftover_box.lower()(brk_dir) = lo_lower_cut_plane;
            TBOX_ASSERT( best_breakoff_box.size() == lo_lower_cut_vol );
         }
      }

      if ( ( hi_lower_cut_plane - box.lower()(brk_dir) > d_pparams->getMinBoxSize()(brk_dir) &&
           box.upper()(brk_dir)+1 - hi_lower_cut_plane > d_pparams->getMinBoxSize()(brk_dir) ) ||
           hi_lower_cut_plane >= box.upper()(brk_dir)+1 ) {

         const int hi_lower_cut_vol = brk_area*( hi_lower_cut_plane - box.lower()(brk_dir) );

         if ( BalanceUtilities::compareLoads(
                 break_acceptance_flags, brk_load,
                 hi_lower_cut_vol, ideal_brk_load,
                 low_load, high_load, *d_pparams ) ) {
            brk_load = hi_lower_cut_vol;
            best_breakoff_box = best_leftover_box = box;
            best_breakoff_box.upper()(brk_dir) = hi_lower_cut_plane - 1;
            best_leftover_box.lower()(brk_dir) = hi_lower_cut_plane;
            TBOX_ASSERT( best_breakoff_box.size() == hi_lower_cut_vol );
         }
      }

      if ( ( box.upper()(brk_dir)+1 - lo_upper_cut_plane > d_pparams->getMinBoxSize()(brk_dir) &&
           lo_upper_cut_plane - box.lower()(brk_dir) > d_pparams->getMinBoxSize()(brk_dir) ) ||
           lo_upper_cut_plane <= box.lower()(brk_dir) ) {

         const int lo_upper_cut_vol = brk_area*( box.upper()(brk_dir)+1 - lo_upper_cut_plane );

         if ( BalanceUtilities::compareLoads(
                 break_acceptance_flags, brk_load,
                 lo_upper_cut_vol, ideal_brk_load,
                 low_load, high_load, *d_pparams ) ) {
            brk_load = lo_upper_cut_vol;
            best_breakoff_box = best_leftover_box = box;
            best_breakoff_box.lower()(brk_dir) = lo_upper_cut_plane;
            best_leftover_box.upper()(brk_dir) = lo_upper_cut_plane - 1;
            TBOX_ASSERT( best_breakoff_box.size() == lo_upper_cut_vol );
         }
      }

      if ( box.upper()(brk_dir)+1 - hi_upper_cut_plane > d_pparams->getMinBoxSize()(brk_dir) &&
           hi_upper_cut_plane - box.lower()(brk_dir) > d_pparams->getMinBoxSize()(brk_dir) ) {

         const int hi_upper_cut_vol = brk_area*( box.upper()(brk_dir)+1 - hi_upper_cut_plane );

         if ( BalanceUtilities::compareLoads(
                 break_acceptance_flags, brk_load,
                 hi_upper_cut_vol, ideal_brk_load,
                 low_load, high_load, *d_pparams ) ) {
            brk_load = hi_upper_cut_vol;
            best_breakoff_box = best_leftover_box = box;
            best_breakoff_box.lower()(brk_dir) = hi_upper_cut_plane;
            best_leftover_box.upper()(brk_dir) = hi_upper_cut_plane - 1;
            TBOX_ASSERT( best_breakoff_box.size() == hi_upper_cut_vol );
         }
      }

      sufficient_brk_load = (brk_load >= low_load) && (brk_load <= high_load);

   } // d-loop

   bool successful_break = false;
   if (!best_breakoff_box.empty()) {
      breakoff.push_back(best_breakoff_box);
      TBOX_ASSERT( brk_load == best_breakoff_box.size() );
      successful_break = true;
      if (d_print_break_steps) {
         tbox::plog << "      breakOffLoad_planar broke box " << box << box.numberCells()
                    << " for breakoff box " << best_breakoff_box << best_breakoff_box.numberCells()
                    << " and leftover " << best_leftover_box << best_leftover_box.numberCells()
                    << std::endl;
      }
   } else {
      if (d_print_break_steps) {
         tbox::plog << "      breakOffLoad_planar could not break "
                    << ideal_brk_load << " from Box " << box
                    << std::endl;
      }
   }
   if (!best_leftover_box.empty()) {
      leftover.push_back(best_leftover_box);
   }

#ifdef DEBUG_CHECK_ASSERTIONS
   for (std::vector<hier::Box>::iterator bi = breakoff.begin();
        bi != breakoff.end();
        ++bi) {
      const hier::Box& b = *bi;
      const hier::IntVector s = b.numberCells();
      for (int d = 0; d < box.getDim().getValue(); ++d) {
         if (((s(d) < d_pparams->getMinBoxSize()(d)) && (s(d) != box_dims(d))) ||
             (s(d) > box_dims(d))) {
            TBOX_ERROR("BalanceBoxBreaker library error:\n"
               << "breakoff box " << b << ", size " << s
               << "\nis not between the min size " << d_pparams->getMinBoxSize()
               << "\nand the original box size " << box_dims << "\n"
               << "break box size " << best_breakoff_box.numberCells() << "\n"
               << "ideal brk load " << ideal_brk_load);
         }
      }
   }
   for (std::vector<hier::Box>::iterator bi = leftover.begin();
        bi != leftover.end();
        ++bi) {
      const hier::Box& b = *bi;
      const hier::IntVector s = b.numberCells();
      for (int d = 0; d < box.getDim().getValue(); ++d) {
         if (((s(d) < d_pparams->getMinBoxSize()(d)) && (s(d) != box_dims(d))) ||
             (s(d) > box_dims(d))) {
            TBOX_ERROR("BalanceBoxBreaker library error:\n"
               << "leftover box " << b << ", size " << s
               << "\nis not between the min size " << d_pparams->getMinBoxSize()
               << "\nand the original box size " << box_dims << "\n"
               << "break box size " << best_breakoff_box.numberCells() << "\n"
               << "ideal brk load " << ideal_brk_load);
         }
      }
   }
#endif

   return successful_break;
}



/*
 *************************************************************************
 * Break off a load from a box by making a box cut that is as close
 * to cubic as feasible.
 *
 * Currently assuming uniform load of one unit per cell.
 *
 * Return whether a successful break was made.
 *
 * Differs from breakOffLoad in that it will always
 * performs a break and if needed, break off more than
 * the ideal.  The calling method should take this into
 * account.
 *************************************************************************
 */
bool
BalanceBoxBreaker::breakOffLoad_cubic(
   TrialBreak &trial,
   std::vector<hier::Box>& breakoff,
   std::vector<hier::Box>& leftover,
   double& brk_load,
   const hier::Box& box,
   double ideal_brk_load,
   double low_load,
   double high_load,
   const std::vector<std::vector<bool> >& bad_cuts ) const
{

   const hier::IntVector box_dims(box.numberCells());

   const double box_load(box_dims.getProduct());

   if (ideal_brk_load >= box_load) {
      // Easy: break off everything.
      leftover.clear();
      breakoff.clear();
      breakoff.push_back(box);
      brk_load = box_load;
      if (d_print_break_steps) {
         tbox::plog << "      breakOffLoad_cubic broke off entire Box "
                    << box
                    << std::endl;
      }
      return true;
   }

   if (ideal_brk_load > 0.5 * box_load) {
      /*
       * This algorithm is better when breaking off a small portion.
       * Since the ideal is a bigger portion, switch breakoff with leftover.
       */
      if (d_print_break_steps) {
         tbox::plog
         << "      breakOffLoad_cubic reversing direction to break "
         << (box_dims.getProduct() - ideal_brk_load)
         << " instead of " << ideal_brk_load << " / "
         << box_dims.getProduct() << std::endl;
      }
      bool success =
         breakOffLoad_cubic(
            trial,
            breakoff,
            leftover,
            brk_load,
            box,
            box_dims.getProduct() - ideal_brk_load,
            box_dims.getProduct() - high_load,
            box_dims.getProduct() - low_load,
            bad_cuts );
      trial.d_breakoff.swap(trial.d_leftover);
      if (success) {
         brk_load = box_dims.getProduct() - brk_load;
      }
      return success;
   }

   if (d_print_break_steps) {
      tbox::plog << "      breakOffLoad_cubic attempting to break "
                 << ideal_brk_load << " from Box "
                 << box << box.numberCells() << '|' << box.size()
                 << " min_size=" << d_pparams->getMinBoxSize() << std::endl;
   }

   breakoff.clear();
   leftover.clear();
   brk_load = 0.0;

   const hier::IntVector &one_vec = hier::IntVector::getOne(box.getDim());
   const hier::IntVector &zero_vec = hier::IntVector::getZero(box.getDim());

   hier::Box best_breakoff_box(box.getDim());
   hier::IntVector best_breakoff_size = zero_vec;
   double best_breakoff_load = 0;

   /*
    * We consider 2^dim boxes grown from the incoming box's corners.
    * Imagine 2 cutting planes per dimension, perpendicular to each
    * axis, an upper cut and a lower cut.  The box is cut into 3 parts
    * in each direction, so the 2*dim planes divide the box into 3^dim
    * boxes.
    *
    * 2D example:
    *
    *       +-----------------+
    *       |    |        |   |
    *       |----+--------+---|
    *       |    |        |   |
    *       |    |        |   |
    *       |    |        |   |
    *       |    |        |   |
    *       |----+--------+---|
    *       |    |        |   |
    *       +-----------------+
    *
    * upper_intersection is the point where all upper cuts intersect.
    * lower_intersection is the point where all lower cuts intersect.
    * We only consider the cut boxes that touch the incoming box's
    * corners.  Using the other boxes result in too much fragmentation
    * of the incoming box.
    */
   hier::IntVector brk_size(d_pparams->getMinBoxSize());
   brk_size.max(d_pparams->getCutFactor());
   brk_size.min(box_dims);

   /*
    * Make sure brk_size is a multiple of d_pparams->getCutFactor().
    */
   for (int d = 0; d < box.getDim().getValue(); ++d) {
      if (brk_size(d) % d_pparams->getCutFactor()(d) != 0) {
         brk_size(d) = ((brk_size(d) / d_pparams->getCutFactor()(d)) + 1) * d_pparams->getCutFactor()(d);
      }
   }

   /*
    * Initialize the cut plane intersections.  We will grow the
    * corner boxes by gradually moving the intersections away
    * from their initial location.
    */
   hier::IntVector lower_intersection(box.lower() + d_pparams->getMinBoxSize());
   hier::IntVector upper_intersection(box.upper() - d_pparams->getMinBoxSize() + one_vec);
   for ( int d=0; d<box.getDim().getValue(); ++d ) {
      lower_intersection(d) = ROUND_TO_HI( lower_intersection(d),
                                           d_pparams->getCutFactor()(d) );
      upper_intersection(d) = ROUND_TO_LO( upper_intersection(d),
                                           d_pparams->getCutFactor()(d) );
   }


   const int num_corners = 1 << box.getDim().getValue();

   for ( int bn=0; bn<num_corners; ++bn ) {

      if ( d_print_break_steps ) {
         tbox::plog << "Examining corner box " << bn << std::endl;
      }

      /*
       * Compute initial box at corner bn and its expansion rate.
       */
      hier::Box corner_box(box);
      hier::IntVector corner_box_size = zero_vec;
      double corner_box_load = 0;
      hier::IntVector expansion_rate(box.getDim());

      for ( int d=0; d<box.getDim().getValue(); ++d ) {

         // In direction d, does corner_box touch the upper (vs lower) side of box:
         int touches_upper_side = bn & (1 << d) ;

         if ( touches_upper_side ) {
            corner_box.lower()(d) = upper_intersection(d);
            if ( corner_box.lower()(d) - box.lower()(d) < d_pparams->getMinBoxSize()(d) ) {
               corner_box.lower()(d) = box.lower()(d);
            }
            expansion_rate(d) = -d_pparams->getCutFactor()(d);
         }
         else {
            corner_box.upper()(d) = lower_intersection(d) - 1;
            if ( box.upper()(d) - corner_box.upper()(d) < d_pparams->getMinBoxSize()(d) ) {
               corner_box.upper()(d) = box.upper()(d);
            }
            expansion_rate(d) = d_pparams->getCutFactor()(d);
         }

      }

      corner_box_size = corner_box.numberCells();
      corner_box_load = corner_box.size();

      if ( d_print_break_steps ) {
         tbox::plog << "Initial corner box " << bn << " is " << corner_box << corner_box.numberCells() << '|' << corner_box.size() << std::endl;
      }


      int break_acceptance_flags[4] = {0,0,0,0};

      if ( BalanceUtilities::compareLoads(
              break_acceptance_flags, best_breakoff_load,
              corner_box_load, ideal_brk_load,
              low_load, high_load, *d_pparams) ) {
         best_breakoff_box = corner_box;
         best_breakoff_size = corner_box_size;
         best_breakoff_load = corner_box_load;
         if ( d_print_break_steps ) {
            tbox::plog << "best_breakoff_box is now box " << bn << " " << best_breakoff_box
                       << ", best_breakoff_size = " << best_breakoff_size
                       << ", best_breakoff_load = " << best_breakoff_load
                       << std::endl;
         }
         if ( best_breakoff_load >= low_load && brk_load <= high_load ) {
            break;
         }
      }



      /*
       * stop_growing: whether corner_box_size is already
       * big engough so that it cannot not be grown without breaking
       * off too much.
       */
      hier::IntVector growable(box.getDim(), 1);
      for (int d = 0; d < box.getDim().getValue(); ++d) {
         growable[d] = corner_box_size[d] < box_dims[d];
      }

      while ( ( best_breakoff_load < low_load || best_breakoff_load > high_load ) &&
              corner_box_load < ideal_brk_load ) {
         /*
          * The while loop gradually increases corner_box to bring
          * its size closer to ideal_brk_load.  Stop loop when
          * its size is in the acceptable range or if increasing
          * it only takes it farther from ideal_brk_load.
          *
          * Select inc_dir, the direction to expand corner_box.  Use the
          * smallest direction that is still allowed to grow.
          */

         int inc_dir = -1;
         for (int d = 0; d < box.getDim().getValue(); ++d) {
            if ( growable(d) &&
                 (inc_dir == -1 || corner_box_size(d) < corner_box_size(inc_dir)) )
               inc_dir = d;
         }
         if (inc_dir == -1) break; // No growable direction.

         TBOX_ASSERT(corner_box_size(inc_dir) < box_dims(inc_dir));


         /*
          * Grow corner_box, but keep within boundary of box and
          * prevent remainder from violating min size.  Update growability.
          */
         if ( expansion_rate(inc_dir) > 0 ) {
            corner_box.upper()(inc_dir) = tbox::MathUtilities<int>::Min(
               corner_box.upper()(inc_dir) + expansion_rate(inc_dir),
               box.upper()(inc_dir) );
            if ( box.upper()(inc_dir) - corner_box.upper()(inc_dir) < d_pparams->getMinBoxSize()(inc_dir) ) {
               corner_box.upper()(inc_dir) = box.upper()(inc_dir);
            }
            growable(inc_dir) = corner_box.upper()(inc_dir) < box.upper()(inc_dir);
         }
         else {
            corner_box.lower()(inc_dir) = tbox::MathUtilities<int>::Max(
               corner_box.lower()(inc_dir) + expansion_rate(inc_dir),
               box.lower()(inc_dir) );
            if ( corner_box.lower()(inc_dir) - box.lower()(inc_dir) < d_pparams->getMinBoxSize()(inc_dir) ) {
               corner_box.lower()(inc_dir) = box.lower()(inc_dir);
            }
            growable(inc_dir) = corner_box.lower()(inc_dir) > box.lower()(inc_dir);
         }
         corner_box_size = corner_box.numberCells();
         corner_box_load = corner_box.size();

         if ( d_print_break_steps ) {
            tbox::plog << "Expand corner box " << bn << " to " << corner_box << corner_box.numberCells() << '|' << corner_box.size() << std::endl;
         }


         const bool accept_break = BalanceUtilities::compareLoads(
            break_acceptance_flags, best_breakoff_load, corner_box_load,
            ideal_brk_load, low_load, high_load, *d_pparams );

         if ( accept_break ) {
            best_breakoff_box = corner_box;
            best_breakoff_size = corner_box_size;
            best_breakoff_load = corner_box_load;
            if ( d_print_break_steps ) {
               tbox::plog << "best_breakoff_box is now box " << bn << " " << best_breakoff_box
                          << ", best_breakoff_size = " << best_breakoff_size
                          << ", best_breakoff_load = " << best_breakoff_load
                          << std::endl;
            }
            if ( best_breakoff_load >= low_load && best_breakoff_load <= high_load ) {
               break;
            }
         }

      } // while loop

   } // bn loop


   if ( !best_breakoff_box.empty() ) {
      brk_load = best_breakoff_load;
      breakoff.push_back(best_breakoff_box);

      burstBox(
         leftover,
         box,
         best_breakoff_box );
   }

#ifdef DEBUG_CHECK_ASSERTIONS
   for (std::vector<hier::Box>::iterator bi = breakoff.begin();
        bi != breakoff.end();
        ++bi) {
      const hier::Box& b = *bi;
      const hier::IntVector s = b.numberCells();
      for (int d = 0; d < box.getDim().getValue(); ++d) {
         if (((s(d) < d_pparams->getMinBoxSize()(d)) && (s(d) != box_dims(d))) ||
             (s(d) > box_dims(d))) {
            TBOX_ERROR("BalanceBoxBreaker library error:\n"
               << "breakoff box " << b << ", with size " << s
               << "\nis not between the min size " << d_pparams->getMinBoxSize()
               << "\nand the original box size " << box_dims << "\n"
               << "orig box " << box << "\n"
               << "break box " << b << "\n"
               << "break box size " << b.size() << "\n"
               << "ideal brk load " << ideal_brk_load);
         }
      }
   }
   for (std::vector<hier::Box>::iterator bi = leftover.begin();
        bi != leftover.end();
        ++bi) {
      const hier::Box& b = *bi;
      const hier::IntVector s = b.numberCells();
      for (int d = 0; d < box.getDim().getValue(); ++d) {
         if (((s(d) < d_pparams->getMinBoxSize()(d)) && (s(d) != box_dims(d))) ||
             (s(d) > box_dims(d))) {
            TBOX_ERROR("BalanceBoxBreaker library error:\n"
               << "leftover box " << b << ", with size " << s
               << "\nis not between the min size " << d_pparams->getMinBoxSize()
               << "\nand the original box size " << box_dims << "\n"
               << "orig box " << box << "\n"
               << "break box " << b << "\n"
               << "break box size " << b.size() << "\n"
               << "ideal brk load " << ideal_brk_load);
         }
      }
   }
#endif

   return !breakoff.empty();
}



/*
 *************************************************************************
 *************************************************************************
 */

void
BalanceBoxBreaker::burstBox(
   std::vector<hier::Box>& boxes,
   const hier::Box& bursty,
   const hier::Box& solid )
{
   /*
    * This method lacks logic to handle the case of solid not being
    * completely inside bursty.  That feature is not currently needed.
    */
   TBOX_ASSERT(bursty.contains(solid));

   const hier::IntVector solid_size = solid.numberCells();

   boxes.clear();
   hier::Box cutme = bursty;
   while (!cutme.isSpatiallyEqual(solid)) {

      int cut_dir = 999999;
      bool cut_above_solid = false; // Whether to slice off the piece above solid (vs below).
      /*
       * Find direction and place to cut.  To minimize slivers, cut
       * from cutme the thickest slab (in direction normal to cut)
       * possible.
       */
      int slab_thickness = 0;
      for (int d = 0; d < solid_size.getDim().getValue(); ++d) {
         if (cutme.numberCells(d) > solid_size(d)) {
            const int thickness_from_upper_cut = cutme.upper() (d)
               - solid.upper() (d);
            if (thickness_from_upper_cut > slab_thickness) {
               slab_thickness = thickness_from_upper_cut;
               cut_dir = d;
               cut_above_solid = true;
            }
            const int thickness_from_lower_cut = solid.lower() (d)
               - cutme.lower() (d);
            if (thickness_from_lower_cut > slab_thickness) {
               slab_thickness = thickness_from_lower_cut;
               cut_dir = d;
               cut_above_solid = false;
            }
         }
      }
      TBOX_ASSERT(cut_dir >= 0 && cut_dir < solid_size.getDim().getValue());

      hier::Box removeme = cutme;
      if (cut_above_solid) {
         cutme.upper() (cut_dir) = solid.upper() (cut_dir);
         removeme.lower() (cut_dir) = solid.upper() (cut_dir) + 1;
      } else {
         cutme.lower() (cut_dir) = solid.lower() (cut_dir);
         removeme.upper() (cut_dir) = solid.lower() (cut_dir) - 1;
      }

      boxes.push_back(removeme);

   }

   return;
}


/*
 *************************************************************************
 * Compute a box_size score that is low for box widths smaller than
 * some threshold_width.  Boxes longer than this are okay assuming
 * that they can be broken down further.  Boxes shorter than this are
 * undesirable because they lead to excessive box count and/or aspect
 * ratios.
 *************************************************************************
 */
double BalanceBoxBreaker::computeWidthScore(
   const hier::IntVector &box_size,
   double threshold_width )
{
   double width_score = 1.0;
   for ( int d=0; d<box_size.getDim().getValue(); ++d ) {
      double s = box_size(d)/threshold_width;
      s = tbox::MathUtilities<double>::Min( 1.0, s );
      // For non-linear scoring, try s = sqrt(s);
      width_score *= s;
   }
   return width_score;
}


/*
 *************************************************************************
 * Compute a size score for multiple boxes.  The combined score is the
 * produce of individual scores.
 *************************************************************************
 */
double BalanceBoxBreaker::computeWidthScore(
   const std::vector<hier::Box> &boxes,
   double threshold_width )
{
   double width_score = 1.0;
   for ( int i=0; i<boxes.size(); ++i ) {
      width_score *= computeWidthScore( boxes[i].numberCells(), threshold_width );
   }
   return width_score;
}


/*
 *************************************************************************
 *************************************************************************
 */
void BalanceBoxBreaker::setTimers()
{
   t_break_off_load = tbox::TimerManager::getManager()->
      getTimer("mesh::BalanceBoxBreaker::breakOffLoad()");
   t_find_bad_cuts = tbox::TimerManager::getManager()->
      getTimer("mesh::BalanceBoxBreaker::find_bad_cuts");
}



/*
 *************************************************************************
 *************************************************************************
 */
BalanceBoxBreaker::TrialBreak::TrialBreak(
   const PartitioningParams &pparams,
   double threshold_width )
   : d_breakoff_load(0.0),
     d_breakoff(),
     d_leftover(),
     d_ideal_load(-1.0),
     d_low_load(-1.0),
     d_high_load(-1.0),
     d_width_score(1.0),
     d_balance_penalty(0.0),
     d_pparams(&pparams),
     d_threshold_width(threshold_width)
{}



/*
 *************************************************************************
 *************************************************************************
 */
void BalanceBoxBreaker::TrialBreak::breakBox(
   const hier::Box &box,
   const hier::Box &whole )
{
   d_breakoff.clear();
   d_leftover.clear();
   burstBox( d_leftover, whole, box );
   d_breakoff.push_back(box);
   d_breakoff_load = double(box.size());

   d_width_score =
      computeWidthScore( d_breakoff, d_threshold_width ) *
      computeWidthScore( d_leftover, d_threshold_width );
   return;
}


/*
 *************************************************************************
 *************************************************************************
 */
bool BalanceBoxBreaker::TrialBreak::computeMerits(
   double ideal_load, double low_load, double high_load )
{
   TBOX_ASSERT( !d_breakoff.empty() );

   d_ideal_load = ideal_load;
   d_low_load = low_load;
   d_high_load = high_load;

   d_balance_penalty = BalanceBoxBreaker::computeBalancePenalty(
      d_breakoff_load - d_ideal_load);
   return BalanceUtilities::compareLoads(
      d_flags, 0, d_breakoff_load,
      d_ideal_load, d_low_load, d_high_load, *d_pparams);
}


/*
 *************************************************************************
 * Decide whether to take planar or cubic results.  If both are
 * in-range, pick the one with the best width score.  If only one
 * is in-range, pick that one.  If none are in range but both are
 * better than not breaking, chose the one with better overall
 * improvement.  If only one is better than not breaking, choose
 * that one.  Else, choose none.
 *************************************************************************
 */
int BalanceBoxBreaker::TrialBreak::improvesOver(
   const TrialBreak &other ) const
{
   TBOX_ASSERT( !this->d_breakoff.empty() );
   TBOX_ASSERT( !other.d_breakoff.empty() );

   int improves = 0;

   if ( this->d_flags[3] && other.d_flags[3] ) {
      improves =
         ( this->d_width_score > other.d_width_score ) ? 1 :
         ( this->d_width_score < other.d_width_score ) ? -1 : 0;
      if ( improves == 0 ) {
         improves =
            ( this->d_balance_penalty < other.d_balance_penalty ) ? 1 :
            ( this->d_balance_penalty > other.d_balance_penalty ) ? -1 : 0;
         // How about balance_score = -balance_penalty so everything is a "score."
      }
   }

   else if ( this->d_flags[3] ) {
      improves = 1;
   }

   else if ( other.d_flags[3] ) {
      improves = -1;
   }

   else if ( this->d_flags[2] && other.d_flags[2] ) {
      int flags[4] = {0,0,0,0};
      BalanceUtilities::compareLoads(
         flags, this->d_breakoff_load, other.d_breakoff_load,
         d_ideal_load, d_low_load, d_high_load, *d_pparams );
      improves = flags[2];
   }

   else if ( this->d_flags[2] ) {
      improves = 1;
   }

   else if ( other.d_flags[2] ) {
      improves = -1;
   }

   return improves;
}

}
}

#if !defined(__BGL_FAMILY__) && defined(__xlC__)
/*
 * Suppress XLC warnings
 */
#pragma report(enable, CPPC5334)
#pragma report(enable, CPPC5328)
#endif

#endif
