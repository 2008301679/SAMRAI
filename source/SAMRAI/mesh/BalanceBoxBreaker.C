/*************************************************************************
 *
 * This file is part of the SAMRAI distribution.  For full copyright
 * information, see COPYRIGHT and COPYING.LESSER.
 *
 * Copyright:     (c) 1997-2013 Lawrence Livermore National Security, LLC
 * Description:   Utilitiy for breaking boxes during partitioning.
 *
 ************************************************************************/

#ifndef included_mesh_BalanceBoxBreaker_C
#define included_mesh_BalanceBoxBreaker_C

#include "SAMRAI/mesh/BalanceBoxBreaker.h"

#include "SAMRAI/hier/BoxUtilities.h"
#include "SAMRAI/mesh/BalanceUtilities.h"
#include "SAMRAI/tbox/Utilities.h"
#include "SAMRAI/tbox/TimerManager.h"

#if !defined(__BGL_FAMILY__) && defined(__xlC__)
/*
 * Suppress XLC warnings
 */
#pragma report(disable, CPPC5334)
#pragma report(disable, CPPC5328)
#endif

namespace SAMRAI {
namespace mesh {


// Round a to the nearest higher integer divisible by b.  This should work even for a < 0.
#define ROUND_TO_HI(a,b) ((a)-((((a)%(b))-(b))%(b)))
// Round a to the nearest lower integer divisible by b.  This should work even for a < 0.
#define ROUND_TO_LO(a,b) ((a)-((((a)%(b))+(b))%(b)))


/*
 *************************************************************************
 * Master method for breaking off a load.
 *
 * Try different heuristics and pick the "best" way to break off a
 * load.  The best is defined as the one with the lowest combined
 * penalty.
 *
 * This method always return a breakage if at all possible, without
 * considering whether the break should be used.  For example,
 * requesting breakage of 1 cell in a 100x100 box might return a
 * breakage of a 100-cells sliver!
 *
 * Return whether a successful break was made.
 *************************************************************************
 */
bool
BalanceBoxBreaker::breakOffLoad(
   std::vector<hier::Box>& breakoff,
   std::vector<hier::Box>& leftover,
   double& brk_load,
   const hier::Box& box,
   double ideal_load_to_break,
   double low_load,
   double high_load,
   double threshold_width ) const
{
   TBOX_ASSERT(ideal_load_to_break > 0);

   /*
    * NOTE: We need in this method a way to weigh the
    * value of proximity to the ideal breakoff vs the
    * increased area of the cuts.  However, the weight
    * given to area-optimized cuts should be considered
    * only with real application performance data.
    *
    * NOTE: We can compute the amount of new box boundaries
    * generated by computing the box boundary before and
    * after, and subtracting.  Easier than reconstructing
    * the cuts from the box definitions.
    *
    * NOTE: We should weight negatively the production of
    * high surface-to-volume boxes.
    */

   t_break_off_load->start();

   breakoff.clear();
   leftover.clear();


   /*
    * To avoid repeated computations of bad cuts,
    * we precompute bad_cuts here to provide to
    * methods that actually use the information.
    */
   std::vector<std::vector<bool> > bad_cuts(box.getDim().getValue());
   t_find_bad_cuts->start();
   hier::BoxUtilities::findBadCutPoints(
      bad_cuts,
      box,
      d_pparams->getDomainBoxes(box.getBlockId()),
      d_pparams->getBadInterval());
   t_find_bad_cuts->stop();

   // Penalty for not transfering ideal load.
   double best_balance_penalty = computeBalancePenalty(ideal_load_to_break);

   if (d_print_break_steps) {
      tbox::plog.unsetf(std::ios::fixed | std::ios::scientific);
      tbox::plog.precision(6);
      tbox::plog << "      pre-break imbalance: " << ideal_load_to_break
                 << " balance penalty: " << best_balance_penalty
                 << std::endl;
   }

   brk_load = 0;
   bool found_any_break = false;

   {
      std::vector<hier::Box> planar_breakoff;
      std::vector<hier::Box> planar_leftover;
      double planar_brk_load;

      bool found_this_break = breakOffLoad_planar(
            planar_breakoff,
            planar_leftover,
            planar_brk_load,
            box,
            ideal_load_to_break,
            low_load,
            high_load,
            bad_cuts );

      if (found_this_break) {

         found_any_break = true;

         double planar_balance_penalty = computeBalancePenalty(
               static_cast<double>(planar_brk_load - ideal_load_to_break));

         if (d_print_break_steps) {
            tbox::plog.unsetf(std::ios::fixed | std::ios::scientific);
            tbox::plog.precision(6);
            tbox::plog << "      breakOffLoad_planar broke off "
                       << planar_brk_load << " / " << ideal_load_to_break
                       << " from " << box << '|'
                       << box.numberCells() << '|'
                       << box.size() << " into "
                       << planar_breakoff.size()
                       << " breakoff: ";
            for (std::vector<hier::Box>::const_iterator bi =
                    planar_breakoff.begin();
                 bi != planar_breakoff.end();
                 ++bi) {
               tbox::plog << " " << *bi << '|' << bi->numberCells() << '|'
                          << bi->size();
            }
            tbox::plog << "\n        and " << planar_leftover.size()
                       << " leftover boxes:";
            for (std::vector<hier::Box>::const_iterator bi =
                    planar_leftover.begin();
                 bi != planar_leftover.end();
                 ++bi) {
               tbox::plog << " " << *bi << '|' << bi->numberCells() << '|'
                          << bi->size();
            }
            tbox::plog << "\n        imbalance: "
                       << (planar_brk_load - ideal_load_to_break)
                       << " balance penalties: "
                       << planar_balance_penalty
                       << std::endl;
         }


         int break_acceptance_flags[4] = {0,0,0,0};

         const bool accept_break = BalanceUtilities::compareLoads(
            break_acceptance_flags, brk_load, planar_brk_load,
            ideal_load_to_break, low_load, high_load, *d_pparams );
         if (d_print_break_steps) {
            tbox::plog << "      Break evaluation:"
                       << "  " << break_acceptance_flags[0]
                       << "  " << break_acceptance_flags[1]
                       << "  " << break_acceptance_flags[2]
                       << std::endl;
         }

         if (accept_break) {
            if (d_print_break_steps) {
               tbox::plog << "      Keeping planar cut result."
                          << "  " << planar_breakoff.size() << " boxes broken off."
                          << "  " << planar_leftover.size() << " boxes leftover."
                          << std::endl;
            }
            breakoff.swap(planar_breakoff);
            leftover.swap(planar_leftover);
            brk_load = planar_brk_load;
            best_balance_penalty = planar_balance_penalty;
         } else {
            if (d_print_break_steps) {
               tbox::plog << "      Rejecting planar cut result." << std::endl;
            }
         }

      }
   }

   /*
    * If above cut algorithms fail to break or improve the penalty, try
    * more cutting algorithms.
    */
   {

      std::vector<hier::Box> cubic_breakoff;
      std::vector<hier::Box> cubic_leftover;
      double cubic_brk_load;

      bool found_this_break = breakOffLoad_cubic(
            cubic_breakoff,
            cubic_leftover,
            cubic_brk_load,
            box,
            ideal_load_to_break,
            low_load,
            high_load,
            bad_cuts );

      if (found_this_break) {

         found_any_break = true;

         double cubic_balance_penalty = computeBalancePenalty(
            static_cast<double>(cubic_brk_load - ideal_load_to_break));

         if (d_print_break_steps) {
            tbox::plog.unsetf(std::ios::fixed | std::ios::scientific);
            tbox::plog.precision(6);
            tbox::plog << "      breakOffLoad_cubic broke off "
                       << cubic_brk_load << " / " << ideal_load_to_break
                       << " from " << box << '|'
                       << box.numberCells() << '|'
                       << box.size() << " into "
                       << cubic_breakoff.size()
                       << " breakoff: ";
            for (std::vector<hier::Box>::const_iterator bi =
                    cubic_breakoff.begin();
                 bi != cubic_breakoff.end();
                 ++bi) {
               tbox::plog << " " << *bi << '|' << bi->numberCells() << '|'
                          << bi->size();
            }
            tbox::plog << "\n        and " << cubic_leftover.size()
                       << " leftover boxes:";
            for (std::vector<hier::Box>::const_iterator bi =
                    cubic_leftover.begin();
                 bi != cubic_leftover.end();
                 ++bi) {
               tbox::plog << " " << *bi << '|' << bi->numberCells() << '|'
                          << bi->size();
            }
            tbox::plog << "\n        imbalance: "
                       << (cubic_brk_load - ideal_load_to_break)
                       << " balance penalties: "
                       << cubic_balance_penalty
                       << std::endl;
         }

         int break_acceptance_flags[4] = {0,0,0,0};

         const bool accept_break = BalanceUtilities::compareLoads(
            break_acceptance_flags, brk_load, cubic_brk_load,
            ideal_load_to_break, low_load, high_load, *d_pparams );
         if (d_print_break_steps) {
            tbox::plog << "      Break evaluation:"
                       << "  " << break_acceptance_flags[0]
                       << "  " << break_acceptance_flags[1]
                       << "  " << break_acceptance_flags[2]
                       << std::endl;
         }

         if (accept_break) {
            if (d_print_break_steps) {
               tbox::plog << "      choosing breakOffLoad_cubic result."
                          << "  " << cubic_breakoff.size() << " boxes broken off."
                          << "  " << cubic_leftover.size() << " boxes leftover."
                          << std::endl;
            }
            breakoff.swap(cubic_breakoff);
            leftover.swap(cubic_leftover);
            brk_load = cubic_brk_load;
            best_balance_penalty = cubic_balance_penalty;
         } else {
            if (d_print_break_steps) {
               tbox::plog << "      Rejecting cubic cut result." << std::endl;
            }
         }
      } else {
         if (d_print_break_steps) {
            tbox::plog << "      breakOffLoad_cubic could not break "
                       << ideal_load_to_break << " from " << box
                       << '/' << box.numberCells()
                       << '/' << box.numberCells().getProduct()
                       << std::endl;
         }
      }

   }

   t_break_off_load->stop();

   return found_any_break;
}



/*
 *************************************************************************
 * Break off a load from a box by making a single planar cut across
 * the box's longest direction.
 *
 * Currently assuming uniform load of one unit per cell.
 *
 * Return whether a successful break was made.
 *************************************************************************
 */
bool
BalanceBoxBreaker::breakOffLoad_planar(
   std::vector<hier::Box>& breakoff,
   std::vector<hier::Box>& leftover,
   double& brk_load,
   const hier::Box& box,
   double ideal_brk_load,
   double low_load,
   double high_load,
   const std::vector<std::vector<bool> >& bad_cuts ) const
{

   const tbox::Dimension dim(box.getDim());

   if (d_print_break_steps) {
      tbox::plog << "      breakOffLoad_planar attempting to break "
                 << ideal_brk_load << " from Box "
                 << box << box.numberCells() << '|' << box.size()
                 << " min_size=" << d_pparams->getMinBoxSize() << std::endl;
   }

   breakoff.clear();
   leftover.clear();

   const hier::IntVector& box_dims = box.numberCells();

   const int box_vol = box_dims.getProduct();

   if (box_vol <= ideal_brk_load) {
      // Easy: break off everything.
      breakoff.push_back(box);
      brk_load = box_vol;
      if (d_print_break_steps) {
         tbox::plog << "      breakOffLoad_planar broke off entire Box "
                    << box
                    << std::endl;
      }
      return true;
   }

   /*
    * Determine ordering of box_dims from shortest to longest.
    */
   hier::IntVector sorted_dirs(dim);
   sorted_dirs.sortIntVector(box_dims);

   hier::Box best_breakoff_box(dim);
   hier::Box best_leftover_box(dim);
   best_breakoff_box.setBlockId(box.getBlockId());
   best_leftover_box.setBlockId(box.getBlockId());
   brk_load = 0;

   int break_acceptance_flags[4] = {0,0,0,0};
   bool sufficient_brk_load = false;

   for (int d = box.getDim().getValue() - 1; d >= 0 && !sufficient_brk_load; --d) {

      /*
       * Search directions from longest to shortest because we prefer
       * to break across longer directions.
       */
      const int brk_dir = sorted_dirs(d);

      const int brk_area = box_vol / box_dims(brk_dir);

      const std::vector<bool>& bad = bad_cuts[brk_dir];

      const double ideal_cut_length = double(ideal_brk_load)/brk_area;

      /*
       * Try 4 different cuts for direction brk_dir:
       * upper/lower: should we break off the upper end or lower end of the box.
       * hi/lo: should we round the break plane to the high or low side.
       *
       * plane refers to the index of the mesh line where the cut is.
       *
       * offset refers to a cut plane index relative to the box's lower corner.
       */

      // Ideal cut planes, not necessarily coincident with a grid line.
      const double ideal_upper_cut_offset = box.numberCells(brk_dir) - ideal_cut_length;
      const double ideal_lower_cut_offset = ideal_cut_length;

      // Compute valid cut planes on high and low sides of upper cut plane.
      int lo_upper_cut_plane = box.lower()(brk_dir) + int(ideal_upper_cut_offset);
      int hi_upper_cut_plane = box.lower()(brk_dir) + int(ideal_upper_cut_offset) + 1;
      lo_upper_cut_plane = ROUND_TO_LO(lo_upper_cut_plane, d_pparams->getCutFactor()(brk_dir));
      hi_upper_cut_plane = ROUND_TO_HI(hi_upper_cut_plane, d_pparams->getCutFactor()(brk_dir));
      while ( lo_upper_cut_plane > box.lower()(brk_dir)   && bad[lo_upper_cut_plane-box.lower()(brk_dir)] ) { lo_upper_cut_plane -= d_pparams->getCutFactor()(brk_dir); }
      while ( hi_upper_cut_plane < box.upper()(brk_dir)+1 && bad[hi_upper_cut_plane-box.lower()(brk_dir)] ) { hi_upper_cut_plane += d_pparams->getCutFactor()(brk_dir); }

      // Compute valid cut planes on high and low sides of lower cut plane.
      int lo_lower_cut_plane = box.lower()(brk_dir) + int(ideal_lower_cut_offset);
      int hi_lower_cut_plane = box.lower()(brk_dir) + int(ideal_lower_cut_offset) + 1;
      lo_lower_cut_plane = ROUND_TO_LO(lo_lower_cut_plane, d_pparams->getCutFactor()(brk_dir));
      hi_lower_cut_plane = ROUND_TO_HI(hi_lower_cut_plane, d_pparams->getCutFactor()(brk_dir));
      while ( lo_lower_cut_plane > box.lower()(brk_dir)   && bad[lo_lower_cut_plane-box.lower()(brk_dir)] ) { lo_lower_cut_plane -= d_pparams->getCutFactor()(brk_dir); }
      while ( hi_lower_cut_plane < box.upper()(brk_dir)+1 && bad[hi_lower_cut_plane-box.lower()(brk_dir)] ) { hi_lower_cut_plane += d_pparams->getCutFactor()(brk_dir); }


      if ( lo_lower_cut_plane - box.lower()(brk_dir) > d_pparams->getMinBoxSize()(brk_dir) &&
           box.upper()(brk_dir)+1 - lo_lower_cut_plane > d_pparams->getMinBoxSize()(brk_dir) ) {

         const int lo_lower_cut_vol = brk_area*( lo_lower_cut_plane - box.lower()(brk_dir) );

         if ( BalanceUtilities::compareLoads(
                 break_acceptance_flags, brk_load,
                 lo_lower_cut_vol, ideal_brk_load,
                 low_load, high_load, *d_pparams ) ) {
            brk_load = lo_lower_cut_vol;
            best_breakoff_box = best_leftover_box = box;
            best_breakoff_box.upper()(brk_dir) = lo_lower_cut_plane - 1;
            best_leftover_box.lower()(brk_dir) = lo_lower_cut_plane;
            TBOX_ASSERT( best_breakoff_box.size() == lo_lower_cut_vol );
         }
      }

      if ( ( hi_lower_cut_plane - box.lower()(brk_dir) > d_pparams->getMinBoxSize()(brk_dir) &&
           box.upper()(brk_dir)+1 - hi_lower_cut_plane > d_pparams->getMinBoxSize()(brk_dir) ) ||
           hi_lower_cut_plane >= box.upper()(brk_dir)+1 ) {

         const int hi_lower_cut_vol = brk_area*( hi_lower_cut_plane - box.lower()(brk_dir) );

         if ( BalanceUtilities::compareLoads(
                 break_acceptance_flags, brk_load,
                 hi_lower_cut_vol, ideal_brk_load,
                 low_load, high_load, *d_pparams ) ) {
            brk_load = hi_lower_cut_vol;
            best_breakoff_box = best_leftover_box = box;
            best_breakoff_box.upper()(brk_dir) = hi_lower_cut_plane - 1;
            best_leftover_box.lower()(brk_dir) = hi_lower_cut_plane;
            TBOX_ASSERT( best_breakoff_box.size() == hi_lower_cut_vol );
         }
      }

      if ( ( box.upper()(brk_dir)+1 - lo_upper_cut_plane > d_pparams->getMinBoxSize()(brk_dir) &&
           lo_upper_cut_plane - box.lower()(brk_dir) > d_pparams->getMinBoxSize()(brk_dir) ) ||
           lo_upper_cut_plane <= box.lower()(brk_dir) ) {

         const int lo_upper_cut_vol = brk_area*( box.upper()(brk_dir)+1 - lo_upper_cut_plane );

         if ( BalanceUtilities::compareLoads(
                 break_acceptance_flags, brk_load,
                 lo_upper_cut_vol, ideal_brk_load,
                 low_load, high_load, *d_pparams ) ) {
            brk_load = lo_upper_cut_vol;
            best_breakoff_box = best_leftover_box = box;
            best_breakoff_box.lower()(brk_dir) = lo_upper_cut_plane;
            best_leftover_box.upper()(brk_dir) = lo_upper_cut_plane - 1;
            TBOX_ASSERT( best_breakoff_box.size() == lo_upper_cut_vol );
         }
      }

      if ( box.upper()(brk_dir)+1 - hi_upper_cut_plane > d_pparams->getMinBoxSize()(brk_dir) &&
           hi_upper_cut_plane - box.lower()(brk_dir) > d_pparams->getMinBoxSize()(brk_dir) ) {

         const int hi_upper_cut_vol = brk_area*( box.upper()(brk_dir)+1 - hi_upper_cut_plane );

         if ( BalanceUtilities::compareLoads(
                 break_acceptance_flags, brk_load,
                 hi_upper_cut_vol, ideal_brk_load,
                 low_load, high_load, *d_pparams ) ) {
            brk_load = hi_upper_cut_vol;
            best_breakoff_box = best_leftover_box = box;
            best_breakoff_box.lower()(brk_dir) = hi_upper_cut_plane;
            best_leftover_box.upper()(brk_dir) = hi_upper_cut_plane - 1;
            TBOX_ASSERT( best_breakoff_box.size() == hi_upper_cut_vol );
         }
      }

      sufficient_brk_load = (brk_load >= low_load) && (brk_load <= high_load);

   }

   bool successful_break = false;
   if (!best_breakoff_box.empty()) {
      breakoff.push_back(best_breakoff_box);
      TBOX_ASSERT( brk_load == best_breakoff_box.size() );
      successful_break = true;
      if (d_print_break_steps) {
         tbox::plog << "      breakOffLoad_planar broke box " << box << box.numberCells()
                    << " for breakoff box " << best_breakoff_box << best_breakoff_box.numberCells()
                    << " and leftover " << best_leftover_box << best_leftover_box.numberCells()
                    << std::endl;
      }
   } else {
      if (d_print_break_steps) {
         tbox::plog << "      breakOffLoad_planar could not break "
                    << ideal_brk_load << " from Box " << box
                    << std::endl;
      }
   }
   if (!best_leftover_box.empty()) {
      leftover.push_back(best_leftover_box);
   }

#ifdef DEBUG_CHECK_ASSERTIONS
   for (std::vector<hier::Box>::iterator bi = breakoff.begin();
        bi != breakoff.end();
        ++bi) {
      const hier::Box& b = *bi;
      const hier::IntVector s = b.numberCells();
      for (int d = 0; d < box.getDim().getValue(); ++d) {
         if (((s(d) < d_pparams->getMinBoxSize()(d)) && (s(d) != box_dims(d))) ||
             (s(d) > box_dims(d))) {
            TBOX_ERROR("BalanceBoxBreaker library error:\n"
               << "breakoff box " << b << ", size " << s
               << "\nis not between the min size " << d_pparams->getMinBoxSize()
               << "\nand the original box size " << box_dims << "\n"
               << "break box size " << best_breakoff_box.numberCells() << "\n"
               << "ideal brk load " << ideal_brk_load);
         }
      }
   }
   for (std::vector<hier::Box>::iterator bi = leftover.begin();
        bi != leftover.end();
        ++bi) {
      const hier::Box& b = *bi;
      const hier::IntVector s = b.numberCells();
      for (int d = 0; d < box.getDim().getValue(); ++d) {
         if (((s(d) < d_pparams->getMinBoxSize()(d)) && (s(d) != box_dims(d))) ||
             (s(d) > box_dims(d))) {
            TBOX_ERROR("BalanceBoxBreaker library error:\n"
               << "leftover box " << b << ", size " << s
               << "\nis not between the min size " << d_pparams->getMinBoxSize()
               << "\nand the original box size " << box_dims << "\n"
               << "break box size " << best_breakoff_box.numberCells() << "\n"
               << "ideal brk load " << ideal_brk_load);
         }
      }
   }
#endif

   return successful_break;
}



/*
 *************************************************************************
 * Break off a load from a box by making a box cut that is as close
 * to cubic as feasible.
 *
 * Currently assuming uniform load of one unit per cell.
 *
 * Return whether a successful break was made.
 *
 * Differs from breakOffLoad in that it will always
 * performs a break and if needed, break off more than
 * the ideal.  The calling method should take this into
 * account.
 *************************************************************************
 */
bool
BalanceBoxBreaker::breakOffLoad_cubic(
   std::vector<hier::Box>& breakoff,
   std::vector<hier::Box>& leftover,
   double& brk_load,
   const hier::Box& box,
   double ideal_brk_load,
   double low_load,
   double high_load,
   const std::vector<std::vector<bool> >& bad_cuts ) const
{

   const hier::IntVector box_dims(box.numberCells());

   const double box_load(box_dims.getProduct());

   if (ideal_brk_load >= box_load) {
      // Easy: break off everything.
      leftover.clear();
      breakoff.clear();
      breakoff.push_back(box);
      brk_load = box_load;
      if (d_print_break_steps) {
         tbox::plog << "      breakOffLoad_cubic broke off entire Box "
                    << box
                    << std::endl;
      }
      return true;
   }

   if (ideal_brk_load > 0.5 * box_load) {
      /*
       * This algorithm is better when breaking off a small portion.
       * Since the ideal is a bigger portion, switch breakoff with leftover.
       */
      if (d_print_break_steps) {
         tbox::plog
         << "      breakOffLoad_cubic reversing direction to break "
         << (box_dims.getProduct() - ideal_brk_load)
         << " instead of " << ideal_brk_load << " / "
         << box_dims.getProduct() << std::endl;
      }
      bool success =
         breakOffLoad_cubic(
            leftover,
            breakoff,
            brk_load,
            box,
            box_dims.getProduct() - ideal_brk_load,
            box_dims.getProduct() - high_load,
            box_dims.getProduct() - low_load,
            bad_cuts );
      if (success) {
         brk_load = box_dims.getProduct() - brk_load;
      }
      return success;
   }

   if (d_print_break_steps) {
      tbox::plog << "      breakOffLoad_cubic attempting to break "
                 << ideal_brk_load << " from Box "
                 << box << box.numberCells() << '|' << box.size()
                 << " min_size=" << d_pparams->getMinBoxSize() << std::endl;
   }

   breakoff.clear();
   leftover.clear();
   brk_load = 0.0;

   const hier::IntVector &one_vec = hier::IntVector::getOne(box.getDim());
   const hier::IntVector &zero_vec = hier::IntVector::getZero(box.getDim());

   hier::Box best_breakoff_box(box.getDim());
   hier::IntVector best_breakoff_size = zero_vec;
   double best_breakoff_load = 0;

   /*
    * We consider 2^dim boxes grown from the incoming box's corners.
    * Imagine 2 cutting planes per dimension, perpendicular to each
    * axis, an upper cut and a lower cut.  The box is cut into 3 parts
    * in each direction, so the 2*dim planes divide the box into 3^dim
    * boxes.
    *
    * 2D example:
    *
    *       +-----------------+
    *       |    |        |   |
    *       |----+--------+---|
    *       |    |        |   |
    *       |    |        |   |
    *       |    |        |   |
    *       |    |        |   |
    *       |----+--------+---|
    *       |    |        |   |
    *       +-----------------+
    *
    * upper_intersection is the point where all upper cuts intersect.
    * lower_intersection is the point where all lower cuts intersect.
    * We only consider the cut boxes that touch the incoming box's
    * corners.  Using the other boxes result in too much fragmentation
    * of the incoming box.
    */
   hier::IntVector brk_size(d_pparams->getMinBoxSize());
   brk_size.max(d_pparams->getCutFactor());
   brk_size.min(box_dims);

   /*
    * Make sure brk_size is a multiple of d_pparams->getCutFactor().
    */
   for (int d = 0; d < box.getDim().getValue(); ++d) {
      if (brk_size(d) % d_pparams->getCutFactor()(d) != 0) {
         brk_size(d) = ((brk_size(d) / d_pparams->getCutFactor()(d)) + 1) * d_pparams->getCutFactor()(d);
      }
   }

   /*
    * Initialize the cut plane intersections.  We will grow the
    * corner boxes by gradually moving the intersections away
    * from their initial location.
    */
   hier::IntVector lower_intersection(box.lower() + d_pparams->getMinBoxSize());
   hier::IntVector upper_intersection(box.upper() - d_pparams->getMinBoxSize() + one_vec);
   for ( int d=0; d<box.getDim().getValue(); ++d ) {
      lower_intersection(d) = ROUND_TO_HI( lower_intersection(d),
                                           d_pparams->getCutFactor()(d) );
      upper_intersection(d) = ROUND_TO_LO( upper_intersection(d),
                                           d_pparams->getCutFactor()(d) );
   }


   const int num_corners = 1 << box.getDim().getValue();

   for ( int bn=0; bn<num_corners; ++bn ) {

      if ( d_print_break_steps ) {
         tbox::plog << "Examining corner box " << bn << std::endl;
      }

      /*
       * Compute initial box at corner bn and its expansion rate.
       */
      hier::Box corner_box(box);
      hier::IntVector corner_box_size = zero_vec;
      double corner_box_load = 0;
      hier::IntVector expansion_rate(box.getDim());

      for ( int d=0; d<box.getDim().getValue(); ++d ) {

         // In direction d, does corner_box touch the upper (vs lower) side of box:
         int touches_upper_side = bn & (1 << d) ;

         if ( touches_upper_side ) {
            corner_box.lower()(d) = upper_intersection(d);
            if ( corner_box.lower()(d) - box.lower()(d) < d_pparams->getMinBoxSize()(d) ) {
               corner_box.lower()(d) = box.lower()(d);
            }
            expansion_rate(d) = -d_pparams->getCutFactor()(d);
         }
         else {
            corner_box.upper()(d) = lower_intersection(d) - 1;
            if ( box.upper()(d) - corner_box.upper()(d) < d_pparams->getMinBoxSize()(d) ) {
               corner_box.upper()(d) = box.upper()(d);
            }
            expansion_rate(d) = d_pparams->getCutFactor()(d);
         }

      }

      corner_box_size = corner_box.numberCells();
      corner_box_load = corner_box.size();

      if ( d_print_break_steps ) {
         tbox::plog << "Initial corner box " << bn << " is " << corner_box << corner_box.numberCells() << '|' << corner_box.size() << std::endl;
      }


      int break_acceptance_flags[4] = {0,0,0,0};

      if ( BalanceUtilities::compareLoads(
              break_acceptance_flags, best_breakoff_load,
              corner_box_load, ideal_brk_load,
              low_load, high_load, *d_pparams) ) {
         best_breakoff_box = corner_box;
         best_breakoff_size = corner_box_size;
         best_breakoff_load = corner_box_load;
         if ( best_breakoff_load >= low_load && brk_load <= high_load ) {
            break;
         }
      }



      /*
       * stop_growing: whether corner_box_size is already
       * big engough so that it cannot not be grown without breaking
       * off too much.
       */
      hier::IntVector growable(box.getDim(), 1);
      for (int d = 0; d < box.getDim().getValue(); ++d) {
         growable[d] = corner_box_size[d] < box_dims[d];
      }

      while ( ( best_breakoff_load < low_load || best_breakoff_load > high_load ) &&
              corner_box_load < ideal_brk_load ) {
         /*
          * The while loop gradually increases corner_box to bring
          * its size closer to ideal_brk_load.  Stop loop when
          * its size is in the acceptable range or if increasing
          * it only takes it farther from ideal_brk_load.
          *
          * Select inc_dir, the direction to expand corner_box.  Use the
          * smallest direction that is still allowed to grow.
          */

         int inc_dir = -1;
         for (int d = 0; d < box.getDim().getValue(); ++d) {
            if ( growable(d) &&
                 (inc_dir == -1 || corner_box_size(d) < corner_box_size(inc_dir)) )
               inc_dir = d;
         }
         if (inc_dir == -1) break; // No growable direction.

         TBOX_ASSERT(corner_box_size(inc_dir) < box_dims(inc_dir));


         /*
          * Grow corner_box, but keep within boundary of box and
          * prevent remainder from violating min size.  Update growability.
          */
         if ( expansion_rate(inc_dir) > 0 ) {
            corner_box.upper()(inc_dir) = tbox::MathUtilities<int>::Min(
               corner_box.upper()(inc_dir) + expansion_rate(inc_dir),
               box.upper()(inc_dir) );
            if ( box.upper()(inc_dir) - corner_box.upper()(inc_dir) < d_pparams->getMinBoxSize()(inc_dir) ) {
               corner_box.upper()(inc_dir) = box.upper()(inc_dir);
            }
            growable(inc_dir) = corner_box.upper()(inc_dir) < box.upper()(inc_dir);
         }
         else {
            corner_box.lower()(inc_dir) = tbox::MathUtilities<int>::Max(
               corner_box.lower()(inc_dir) + expansion_rate(inc_dir),
               box.lower()(inc_dir) );
            if ( corner_box.lower()(inc_dir) - box.lower()(inc_dir) < d_pparams->getMinBoxSize()(inc_dir) ) {
               corner_box.lower()(inc_dir) = box.lower()(inc_dir);
            }
            growable(inc_dir) = corner_box.lower()(inc_dir) > box.lower()(inc_dir);
         }
         corner_box_size = corner_box.numberCells();
         corner_box_load = corner_box.size();

         if ( d_print_break_steps ) {
            tbox::plog << "Expand corner box " << bn << " to " << corner_box << corner_box.numberCells() << '|' << corner_box.size() << std::endl;
         }


         const bool accept_break = BalanceUtilities::compareLoads(
            break_acceptance_flags, best_breakoff_load, corner_box_load,
            ideal_brk_load, low_load, high_load, *d_pparams );

         if ( accept_break ) {
            best_breakoff_box = corner_box;
            best_breakoff_size = corner_box_size;
            best_breakoff_load = corner_box_load;
            if ( best_breakoff_load >= low_load && best_breakoff_load <= high_load ) {
               break;
            }
         }

      } // while loop

   } // bn loop


   if ( !best_breakoff_box.empty() ) {
      brk_load = best_breakoff_load;
      breakoff.push_back(best_breakoff_box);

      burstBox(
         leftover,
         box,
         best_breakoff_box );
   }

#ifdef DEBUG_CHECK_ASSERTIONS
   for (std::vector<hier::Box>::iterator bi = breakoff.begin();
        bi != breakoff.end();
        ++bi) {
      const hier::Box& b = *bi;
      const hier::IntVector s = b.numberCells();
      for (int d = 0; d < box.getDim().getValue(); ++d) {
         if (((s(d) < d_pparams->getMinBoxSize()(d)) && (s(d) != box_dims(d))) ||
             (s(d) > box_dims(d))) {
            TBOX_ERROR("BalanceBoxBreaker library error:\n"
               << "breakoff box " << b << ", with size " << s
               << "\nis not between the min size " << d_pparams->getMinBoxSize()
               << "\nand the original box size " << box_dims << "\n"
               << "orig box " << box << "\n"
               << "break box " << b << "\n"
               << "break box size " << b.size() << "\n"
               << "ideal brk load " << ideal_brk_load);
         }
      }
   }
   for (std::vector<hier::Box>::iterator bi = leftover.begin();
        bi != leftover.end();
        ++bi) {
      const hier::Box& b = *bi;
      const hier::IntVector s = b.numberCells();
      for (int d = 0; d < box.getDim().getValue(); ++d) {
         if (((s(d) < d_pparams->getMinBoxSize()(d)) && (s(d) != box_dims(d))) ||
             (s(d) > box_dims(d))) {
            TBOX_ERROR("BalanceBoxBreaker library error:\n"
               << "leftover box " << b << ", with size " << s
               << "\nis not between the min size " << d_pparams->getMinBoxSize()
               << "\nand the original box size " << box_dims << "\n"
               << "orig box " << box << "\n"
               << "break box " << b << "\n"
               << "break box size " << b.size() << "\n"
               << "ideal brk load " << ideal_brk_load);
         }
      }
   }
#endif

   return !breakoff.empty();
}



/*
 *************************************************************************
 * Break up box bursty against box solid and adds the pieces to list.
 * This version differs from that in BoxContainer in that it tries to
 * minimize slivers.
 *************************************************************************
 */

void
BalanceBoxBreaker::burstBox(
   std::vector<hier::Box>& boxes,
   const hier::Box& bursty,
   const hier::Box& solid ) const
{
   /*
    * This method lacks logic to handle the case of solid not being
    * completely inside bursty.  That feature is not currently needed.
    */
   TBOX_ASSERT(bursty.contains(solid));

   const hier::IntVector solid_size = solid.numberCells();

   boxes.clear();
   hier::Box cutme = bursty;
   while (!cutme.isSpatiallyEqual(solid)) {

      int cut_dir = 999999;
      bool cut_above_solid = false; // Whether to slice off the piece above solid (vs below).
      /*
       * Find direction and place to cut.  To minimize slivers, cut
       * from cutme the thickest slab (in direction normal to cut)
       * possible.
       */
      int slab_thickness = 0;
      for (int d = 0; d < solid_size.getDim().getValue(); ++d) {
         if (cutme.numberCells(d) > solid_size(d)) {
            const int thickness_from_upper_cut = cutme.upper() (d)
               - solid.upper() (d);
            if (thickness_from_upper_cut > slab_thickness) {
               slab_thickness = thickness_from_upper_cut;
               cut_dir = d;
               cut_above_solid = true;
            }
            const int thickness_from_lower_cut = solid.lower() (d)
               - cutme.lower() (d);
            if (thickness_from_lower_cut > slab_thickness) {
               slab_thickness = thickness_from_lower_cut;
               cut_dir = d;
               cut_above_solid = false;
            }
         }
      }
      TBOX_ASSERT(cut_dir >= 0 && cut_dir < solid_size.getDim().getValue());

      hier::Box removeme = cutme;
      if (cut_above_solid) {
         cutme.upper() (cut_dir) = solid.upper() (cut_dir);
         removeme.lower() (cut_dir) = solid.upper() (cut_dir) + 1;
      } else {
         cutme.lower() (cut_dir) = solid.lower() (cut_dir);
         removeme.upper() (cut_dir) = solid.lower() (cut_dir) - 1;
      }

      boxes.push_back(removeme);

   }

   if (d_print_break_steps) {
      tbox::plog << "      burstBox: " << bursty << " = " << solid;
      for (std::vector<hier::Box>::const_iterator bi = boxes.begin();
           bi != boxes.end();
           bi++) {
         tbox::plog << " + " << *bi;
      }
      tbox::plog << std::endl;
   }
#ifdef DEBUG_CHECK_ASSERTIONS
   for (std::vector<hier::Box>::const_iterator bi = boxes.begin();
        bi != boxes.end();
        bi++) {
      for (std::vector<hier::Box>::const_iterator bj = boxes.begin();
           bj != boxes.end();
           bj++) {
         if (bi != bj) {
            TBOX_ASSERT(!bi->intersects(*bj));
         }
      }
   }
   hier::BoxContainer l1(bursty);
   hier::BoxContainer l2(solid);
   for (std::vector<hier::Box>::const_iterator bi = boxes.begin();
        bi != boxes.end();
        bi++) {
      l2.pushFront(*bi);
   }
   l1.removeIntersections(l2);
   TBOX_ASSERT(l1.isEmpty());
   l2.removeIntersections(bursty);
   TBOX_ASSERT(l2.isEmpty());
#endif
}


/*
 *************************************************************************
 * Compute a box_size score that is low for box widths smaller than
 * some threshold_width.  Boxes longer than this are okay assuming
 * that they can be broken down further.  Boxes shorter than this are
 * undesirable because they lead to excessive box count and/or aspect
 * ratios.
 *************************************************************************
 */
double BalanceBoxBreaker::computeWidthScore(
   const hier::IntVector &box_size,
   double threshold_width ) const
{
   double width_score = 1.0;
   for ( int d=0; d<box_size.getDim().getValue(); ++d ) {
      double s = box_size(d)/threshold_width;
      s = tbox::MathUtilities<double>::Max( 1.0, s );
      // For non-linear scoring, try s = sqrt(s);
      width_score *= s;
   }
   return width_score;
}


/*
 *************************************************************************
 * Compute a size score for multiple boxes.  The combined score is the
 * produce of individual scores.
 *************************************************************************
 */
double BalanceBoxBreaker::computeWidthScore(
   const std::vector<hier::Box> &boxes,
   double threshold_width ) const
{
   double width_score = 1.0;
   for ( int i=0; i<boxes.size(); ++i ) {
      width_score *= computeWidthScore( boxes[i].numberCells(), threshold_width );
   }
   return width_score;
}


/*
 *************************************************************************
 *************************************************************************
 */
void BalanceBoxBreaker::setTimers()
{
   t_break_off_load = tbox::TimerManager::getManager()->
      getTimer("mesh::BalanceBoxBreaker::breakOffLoad()");
   t_find_bad_cuts = tbox::TimerManager::getManager()->
      getTimer("mesh::BalanceBoxBreaker::find_bad_cuts");
}

}
}

#if !defined(__BGL_FAMILY__) && defined(__xlC__)
/*
 * Suppress XLC warnings
 */
#pragma report(enable, CPPC5334)
#pragma report(enable, CPPC5328)
#endif

#endif
