/*************************************************************************
 *
 * This file is part of the SAMRAI distribution.  For full copyright
 * information, see COPYRIGHT and COPYING.LESSER.
 *
 * Copyright:     (c) 1997-2013 Lawrence Livermore National Security, LLC
 * Description:   Performance input file for TreeLoadBalancer
 *
 ************************************************************************/



Main {
   dim = 2

   base_name = "scaled_front.2d.treelb"
   log_all_nodes = TRUE

   // Balancer types: TreeLoadBalancer, ChopAndPackLoadBalancer
   load_balancer_type = "TreeLoadBalancer"

   /*
     Specify domain as a box array in the reference index space.
   */
   domain_boxes = [(0,0),(199,99)]

   /*
     Specify physical domain box.
   */
   xlo = 0.0, 0.0
   xhi = 4.0, 2.0

   /*
     Use num_procs_in_tile if you want to scale up the problem
     size by tiling the domain.  Tiling doubles the domain
     size one direction at a time, starting with the j-direction.

     When tiling, we keep constant the ratio of the domain size to
     num_procs_in_tile and double the domain as many times as needed
     for the number of MPI processes running.  We require that the
     number of MPI processes be a power-of-two times
     num_procs_in_tile.
   */
   num_procs_in_tile = 1

   /*
     Specify L0 layer as a box array in the reference index space.
     The L0 layer will be partitioned but its partitioning is not
     used in the performance test.

     If omitted, the L0 layer is the same as the domain.
   */
   // L0_boxes = [(0,0),(199,99)]

   /*
     Specify ghost-cell-width between L0 and unbalanced.
   */
   ghost_cell_width = 4, 4

   L1_box_gen_method = "PrebalanceBySinusoidalFront"

   PrebalanceByUserBoxes {
      /*
        Specify unbalanced layer as a box array in the reference index space.

        initial_owners are the ranks of the owners of all the initial balance boxes.
        By default, processor 0 owns all the initial balance boxes.
      */
      prebalance_boxes = [(0,0),(36,36)]
      // prebalance_boxes = [(0,0),(19,39)], [(20,0),(39,39)]
      initial_owners = 0
   }

   PrebalanceBySinusoidalFront {
      /*
        Specify unbalanced layer by tagging a set of sinusoidal fronts
        oriented in perpendicular to the x-axis.
      */
      efficiency_tol = 0.80
      combine_tol = 0.80
      tag_buffer = 4, 4
      SinusoidalFrontTagger {
         init_disp = 1.0, 1.0, 1.0
         period = 2.0, 4.0, 4.0
         amplitude = 0.5
      }
      BergerRigoutsos {
         sort_output_nodes = TRUE
         DEV_log_node_history = FALSE
         DEV_log_cluster_summary = TRUE
         DEV_log_cluster = FALSE
         // DEV_owner_mode = "SINGLE_OWNER"
         // DEV_algo_advance_mode = "SYNCHRONOUS"
      }
   }

   PrebalanceByShrinkingLevel {
      shrink_width = 10, 10
      BergerRigoutsos {
         sort_output_nodes = TRUE
         DEV_log_node_history = FALSE
         DEV_log_cluster_summary = TRUE
         DEV_log_cluster = FALSE
         // DEV_owner_mode = "SINGLE_OWNER"
         // DEV_algo_advance_mode = "SYNCHRONOUS"
      }
   }

}

TreeLoadBalancer {
  DEV_report_load_balance = FALSE // Reported in main
  DEV_balance_penalty_wt = 1.0
  DEV_surface_penalty_wt = 1.0
  DEV_slender_penalty_wt = 1.0
  DEV_precut_penalty_wt = 1.0

  // Debugging options
  DEV_check_map = FALSE
  DEV_check_connectivity = FALSE
  DEV_print_steps = FALSE
  DEV_print_swap_steps = FALSE
  DEV_print_break_steps = FALSE
  DEV_print_edge_steps = FALSE
}

TimerManager {
//   print_exclusive      = TRUE
   print_summed           = TRUE
   print_max              = TRUE
   print_threshold        = 0.
   timer_list             = "hier::*::*", "mesh::*::*", "apps::*::*"
}


PatchHierarchy {

   /*
     Specify number of levels (1, 2 or 3 for this test).
   */
   max_levels = 3

   largest_patch_size {
      level_0 = -1,-1
      // level_0 = 20,20
      // all finer levels will use same values as level_0...
   }
   smallest_patch_size {
      level_0 = 5,5
      // all finer levels will use same values as level_0...
   }
   ratio_to_coarser {
      level_1            = 3, 3
      level_2            = 3, 3
      level_3            = 2, 2
      //  etc.
   }

   allow_patches_smaller_than_ghostwidth = TRUE
   allow_patches_smaller_than_minimum_size_to_prevent_overlaps = TRUE
   proper_nesting_buffer = 1, 1
}
