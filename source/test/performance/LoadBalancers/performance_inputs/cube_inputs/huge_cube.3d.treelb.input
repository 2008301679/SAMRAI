/*************************************************************************
 *
 * This file is part of the SAMRAI distribution.  For full copyright 
 * information, see COPYRIGHT and COPYING.LESSER. 
 *
 * Copyright:     (c) 1997-2013 Lawrence Livermore National Security, LLC
 * Description:   Performance input file for TreeLoadBalancer 
 *
 ************************************************************************/



Main {
   dim = 3

   base_name = "huge_cube.3d.treelb"
   log_all_nodes = FALSE

   // Balancer types: TreeLoadBalancer, ChopAndPackLoadBalancer
   load_balancer_type = "TreeLoadBalancer"

   /*
     Specify domain as a box array in the reference index space.
   */
   domain_boxes = [(0,0,0),(199,199,199)]

   /*
     Specify ghost-cell-width between L0 and unbalanced.
   */
   ghost_cell_width = 4, 4, 4

   L1_box_gen_method = "PrebalanceByUserBoxes"

   PrebalanceByUserBoxes {
      /*
        Specify unbalanced layer as a box array in the reference index space.

        initial_owners are the ranks of the owners of all the initial balance boxes.
        By default, processor 0 owns all the initial balance boxes.
      */
      prebalance_boxes = [(10,10,10),(189,189,189)]
      initial_owners = 0
   }

   PrebalanceByShrinkingLevel {
      shrink_width = 10, 10
      BergerRigoutsos {
         sort_output_nodes = TRUE
         DEV_log_node_history = FALSE
         DEV_log_cluster_summary = TRUE
         DEV_log_cluster = FALSE
         // DEV_owner_mode = "SINGLE_OWNER"
         // DEV_algo_advance_mode = "SYNCHRONOUS"
      }
   }

}

TreeLoadBalancer {
  DEV_report_load_balance = FALSE // Reported in main
  DEV_balance_penalty_wt = 1.0
  DEV_surface_penalty_wt = 1.0
  DEV_slender_penalty_wt = 1.0
  DEV_precut_penalty_wt = 1.0

  // Debugging options
  DEV_check_map = FALSE
  DEV_check_connectivity = FALSE
  DEV_print_steps = FALSE
  DEV_print_swap_steps = FALSE
  DEV_print_break_steps = FALSE
  DEV_print_edge_steps = FALSE
}

TimerManager {
//   print_exclusive      = TRUE
   print_summed           = TRUE
   print_max              = TRUE
   print_threshold        = 0.
   timer_list             = "hier::*::*", "mesh::*::*", "apps::*::*"
}


PatchHierarchy {

   /*
     Specify number of levels (1, 2 or 3 for this test).
   */
   max_levels = 2

   largest_patch_size {
      level_0 = -1,-1,-1
      // level_0 = 20,20,20
      // all finer levels will use same values as level_0...
   }
   smallest_patch_size {
      level_0 = 5,5,5
      // all finer levels will use same values as level_0...
   }
   ratio_to_coarser {
      level_1            = 3, 3, 3
      level_2            = 3, 3, 3
      level_3            = 2, 2, 2
      //  etc.
   }

   allow_patches_smaller_than_ghostwidth = TRUE
   allow_patches_smaller_than_minimum_size_to_prevent_overlaps = TRUE
   proper_nesting_buffer = 1, 1, 1
}
