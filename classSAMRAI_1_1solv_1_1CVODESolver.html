<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>SAMRAI: SAMRAI::solv::CVODESolver Class Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.7 -->
<div class="tabs">
  <ul>
    <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="namespaces.html"><span>Namespaces</span></a></li>
    <li id="current"><a href="annotated.html"><span>Classes</span></a></li>
    <li><a href="files.html"><span>Files</span></a></li>
    <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
  </ul></div>
<div class="tabs">
  <ul>
    <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
    <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
    <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
  </ul></div>
<div class="nav">
<a class="el" href="namespaceSAMRAI.html">SAMRAI</a>::<a class="el" href="namespaceSAMRAI_1_1solv.html">solv</a>::<a class="el" href="classSAMRAI_1_1solv_1_1CVODESolver.html">CVODESolver</a></div>
<h1>SAMRAI::solv::CVODESolver Class Reference</h1><!-- doxytag: class="SAMRAI::solv::CVODESolver" -->Class <a class="el" href="classSAMRAI_1_1solv_1_1CVODESolver.html">CVODESolver</a> serves as a C++ wrapper for the CVODE ordinary differential equation solver package.  
<a href="#_details">More...</a>
<p>
<code>#include &lt;source/SAMRAI/solv/CVODESolver.h&gt;</code>
<p>
<a href="classSAMRAI_1_1solv_1_1CVODESolver-members.html">List of all members.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1CVODESolver.html#f640a046e2a756c98a0d65e40a567841">CVODESolver</a> (const std::string &amp;object_name, <a class="el" href="classSAMRAI_1_1solv_1_1CVODEAbstractFunctions.html">CVODEAbstractFunctions</a> *my_functions, const bool uses_preconditioner)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1CVODESolver.html#19c76c484c10176c4cd84f5a074649d8">~CVODESolver</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1CVODESolver.html#f46b2e62c8aff2e5dbd611337e3cbffb">initialize</a> (<a class="el" href="classSAMRAI_1_1solv_1_1SundialsAbstractVector.html">SundialsAbstractVector</a> *solution)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1CVODESolver.html#a9034e37dbcc3a3d414e43e611fa3ae0">solve</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1CVODESolver.html#8f12a684c80d6da257b97b5c6441a694">setLogFileData</a> (const std::string &amp;log_fname=std::string())</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1CVODESolver.html#0e5a3871b89bfdb65f02d11fca4209fe">setCVODEFunctions</a> (<a class="el" href="classSAMRAI_1_1solv_1_1CVODEAbstractFunctions.html">CVODEAbstractFunctions</a> *my_functions, const bool uses_preconditioner)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classSAMRAI_1_1solv_1_1CVODEAbstractFunctions.html">CVODEAbstractFunctions</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1CVODESolver.html#96a0a9255fed2e28dbc0e50568579dcf">getCVODEFunctions</a> () const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1CVODESolver.html#3349215efc0342cad109e47c98449f86">setLinearMultistepMethod</a> (int linear_multistep_method)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1CVODESolver.html#b4ef6bbfb197584fd6fe0314487dbebe">setIterationType</a> (int iteration_type)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1CVODESolver.html#97d7e08e18c8fc65307c18133304acb1">setToleranceType</a> (int tolerance_type)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1CVODESolver.html#87e59db3a5e5ea1f16c7924fd8f27e93">setRelativeTolerance</a> (double relative_tolerance)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1CVODESolver.html#37b23a169437d798fe6fae127db619ad">setAbsoluteTolerance</a> (double absolute_tolerance)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1CVODESolver.html#70a77de797968f316d305dfb7082dfa3">setAbsoluteTolerance</a> (<a class="el" href="classSAMRAI_1_1solv_1_1SundialsAbstractVector.html">SundialsAbstractVector</a> *absolute_tolerance)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1CVODESolver.html#4c7dd62716a239ec2c0168564d3cfacd">setSteppingMethod</a> (int stepping_method)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1CVODESolver.html#0ab445a0df1495c106092d84ed1faaa5">setInitialValueOfIndependentVariable</a> (double t_0)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1CVODESolver.html#e2842d0522603847039193dccfbfd0db">setFinalValueOfIndependentVariable</a> (double t_f, bool cvode_needs_initialization)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1CVODESolver.html#a8f2537f71e9c46689f08f32e9f52fb4">setInitialConditionVector</a> (<a class="el" href="classSAMRAI_1_1solv_1_1SundialsAbstractVector.html">SundialsAbstractVector</a> *ic_vector)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1CVODESolver.html#7fa220f18d340aea133c227f88684010">setMaximumLinearMultistepMethodOrder</a> (int max_order)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1CVODESolver.html#a68a494477159ef9abab777629fd16a2">setMaximumNumberOfInternalSteps</a> (int max_num_internal_steps)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1CVODESolver.html#024fd8957503e9b0614f5e74600881a3">setMaximumNumberOfNilStepWarnings</a> (int max_num_warnings)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1CVODESolver.html#3f87cd4e9de810f286da061e8de3c399">setInitialStepSize</a> (double init_step_size)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1CVODESolver.html#635b8c72916030b45d59ae113257630b">setMaximumAbsoluteStepSize</a> (double max_step_size)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1CVODESolver.html#391f381d1072b8f2e5394ec6df366ac3">setMinimumAbsoluteStepSize</a> (double min_step_size)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1CVODESolver.html#c009b00dbc79fbdb4856932db7f11386">setPreconditioningType</a> (int precondition_type)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1CVODESolver.html#7728d0cc5ec414840c551bc0432519ed">setGramSchmidtType</a> (int gs_type)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1CVODESolver.html#6434fdde8d7bc9ce33555480c12b7579">setMaxKrylovDimension</a> (int max_krylov_dim)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1CVODESolver.html#23a5887e91b67bd652554308b250cbd3">setCVSpgmrToleranceScaleFactor</a> (double tol_scale_factor)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classSAMRAI_1_1solv_1_1SundialsAbstractVector.html">SundialsAbstractVector</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1CVODESolver.html#20d8cc8b871135c07c39b2b7f5c35ae3">getSolutionVector</a> () const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1CVODESolver.html#3b9cee8dea1c0aae624e247806d9f933">getDkyVector</a> (double t, int k, <a class="el" href="classSAMRAI_1_1solv_1_1SundialsAbstractVector.html">SundialsAbstractVector</a> *dky) const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1CVODESolver.html#a4722bed5d9a6113a3dbe9f242b6a5fb">getActualFinalValueOfIndependentVariable</a> () const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1CVODESolver.html#91daa119a71f1fa19e683629575cb3c8">printStatistics</a> (std::ostream &amp;os) const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1CVODESolver.html#717edf83e22fc582d36b2a582327b2ab">printCVODEStatistics</a> (std::ostream &amp;os) const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1CVODESolver.html#52c75ba43c0718ce961934c8a7703810">getNumberOfInternalStepsTaken</a> () const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1CVODESolver.html#941ebc392c4612c1b096e66a0b78afc1">getNumberOfRHSFunctionCalls</a> () const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1CVODESolver.html#79abb165024c34b581c090d66a1e5502">getNumberOfLinearSolverSetupCalls</a> () const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1CVODESolver.html#edb190402c9d9875138397988b283338">getNumberOfNewtonIterations</a> () const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1CVODESolver.html#81751ec8f2656ded3d8c7ad27ac4825f">getNumberOfNonlinearConvergenceFailures</a> () const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1CVODESolver.html#9c9b2079851b1e3bdef82726643b75cb">getNumberOfLocalErrorTestFailures</a> () const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1CVODESolver.html#b94f2b66d802663ba1032d73f31efe2c">getOrderUsedDuringLastInternalStep</a> () const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1CVODESolver.html#ab7141183623b70e48a4ee4d9206745f">getOrderToBeUsedDuringNextInternalStep</a> () const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1CVODESolver.html#fee30149975009efb602671ca93bb5c5">getCVODEMemoryUsageForDoubles</a> () const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1CVODESolver.html#93057e16e70dedd1264747c8e90b6753">getCVODEMemoryUsageForIntegers</a> () const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1CVODESolver.html#63a5bfb0b71fb2c60076ae77e2960c48">getStepSizeForLastInternalStep</a> () const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1CVODESolver.html#625858f9a1b3b6d1d66182e31b81fa64">getStepSizeForNextInternalStep</a> () const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1CVODESolver.html#8d49e1aeede6a6125c2802e763c93fff">getCurrentInternalValueOfIndependentVariable</a> () const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1CVODESolver.html#ad683c6628c8f0a928f36e962a4d1fca">getCVODESuggestedToleranceScalingFactor</a> () const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1CVODESolver.html#7ce2d1ef47313daa66209f1476879c90">printCVSpgmrStatistics</a> (std::ostream &amp;os) const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1CVODESolver.html#39e4eec3b6337e16f33701d00b31d71e">getNumberOfPreconditionerEvaluations</a> () const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1CVODESolver.html#185cd82a514ce0b04c415182e05a9944">getNumberOfLinearIterations</a> () const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1CVODESolver.html#34eb1e54d4dc88462108f55431b6fde2">getNumberOfPrecondSolveCalls</a> () const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1CVODESolver.html#e8cf463127e3cb185f3787b63a572638">getNumberOfLinearConvergenceFailures</a> () const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1CVODESolver.html#6d7e51c8e72f0cb3df4946ceabf4a55a">getCVSpgmrMemoryUsageForDoubles</a> () const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1CVODESolver.html#4a49b33a006705baff5c5139ec3378cd">getCVSpgmrMemoryUsageForIntegers</a> () const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1CVODESolver.html#c595f1cab02118e007e32deff36f256b">printClassData</a> (std::ostream &amp;os) const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">const std::string &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1CVODESolver.html#6dc038cafb620533f33adcf5846375c6">getObjectName</a> () const </td></tr>

</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
Class <a class="el" href="classSAMRAI_1_1solv_1_1CVODESolver.html">CVODESolver</a> serves as a C++ wrapper for the CVODE ordinary differential equation solver package. 
<p>
It is intended to be sufficiently generic to be used independently of the <a class="el" href="namespaceSAMRAI.html">SAMRAI</a> framework. This class declares one private static member function to link the user-defined routine for right-hand side function evaluation and two private statice member functions to link the user-defined preconditioner setup and solve routines. The implementation of these functions is defined by the user in a subclass of the abstract base class <a class="el" href="classSAMRAI_1_1solv_1_1CVODEAbstractFunctions.html">CVODEAbstractFunctions</a>. The vector objects used within the solver are given in a subclass of the abstract class <a class="el" href="classSAMRAI_1_1solv_1_1SundialsAbstractVector.html">SundialsAbstractVector</a>. The <a class="el" href="classSAMRAI_1_1solv_1_1SundialsAbstractVector.html">SundialsAbstractVector</a> class defines the vector kernel operations required by the CVODE package so that they may be easily supplied by a user who opts not to use the vector kernel supplied by the CVODE package. (It should be noted that the vector kernel used by CVODE is the same as the one used by the other packages in the Sundials of solvers).<p>
Note that this class provides no input or restart capabilities and relies on CVODE for output reporting.<p>
<a class="el" href="classSAMRAI_1_1solv_1_1CVODESolver.html">CVODESolver</a> Usage:<p>
<ul>
<li>In order to use the <a class="el" href="classSAMRAI_1_1solv_1_1CVODESolver.html">CVODESolver</a>, the user must provide a concrete subclass of <a class="el" href="classSAMRAI_1_1solv_1_1CVODEAbstractFunctions.html">CVODEAbstractFunctions</a> abstract base class which defines the evaluateRHSFunction(), CVSpgmrPrecondSet(), and CVSpgmrPrecondSolve() methods.</li></ul>
<p>
<ul>
<li>Solving a system of ODEs using this CVODE C++ interface requires four main stages. First, a <a class="el" href="classSAMRAI_1_1solv_1_1CVODESolver.html">CVODESolver</a> object is created with a user-specified name and <a class="el" href="classSAMRAI_1_1solv_1_1CVODEAbstractFunctions.html">CVODEAbstractFunctions</a> object. Second, the user must specify the integration parameters that s/he wishes to use. Next, the user must call the <a class="el" href="classSAMRAI_1_1solv_1_1CVODESolver.html">CVODESolver</a> method initialize(solution_vector) with the <a class="el" href="classSAMRAI_1_1solv_1_1SundialsAbstractVector.html">SundialsAbstractVector</a> that s/he wants to put the solution in. Finally, the <a class="el" href="classSAMRAI_1_1solv_1_1CVODESolver.html#a9034e37dbcc3a3d414e43e611fa3ae0">solve()</a> method is invoked to solve the system of ODEs to the specified value of the independent variable.</li></ul>
<p>
<ul>
<li>The following is a list of integration parameters that must be specified by the user before calling the <a class="el" href="classSAMRAI_1_1solv_1_1CVODESolver.html#a9034e37dbcc3a3d414e43e611fa3ae0">solve()</a> method:</li></ul>
<p>
<ul>
<li>Either relative or absolute tolerance must be set - setRelativeTolerance(relative_tolerance), setAbsoluteTolerance(absolute_tolerance)</li></ul>
<p>
<ul>
<li>Initial value of independent variable - setInitialValueOfIndependentVariable(init_time)</li><li>Final value of independent variable - setFinalValueOfIndependentVariable(final_time cvode_needs_initialization)</li><li>Initial condition vector - setInitialConditionVector(ic_vector)</li></ul>
<p>
<ul>
<li>The following is a list of default values for integration parameters:</li></ul>
<p>
<ul>
<li><b>Linear</b> Multistep Method BDF</li></ul>
<p>
<ul>
<li><b>Iteration</b> Type FUNCTIONAL</li></ul>
<p>
<ul>
<li><b>Tolerance</b> Type SS (scalar relative and scalar absolute tolerances)</li></ul>
<p>
<ul>
<li><b>Relative</b> Tolerance 0.0</li></ul>
<p>
<ul>
<li><b>Scalar</b> Absolute Tolerance 0.0</li></ul>
<p>
<ul>
<li><b>Vector</b> Absolute Tolerance NULL</li></ul>
<p>
<ul>
<li><b>Stepping</b> Method NORMAL</li></ul>
<p>
<ul>
<li><b>Maximum</b> Order for Multistep Method 12 for ADAMS, 5 for BDF</li></ul>
<p>
<ul>
<li><b>Maximum</b> Number of Internal Steps 500</li></ul>
<p>
<ul>
<li><b>Maximum</b> Number of NIL Step Warnings 10</li></ul>
<p>
<ul>
<li><b>Initial</b> Step Size determined by CVODE</li></ul>
<p>
<ul>
<li><b>Maximum</b> Absolute Value of Step Size infinity</li></ul>
<p>
<ul>
<li><b>Minimum</b> Absolute Value of Step Size 0.0</li></ul>
<p>
<ul>
<li><b>CVSpgmr</b> Preconditioning Type NONE</li></ul>
<p>
<ul>
<li><b>CVSpgmr</b> Gram Schmidt Algorithm MODIFIED_GS</li></ul>
<p>
<ul>
<li><b>CVSpgmr</b> Maximum Krylov Dimension MIN(num_equations, CVSPGMR_MAXL=5)</li></ul>
<p>
<ul>
<li><b>CVSpgmr</b> Tolerance Scale Factor CVSPGMR_DELT = 0.05.</li></ul>
<p>
CVODE was developed in the Center for Applied Scientific Computing (CASC) at Lawrence Livermore National Laboratory (LLNL). Many of the comments in this class were taken verbatim from CVODE header files. For more information about CVODE and a complete description of the operations and data structures used by this class, see S.D. Cohen and A.C. Hindmarsh, "CVODE User Guide", UCRL-MA-118618, Lawrence Livermore National Laboratory, 1994.<p>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classSAMRAI_1_1solv_1_1CVODEAbstractFunctions.html">solv::CVODEAbstractFunctions</a> <p>
<a class="el" href="classSAMRAI_1_1solv_1_1SundialsAbstractVector.html">solv::SundialsAbstractVector</a> </dd></dl>

<p>
<hr><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" name="f640a046e2a756c98a0d65e40a567841"></a><!-- doxytag: member="SAMRAI::solv::CVODESolver::CVODESolver" ref="f640a046e2a756c98a0d65e40a567841" args="(const std::string &amp;object_name, CVODEAbstractFunctions *my_functions, const bool uses_preconditioner)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SAMRAI::solv::CVODESolver::CVODESolver           </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>object_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1solv_1_1CVODEAbstractFunctions.html">CVODEAbstractFunctions</a> *&nbsp;</td>
          <td class="paramname"> <em>my_functions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&nbsp;</td>
          <td class="paramname"> <em>uses_preconditioner</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Constructor for <a class="el" href="classSAMRAI_1_1solv_1_1CVODESolver.html">CVODESolver</a> sets default CVODE parameters and initializes the solver package with user-supplied functions <a class="el" href="classSAMRAI_1_1solv_1_1CVODESolver.html">CVODESolver</a> parameters may be changed later using member functions described below.<p>
Notes:<p>
<ul>
<li>The solution vector is not passed into the constructor. Before the solver can be used, the <a class="el" href="classSAMRAI_1_1solv_1_1CVODESolver.html#f46b2e62c8aff2e5dbd611337e3cbffb">initialize()</a> function must be called.</li></ul>
<p>
Assertion checks:<p>
<ul>
<li>my_functions must not be null</li></ul>
<p>
<ul>
<li>object_name must not be empty. </li></ul>

</div>
</div><p>
<a class="anchor" name="19c76c484c10176c4cd84f5a074649d8"></a><!-- doxytag: member="SAMRAI::solv::CVODESolver::~CVODESolver" ref="19c76c484c10176c4cd84f5a074649d8" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SAMRAI::solv::CVODESolver::~CVODESolver           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Virtual destructor for <a class="el" href="classSAMRAI_1_1solv_1_1CVODESolver.html">CVODESolver</a> closes the CVODE log file and frees the memory allocated for the CVODE memory record. 
</div>
</div><p>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="f46b2e62c8aff2e5dbd611337e3cbffb"></a><!-- doxytag: member="SAMRAI::solv::CVODESolver::initialize" ref="f46b2e62c8aff2e5dbd611337e3cbffb" args="(SundialsAbstractVector *solution)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::solv::CVODESolver::initialize           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1solv_1_1SundialsAbstractVector.html">SundialsAbstractVector</a> *&nbsp;</td>
          <td class="paramname"> <em>solution</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Initialize solver with solution vector. The solution vector is required to initialize the memory record used internally within CVODE. This routine must be called before the solver can be used.<p>
Assertion checks:<p>
<ul>
<li>the solution vector must not be null</li></ul>
<p>
<ul>
<li>the solution vector must not have already been set </li></ul>

</div>
</div><p>
<a class="anchor" name="a9034e37dbcc3a3d414e43e611fa3ae0"></a><!-- doxytag: member="SAMRAI::solv::CVODESolver::solve" ref="a9034e37dbcc3a3d414e43e611fa3ae0" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int SAMRAI::solv::CVODESolver::solve           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Integrate ODE system specified t_f. The integer return value is a termination code defined by CVODE. The following is a table of termination codes and a brief description of their meanings.<p>
CVODE Termination Codes:<p>
<ul>
<li><b>SUCCESS</b> (=0) CVode succeeded.</li></ul>
<p>
<ul>
<li><b>CVODE_NO_MEM</b> (=-1) The cvode_mem argument was NULL.</li></ul>
<p>
<ul>
<li><b>ILL_INPUT</b> (=-2) One of the inputs to CVode is illegal. This includes the situation when a component of the error weight vectors becomes &lt; 0 during internal time-stepping. The ILL_INPUT flag will also be returned if the linear solver routine CV--- (called by the user after calling CVodeMalloc) failed to set one of the linear solver-related fields in cvode_mem or if the linear solver's init routine failed. In any case, the user should see the printed error message for more details.</li></ul>
<p>
<ul>
<li><b>TOO_MUCH_WORK</b> (=-3) The solver took maxstep internal steps but could not reach t_f. The default value for mxstep is MXSTEP_DEFAULT = 500.</li></ul>
<p>
<ul>
<li><b>TOO_MUCH_ACC</b> (=-4) The solver could not satisfy the accuracy demanded by the user for some internal step.</li></ul>
<p>
<ul>
<li><b>ERR_FAILURE</b> (=-5) Error test failures occurred too many times (= MXNEF = 7) during one internal time step or occurred with |h| = hmin.</li></ul>
<p>
<ul>
<li><b>CONV_FAILURE</b> (=-6) Convergence test failures occurred too many times (= MXNCF = 10) during one internal time step or occurred with |h| = hmin.</li></ul>
<p>
<ul>
<li><b>SETUP_FAILURE</b> (=-7) The linear solver's setup routine failed in an unrecoverable manner.</li></ul>
<p>
<ul>
<li><b>SOLVE_FAILURE</b> (=-8) The linear solver's solve routine failed in an unrecoverable manner.</li></ul>
<p>
See cvode.h header file for more information about return values.<p>
If CVODE or CVSpgmr requires re-initialization, it is automatically done before the solve. This may be required if any of the CVODE or CVSpgmr data parameters have changed since the last call to the solver.<p>
Assertion checks:<p>
<ul>
<li>The user specified final value for the independent variable t must be greater than the specified initial value. </li></ul>

</div>
</div><p>
<a class="anchor" name="8f12a684c80d6da257b97b5c6441a694"></a><!-- doxytag: member="SAMRAI::solv::CVODESolver::setLogFileData" ref="8f12a684c80d6da257b97b5c6441a694" args="(const std::string &amp;log_fname=std::string())" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::solv::CVODESolver::setLogFileData           </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>log_fname</em> = <code>std::string()</code>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Accessor function for setting CVODE output log file name and output printing options. Output file name and options may be changed throughout run as desired.<p>
If the file name string is empty the default file name "cvode.log" is used. 
</div>
</div><p>
<a class="anchor" name="0e5a3871b89bfdb65f02d11fca4209fe"></a><!-- doxytag: member="SAMRAI::solv::CVODESolver::setCVODEFunctions" ref="0e5a3871b89bfdb65f02d11fca4209fe" args="(CVODEAbstractFunctions *my_functions, const bool uses_preconditioner)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::solv::CVODESolver::setCVODEFunctions           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1solv_1_1CVODEAbstractFunctions.html">CVODEAbstractFunctions</a> *&nbsp;</td>
          <td class="paramname"> <em>my_functions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&nbsp;</td>
          <td class="paramname"> <em>uses_preconditioner</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set <a class="el" href="classSAMRAI_1_1solv_1_1CVODESolver.html">CVODESolver</a> to use my_functions as the concrete subclass of the <a class="el" href="classSAMRAI_1_1solv_1_1CVODEAbstractFunctions.html">CVODEAbstractFunctions</a> class that defines the right-hand side evaluation and preconditioner functions. The uses_preconditioner argument indicates whether or not the the user has defined preconditioner routines in their concrete subclass of the <a class="el" href="classSAMRAI_1_1solv_1_1CVODEAbstractFunctions.html">CVODEAbstractFunctions</a> class.<p>
Assertion checks:<p>
<ul>
<li>my_function must not be a null pointer </li></ul>

</div>
</div><p>
<a class="anchor" name="96a0a9255fed2e28dbc0e50568579dcf"></a><!-- doxytag: member="SAMRAI::solv::CVODESolver::getCVODEFunctions" ref="96a0a9255fed2e28dbc0e50568579dcf" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSAMRAI_1_1solv_1_1CVODEAbstractFunctions.html">CVODEAbstractFunctions</a> * SAMRAI::solv::CVODESolver::getCVODEFunctions           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return pointer to object that provides user-defined functions for CVODE and CVSpgmr. 
</div>
</div><p>
<a class="anchor" name="3349215efc0342cad109e47c98449f86"></a><!-- doxytag: member="SAMRAI::solv::CVODESolver::setLinearMultistepMethod" ref="3349215efc0342cad109e47c98449f86" args="(int linear_multistep_method)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::solv::CVODESolver::setLinearMultistepMethod           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>linear_multistep_method</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set linear multistep method. The user can specify either ADAMS or BDF (backward differentiation formula) methods The BDF method is recommended for stiff problems, and the ADAMS method is recommended for nonstiff problems.<p>
Assertion checks:<p>
<ul>
<li>linear_multistep_method must be one of ADAMS or BDF.</li></ul>
<p>
Note: the enumeration constants ADAMS and BDF are defined in cvode.h. 
</div>
</div><p>
<a class="anchor" name="b4ef6bbfb197584fd6fe0314487dbebe"></a><!-- doxytag: member="SAMRAI::solv::CVODESolver::setIterationType" ref="b4ef6bbfb197584fd6fe0314487dbebe" args="(int iteration_type)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::solv::CVODESolver::setIterationType           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>iteration_type</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set iteration type. The user can specify either FUNCTIONAL iteration, which does not require linear algebra, or a NEWTON iteration, which requires the solution of linear systems. In the NEWTON case, the user must also specify a CVODE linear solver. NEWTON is recommended in case of stiff problems.<p>
Assertion checks:<p>
<ul>
<li>iteration_type must be one of FUNCTIONAL or NEWTON</li></ul>
<p>
Note: the enumeration constants FUNCTIONAL and NEWTON are defined in cvode.h. 
</div>
</div><p>
<a class="anchor" name="97d7e08e18c8fc65307c18133304acb1"></a><!-- doxytag: member="SAMRAI::solv::CVODESolver::setToleranceType" ref="97d7e08e18c8fc65307c18133304acb1" args="(int tolerance_type)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::solv::CVODESolver::setToleranceType           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>tolerance_type</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set tolerance type. This parameter specifies the relative and absolute tolerance types to be used. The SS tolerance type means a scalar relative and absolute tolerance, while the SV tolerance type means a scalar relative tolerance and a vector absolute tolerance (a potentially different absolute tolerance for each vector component).<p>
Assertion checks:<p>
<ul>
<li>tolerance_type must be one of SS or SV</li></ul>
<p>
Note: the enumeration constants SS and SV are defined in cvode.h. 
</div>
</div><p>
<a class="anchor" name="87e59db3a5e5ea1f16c7924fd8f27e93"></a><!-- doxytag: member="SAMRAI::solv::CVODESolver::setRelativeTolerance" ref="87e59db3a5e5ea1f16c7924fd8f27e93" args="(double relative_tolerance)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::solv::CVODESolver::setRelativeTolerance           </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>relative_tolerance</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set the relative tolerance level.<p>
Assertion checks:<p>
<ul>
<li>relative_tolerance must be greater than or equal to 0.0</li></ul>
<p>
Note that pure absolute tolerance can be used by setting the relative tolerance to 0. However, it is an error to simultaneously set relative and absolute tolerances to 0. 
</div>
</div><p>
<a class="anchor" name="37b23a169437d798fe6fae127db619ad"></a><!-- doxytag: member="SAMRAI::solv::CVODESolver::setAbsoluteTolerance" ref="37b23a169437d798fe6fae127db619ad" args="(double absolute_tolerance)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::solv::CVODESolver::setAbsoluteTolerance           </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>absolute_tolerance</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set the scalar absolute tolerance level.<p>
Assertion checks:<p>
<ul>
<li>absolute_tolerance must be greater than or equal to 0.0</li></ul>
<p>
Note that pure relative tolerance can be used by setting the absolute tolerance to 0. However, it is an error to simultaneously set relative and absolute tolerances to 0. 
</div>
</div><p>
<a class="anchor" name="70a77de797968f316d305dfb7082dfa3"></a><!-- doxytag: member="SAMRAI::solv::CVODESolver::setAbsoluteTolerance" ref="70a77de797968f316d305dfb7082dfa3" args="(SundialsAbstractVector *absolute_tolerance)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::solv::CVODESolver::setAbsoluteTolerance           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1solv_1_1SundialsAbstractVector.html">SundialsAbstractVector</a> *&nbsp;</td>
          <td class="paramname"> <em>absolute_tolerance</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set the vector absolute tolerance level.<p>
Assertion checks:<p>
<ul>
<li>absolute_tolerance must not be a null pointer</li></ul>
<p>
<ul>
<li>each component of absolute_tolerance must be greater than or equal to 0.0</li></ul>
<p>
Note that pure relative tolerance can be used by setting the absolute tolerance to 0. However, it is an error to simultaneously set relative and absolute tolerances to 0. 
</div>
</div><p>
<a class="anchor" name="4c7dd62716a239ec2c0168564d3cfacd"></a><!-- doxytag: member="SAMRAI::solv::CVODESolver::setSteppingMethod" ref="4c7dd62716a239ec2c0168564d3cfacd" args="(int stepping_method)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::solv::CVODESolver::setSteppingMethod           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>stepping_method</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set stepping method to use for integration. There are stepping methods: NORMAL and ONE_STEP. The NORMAL method has the solver take internal steps until it has reached or just passed the user specified t_f parameter. The solver then interpolates in order to return an approximate value of y(t_f). The ONE_STEP option tells the solver to just take one internal step and return the solution at the point reached by that step.<p>
Assertion checks:<p>
<ul>
<li>stepping_method must be one of NORMAL or ONE_STEP</li></ul>
<p>
Note: the enumeration constants NORMAL and ONE_STEP are defined in cvode.h. 
</div>
</div><p>
<a class="anchor" name="0ab445a0df1495c106092d84ed1faaa5"></a><!-- doxytag: member="SAMRAI::solv::CVODESolver::setInitialValueOfIndependentVariable" ref="0ab445a0df1495c106092d84ed1faaa5" args="(double t_0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::solv::CVODESolver::setInitialValueOfIndependentVariable           </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>t_0</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set initial value for independent variable. 
</div>
</div><p>
<a class="anchor" name="e2842d0522603847039193dccfbfd0db"></a><!-- doxytag: member="SAMRAI::solv::CVODESolver::setFinalValueOfIndependentVariable" ref="e2842d0522603847039193dccfbfd0db" args="(double t_f, bool cvode_needs_initialization)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::solv::CVODESolver::setFinalValueOfIndependentVariable           </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>t_f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>cvode_needs_initialization</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set final value for independent variable (i.e. the value of independent variable to integrate the system to). The boolean argument specifies whether CVODE should be re-initialized (i.e. on first step) or if we are taking subsequent steps in a sequence, in which case it is not initialized. 
</div>
</div><p>
<a class="anchor" name="a8f2537f71e9c46689f08f32e9f52fb4"></a><!-- doxytag: member="SAMRAI::solv::CVODESolver::setInitialConditionVector" ref="a8f2537f71e9c46689f08f32e9f52fb4" args="(SundialsAbstractVector *ic_vector)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::solv::CVODESolver::setInitialConditionVector           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1solv_1_1SundialsAbstractVector.html">SundialsAbstractVector</a> *&nbsp;</td>
          <td class="paramname"> <em>ic_vector</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set initial condition vector.<p>
Assertion checks:<p>
<ul>
<li>ic_vector must not be null </li></ul>

</div>
</div><p>
<a class="anchor" name="7fa220f18d340aea133c227f88684010"></a><!-- doxytag: member="SAMRAI::solv::CVODESolver::setMaximumLinearMultistepMethodOrder" ref="7fa220f18d340aea133c227f88684010" args="(int max_order)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::solv::CVODESolver::setMaximumLinearMultistepMethodOrder           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>max_order</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set maximum order for the linear multistep method. By default, this is set to 12 for ADAMS methods and 5 for BDF methods.<p>
Assertion checks:<p>
<ul>
<li>max_order must be greater than or equal to 0 </li></ul>

</div>
</div><p>
<a class="anchor" name="a68a494477159ef9abab777629fd16a2"></a><!-- doxytag: member="SAMRAI::solv::CVODESolver::setMaximumNumberOfInternalSteps" ref="a68a494477159ef9abab777629fd16a2" args="(int max_num_internal_steps)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::solv::CVODESolver::setMaximumNumberOfInternalSteps           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>max_num_internal_steps</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set maximum number of internal steps to be taken by the solver in its attempt to reach t_f. By default, this is set to 500.<p>
Assertion checks:<p>
<ul>
<li>max_num_internal_steps must be greater than or equal to 0 </li></ul>

</div>
</div><p>
<a class="anchor" name="024fd8957503e9b0614f5e74600881a3"></a><!-- doxytag: member="SAMRAI::solv::CVODESolver::setMaximumNumberOfNilStepWarnings" ref="024fd8957503e9b0614f5e74600881a3" args="(int max_num_warnings)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::solv::CVODESolver::setMaximumNumberOfNilStepWarnings           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>max_num_warnings</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set maximum number of warning messages issued by the solver that (t + h == t) on the next internal step. By default, this is set to 10.<p>
Assertion checks:<p>
<ul>
<li>max_num_warnings must be greater than or equal to 0 </li></ul>

</div>
</div><p>
<a class="anchor" name="3f87cd4e9de810f286da061e8de3c399"></a><!-- doxytag: member="SAMRAI::solv::CVODESolver::setInitialStepSize" ref="3f87cd4e9de810f286da061e8de3c399" args="(double init_step_size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::solv::CVODESolver::setInitialStepSize           </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>init_step_size</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set initial step size.<p>
Assertion checks:<p>
<ul>
<li>init_step_size must be greater than or equal to 0.0 </li></ul>

</div>
</div><p>
<a class="anchor" name="635b8c72916030b45d59ae113257630b"></a><!-- doxytag: member="SAMRAI::solv::CVODESolver::setMaximumAbsoluteStepSize" ref="635b8c72916030b45d59ae113257630b" args="(double max_step_size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::solv::CVODESolver::setMaximumAbsoluteStepSize           </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>max_step_size</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set maximum absolute value of step size allowed. By default, there is no upper bound on the absolute value of step size.<p>
Assertion checks:<p>
<ul>
<li>max_step_size must be greater than or equal to 0.0 </li></ul>

</div>
</div><p>
<a class="anchor" name="391f381d1072b8f2e5394ec6df366ac3"></a><!-- doxytag: member="SAMRAI::solv::CVODESolver::setMinimumAbsoluteStepSize" ref="391f381d1072b8f2e5394ec6df366ac3" args="(double min_step_size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::solv::CVODESolver::setMinimumAbsoluteStepSize           </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>min_step_size</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set minimum absolute value of step size allowed. By default, this is set to 0.0.<p>
Assertion checks:<p>
<ul>
<li>min_step_size must be greater than or equal to 0.0 </li></ul>

</div>
</div><p>
<a class="anchor" name="c009b00dbc79fbdb4856932db7f11386"></a><!-- doxytag: member="SAMRAI::solv::CVODESolver::setPreconditioningType" ref="c009b00dbc79fbdb4856932db7f11386" args="(int precondition_type)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::solv::CVODESolver::setPreconditioningType           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>precondition_type</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set the preconditioning type to be used by CVSpgmr. This must be one of the four enumeration constants NONE, LEFT, RIGHT, or BOTH defined in iterativ.h. These correspond to no preconditioning, left preconditioning only, right preconditioning only, and both left and right preconditioning, respectively.<p>
Assertion Checks:<p>
<ul>
<li>precondition_type must be one of NONE, LEFT, RIGHT, or BOTH. </li></ul>

</div>
</div><p>
<a class="anchor" name="7728d0cc5ec414840c551bc0432519ed"></a><!-- doxytag: member="SAMRAI::solv::CVODESolver::setGramSchmidtType" ref="7728d0cc5ec414840c551bc0432519ed" args="(int gs_type)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::solv::CVODESolver::setGramSchmidtType           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>gs_type</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set the Gram-Schmidt orthogonalization type to be used by CVSpgmr. This must be one of the two enumeration constants MODIFIED_GS or CLASSICAL_GS defined in iterativ.h. These correspond to using modified Gram-Schmidt and classical Gram-Schmidt, respectively.<p>
Assertion Checks:<p>
<ul>
<li>gs_type must be one of CLASSICAL_GS or MODIFIED_GS. </li></ul>

</div>
</div><p>
<a class="anchor" name="6434fdde8d7bc9ce33555480c12b7579"></a><!-- doxytag: member="SAMRAI::solv::CVODESolver::setMaxKrylovDimension" ref="6434fdde8d7bc9ce33555480c12b7579" args="(int max_krylov_dim)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::solv::CVODESolver::setMaxKrylovDimension           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>max_krylov_dim</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set the maximum Krylov dimension to be used by CVSpgmr. This is an optional input to the CVSPGMR solver. Pass 0 to use the default value MIN(num_equations, CVSPGMR_MAXL=5).<p>
Assertion Checks:<p>
<ul>
<li>max_krylov_dim must be nonnegative </li></ul>

</div>
</div><p>
<a class="anchor" name="23a5887e91b67bd652554308b250cbd3"></a><!-- doxytag: member="SAMRAI::solv::CVODESolver::setCVSpgmrToleranceScaleFactor" ref="23a5887e91b67bd652554308b250cbd3" args="(double tol_scale_factor)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::solv::CVODESolver::setCVSpgmrToleranceScaleFactor           </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>tol_scale_factor</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set the factor by which the tolerance on the nonlinear iteration is multiplied to get a tolerance on the linear iteration. This is an optional input to the CVSPGMR solver. Pass 0 to use the default value CVSPGMR_DELT = 0.05.<p>
Assertion Checks:<p>
<ul>
<li>tol_scale_factor must be nonnegative </li></ul>

</div>
</div><p>
<a class="anchor" name="20d8cc8b871135c07c39b2b7f5c35ae3"></a><!-- doxytag: member="SAMRAI::solv::CVODESolver::getSolutionVector" ref="20d8cc8b871135c07c39b2b7f5c35ae3" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSAMRAI_1_1solv_1_1SundialsAbstractVector.html">SundialsAbstractVector</a> * SAMRAI::solv::CVODESolver::getSolutionVector           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get solution vector. 
</div>
</div><p>
<a class="anchor" name="3b9cee8dea1c0aae624e247806d9f933"></a><!-- doxytag: member="SAMRAI::solv::CVODESolver::getDkyVector" ref="3b9cee8dea1c0aae624e247806d9f933" args="(double t, int k, SundialsAbstractVector *dky) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int SAMRAI::solv::CVODESolver::getDkyVector           </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1solv_1_1SundialsAbstractVector.html">SundialsAbstractVector</a> *&nbsp;</td>
          <td class="paramname"> <em>dky</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get k-th derivative vector at the specified value of the independent variable, t. The integer return value is return code the CVODE CVodeDky() function. The following is a table of termination codes and a brief description of their meanings.<p>
CVodeDky Return Codes:<p>
<ul>
<li><b>OKAY</b> (=0) CVodeDky succeeded.</li></ul>
<p>
<ul>
<li><b>BAD_K</b> (=-1)</li></ul>
<p>
<ul>
<li><b>BAD_T</b> (=-2)</li></ul>
<p>
<ul>
<li><b>BAD_DKY</b> (=-3)</li></ul>
<p>
<ul>
<li><b>DKY_NO_MEM</b> (=-4)</li></ul>
<p>
Important Notes:<p>
<ul>
<li>t must lie in the interval [t_cur - h, t_cur] where t_cur is the current internal time reached and h is the last internal step size successfully used by the solver.</li></ul>
<p>
<ul>
<li>k may take on value 0, 1, . . . q where q is the order of the current linear multistep method being used.</li></ul>
<p>
<ul>
<li>the dky vector must be allocated by the user.</li></ul>
<p>
<ul>
<li>it is only leagal to call this method after a successful return from the <a class="el" href="classSAMRAI_1_1solv_1_1CVODESolver.html#a9034e37dbcc3a3d414e43e611fa3ae0">solve()</a> method. </li></ul>

</div>
</div><p>
<a class="anchor" name="a4722bed5d9a6113a3dbe9f242b6a5fb"></a><!-- doxytag: member="SAMRAI::solv::CVODESolver::getActualFinalValueOfIndependentVariable" ref="a4722bed5d9a6113a3dbe9f242b6a5fb" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double SAMRAI::solv::CVODESolver::getActualFinalValueOfIndependentVariable           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get actual value of the independent variable that CVODE integrated to (i.e. the value of t that actually corresponds to the solution vector y). 
</div>
</div><p>
<a class="anchor" name="91daa119a71f1fa19e683629575cb3c8"></a><!-- doxytag: member="SAMRAI::solv::CVODESolver::printStatistics" ref="91daa119a71f1fa19e683629575cb3c8" args="(std::ostream &amp;os) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::solv::CVODESolver::printStatistics           </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&nbsp;</td>
          <td class="paramname"> <em>os</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Print CVODE and CVSpgmr statistics. 
</div>
</div><p>
<a class="anchor" name="717edf83e22fc582d36b2a582327b2ab"></a><!-- doxytag: member="SAMRAI::solv::CVODESolver::printCVODEStatistics" ref="717edf83e22fc582d36b2a582327b2ab" args="(std::ostream &amp;os) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::solv::CVODESolver::printCVODEStatistics           </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&nbsp;</td>
          <td class="paramname"> <em>os</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Print CVODE statistics to the stream.<p>
The abbreviations printed out refer to the following quantities:<p>
<ul>
<li><b>lenrw</b> size (in double words) of memory used for doubles</li></ul>
<p>
<ul>
<li><b>leniw</b> size (in integer words) of memory used for integers</li></ul>
<p>
<ul>
<li><b>nst</b> cumulative number of internal steps taken by solver</li></ul>
<p>
<ul>
<li><b>nfe</b> number of right-hand side function evaluations</li></ul>
<p>
<ul>
<li><b>nni</b> number of NEWTON iterations performed</li></ul>
<p>
<ul>
<li><b>nsetups</b> number of calls made to linear solver's setup routine</li></ul>
<p>
<ul>
<li><b>netf</b> number of local error test failures</li></ul>
<p>
<ul>
<li><b>ncfn</b> number of nonlinear convergence failures</li></ul>
<p>
<ul>
<li><b>qu</b> order used during the last internal step</li></ul>
<p>
<ul>
<li><b>qcur</b> order to be used on the next internal step</li></ul>
<p>
<ul>
<li><b>hu</b> step size for the last internal step</li></ul>
<p>
<ul>
<li><b>hcur</b> step size to be attempted on the next internal step</li></ul>
<p>
<ul>
<li><b>tcur</b> current internal value of t reached by the solver</li></ul>
<p>
<ul>
<li><b>tolsf</b> suggested tolerance scaling factor </li></ul>

</div>
</div><p>
<a class="anchor" name="52c75ba43c0718ce961934c8a7703810"></a><!-- doxytag: member="SAMRAI::solv::CVODESolver::getNumberOfInternalStepsTaken" ref="52c75ba43c0718ce961934c8a7703810" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int SAMRAI::solv::CVODESolver::getNumberOfInternalStepsTaken           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return the cumulative number of internal steps taken by the solver.<p>
Note: if the solver was not set to collect statistics, a value of -1 is returned. 
</div>
</div><p>
<a class="anchor" name="941ebc392c4612c1b096e66a0b78afc1"></a><!-- doxytag: member="SAMRAI::solv::CVODESolver::getNumberOfRHSFunctionCalls" ref="941ebc392c4612c1b096e66a0b78afc1" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int SAMRAI::solv::CVODESolver::getNumberOfRHSFunctionCalls           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return the number of calls to the right-hand side function.<p>
Note: if the solver was not set to collect statistics, a value of -1 is returned. 
</div>
</div><p>
<a class="anchor" name="79abb165024c34b581c090d66a1e5502"></a><!-- doxytag: member="SAMRAI::solv::CVODESolver::getNumberOfLinearSolverSetupCalls" ref="79abb165024c34b581c090d66a1e5502" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int SAMRAI::solv::CVODESolver::getNumberOfLinearSolverSetupCalls           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return the number of calls made to linear solver setup routines.<p>
Note: if the solver was not set to collect statistics, a value of -1 is returned. 
</div>
</div><p>
<a class="anchor" name="edb190402c9d9875138397988b283338"></a><!-- doxytag: member="SAMRAI::solv::CVODESolver::getNumberOfNewtonIterations" ref="edb190402c9d9875138397988b283338" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int SAMRAI::solv::CVODESolver::getNumberOfNewtonIterations           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return the number of NEWTON iterations performed.<p>
Note: if the solver was not set to collect statistics, a value of -1 is returned. 
</div>
</div><p>
<a class="anchor" name="81751ec8f2656ded3d8c7ad27ac4825f"></a><!-- doxytag: member="SAMRAI::solv::CVODESolver::getNumberOfNonlinearConvergenceFailures" ref="81751ec8f2656ded3d8c7ad27ac4825f" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int SAMRAI::solv::CVODESolver::getNumberOfNonlinearConvergenceFailures           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return the number of nonlinear convergence failures that have occurred.<p>
Note: if the solver was not set to collect statistics, a value of -1 is returned. 
</div>
</div><p>
<a class="anchor" name="9c9b2079851b1e3bdef82726643b75cb"></a><!-- doxytag: member="SAMRAI::solv::CVODESolver::getNumberOfLocalErrorTestFailures" ref="9c9b2079851b1e3bdef82726643b75cb" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int SAMRAI::solv::CVODESolver::getNumberOfLocalErrorTestFailures           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return the number of local error test failures.<p>
Note: if the solver was not set to collect statistics, a value of -1 is returned. 
</div>
</div><p>
<a class="anchor" name="b94f2b66d802663ba1032d73f31efe2c"></a><!-- doxytag: member="SAMRAI::solv::CVODESolver::getOrderUsedDuringLastInternalStep" ref="b94f2b66d802663ba1032d73f31efe2c" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int SAMRAI::solv::CVODESolver::getOrderUsedDuringLastInternalStep           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return the order of the linear multistep method used during the last internal step.<p>
Note: if the solver was not set to collect statistics, a value of -1 is returned. 
</div>
</div><p>
<a class="anchor" name="ab7141183623b70e48a4ee4d9206745f"></a><!-- doxytag: member="SAMRAI::solv::CVODESolver::getOrderToBeUsedDuringNextInternalStep" ref="ab7141183623b70e48a4ee4d9206745f" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int SAMRAI::solv::CVODESolver::getOrderToBeUsedDuringNextInternalStep           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return the order of the linear multistep method to be used during the next internal step.<p>
Note: if the solver was not set to collect statistics, a value of -1 is returned. 
</div>
</div><p>
<a class="anchor" name="fee30149975009efb602671ca93bb5c5"></a><!-- doxytag: member="SAMRAI::solv::CVODESolver::getCVODEMemoryUsageForDoubles" ref="fee30149975009efb602671ca93bb5c5" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int SAMRAI::solv::CVODESolver::getCVODEMemoryUsageForDoubles           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return the size (in LLNL_REAL words) of memory used for LLNL_REALS.<p>
Note: if the solver was not set to collect statistics, a value of -1 is returned. 
</div>
</div><p>
<a class="anchor" name="93057e16e70dedd1264747c8e90b6753"></a><!-- doxytag: member="SAMRAI::solv::CVODESolver::getCVODEMemoryUsageForIntegers" ref="93057e16e70dedd1264747c8e90b6753" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int SAMRAI::solv::CVODESolver::getCVODEMemoryUsageForIntegers           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return the size (in integer words) of memory used for integers.<p>
Note: if the solver was not set to collect statistics, a value of -1 is returned. 
</div>
</div><p>
<a class="anchor" name="63a5bfb0b71fb2c60076ae77e2960c48"></a><!-- doxytag: member="SAMRAI::solv::CVODESolver::getStepSizeForLastInternalStep" ref="63a5bfb0b71fb2c60076ae77e2960c48" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double SAMRAI::solv::CVODESolver::getStepSizeForLastInternalStep           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return the step size for the last internal step.<p>
Note: if the solver was not set to collect statistics, a value of -1 is returned. 
</div>
</div><p>
<a class="anchor" name="625858f9a1b3b6d1d66182e31b81fa64"></a><!-- doxytag: member="SAMRAI::solv::CVODESolver::getStepSizeForNextInternalStep" ref="625858f9a1b3b6d1d66182e31b81fa64" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double SAMRAI::solv::CVODESolver::getStepSizeForNextInternalStep           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return the step size to be used in the next internal step.<p>
Note: if the solver was not set to collect statistics, a value of -1 is returned. 
</div>
</div><p>
<a class="anchor" name="8d49e1aeede6a6125c2802e763c93fff"></a><!-- doxytag: member="SAMRAI::solv::CVODESolver::getCurrentInternalValueOfIndependentVariable" ref="8d49e1aeede6a6125c2802e763c93fff" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double SAMRAI::solv::CVODESolver::getCurrentInternalValueOfIndependentVariable           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return the current internal value of the independent variable reached by the solver.<p>
Note: if the solver was not set to collect statistics, the minimum double value (as defined in float.h) is returned. 
</div>
</div><p>
<a class="anchor" name="ad683c6628c8f0a928f36e962a4d1fca"></a><!-- doxytag: member="SAMRAI::solv::CVODESolver::getCVODESuggestedToleranceScalingFactor" ref="ad683c6628c8f0a928f36e962a4d1fca" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double SAMRAI::solv::CVODESolver::getCVODESuggestedToleranceScalingFactor           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return the suggested tolerance scaling factor.<p>
Note: if the solver was not set to collect statistics, a value of -1 is returned. 
</div>
</div><p>
<a class="anchor" name="7ce2d1ef47313daa66209f1476879c90"></a><!-- doxytag: member="SAMRAI::solv::CVODESolver::printCVSpgmrStatistics" ref="7ce2d1ef47313daa66209f1476879c90" args="(std::ostream &amp;os) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::solv::CVODESolver::printCVSpgmrStatistics           </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&nbsp;</td>
          <td class="paramname"> <em>os</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Print CVSpgmr statistics to the stream.<p>
The abbreviations printed out refer to the following quantities:<p>
<ul>
<li><b>spgmr_lrw</b> size (in double words) of memory used for doubles</li></ul>
<p>
<ul>
<li><b>spgmr_liw</b> size (in integer words) of memory used for integers</li></ul>
<p>
<ul>
<li><b>nli</b> number of linear iterations</li></ul>
<p>
<ul>
<li><b>ncfl</b> number of linear convergence failures</li></ul>
<p>
<ul>
<li><b>npe</b> number of preconditioner evaluations</li></ul>
<p>
<ul>
<li><b>nps</b> number of calls to CVSpgmrPrecondSolve() </li></ul>

</div>
</div><p>
<a class="anchor" name="39e4eec3b6337e16f33701d00b31d71e"></a><!-- doxytag: member="SAMRAI::solv::CVODESolver::getNumberOfPreconditionerEvaluations" ref="39e4eec3b6337e16f33701d00b31d71e" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int SAMRAI::solv::CVODESolver::getNumberOfPreconditionerEvaluations           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return the number of preconditioner evaluations. 
</div>
</div><p>
<a class="anchor" name="185cd82a514ce0b04c415182e05a9944"></a><!-- doxytag: member="SAMRAI::solv::CVODESolver::getNumberOfLinearIterations" ref="185cd82a514ce0b04c415182e05a9944" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int SAMRAI::solv::CVODESolver::getNumberOfLinearIterations           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return the number of linear iterations. 
</div>
</div><p>
<a class="anchor" name="34eb1e54d4dc88462108f55431b6fde2"></a><!-- doxytag: member="SAMRAI::solv::CVODESolver::getNumberOfPrecondSolveCalls" ref="34eb1e54d4dc88462108f55431b6fde2" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int SAMRAI::solv::CVODESolver::getNumberOfPrecondSolveCalls           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return the number of CVSpgmrPrecondSolve() calls. 
</div>
</div><p>
<a class="anchor" name="e8cf463127e3cb185f3787b63a572638"></a><!-- doxytag: member="SAMRAI::solv::CVODESolver::getNumberOfLinearConvergenceFailures" ref="e8cf463127e3cb185f3787b63a572638" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int SAMRAI::solv::CVODESolver::getNumberOfLinearConvergenceFailures           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return the number of linear convergence failures. 
</div>
</div><p>
<a class="anchor" name="6d7e51c8e72f0cb3df4946ceabf4a55a"></a><!-- doxytag: member="SAMRAI::solv::CVODESolver::getCVSpgmrMemoryUsageForDoubles" ref="6d7e51c8e72f0cb3df4946ceabf4a55a" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int SAMRAI::solv::CVODESolver::getCVSpgmrMemoryUsageForDoubles           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return the size (in double words) of memory used for doubles. 
</div>
</div><p>
<a class="anchor" name="4a49b33a006705baff5c5139ec3378cd"></a><!-- doxytag: member="SAMRAI::solv::CVODESolver::getCVSpgmrMemoryUsageForIntegers" ref="4a49b33a006705baff5c5139ec3378cd" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int SAMRAI::solv::CVODESolver::getCVSpgmrMemoryUsageForIntegers           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return the size (in integer words) of memory used for integers. 
</div>
</div><p>
<a class="anchor" name="c595f1cab02118e007e32deff36f256b"></a><!-- doxytag: member="SAMRAI::solv::CVODESolver::printClassData" ref="c595f1cab02118e007e32deff36f256b" args="(std::ostream &amp;os) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::solv::CVODESolver::printClassData           </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&nbsp;</td>
          <td class="paramname"> <em>os</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Print out all data members for this object. 
</div>
</div><p>
<a class="anchor" name="6dc038cafb620533f33adcf5846375c6"></a><!-- doxytag: member="SAMRAI::solv::CVODESolver::getObjectName" ref="6dc038cafb620533f33adcf5846375c6" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SAMRAI_INLINE_KEYWORD const std::string &amp; SAMRAI::solv::CVODESolver::getObjectName           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the object name. 
</div>
</div><p>
<hr>The documentation for this class was generated from the following files:<ul>
<li>source/SAMRAI/solv/<a class="el" href="CVODESolver_8h.html">CVODESolver.h</a><li>source/SAMRAI/solv/<a class="el" href="CVODESolver_8C.html">CVODESolver.C</a><li>source/SAMRAI/solv/<a class="el" href="CVODESolver_8I.html">CVODESolver.I</a></ul>
<hr size="1"><address style="align: right;"><small>Generated on Fri Mar 16 14:34:21 2012 for SAMRAI by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.7 </small></address>
</body>
</html>
