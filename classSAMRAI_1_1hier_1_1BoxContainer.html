<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>SAMRAI: SAMRAI::hier::BoxContainer Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath"><a class="el" href="namespaceSAMRAI.html">SAMRAI</a>::<a class="el" href="namespaceSAMRAI_1_1hier.html">hier</a>::<a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a>
  </div>
</div>
<div class="contents">
<h1>SAMRAI::hier::BoxContainer Class Reference</h1><!-- doxytag: class="SAMRAI::hier::BoxContainer" -->
<p>A container for Boxes.  
<a href="#_details">More...</a></p>

<p><code>#include &lt;source/SAMRAI/hier/BoxContainer.h&gt;</code></p>

<p><a href="classSAMRAI_1_1hier_1_1BoxContainer-members.html">List of all members.</a></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Classes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer_1_1BoxContainerConstIterator.html">BoxContainerConstIterator</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A immutable iterator over the boxes in a <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html" title="A container for Boxes.">BoxContainer</a>.  <a href="classSAMRAI_1_1hier_1_1BoxContainer_1_1BoxContainerConstIterator.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer_1_1BoxContainerIterator.html">BoxContainerIterator</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A mutable iterator over the boxes in a <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html" title="A container for Boxes.">BoxContainer</a>.  <a href="classSAMRAI_1_1hier_1_1BoxContainer_1_1BoxContainerIterator.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer_1_1Outputter.html">Outputter</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Intermediary between <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html" title="A container for Boxes.">BoxContainer</a> and output streams, adding ability to control the output. See <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html#a690469554c526eae84d5763ac0965e3c" title="Return a object to that can format the BoxContainer for inserting into output streams...">BoxContainer::format()</a>.  <a href="classSAMRAI_1_1hier_1_1BoxContainer_1_1Outputter.html#_details">More...</a><br/></td></tr>
<tr><td colspan="2"><h2>Public Types</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer_1_1BoxContainerIterator.html">BoxContainerIterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html#aff3fe3b8197b28da1ce580dd10a80d04">iterator</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The iterator for class <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html" title="A container for Boxes.">BoxContainer</a>.  <a href="#aff3fe3b8197b28da1ce580dd10a80d04"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer_1_1BoxContainerConstIterator.html">BoxContainerConstIterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html#a9029557738c2cf06d5e00b072a5606a2">const_iterator</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The const iterator for class <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html" title="A container for Boxes.">BoxContainer</a>.  <a href="#a9029557738c2cf06d5e00b072a5606a2"></a><br/></td></tr>
<tr><td colspan="2"><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html#ad795e5b89220de39c135f35a67cdd9f4">operator==</a> (const <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a> &amp;rhs) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Equality operator.  <a href="#ad795e5b89220de39c135f35a67cdd9f4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html#addbc2e3fd0573678cd793bcfe4e0258c">isIdEqual</a> (const <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a> &amp;other) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Check for equality of BoxIds in ordered containers.  <a href="#addbc2e3fd0573678cd793bcfe4e0258c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html#a8c5e154d95a5cc990613062dc62c70d0">isSpatiallyEqual</a> (const <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a> &amp;other) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Check for spatial equality of all boxes.  <a href="#a8c5e154d95a5cc990613062dc62c70d0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html#a3388a48a209f9b2d08f51bc64f1b33f5">operator!=</a> (const <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a> &amp;rhs) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Inequality operator.  <a href="#a3388a48a209f9b2d08f51bc64f1b33f5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html#afaa3a4f83b2f6714087926aea2d21664">makeTree</a> (const <a class="el" href="classSAMRAI_1_1hier_1_1BaseGridGeometry.html">BaseGridGeometry</a> *grid_geometry=0, const int min_number=10) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a search tree representation of the boxes in this container.  <a href="#afaa3a4f83b2f6714087926aea2d21664"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html#a6583a10f3562655a992cc0108222dd3e">hasTree</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Query if the search tree representation exists.  <a href="#a6583a10f3562655a992cc0108222dd3e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html#a8f29006cbc555f91394a5b641d99027a">hasBoxInBlock</a> (const <a class="el" href="classSAMRAI_1_1hier_1_1BlockId.html">BlockId</a> &amp;block_id) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Query if this <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html" title="A container for Boxes.">BoxContainer</a> contains any <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> with the given <a class="el" href="classSAMRAI_1_1hier_1_1BlockId.html" title="Generic identifier for identifying the block id.">BlockId</a>.  <a href="#a8f29006cbc555f91394a5b641d99027a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html#aa6e83d2ee9cc30cc14da50cc398e89c2">findOverlapBoxes</a> (<a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a> &amp;overlap_boxes, const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> &amp;box) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Find all boxes that intersect with a given box.  <a href="#aa6e83d2ee9cc30cc14da50cc398e89c2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html#ad254ff6fa6afdaa32c7539dcef0749c4">findOverlapBoxes</a> (std::vector&lt; const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> * &gt; &amp;overlap_boxes, const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> &amp;box) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Find all boxes that intersect with a given box.  <a href="#ad254ff6fa6afdaa32c7539dcef0749c4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html#a046d85a16e8923c8e7493a128c27595e">findOverlapBoxes</a> (<a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a> &amp;overlap_boxes, const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> &amp;box, const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;refinement_ratio, bool include_singularity_block_neighbors=false) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Find all boxes that intersect with a given box.  <a href="#a046d85a16e8923c8e7493a128c27595e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html#aa97cea6ce26cd7669d8cda4898b91b95">findOverlapBoxes</a> (std::vector&lt; const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> * &gt; &amp;overlap_boxes, const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> &amp;box, const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;refinement_ratio, bool include_singularity_block_neighbors=false) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html#ab161e5c0d9cb1ef48c0b06016f6ec78f">hasOverlap</a> (const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> &amp;box) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Determine if a given box intersects with the <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html" title="A container for Boxes.">BoxContainer</a>.  <a href="#ab161e5c0d9cb1ef48c0b06016f6ec78f"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrpd41d8cd98f00b204e9800998ecf8427e"></a> </p>
<br/><br/></div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html#a7b71e640373c9fdc6c7a5caca13a1077">BoxContainer</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Default constructor creates empty container in unordered state.  <a href="#a7b71e640373c9fdc6c7a5caca13a1077"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html#a3c485123fcf0afa0f3fda4b0769cafa0">BoxContainer</a> (const bool ordered)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates empty container in state determined by boolean.  <a href="#a3c485123fcf0afa0f3fda4b0769cafa0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html#a41fe31cad64a3b15ed599a910d2f8273">BoxContainer</a> (<a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer_1_1BoxContainerConstIterator.html">const_iterator</a> first, <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer_1_1BoxContainerConstIterator.html">const_iterator</a> last, const bool ordered=false)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create container containing members from another container.  <a href="#a41fe31cad64a3b15ed599a910d2f8273"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html#ad63ddcd7165e1b411faafc10452056ac">BoxContainer</a> (const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> &amp;box, const bool ordered=false)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a container with 1 box.  <a href="#ad63ddcd7165e1b411faafc10452056ac"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html#adcb9a691b0d39407ddc04c21014d1892">BoxContainer</a> (const <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a> &amp;other)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copy constructor from another <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html" title="A container for Boxes.">BoxContainer</a>.  <a href="#adcb9a691b0d39407ddc04c21014d1892"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html#a9c10c1fbfe303934ace48ad09de2c1d0">BoxContainer</a> (const std::vector&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1DatabaseBox.html">tbox::DatabaseBox</a> &gt; &amp;other)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copy constructor from an array of <a class="el" href="classSAMRAI_1_1tbox_1_1DatabaseBox.html">tbox::DatabaseBox</a> objects.  <a href="#a9c10c1fbfe303934ace48ad09de2c1d0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html#afe2288d97c15f402d9b0f2d999de9c47">BoxContainer</a> (const <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a> &amp;other, const <a class="el" href="classSAMRAI_1_1hier_1_1BlockId.html">BlockId</a> &amp;block_id)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Constructor that copies only Boxes having the given <a class="el" href="classSAMRAI_1_1hier_1_1BlockId.html" title="Generic identifier for identifying the block id.">BlockId</a> from the other container.  <a href="#afe2288d97c15f402d9b0f2d999de9c47"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html#aff2f982d2652d67aeb3ff8100dfdc163">operator=</a> (const <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a> &amp;rhs)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Assignment from other <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html" title="A container for Boxes.">BoxContainer</a>.  <a href="#aff2f982d2652d67aeb3ff8100dfdc163"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html#a52c10d65f3522145a133f40c8fdcfe28">operator=</a> (const std::vector&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1DatabaseBox.html">tbox::DatabaseBox</a> &gt; &amp;rhs)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Assignment from an array of <a class="el" href="classSAMRAI_1_1tbox_1_1DatabaseBox.html">tbox::DatabaseBox</a> objects.  <a href="#a52c10d65f3522145a133f40c8fdcfe28"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html#a4e7ae9ea3a7700f61efc722c56d9ed40">~BoxContainer</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The destructor releases all storage.  <a href="#a4e7ae9ea3a7700f61efc722c56d9ed40"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html#a2471b46bb9a12ca391187ac781240ba3">size</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the number of boxes in the container.  <a href="#a2471b46bb9a12ca391187ac781240ba3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html#a7371af1cb3790c297440cec6dda6a72e">isEmpty</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns true if there are no boxes in the container.  <a href="#a7371af1cb3790c297440cec6dda6a72e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html#ad871f3c0557760094807290656e33750">empty</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns true if there are no boxes in the container.  <a href="#ad871f3c0557760094807290656e33750"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer_1_1BoxContainerConstIterator.html">const_iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html#a7d67bdccb18882a276659b5c2851edc0">begin</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return a const_iterator pointing to the start of the container.  <a href="#a7d67bdccb18882a276659b5c2851edc0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer_1_1BoxContainerConstIterator.html">const_iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html#a192b7c4c41e41cdb9466afb9005136e5">end</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return a const_iterator pointing to the end of the container.  <a href="#a192b7c4c41e41cdb9466afb9005136e5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer_1_1BoxContainerIterator.html">iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html#a9177f688d517d8106664d509c6851f86">begin</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return an iterator pointing to the start of the container.  <a href="#a9177f688d517d8106664d509c6851f86"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer_1_1BoxContainerIterator.html">iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html#a9c566195352afe03c2c1b2ef8d19e55c">end</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return an iterator pointing to the end of the container.  <a href="#a9c566195352afe03c2c1b2ef8d19e55c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainerSingleBlockIterator.html">BoxContainerSingleBlockIterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html#a109bd0cce2a5b8f69e5ea1f971294ca2">begin</a> (const <a class="el" href="classSAMRAI_1_1hier_1_1BlockId.html">BlockId</a> &amp;block_id) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return a <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainerSingleBlockIterator.html" title="BoxContainer iterator picking items with a specified BlockId.">BoxContainerSingleBlockIterator</a> pointing to the first box in the container with the given <a class="el" href="classSAMRAI_1_1hier_1_1BlockId.html" title="Generic identifier for identifying the block id.">BlockId</a>.  <a href="#a109bd0cce2a5b8f69e5ea1f971294ca2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainerSingleBlockIterator.html">BoxContainerSingleBlockIterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html#a830399bd31f98ef38c7df25180486f9f">end</a> (const <a class="el" href="classSAMRAI_1_1hier_1_1BlockId.html">BlockId</a> &amp;block_id) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return a <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainerSingleBlockIterator.html" title="BoxContainer iterator picking items with a specified BlockId.">BoxContainerSingleBlockIterator</a> pointing to the end of the container.  <a href="#a830399bd31f98ef38c7df25180486f9f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainerSingleOwnerIterator.html">BoxContainerSingleOwnerIterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html#af0a3a4e59efb7b20fdc43ea27a375582">begin</a> (const int &amp;owner_rank) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return a <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainerSingleOwnerIterator.html" title="BoxContainer iterator picking items with a specified owner rank.">BoxContainerSingleOwnerIterator</a> pointing to the first box in the container having the given owner.  <a href="#af0a3a4e59efb7b20fdc43ea27a375582"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainerSingleOwnerIterator.html">BoxContainerSingleOwnerIterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html#a6de540684a35466938f821a940d459e9">end</a> (const int &amp;owner_rank) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return a <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainerSingleOwnerIterator.html" title="BoxContainer iterator picking items with a specified owner rank.">BoxContainerSingleOwnerIterator</a> pointing to the end of the container.  <a href="#a6de540684a35466938f821a940d459e9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSAMRAI_1_1hier_1_1RealBoxConstIterator.html">RealBoxConstIterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html#a42c5c13e9f4ddb913215f12a030c761e">realBegin</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return a <a class="el" href="classSAMRAI_1_1hier_1_1RealBoxConstIterator.html" title="Iterator through real Boxes (not periodic images) in a const BoxContainer.">RealBoxConstIterator</a> pointing to the first real (non-periodic) box in the container.  <a href="#a42c5c13e9f4ddb913215f12a030c761e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSAMRAI_1_1hier_1_1RealBoxConstIterator.html">RealBoxConstIterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html#a7dae366456c18c63846ffd42a0fbc542">realEnd</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return a <a class="el" href="classSAMRAI_1_1hier_1_1RealBoxConstIterator.html" title="Iterator through real Boxes (not periodic images) in a const BoxContainer.">RealBoxConstIterator</a> pointing to the end of the container.  <a href="#a7dae366456c18c63846ffd42a0fbc542"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html#aacb30f477c077d265d20b477e5adc0f3">front</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the first element in the container.  <a href="#aacb30f477c077d265d20b477e5adc0f3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html#a1a00d37886fa41bd01c6741568ab5bb6">back</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the first element in the container.  <a href="#a1a00d37886fa41bd01c6741568ab5bb6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html#ac4efcb7ab3ef052fa78b468ecb26cf44">erase</a> (<a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer_1_1BoxContainerIterator.html">iterator</a> iter)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Remove the member of the container pointed to by "iter".  <a href="#ac4efcb7ab3ef052fa78b468ecb26cf44"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html#a0c1648bbd364c5d25c1c4b1a99de0f1c">erase</a> (<a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer_1_1BoxContainerIterator.html">iterator</a> first, <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer_1_1BoxContainerIterator.html">iterator</a> last)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Remove the members of the container in the range [first, last).  <a href="#a0c1648bbd364c5d25c1c4b1a99de0f1c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html#a36eeafbcb7e07afea2806d64a2f0d4c3">clear</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Removes all the members of the container.  <a href="#a36eeafbcb7e07afea2806d64a2f0d4c3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html#a9aa7f1ff4dacf6c075e4eadb7363ea3c">swap</a> (<a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a> &amp;other)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Swap all contents and state with another <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html" title="A container for Boxes.">BoxContainer</a>.  <a href="#a9aa7f1ff4dacf6c075e4eadb7363ea3c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html#a8f32186ba3fc0bb9df9f73ed746ebc92">getOwners</a> (std::set&lt; int &gt; &amp;owners) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get all of the ranks that own Boxes in this container.  <a href="#a8f32186ba3fc0bb9df9f73ed746ebc92"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html#a4e0ebf36f1800ef69be70eddfeb9e638">grow</a> (const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;ghosts)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Grow boxes in the container by the specified ghost cell width.  <a href="#a4e0ebf36f1800ef69be70eddfeb9e638"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html#a28ac3b63bd66820c89449634de6e69c1">shift</a> (const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;offset)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Shift boxes in the container by the specified offset.  <a href="#a28ac3b63bd66820c89449634de6e69c1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html#aef570e52b1dedc50e0e2f607f02ef113">refine</a> (const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;ratio)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Refine boxes in container by the specified refinement ratio.  <a href="#aef570e52b1dedc50e0e2f607f02ef113"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html#a9906f066cab6279e709490b50245313e">coarsen</a> (const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;ratio)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Coarsen boxes in container by the specified coarsening ratio.  <a href="#a9906f066cab6279e709490b50245313e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html#adaf04b91b7439bc7cb9f61734871e930">getTotalSizeOfBoxes</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Count total number of indices in the boxes in the container.  <a href="#adaf04b91b7439bc7cb9f61734871e930"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html#ab302f3413aca7d08ae39eb765e0f91d2">contains</a> (const <a class="el" href="classSAMRAI_1_1hier_1_1Index.html">Index</a> &amp;idx, const <a class="el" href="classSAMRAI_1_1hier_1_1BlockId.html">BlockId</a> &amp;block_id) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Determine if "idx" lies within bounds of boxes in container.  <a href="#ab302f3413aca7d08ae39eb765e0f91d2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html#a6440b7e06427fd365eb05604e7dc99f6">getBoundingBox</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the bounding box for all the boxes in the container.  <a href="#a6440b7e06427fd365eb05604e7dc99f6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html#a300c7b4246e444e698f719d8df4b61c6">getBoundingBox</a> (const <a class="el" href="classSAMRAI_1_1hier_1_1BlockId.html">BlockId</a> &amp;block_id) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the bounding box for all the boxes in the container having the given <a class="el" href="classSAMRAI_1_1hier_1_1BlockId.html" title="Generic identifier for identifying the block id.">BlockId</a>.  <a href="#a300c7b4246e444e698f719d8df4b61c6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html#a14358caff71c9fb7dd8d8b3e3e193ea1">boxesIntersect</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Check for non-empty intersection among boxes in container.  <a href="#a14358caff71c9fb7dd8d8b3e3e193ea1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html#a8a554081bd049c99de1e0d6ad53d1cba">order</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Changes state of this container to ordered.  <a href="#a8a554081bd049c99de1e0d6ad53d1cba"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html#ad3fc42e7710adae0c5d1d5a1c0a1698d">unorder</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Changes state of this container to unordered.  <a href="#ad3fc42e7710adae0c5d1d5a1c0a1698d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html#ab60e3636df51eb5997471a5520c7884b">isOrdered</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return whether this container is ordered.  <a href="#ab60e3636df51eb5997471a5520c7884b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html#a9dac68baead6e75db214c8b120f0730e">pushFront</a> (const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> &amp;item)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adds "item" to the "front" of the container.  <a href="#a9dac68baead6e75db214c8b120f0730e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html#a236e2463d9ec5964135861de73f16324">pushBack</a> (const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> &amp;item)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adds "item" to the "end" of the container.  <a href="#a236e2463d9ec5964135861de73f16324"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html#ad73c72c593ada860cc4e354753f4914e">push_front</a> (const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> &amp;item)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">STL-named version of <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html#a9dac68baead6e75db214c8b120f0730e" title="Adds &quot;item&quot; to the &quot;front&quot; of the container.">pushFront()</a>.  <a href="#ad73c72c593ada860cc4e354753f4914e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html#ac7036801c26c07f0eec66853f2f6fd2d">push_back</a> (const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> &amp;item)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">STL-named version of <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html#a236e2463d9ec5964135861de73f16324" title="Adds &quot;item&quot; to the &quot;end&quot; of the container.">pushBack()</a>.  <a href="#ac7036801c26c07f0eec66853f2f6fd2d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html#a3f9ea6e1242029ed5b0bec7ebfc55ecb">insertBefore</a> (<a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer_1_1BoxContainerIterator.html">iterator</a> iter, const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> &amp;item)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Add "item" to specific place in the container.  <a href="#a3f9ea6e1242029ed5b0bec7ebfc55ecb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html#a3229998b188dfe40a9bddb47d737da4f">insertAfter</a> (<a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer_1_1BoxContainerIterator.html">iterator</a> iter, const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> &amp;item)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Add "item" to specific place in the container.  <a href="#a3229998b188dfe40a9bddb47d737da4f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html#aba38984af87d838459be4b85d0638bb9">spliceFront</a> (<a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a> &amp;boxes)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Prepends the Boxes in "boxes" to this <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html" title="A container for Boxes.">BoxContainer</a>.  <a href="#aba38984af87d838459be4b85d0638bb9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html#ad0766ee251b631b81cd2333e71dd33f2">spliceBack</a> (<a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a> &amp;boxes)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Appends the Boxes in "boxes" to this <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html" title="A container for Boxes.">BoxContainer</a>.  <a href="#ad0766ee251b631b81cd2333e71dd33f2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html#aa26e34c146a2e4d3db594350d030682c">popFront</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Remove the first member of the unordered container.  <a href="#aa26e34c146a2e4d3db594350d030682c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html#a09990007ee046ca5b308cdeea9bf9302">popBack</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Remove the last member of the unordered container.  <a href="#a09990007ee046ca5b308cdeea9bf9302"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html#acf2587b68a7d1a7d2a2134d9f87c0fca">simplify</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Place the boxes in the container into a canonical ordering.  <a href="#acf2587b68a7d1a7d2a2134d9f87c0fca"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html#a4f65643b3d30a7bc24dbac9a22abb5c7">coalesce</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Combine any boxes in the container which may be coalesced.  <a href="#a4f65643b3d30a7bc24dbac9a22abb5c7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html#a610b4fa87a46fb7225d10a76014d4c86">rotate</a> (const <a class="el" href="classSAMRAI_1_1hier_1_1Transformation.html#a2dd7d97a19db7c8e97402e8518c0af8d">Transformation::RotationIdentifier</a> rotation_ident)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Rotate boxes in container according to a RotationIdentifier.  <a href="#a610b4fa87a46fb7225d10a76014d4c86"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html#ab7efb9cecef0461f129c18f41fa06402">removeIntersections</a> (const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> &amp;takeaway)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Remove from each box the portions that intersect takeaway.  <a href="#ab7efb9cecef0461f129c18f41fa06402"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html#a140cd0612e724e550fecb567f38c760b">removeIntersections</a> (const <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a> &amp;takeaway)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Remove from each box portions intersecting boxes in takeaway.  <a href="#a140cd0612e724e550fecb567f38c760b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html#a9eae3c6a62fc8e46c2cb3430b72966ec">removeIntersections</a> (const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;refinement_ratio, const <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a> &amp;takeaway, const bool include_singularity_block_neighbors=false)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Remove from each box portions intersecting boxes in takeaway.  <a href="#a9eae3c6a62fc8e46c2cb3430b72966ec"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html#ad98c16c6d4f4d7a3d748dcc08fd3a010">removeIntersections</a> (const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> &amp;box, const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> &amp;takeaway)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Remove from box the portions intersecting takeaway.  <a href="#ad98c16c6d4f4d7a3d748dcc08fd3a010"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html#aafc53135623a761a92fc7053dd482810">intersectBoxes</a> (const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> &amp;keep)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Keep the intersection of the container's boxes and keep.  <a href="#aafc53135623a761a92fc7053dd482810"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html#a2f7078f8f3e4024318d535717ed2cb34">intersectBoxes</a> (const <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a> &amp;keep)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Keep the intersection of the container's boxes and keep's boxes.  <a href="#a2f7078f8f3e4024318d535717ed2cb34"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html#a6332ff5ba2add3c55657b80d254a116e">intersectBoxes</a> (const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;refinement_ratio, const <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a> &amp;keep, bool include_singularity_block_neighbors=false)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Keep the intersection of the container's boxes and keep's boxes.  <a href="#a6332ff5ba2add3c55657b80d254a116e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html#a2c2d862cadd5ab8e61c1104b98d90fbe">insert</a> (const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> &amp;box)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Insert a single <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a>.  <a href="#a2c2d862cadd5ab8e61c1104b98d90fbe"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer_1_1BoxContainerIterator.html">iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html#a235e4cc65c93a2acc692838a0215e44f">insert</a> (<a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer_1_1BoxContainerIterator.html">iterator</a> position, const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> &amp;box)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Insert a single <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a>.  <a href="#a235e4cc65c93a2acc692838a0215e44f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html#ae043c3cad663f7ff9ec97ee02b9a2bd3">insert</a> (<a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer_1_1BoxContainerConstIterator.html">const_iterator</a> first, <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer_1_1BoxContainerConstIterator.html">const_iterator</a> last)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Insert all Boxes within a range.  <a href="#ae043c3cad663f7ff9ec97ee02b9a2bd3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer_1_1BoxContainerIterator.html">iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html#a4460be7ce26be1bc5ce2ffc09b0efc9d">find</a> (const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> &amp;box) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Find a box in an ordered container.  <a href="#a4460be7ce26be1bc5ce2ffc09b0efc9d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer_1_1BoxContainerIterator.html">iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html#a7e31c87c644fd9666c1bf1517f49d935">lowerBound</a> (const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> &amp;box) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get lower bound iterator for a given <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a>.  <a href="#a7e31c87c644fd9666c1bf1517f49d935"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer_1_1BoxContainerIterator.html">iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html#a0b375d7cb0766e9db20fa442c3d67cb3">upperBound</a> (const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> &amp;box) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get upper bound iterator for a given <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a>.  <a href="#a0b375d7cb0766e9db20fa442c3d67cb3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html#a72fdf350374069c52b2a36c715e9fc88">erase</a> (const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> &amp;box)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Erase a <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> from the container.  <a href="#a72fdf350374069c52b2a36c715e9fc88"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html#ae92dc83a2539e418b81f92e63a5c77ab">separatePeriodicImages</a> (std::vector&lt; <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> &gt; &amp;real_box_vector, std::vector&lt; <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> &gt; &amp;periodic_image_box_vector, const <a class="el" href="classSAMRAI_1_1hier_1_1PeriodicShiftCatalog.html">PeriodicShiftCatalog</a> &amp;shift_catalog) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copy the members of this <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html" title="A container for Boxes.">BoxContainer</a> into two vector&lt;Box&gt; objects, one containing real Boxes and one containing their periodic images.  <a href="#ae92dc83a2539e418b81f92e63a5c77ab"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html#ae6c69e1e6065a9b4e0b88384cd7cf49f">removePeriodicImageBoxes</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Any members of this container that are periodic images will be erased.  <a href="#ae6c69e1e6065a9b4e0b88384cd7cf49f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html#a14be836a0a040a017c670c27537f8c30">unshiftPeriodicImageBoxes</a> (<a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a> &amp;output_boxes, const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;refinement_ratio, const <a class="el" href="classSAMRAI_1_1hier_1_1PeriodicShiftCatalog.html">PeriodicShiftCatalog</a> &amp;shift_catalog) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Place unshifted versions of Boxes into a <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html" title="A container for Boxes.">BoxContainer</a>.  <a href="#a14be836a0a040a017c670c27537f8c30"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html#aa24aaf0ff0de7a5a86e80ac1b2cfc96f">putToRestart</a> (const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Database.html">tbox::Database</a> &gt; &amp;restart_db) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Write the <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html" title="A container for Boxes.">BoxContainer</a> to a restart database.  <a href="#aa24aaf0ff0de7a5a86e80ac1b2cfc96f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html#aa0928d91ef08c3bc5ff619be13351577">getFromRestart</a> (<a class="el" href="classSAMRAI_1_1tbox_1_1Database.html">tbox::Database</a> &amp;restart_db)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Read the <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html" title="A container for Boxes.">BoxContainer</a> from a restart database.  <a href="#aa0928d91ef08c3bc5ff619be13351577"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html#a7e47dfbb2f2a4b41458315d14d8515ff">operator std::vector&lt; tbox::DatabaseBox &gt;</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Conversion from <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html" title="A container for Boxes.">BoxContainer</a> to std::vector&lt;tbox::DatabaseBox&gt;.  <a href="#a7e47dfbb2f2a4b41458315d14d8515ff"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html#abfff5008f021e5091f3eb192afa7aa8d">print</a> (std::ostream &amp;os=<a class="el" href="namespaceSAMRAI_1_1tbox.html#ab84041705493761fb17a8127e3a2dca2">tbox::plog</a>, const std::string &amp;border=std::string()) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Print each box in the container to the specified output stream.  <a href="#abfff5008f021e5091f3eb192afa7aa8d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer_1_1Outputter.html">Outputter</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html#a690469554c526eae84d5763ac0965e3c">format</a> (const std::string &amp;border=std::string(), int detail_depth=2) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return a object to that can format the <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html" title="A container for Boxes.">BoxContainer</a> for inserting into output streams.  <a href="#a690469554c526eae84d5763ac0965e3c"></a><br/></td></tr>
<tr><td colspan="2"><h2>Friends</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html#acf9e3e89ec00844bde233c296adf4db5">BoxContainerIterator</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html#ab605c1f6e8e543714f20820b93d2d556">BoxContainerConstIterator</a></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>A container for Boxes. </p>
<p>The <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html" title="A container for Boxes.">BoxContainer</a> stores a collection of Boxes and provides methods for access and manipulation of that collection.</p>
<p>A <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html" title="A container for Boxes.">BoxContainer</a> exists in either an "ordered" or "unordered" state. The ordered state means that the Boxes have been ordered according to the comparison operators defined in the <a class="el" href="classSAMRAI_1_1hier_1_1BoxId.html" title="Identifier for a Box, consisting of a GlobalId and a PeriodicId.">BoxId</a> class, while the unordered state has no meaningful ordering of the Boxes besides the sequence that the Boxes were added to the container. Additionally the ordered state requires that all Boxes in the container have a valid and unique <a class="el" href="classSAMRAI_1_1hier_1_1BoxId.html" title="Identifier for a Box, consisting of a GlobalId and a PeriodicId.">BoxId</a>, while there is no such restriction for unordered containers.</p>
<p>An ordered container can always have its state switched to unordered by a call to the <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html#ad3fc42e7710adae0c5d1d5a1c0a1698d" title="Changes state of this container to unordered.">unorder()</a> method. An unordered container can also have its state switched to ordered by a call to the <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html#a8a554081bd049c99de1e0d6ad53d1cba" title="Changes state of this container to ordered.">order()</a> method, but only under certain conditions specified below in the comments for <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html#a8a554081bd049c99de1e0d6ad53d1cba" title="Changes state of this container to ordered.">order()</a>.</p>
<p>Certain methods in this class can only be called on ordered containers while others can only be called on unordered containers. Violating these restrictions will result in a run-time error.</p>
<p>Regardless of unordered/unordered state, all Boxes within a <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html" title="A container for Boxes.">BoxContainer</a> must be of the same Dimension. If a new <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> added to a container has a different Dimension than the Boxes already in the container, an assertion failure will occur.</p>
<p>An option exists to create an internal search tree representation based on the spatial coordinates of the Boxes in the container. This option can be used to reduce the cost of searching operations in the methods <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html#ab7efb9cecef0461f129c18f41fa06402" title="Remove from each box the portions that intersect takeaway.">removeIntersections()</a>, <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html#aafc53135623a761a92fc7053dd482810" title="Keep the intersection of the container&#39;s boxes and keep.">intersectBoxes()</a>, <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html#aa6e83d2ee9cc30cc14da50cc398e89c2" title="Find all boxes that intersect with a given box.">findOverlapBoxes()</a> and <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html#ab161e5c0d9cb1ef48c0b06016f6ec78f" title="Determine if a given box intersects with the BoxContainer.">hasOverlap()</a>. This option is invoked by calling the method <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html#afaa3a4f83b2f6714087926aea2d21664" title="Create a search tree representation of the boxes in this container.">makeTree()</a>. This option should only be used in cases where the listed search methods will be called multiple times on the same unchanging <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html" title="A container for Boxes.">BoxContainer</a>. The cost of building the tree representaion is O(N(log(N)), while the tree reduces the cost of the search operations to O(log(N)) rather than O(N), thus it is adviseable to only use the tree representation when the reduction in search cost is expected to outweigh the increased cost of building the tree.</p>
<p>Constructing the tree represenation via <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html#afaa3a4f83b2f6714087926aea2d21664" title="Create a search tree representation of the boxes in this container.">makeTree()</a> will change nothing about the Boxes stored in the container, nor will it change the ordered/unordered state of the container.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classSAMRAI_1_1hier_1_1BoxId.html" title="Identifier for a Box, consisting of a GlobalId and a PeriodicId.">BoxId</a> </dd></dl>
<hr/><h2>Member Typedef Documentation</h2>
<a class="anchor" id="aff3fe3b8197b28da1ce580dd10a80d04"></a><!-- doxytag: member="SAMRAI::hier::BoxContainer::iterator" ref="aff3fe3b8197b28da1ce580dd10a80d04" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer_1_1BoxContainerIterator.html">BoxContainerIterator</a> <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer_1_1BoxContainerIterator.html">SAMRAI::hier::BoxContainer::iterator</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The iterator for class <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html" title="A container for Boxes.">BoxContainer</a>. </p>

</div>
</div>
<a class="anchor" id="a9029557738c2cf06d5e00b072a5606a2"></a><!-- doxytag: member="SAMRAI::hier::BoxContainer::const_iterator" ref="a9029557738c2cf06d5e00b072a5606a2" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer_1_1BoxContainerConstIterator.html">BoxContainerConstIterator</a> <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer_1_1BoxContainerConstIterator.html">SAMRAI::hier::BoxContainer::const_iterator</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The const iterator for class <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html" title="A container for Boxes.">BoxContainer</a>. </p>

</div>
</div>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a7b71e640373c9fdc6c7a5caca13a1077"></a><!-- doxytag: member="SAMRAI::hier::BoxContainer::BoxContainer" ref="a7b71e640373c9fdc6c7a5caca13a1077" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SAMRAI::hier::BoxContainer::BoxContainer </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Default constructor creates empty container in unordered state. </p>

</div>
</div>
<a class="anchor" id="a3c485123fcf0afa0f3fda4b0769cafa0"></a><!-- doxytag: member="SAMRAI::hier::BoxContainer::BoxContainer" ref="a3c485123fcf0afa0f3fda4b0769cafa0" args="(const bool ordered)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SAMRAI::hier::BoxContainer::BoxContainer </td>
          <td>(</td>
          <td class="paramtype">const bool&nbsp;</td>
          <td class="paramname"> <em>ordered</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates empty container in state determined by boolean. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>ordered</em>&nbsp;</td><td>Container will be ordered if true, unordered if false. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a41fe31cad64a3b15ed599a910d2f8273"></a><!-- doxytag: member="SAMRAI::hier::BoxContainer::BoxContainer" ref="a41fe31cad64a3b15ed599a910d2f8273" args="(const_iterator first, const_iterator last, const bool ordered=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SAMRAI::hier::BoxContainer::BoxContainer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer_1_1BoxContainerConstIterator.html">const_iterator</a>&nbsp;</td>
          <td class="paramname"> <em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer_1_1BoxContainerConstIterator.html">const_iterator</a>&nbsp;</td>
          <td class="paramname"> <em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&nbsp;</td>
          <td class="paramname"> <em>ordered</em> = <code>false</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create container containing members from another container. </p>
<p>Members in the range [first, last) are copied to new container.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>first</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>last</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>ordered</em>&nbsp;</td><td>Container will be ordered if true, unordered if false. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="BoxContainer_8C_source.html#l01412">order()</a>, and <a class="el" href="BoxContainer_8h_source.html#l01076">pushBack()</a>.</p>

</div>
</div>
<a class="anchor" id="ad63ddcd7165e1b411faafc10452056ac"></a><!-- doxytag: member="SAMRAI::hier::BoxContainer::BoxContainer" ref="ad63ddcd7165e1b411faafc10452056ac" args="(const Box &amp;box, const bool ordered=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SAMRAI::hier::BoxContainer::BoxContainer </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>box</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&nbsp;</td>
          <td class="paramname"> <em>ordered</em> = <code>false</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create a container with 1 box. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>box</em>&nbsp;</td><td><a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> to copy into new container. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>ordered</em>&nbsp;</td><td>Container will be ordered if true, unordered if false. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="BoxContainer_8C_source.html#l01412">order()</a>.</p>

</div>
</div>
<a class="anchor" id="adcb9a691b0d39407ddc04c21014d1892"></a><!-- doxytag: member="SAMRAI::hier::BoxContainer::BoxContainer" ref="adcb9a691b0d39407ddc04c21014d1892" args="(const BoxContainer &amp;other)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SAMRAI::hier::BoxContainer::BoxContainer </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>other</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Copy constructor from another <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html" title="A container for Boxes.">BoxContainer</a>. </p>
<p>All boxes and the ordered/unordered state will be copied to the new <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html" title="A container for Boxes.">BoxContainer</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>other</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="BoxContainer_8C_source.html#l01609">makeTree()</a>, and <a class="el" href="BoxContainer_8C_source.html#l01412">order()</a>.</p>

</div>
</div>
<a class="anchor" id="a9c10c1fbfe303934ace48ad09de2c1d0"></a><!-- doxytag: member="SAMRAI::hier::BoxContainer::BoxContainer" ref="a9c10c1fbfe303934ace48ad09de2c1d0" args="(const std::vector&lt; tbox::DatabaseBox &gt; &amp;other)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SAMRAI::hier::BoxContainer::BoxContainer </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1DatabaseBox.html">tbox::DatabaseBox</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>other</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Copy constructor from an array of <a class="el" href="classSAMRAI_1_1tbox_1_1DatabaseBox.html">tbox::DatabaseBox</a> objects. </p>
<p>The new <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html" title="A container for Boxes.">BoxContainer</a> will be unordered.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>other</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="BoxContainer_8h_source.html#l01076">pushBack()</a>.</p>

</div>
</div>
<a class="anchor" id="afe2288d97c15f402d9b0f2d999de9c47"></a><!-- doxytag: member="SAMRAI::hier::BoxContainer::BoxContainer" ref="afe2288d97c15f402d9b0f2d999de9c47" args="(const BoxContainer &amp;other, const BlockId &amp;block_id)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SAMRAI::hier::BoxContainer::BoxContainer </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1BlockId.html">BlockId</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>block_id</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Constructor that copies only Boxes having the given <a class="el" href="classSAMRAI_1_1hier_1_1BlockId.html" title="Generic identifier for identifying the block id.">BlockId</a> from the other container. </p>
<p>The unordered or ordered state will be the same as that of the argument container.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>other</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>block_id</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="BoxContainer_8h_source.html#l00706">begin()</a>, <a class="el" href="BoxContainer_8h_source.html#l00717">end()</a>, <a class="el" href="BoxContainer_8C_source.html#l01412">order()</a>, and <a class="el" href="BoxContainer_8h_source.html#l01076">pushBack()</a>.</p>

</div>
</div>
<a class="anchor" id="a4e7ae9ea3a7700f61efc722c56d9ed40"></a><!-- doxytag: member="SAMRAI::hier::BoxContainer::~BoxContainer" ref="a4e7ae9ea3a7700f61efc722c56d9ed40" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SAMRAI::hier::BoxContainer::~BoxContainer </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The destructor releases all storage. </p>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="aff2f982d2652d67aeb3ff8100dfdc163"></a><!-- doxytag: member="SAMRAI::hier::BoxContainer::operator=" ref="aff2f982d2652d67aeb3ff8100dfdc163" args="(const BoxContainer &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a> &amp; SAMRAI::hier::BoxContainer::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Assignment from other <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html" title="A container for Boxes.">BoxContainer</a>. </p>
<p>All boxes and the ordered/unordered state will be copied to the assigned <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html" title="A container for Boxes.">BoxContainer</a>. Any previous state of the assigned <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html" title="A container for Boxes.">BoxContainer</a> is discarded.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>rhs</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="BoxContainer_8h_source.html#l00865">clear()</a>, and <a class="el" href="BoxContainer_8C_source.html#l01412">order()</a>.</p>

</div>
</div>
<a class="anchor" id="a52c10d65f3522145a133f40c8fdcfe28"></a><!-- doxytag: member="SAMRAI::hier::BoxContainer::operator=" ref="a52c10d65f3522145a133f40c8fdcfe28" args="(const std::vector&lt; tbox::DatabaseBox &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a> &amp; SAMRAI::hier::BoxContainer::operator= </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1DatabaseBox.html">tbox::DatabaseBox</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Assignment from an array of <a class="el" href="classSAMRAI_1_1tbox_1_1DatabaseBox.html">tbox::DatabaseBox</a> objects. </p>
<p>The assigned <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html" title="A container for Boxes.">BoxContainer</a> will be unordered. Any previous state of the assigned <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html" title="A container for Boxes.">BoxContainer</a> is discarded.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>rhs</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="BoxContainer_8h_source.html#l00865">clear()</a>, and <a class="el" href="BoxContainer_8h_source.html#l01076">pushBack()</a>.</p>

</div>
</div>
<a class="anchor" id="a2471b46bb9a12ca391187ac781240ba3"></a><!-- doxytag: member="SAMRAI::hier::BoxContainer::size" ref="a2471b46bb9a12ca391187ac781240ba3" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int SAMRAI::hier::BoxContainer::size </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return the number of boxes in the container. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>The number of boxes in the container. </dd></dl>

<p>Referenced by <a class="el" href="BoxContainer_8C_source.html#l00748">boxesIntersect()</a>, <a class="el" href="CartesianGridGeometry_8C_source.html#l00127">SAMRAI::geom::CartesianGridGeometry::CartesianGridGeometry()</a>, <a class="el" href="PatchLevelEnhancedFillPattern_8C_source.html#l00052">SAMRAI::xfer::PatchLevelEnhancedFillPattern::computeFillBoxesAndNeighborhoodSets()</a>, <a class="el" href="PatchLevelBorderFillPattern_8C_source.html#l00053">SAMRAI::xfer::PatchLevelBorderFillPattern::computeFillBoxesAndNeighborhoodSets()</a>, <a class="el" href="PatchLevelBorderAndInteriorFillPattern_8C_source.html#l00052">SAMRAI::xfer::PatchLevelBorderAndInteriorFillPattern::computeFillBoxesAndNeighborhoodSets()</a>, <a class="el" href="Connector_8C_source.html#l00523">SAMRAI::hier::Connector::computeTransposeOf()</a>, <a class="el" href="BalanceUtilities_8C_source.html#l02137">SAMRAI::mesh::BalanceUtilities::constrainMaxBoxSizes()</a>, <a class="el" href="TileClustering_8C_source.html#l00125">SAMRAI::mesh::TileClustering::findBoxesContainingTags()</a>, <a class="el" href="AssumedPartition_8C_source.html#l00239">SAMRAI::hier::AssumedPartition::findOverlaps()</a>, <a class="el" href="BaseGridGeometry_8C_source.html#l01075">SAMRAI::hier::BaseGridGeometry::getBoundaryBoxes()</a>, <a class="el" href="BoxContainer_8C_source.html#l01523">getTotalSizeOfBoxes()</a>, <a class="el" href="BoxUtilities_8C_source.html#l01817">SAMRAI::hier::BoxUtilities::growAndAdjustAcrossBlockBoundary()</a>, <a class="el" href="BaseGridGeometry_8C_source.html#l01615">SAMRAI::hier::BaseGridGeometry::initializePeriodicShift()</a>, <a class="el" href="BoxTransitSet_8C_source.html#l00128">SAMRAI::mesh::BoxTransitSet::insertAll()</a>, <a class="el" href="BoxContainer_8C_source.html#l00204">isIdEqual()</a>, <a class="el" href="BoxContainer_8C_source.html#l00221">isSpatiallyEqual()</a>, <a class="el" href="GraphLoadBalancer_8C_source.html#l00072">SAMRAI::mesh::GraphLoadBalancer::loadBalanceBoxLevel()</a>, <a class="el" href="GridGeometry_8C_source.html#l00151">SAMRAI::geom::GridGeometry::makeCoarsenedGridGeometry()</a>, <a class="el" href="CartesianGridGeometry_8C_source.html#l00221">SAMRAI::geom::CartesianGridGeometry::makeCoarsenedGridGeometry()</a>, <a class="el" href="BoxUtilities_8C_source.html#l01773">SAMRAI::hier::BoxUtilities::makeNonOverlappingBoxContainers()</a>, <a class="el" href="BoxLevelConnectorUtils_8C_source.html#l01085">SAMRAI::hier::BoxLevelConnectorUtils::makeRemainderMap()</a>, <a class="el" href="BaseConnectorAlgorithm_8C_source.html#l00119">SAMRAI::hier::BaseConnectorAlgorithm::packReferencedNeighbors()</a>, <a class="el" href="AssumedPartition_8C_source.html#l00068">SAMRAI::hier::AssumedPartition::partition()</a>, <a class="el" href="BalanceUtilities_8C_source.html#l02242">SAMRAI::mesh::BalanceUtilities::prebalanceBoxLevel()</a>, <a class="el" href="BoxContainer_8C_source.html#l01728">print()</a>, <a class="el" href="BaseGridGeometry_8C_source.html#l03290">SAMRAI::hier::BaseGridGeometry::printClassData()</a>, <a class="el" href="BoxContainer_8C_source.html#l01642">putToRestart()</a>, <a class="el" href="BaseGridGeometry_8C_source.html#l01870">SAMRAI::hier::BaseGridGeometry::readBlockDataFromInput()</a>, <a class="el" href="AssumedPartitionBox_8C_source.html#l00286">SAMRAI::hier::AssumedPartitionBox::selfCheck()</a>, <a class="el" href="BoxContainer_8C_source.html#l00606">separatePeriodicImages()</a>, <a class="el" href="BaseGridGeometry_8C_source.html#l01472">SAMRAI::hier::BaseGridGeometry::setPhysicalDomain()</a>, <a class="el" href="BalanceUtilities_8C_source.html#l01725">SAMRAI::mesh::BalanceUtilities::sortDescendingBoxWorkloads()</a>, and <a class="el" href="BalanceUtilities_8C_source.html#l01149">SAMRAI::mesh::BalanceUtilities::spatialBinPack()</a>.</p>

</div>
</div>
<a class="anchor" id="a7371af1cb3790c297440cec6dda6a72e"></a><!-- doxytag: member="SAMRAI::hier::BoxContainer::isEmpty" ref="a7371af1cb3790c297440cec6dda6a72e" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SAMRAI::hier::BoxContainer::isEmpty </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns true if there are no boxes in the container. </p>
<p>Archaic syntax. Synonymous with <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html#ad871f3c0557760094807290656e33750" title="Returns true if there are no boxes in the container.">empty()</a>. Retained for backward compatibility.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html#ad871f3c0557760094807290656e33750" title="Returns true if there are no boxes in the container.">empty()</a> </dd></dl>

<p>References <a class="el" href="BoxContainer_8h_source.html#l00695">empty()</a>.</p>

</div>
</div>
<a class="anchor" id="ad871f3c0557760094807290656e33750"></a><!-- doxytag: member="SAMRAI::hier::BoxContainer::empty" ref="ad871f3c0557760094807290656e33750" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SAMRAI::hier::BoxContainer::empty </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns true if there are no boxes in the container. </p>
<p>This version follows the naming standards used in STL.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>True if the container is empty. </dd></dl>

<p>Referenced by <a class="el" href="BoxLevel_8C_source.html#l01045">SAMRAI::hier::BoxLevel::addBox()</a>, <a class="el" href="BaseGridGeometry_8C_source.html#l00107">SAMRAI::hier::BaseGridGeometry::BaseGridGeometry()</a>, <a class="el" href="BalanceBoxBreaker_8C_source.html#l00072">SAMRAI::mesh::BalanceBoxBreaker::breakOffLoad()</a>, <a class="el" href="BoxUtilities_8C_source.html#l00116">SAMRAI::hier::BoxUtilities::checkBoxConstraints()</a>, <a class="el" href="BoxUtilities_8C_source.html#l01202">SAMRAI::hier::BoxUtilities::checkBoxForBadCutPointsInDirection()</a>, <a class="el" href="BoxUtilities_8C_source.html#l00417">SAMRAI::hier::BoxUtilities::chopBox()</a>, <a class="el" href="BoxUtilities_8C_source.html#l00326">SAMRAI::hier::BoxUtilities::chopBoxes()</a>, <a class="el" href="BaseGridGeometry_8C_source.html#l02512">SAMRAI::hier::BaseGridGeometry::chopDomain()</a>, <a class="el" href="BoxContainer_8C_source.html#l00528">coalesce()</a>, <a class="el" href="BaseGridGeometry_8C_source.html#l00361">SAMRAI::hier::BaseGridGeometry::computeBoxTouchingBoundaries()</a>, <a class="el" href="SideGeometry_8C_source.html#l00120">SAMRAI::pdat::SideGeometry::computeDestinationBoxes()</a>, <a class="el" href="NodeGeometry_8C_source.html#l00095">SAMRAI::pdat::NodeGeometry::computeDestinationBoxes()</a>, <a class="el" href="FaceGeometry_8C_source.html#l00132">SAMRAI::pdat::FaceGeometry::computeDestinationBoxes()</a>, <a class="el" href="EdgeGeometry_8C_source.html#l00098">SAMRAI::pdat::EdgeGeometry::computeDestinationBoxes()</a>, <a class="el" href="CellGeometry_8C_source.html#l00094">SAMRAI::pdat::CellGeometry::computeDestinationBoxes()</a>, <a class="el" href="PatchLevelBorderFillPattern_8C_source.html#l00053">SAMRAI::xfer::PatchLevelBorderFillPattern::computeFillBoxesAndNeighborhoodSets()</a>, <a class="el" href="PatchLevelBorderAndInteriorFillPattern_8C_source.html#l00052">SAMRAI::xfer::PatchLevelBorderAndInteriorFillPattern::computeFillBoxesAndNeighborhoodSets()</a>, <a class="el" href="BoxLevelConnectorUtils_8C_source.html#l01486">SAMRAI::hier::BoxLevelConnectorUtils::computeNonIntersectingParts()</a>, <a class="el" href="BalanceUtilities_8C_source.html#l02137">SAMRAI::mesh::BalanceUtilities::constrainMaxBoxSizes()</a>, <a class="el" href="BoxUtilities_8C_source.html#l00506">SAMRAI::hier::BoxUtilities::extendBoxesToDomainBoundary()</a>, <a class="el" href="BoxUtilities_8C_source.html#l00536">SAMRAI::hier::BoxUtilities::extendBoxToDomainBoundary()</a>, <a class="el" href="BoxUtilities_8C_source.html#l01336">SAMRAI::hier::BoxUtilities::findBadCutPointsForDirection()</a>, <a class="el" href="TileClustering_8C_source.html#l00125">SAMRAI::mesh::TileClustering::findBoxesContainingTags()</a>, <a class="el" href="BergerRigoutsos_8C_source.html#l00251">SAMRAI::mesh::BergerRigoutsos::findBoxesContainingTags()</a>, <a class="el" href="BoxContainer_8C_source.html#l01832">findOverlapBoxes()</a>, <a class="el" href="BaseGridGeometry_8C_source.html#l00306">SAMRAI::hier::BaseGridGeometry::findPatchesTouchingBoundaries()</a>, <a class="el" href="FlattenedHierarchy_8C_source.html#l00027">SAMRAI::hier::FlattenedHierarchy::FlattenedHierarchy()</a>, <a class="el" href="BaseGridGeometry_8C_source.html#l01075">SAMRAI::hier::BaseGridGeometry::getBoundaryBoxes()</a>, <a class="el" href="BoxContainer_8C_source.html#l00676">getBoundingBox()</a>, <a class="el" href="BoxLevel_8C_source.html#l01359">SAMRAI::hier::BoxLevel::getFirstLocalId()</a>, <a class="el" href="BoxLevel_8C_source.html#l01376">SAMRAI::hier::BoxLevel::getLastLocalId()</a>, <a class="el" href="SideOverlap_8C_source.html#l00052">SAMRAI::pdat::SideOverlap::getSourceBoxContainer()</a>, <a class="el" href="NodeOverlap_8C_source.html#l00041">SAMRAI::pdat::NodeOverlap::getSourceBoxContainer()</a>, <a class="el" href="FaceOverlap_8C_source.html#l00053">SAMRAI::pdat::FaceOverlap::getSourceBoxContainer()</a>, <a class="el" href="EdgeOverlap_8C_source.html#l00052">SAMRAI::pdat::EdgeOverlap::getSourceBoxContainer()</a>, <a class="el" href="CellOverlap_8C_source.html#l00043">SAMRAI::pdat::CellOverlap::getSourceBoxContainer()</a>, <a class="el" href="BoxUtilities_8C_source.html#l01817">SAMRAI::hier::BoxUtilities::growAndAdjustAcrossBlockBoundary()</a>, <a class="el" href="BoxUtilities_8C_source.html#l00622">SAMRAI::hier::BoxUtilities::growBoxesWithinDomain()</a>, <a class="el" href="BoxContainer_8C_source.html#l00248">insert()</a>, <a class="el" href="BoxContainer_8h_source.html#l01127">insertBefore()</a>, <a class="el" href="BoxContainer_8C_source.html#l01050">intersectBoxes()</a>, <a class="el" href="BoxContainer_8h_source.html#l00682">isEmpty()</a>, <a class="el" href="GraphLoadBalancer_8C_source.html#l00072">SAMRAI::mesh::GraphLoadBalancer::loadBalanceBoxLevel()</a>, <a class="el" href="BoxLevelConnectorUtils_8C_source.html#l00357">SAMRAI::hier::BoxLevelConnectorUtils::makeSortingMap()</a>, <a class="el" href="BoxContainer_8C_source.html#l01609">makeTree()</a>, <a class="el" href="SideData_8C_source.html#l00476">SAMRAI::pdat::SideData&lt; TYPE &gt;::packStream()</a>, <a class="el" href="OuterfaceData_8C_source.html#l00408">SAMRAI::pdat::OuterfaceData&lt; TYPE &gt;::packStream()</a>, <a class="el" href="EdgeData_8C_source.html#l00409">SAMRAI::pdat::EdgeData&lt; TYPE &gt;::packStream()</a>, <a class="el" href="BoxContainer_8h_source.html#l01076">pushBack()</a>, <a class="el" href="BoxContainer_8h_source.html#l01046">pushFront()</a>, <a class="el" href="BaseGridGeometry_8C_source.html#l01870">SAMRAI::hier::BaseGridGeometry::readBlockDataFromInput()</a>, <a class="el" href="BalanceUtilities_8C_source.html#l01418">SAMRAI::mesh::BalanceUtilities::recursiveBisectionNonuniform()</a>, <a class="el" href="BalanceUtilities_8C_source.html#l01325">SAMRAI::mesh::BalanceUtilities::recursiveBisectionUniform()</a>, <a class="el" href="BoxContainer_8C_source.html#l00781">removeIntersections()</a>, <a class="el" href="BoxContainer_8C_source.html#l00580">removePeriodicImageBoxes()</a>, <a class="el" href="BoxContainer_8C_source.html#l00638">rotate()</a>, <a class="el" href="AssumedPartitionBox_8C_source.html#l00286">SAMRAI::hier::AssumedPartitionBox::selfCheck()</a>, <a class="el" href="BoxContainer_8C_source.html#l00606">separatePeriodicImages()</a>, <a class="el" href="BaseGridGeometry_8C_source.html#l01472">SAMRAI::hier::BaseGridGeometry::setPhysicalDomain()</a>, <a class="el" href="BoxContainer_8C_source.html#l00401">simplify()</a>, <a class="el" href="BoxContainer_8h_source.html#l01223">spliceBack()</a>, <a class="el" href="BoxContainer_8h_source.html#l01192">spliceFront()</a>, <a class="el" href="SideData_8C_source.html#l00574">SAMRAI::pdat::SideData&lt; TYPE &gt;::unpackStream()</a>, <a class="el" href="FaceData_8C_source.html#l00544">SAMRAI::pdat::FaceData&lt; TYPE &gt;::unpackStream()</a>, <a class="el" href="EdgeData_8C_source.html#l00503">SAMRAI::pdat::EdgeData&lt; TYPE &gt;::unpackStream()</a>, and <a class="el" href="BoxContainer_8C_source.html#l01377">unshiftPeriodicImageBoxes()</a>.</p>

</div>
</div>
<a class="anchor" id="a7d67bdccb18882a276659b5c2851edc0"></a><!-- doxytag: member="SAMRAI::hier::BoxContainer::begin" ref="a7d67bdccb18882a276659b5c2851edc0" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer_1_1BoxContainerConstIterator.html">const_iterator</a> SAMRAI::hier::BoxContainer::begin </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return a const_iterator pointing to the start of the container. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>An immutable iterator pointing to the first box. </dd></dl>

<p>Referenced by <a class="el" href="BoxLevel_8C_source.html#l01045">SAMRAI::hier::BoxLevel::addBox()</a>, <a class="el" href="BaseGridGeometry_8C_source.html#l02820">SAMRAI::hier::BaseGridGeometry::adjustMultiblockPatchLevelBoundaries()</a>, <a class="el" href="BaseGridGeometry_8C_source.html#l00107">SAMRAI::hier::BaseGridGeometry::BaseGridGeometry()</a>, <a class="el" href="BoxLevelConnectorUtils_8C_source.html#l00171">SAMRAI::hier::BoxLevelConnectorUtils::baseNestsInHead()</a>, <a class="el" href="BoxContainer_8C_source.html#l00078">BoxContainer()</a>, <a class="el" href="BoxContainer_8C_source.html#l00748">boxesIntersect()</a>, <a class="el" href="BoxNeighborhoodCollection_8C_source.html#l00022">SAMRAI::hier::BoxNeighborhoodCollection::BoxNeighborhoodCollection()</a>, <a class="el" href="BoxUtilities_8C_source.html#l00116">SAMRAI::hier::BoxUtilities::checkBoxConstraints()</a>, <a class="el" href="BoxUtilities_8C_source.html#l01202">SAMRAI::hier::BoxUtilities::checkBoxForBadCutPointsInDirection()</a>, <a class="el" href="BoxContainer_8C_source.html#l00528">coalesce()</a>, <a class="el" href="BoxContainer_8C_source.html#l01597">coarsen()</a>, <a class="el" href="BoxLevelConnectorUtils_8C_source.html#l00880">SAMRAI::hier::BoxLevelConnectorUtils::computeBoxesAroundBoundary()</a>, <a class="el" href="BaseGridGeometry_8C_source.html#l00361">SAMRAI::hier::BaseGridGeometry::computeBoxTouchingBoundaries()</a>, <a class="el" href="SideGeometry_8C_source.html#l00120">SAMRAI::pdat::SideGeometry::computeDestinationBoxes()</a>, <a class="el" href="NodeGeometry_8C_source.html#l00095">SAMRAI::pdat::NodeGeometry::computeDestinationBoxes()</a>, <a class="el" href="FaceGeometry_8C_source.html#l00132">SAMRAI::pdat::FaceGeometry::computeDestinationBoxes()</a>, <a class="el" href="EdgeGeometry_8C_source.html#l00098">SAMRAI::pdat::EdgeGeometry::computeDestinationBoxes()</a>, <a class="el" href="PatchLevelInteriorFillPattern_8C_source.html#l00105">SAMRAI::xfer::PatchLevelInteriorFillPattern::computeDestinationFillBoxesOnSourceProc()</a>, <a class="el" href="PatchLevelFullFillPattern_8C_source.html#l00102">SAMRAI::xfer::PatchLevelFullFillPattern::computeDestinationFillBoxesOnSourceProc()</a>, <a class="el" href="PatchLevelBorderFillPattern_8C_source.html#l00053">SAMRAI::xfer::PatchLevelBorderFillPattern::computeFillBoxesAndNeighborhoodSets()</a>, <a class="el" href="PatchLevelBorderAndInteriorFillPattern_8C_source.html#l00052">SAMRAI::xfer::PatchLevelBorderAndInteriorFillPattern::computeFillBoxesAndNeighborhoodSets()</a>, <a class="el" href="SecondLayerNodeVariableFillPattern_8C_source.html#l00157">SAMRAI::pdat::SecondLayerNodeVariableFillPattern::computeFillBoxesOverlap()</a>, <a class="el" href="SecondLayerNodeNoCornersVariableFillPattern_8C_source.html#l00167">SAMRAI::pdat::SecondLayerNodeNoCornersVariableFillPattern::computeFillBoxesOverlap()</a>, <a class="el" href="FirstLayerSideVariableFillPattern_8C_source.html#l00160">SAMRAI::pdat::FirstLayerSideVariableFillPattern::computeFillBoxesOverlap()</a>, <a class="el" href="FirstLayerNodeVariableFillPattern_8C_source.html#l00150">SAMRAI::pdat::FirstLayerNodeVariableFillPattern::computeFillBoxesOverlap()</a>, <a class="el" href="FirstLayerEdgeVariableFillPattern_8C_source.html#l00160">SAMRAI::pdat::FirstLayerEdgeVariableFillPattern::computeFillBoxesOverlap()</a>, <a class="el" href="BaseGridGeometry_8C_source.html#l01225">SAMRAI::hier::BaseGridGeometry::computePhysicalDomain()</a>, <a class="el" href="Connector_8C_source.html#l00523">SAMRAI::hier::Connector::computeTransposeOf()</a>, <a class="el" href="BalanceBoxBreaker_8C_source.html#l00967">SAMRAI::mesh::BalanceBoxBreaker::computeWidthScore()</a>, <a class="el" href="BalanceUtilities_8C_source.html#l02137">SAMRAI::mesh::BalanceUtilities::constrainMaxBoxSizes()</a>, <a class="el" href="BoxContainer_8C_source.html#l01539">contains()</a>, <a class="el" href="ArrayData_8C_source.html#l00351">SAMRAI::pdat::ArrayData&lt; TYPE &gt;::copy()</a>, <a class="el" href="BoxContainerSingleBlockIterator_8C_source.html#l00071">SAMRAI::hier::BoxContainerSingleBlockIterator::count()</a>, <a class="el" href="BoxNeighborhoodCollection_8C_source.html#l00303">SAMRAI::hier::BoxNeighborhoodCollection::erase()</a>, <a class="el" href="BoxUtilities_8C_source.html#l00536">SAMRAI::hier::BoxUtilities::extendBoxToDomainBoundary()</a>, <a class="el" href="OverlapConnectorAlgorithm_8C_source.html#l00147">SAMRAI::hier::OverlapConnectorAlgorithm::extractNeighbors()</a>, <a class="el" href="BoxLevel_8C_source.html#l00307">SAMRAI::hier::BoxLevel::finalize()</a>, <a class="el" href="BoxUtilities_8C_source.html#l01336">SAMRAI::hier::BoxUtilities::findBadCutPointsForDirection()</a>, <a class="el" href="TileClustering_8C_source.html#l00125">SAMRAI::mesh::TileClustering::findBoxesContainingTags()</a>, <a class="el" href="BergerRigoutsos_8C_source.html#l00251">SAMRAI::mesh::BergerRigoutsos::findBoxesContainingTags()</a>, <a class="el" href="BoxContainer_8C_source.html#l01788">findOverlapBoxes()</a>, <a class="el" href="OverlapConnectorAlgorithm_8C_source.html#l00490">SAMRAI::hier::OverlapConnectorAlgorithm::findOverlaps_assumedPartition()</a>, <a class="el" href="BalanceUtilities_8C_source.html#l01871">SAMRAI::mesh::BalanceUtilities::findSmallBoxesInPostbalance()</a>, <a class="el" href="FlattenedHierarchy_8C_source.html#l00027">SAMRAI::hier::FlattenedHierarchy::FlattenedHierarchy()</a>, <a class="el" href="BaseGridGeometry_8C_source.html#l01075">SAMRAI::hier::BaseGridGeometry::getBoundaryBoxes()</a>, <a class="el" href="BoxContainer_8C_source.html#l00676">getBoundingBox()</a>, <a class="el" href="PatchLevel_8C_source.html#l00708">SAMRAI::hier::PatchLevel::getBoxes()</a>, <a class="el" href="IndexData_8C_source.html#l00350">SAMRAI::pdat::IndexData&lt; TYPE, BOX_GEOMETRY &gt;::getDataStreamSize()</a>, <a class="el" href="BoxLevel_8C_source.html#l01359">SAMRAI::hier::BoxLevel::getFirstLocalId()</a>, <a class="el" href="BoxLevel_8C_source.html#l01502">SAMRAI::hier::BoxLevel::getGlobalBoxes()</a>, <a class="el" href="BoxLevel_8C_source.html#l01376">SAMRAI::hier::BoxLevel::getLastLocalId()</a>, <a class="el" href="BoxLevel_8C_source.html#l00746">SAMRAI::hier::BoxLevel::getLocalNumberOfBoxes()</a>, <a class="el" href="BoxLevel_8C_source.html#l00775">SAMRAI::hier::BoxLevel::getLocalNumberOfCells()</a>, <a class="el" href="BoxContainer_8C_source.html#l01348">getOwners()</a>, <a class="el" href="SideOverlap_8C_source.html#l00052">SAMRAI::pdat::SideOverlap::getSourceBoxContainer()</a>, <a class="el" href="FaceOverlap_8C_source.html#l00053">SAMRAI::pdat::FaceOverlap::getSourceBoxContainer()</a>, <a class="el" href="EdgeOverlap_8C_source.html#l00052">SAMRAI::pdat::EdgeOverlap::getSourceBoxContainer()</a>, <a class="el" href="BoxLevel_8C_source.html#l00804">SAMRAI::hier::BoxLevel::getSpatiallyEqualBox()</a>, <a class="el" href="BoxContainer_8C_source.html#l01523">getTotalSizeOfBoxes()</a>, <a class="el" href="BoxContainer_8C_source.html#l01560">grow()</a>, <a class="el" href="BoxUtilities_8C_source.html#l00622">SAMRAI::hier::BoxUtilities::growBoxesWithinDomain()</a>, <a class="el" href="BoxUtilities_8C_source.html#l00741">SAMRAI::hier::BoxUtilities::growBoxWithinDomain()</a>, <a class="el" href="BoxContainer_8C_source.html#l01621">hasBoxInBlock()</a>, <a class="el" href="BoxContainer_8C_source.html#l01878">hasOverlap()</a>, <a class="el" href="HierarchyNeighbors_8C_source.html#l00023">SAMRAI::hier::HierarchyNeighbors::HierarchyNeighbors()</a>, <a class="el" href="BoxNeighborhoodCollection_8C_source.html#l00245">SAMRAI::hier::BoxNeighborhoodCollection::insert()</a>, <a class="el" href="VoucherTransitLoad_8C_source.html#l00117">SAMRAI::mesh::VoucherTransitLoad::insertAll()</a>, <a class="el" href="BoxTransitSet_8C_source.html#l00128">SAMRAI::mesh::BoxTransitSet::insertAll()</a>, <a class="el" href="BoxContainer_8C_source.html#l01050">intersectBoxes()</a>, <a class="el" href="GraphLoadBalancer_8C_source.html#l00072">SAMRAI::mesh::GraphLoadBalancer::loadBalanceBoxLevel()</a>, <a class="el" href="ChopAndPackLoadBalancer_8C_source.html#l00240">SAMRAI::mesh::ChopAndPackLoadBalancer::loadBalanceBoxLevel()</a>, <a class="el" href="GridGeometry_8C_source.html#l00151">SAMRAI::geom::GridGeometry::makeCoarsenedGridGeometry()</a>, <a class="el" href="CartesianGridGeometry_8C_source.html#l00221">SAMRAI::geom::CartesianGridGeometry::makeCoarsenedGridGeometry()</a>, <a class="el" href="BoxUtilities_8C_source.html#l01773">SAMRAI::hier::BoxUtilities::makeNonOverlappingBoxContainers()</a>, <a class="el" href="BoxLevelConnectorUtils_8C_source.html#l01085">SAMRAI::hier::BoxLevelConnectorUtils::makeRemainderMap()</a>, <a class="el" href="UncoveredBoxIterator_8C_source.html#l00122">SAMRAI::hier::UncoveredBoxIterator::operator=()</a>, <a class="el" href="BoxContainer_8C_source.html#l01412">order()</a>, <a class="el" href="BaseConnectorAlgorithm_8C_source.html#l00119">SAMRAI::hier::BaseConnectorAlgorithm::packReferencedNeighbors()</a>, <a class="el" href="OutersideData_8C_source.html#l00388">SAMRAI::pdat::OutersideData&lt; TYPE &gt;::packStream()</a>, <a class="el" href="OuternodeData_8C_source.html#l00496">SAMRAI::pdat::OuternodeData&lt; TYPE &gt;::packStream()</a>, <a class="el" href="OuterfaceData_8C_source.html#l00408">SAMRAI::pdat::OuterfaceData&lt; TYPE &gt;::packStream()</a>, <a class="el" href="OuteredgeData_8C_source.html#l00601">SAMRAI::pdat::OuteredgeData&lt; TYPE &gt;::packStream()</a>, <a class="el" href="IndexData_8C_source.html#l00390">SAMRAI::pdat::IndexData&lt; TYPE, BOX_GEOMETRY &gt;::packStream()</a>, <a class="el" href="ArrayData_8C_source.html#l00641">SAMRAI::pdat::ArrayData&lt; TYPE &gt;::packStream()</a>, <a class="el" href="AssumedPartition_8C_source.html#l00068">SAMRAI::hier::AssumedPartition::partition()</a>, <a class="el" href="RefinePatchStrategy_8h_source.html#l00226">SAMRAI::xfer::RefinePatchStrategy::postprocessRefineBoxes()</a>, <a class="el" href="BalanceUtilities_8C_source.html#l02242">SAMRAI::mesh::BalanceUtilities::prebalanceBoxLevel()</a>, <a class="el" href="RefinePatchStrategy_8h_source.html#l00194">SAMRAI::xfer::RefinePatchStrategy::preprocessRefineBoxes()</a>, <a class="el" href="CellOverlap_8C_source.html#l00069">SAMRAI::pdat::CellOverlap::print()</a>, <a class="el" href="BoxContainer_8C_source.html#l01728">print()</a>, <a class="el" href="BaseGridGeometry_8C_source.html#l03290">SAMRAI::hier::BaseGridGeometry::printClassData()</a>, <a class="el" href="BoxContainer_8C_source.html#l01642">putToRestart()</a>, <a class="el" href="BaseGridGeometry_8C_source.html#l01870">SAMRAI::hier::BaseGridGeometry::readBlockDataFromInput()</a>, <a class="el" href="BalanceUtilities_8C_source.html#l01325">SAMRAI::mesh::BalanceUtilities::recursiveBisectionUniform()</a>, <a class="el" href="BoxLevel_8C_source.html#l01670">SAMRAI::hier::BoxLevel::recursivePrint()</a>, <a class="el" href="BoxContainer_8C_source.html#l01585">refine()</a>, <a class="el" href="BaseGridGeometry_8C_source.html#l02260">SAMRAI::hier::BaseGridGeometry::registerNeighbors()</a>, <a class="el" href="BoxContainer_8C_source.html#l00781">removeIntersections()</a>, <a class="el" href="BoxContainer_8C_source.html#l00580">removePeriodicImageBoxes()</a>, <a class="el" href="BoxContainer_8C_source.html#l00638">rotate()</a>, <a class="el" href="AssumedPartitionBox_8C_source.html#l00286">SAMRAI::hier::AssumedPartitionBox::selfCheck()</a>, <a class="el" href="BoxContainer_8C_source.html#l00606">separatePeriodicImages()</a>, <a class="el" href="CartesianGridGeometry_8C_source.html#l00281">SAMRAI::geom::CartesianGridGeometry::setGeometryData()</a>, <a class="el" href="BaseGridGeometry_8C_source.html#l01472">SAMRAI::hier::BaseGridGeometry::setPhysicalDomain()</a>, <a class="el" href="SideGeometry_8C_source.html#l00269">SAMRAI::pdat::SideGeometry::setUpOverlap()</a>, <a class="el" href="OutersideGeometry_8C_source.html#l00356">SAMRAI::pdat::OutersideGeometry::setUpOverlap()</a>, <a class="el" href="OuternodeGeometry_8C_source.html#l00467">SAMRAI::pdat::OuternodeGeometry::setUpOverlap()</a>, <a class="el" href="OuterfaceGeometry_8C_source.html#l00335">SAMRAI::pdat::OuterfaceGeometry::setUpOverlap()</a>, <a class="el" href="OuteredgeGeometry_8C_source.html#l00433">SAMRAI::pdat::OuteredgeGeometry::setUpOverlap()</a>, <a class="el" href="NodeGeometry_8C_source.html#l00152">SAMRAI::pdat::NodeGeometry::setUpOverlap()</a>, <a class="el" href="FaceGeometry_8C_source.html#l00241">SAMRAI::pdat::FaceGeometry::setUpOverlap()</a>, <a class="el" href="EdgeGeometry_8C_source.html#l00238">SAMRAI::pdat::EdgeGeometry::setUpOverlap()</a>, <a class="el" href="BoxContainer_8C_source.html#l01573">shift()</a>, <a class="el" href="Connector_8C_source.html#l00382">SAMRAI::hier::Connector::shrinkWidth()</a>, <a class="el" href="BoxContainer_8C_source.html#l00401">simplify()</a>, <a class="el" href="BalanceUtilities_8C_source.html#l01725">SAMRAI::mesh::BalanceUtilities::sortDescendingBoxWorkloads()</a>, <a class="el" href="BalanceUtilities_8C_source.html#l01149">SAMRAI::mesh::BalanceUtilities::spatialBinPack()</a>, <a class="el" href="BoxContainer_8h_source.html#l01192">spliceFront()</a>, <a class="el" href="ArrayData_8C_source.html#l00567">SAMRAI::pdat::ArrayData&lt; TYPE &gt;::sum()</a>, <a class="el" href="BaseGridGeometry_8C_source.html#l02764">SAMRAI::hier::BaseGridGeometry::transformBoxContainer()</a>, <a class="el" href="UncoveredBoxIterator_8C_source.html#l00066">SAMRAI::hier::UncoveredBoxIterator::UncoveredBoxIterator()</a>, <a class="el" href="OutersideData_8C_source.html#l00416">SAMRAI::pdat::OutersideData&lt; TYPE &gt;::unpackStream()</a>, <a class="el" href="OuternodeData_8C_source.html#l00525">SAMRAI::pdat::OuternodeData&lt; TYPE &gt;::unpackStream()</a>, <a class="el" href="OuterfaceData_8C_source.html#l00454">SAMRAI::pdat::OuterfaceData&lt; TYPE &gt;::unpackStream()</a>, <a class="el" href="OuteredgeData_8C_source.html#l00655">SAMRAI::pdat::OuteredgeData&lt; TYPE &gt;::unpackStream()</a>, <a class="el" href="IndexData_8C_source.html#l00440">SAMRAI::pdat::IndexData&lt; TYPE, BOX_GEOMETRY &gt;::unpackStream()</a>, <a class="el" href="ArrayData_8C_source.html#l00742">SAMRAI::pdat::ArrayData&lt; TYPE &gt;::unpackStream()</a>, <a class="el" href="OuternodeData_8C_source.html#l00560">SAMRAI::pdat::OuternodeData&lt; TYPE &gt;::unpackStreamAndSum()</a>, <a class="el" href="OuteredgeData_8C_source.html#l00713">SAMRAI::pdat::OuteredgeData&lt; TYPE &gt;::unpackStreamAndSum()</a>, <a class="el" href="ArrayData_8C_source.html#l00797">SAMRAI::pdat::ArrayData&lt; TYPE &gt;::unpackStreamAndSum()</a>, and <a class="el" href="BoxContainer_8C_source.html#l01377">unshiftPeriodicImageBoxes()</a>.</p>

</div>
</div>
<a class="anchor" id="a192b7c4c41e41cdb9466afb9005136e5"></a><!-- doxytag: member="SAMRAI::hier::BoxContainer::end" ref="a192b7c4c41e41cdb9466afb9005136e5" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer_1_1BoxContainerConstIterator.html">const_iterator</a> SAMRAI::hier::BoxContainer::end </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return a const_iterator pointing to the end of the container. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>An immutable iterator pointing beyond the last box. </dd></dl>

<p>Referenced by <a class="el" href="BoxLevel_8C_source.html#l01045">SAMRAI::hier::BoxLevel::addBox()</a>, <a class="el" href="BoxLevel_8C_source.html#l01109">SAMRAI::hier::BoxLevel::addPeriodicBox()</a>, <a class="el" href="BaseGridGeometry_8C_source.html#l02820">SAMRAI::hier::BaseGridGeometry::adjustMultiblockPatchLevelBoundaries()</a>, <a class="el" href="BaseGridGeometry_8C_source.html#l00107">SAMRAI::hier::BaseGridGeometry::BaseGridGeometry()</a>, <a class="el" href="BoxLevelConnectorUtils_8C_source.html#l00171">SAMRAI::hier::BoxLevelConnectorUtils::baseNestsInHead()</a>, <a class="el" href="BoxContainer_8C_source.html#l00078">BoxContainer()</a>, <a class="el" href="BoxContainer_8C_source.html#l00748">boxesIntersect()</a>, <a class="el" href="BoxNeighborhoodCollection_8C_source.html#l00022">SAMRAI::hier::BoxNeighborhoodCollection::BoxNeighborhoodCollection()</a>, <a class="el" href="BoxUtilities_8C_source.html#l00116">SAMRAI::hier::BoxUtilities::checkBoxConstraints()</a>, <a class="el" href="BoxUtilities_8C_source.html#l01202">SAMRAI::hier::BoxUtilities::checkBoxForBadCutPointsInDirection()</a>, <a class="el" href="Connector_8C_source.html#l01999">SAMRAI::hier::Connector::checkConsistencyWithHead()</a>, <a class="el" href="BoxContainer_8C_source.html#l00528">coalesce()</a>, <a class="el" href="BoxContainer_8C_source.html#l01597">coarsen()</a>, <a class="el" href="BoxLevelConnectorUtils_8C_source.html#l00880">SAMRAI::hier::BoxLevelConnectorUtils::computeBoxesAroundBoundary()</a>, <a class="el" href="BaseGridGeometry_8C_source.html#l00361">SAMRAI::hier::BaseGridGeometry::computeBoxTouchingBoundaries()</a>, <a class="el" href="SideGeometry_8C_source.html#l00120">SAMRAI::pdat::SideGeometry::computeDestinationBoxes()</a>, <a class="el" href="NodeGeometry_8C_source.html#l00095">SAMRAI::pdat::NodeGeometry::computeDestinationBoxes()</a>, <a class="el" href="FaceGeometry_8C_source.html#l00132">SAMRAI::pdat::FaceGeometry::computeDestinationBoxes()</a>, <a class="el" href="EdgeGeometry_8C_source.html#l00098">SAMRAI::pdat::EdgeGeometry::computeDestinationBoxes()</a>, <a class="el" href="PatchLevelInteriorFillPattern_8C_source.html#l00105">SAMRAI::xfer::PatchLevelInteriorFillPattern::computeDestinationFillBoxesOnSourceProc()</a>, <a class="el" href="PatchLevelFullFillPattern_8C_source.html#l00102">SAMRAI::xfer::PatchLevelFullFillPattern::computeDestinationFillBoxesOnSourceProc()</a>, <a class="el" href="PatchLevelBorderFillPattern_8C_source.html#l00053">SAMRAI::xfer::PatchLevelBorderFillPattern::computeFillBoxesAndNeighborhoodSets()</a>, <a class="el" href="PatchLevelBorderAndInteriorFillPattern_8C_source.html#l00052">SAMRAI::xfer::PatchLevelBorderAndInteriorFillPattern::computeFillBoxesAndNeighborhoodSets()</a>, <a class="el" href="SecondLayerNodeVariableFillPattern_8C_source.html#l00157">SAMRAI::pdat::SecondLayerNodeVariableFillPattern::computeFillBoxesOverlap()</a>, <a class="el" href="SecondLayerNodeNoCornersVariableFillPattern_8C_source.html#l00167">SAMRAI::pdat::SecondLayerNodeNoCornersVariableFillPattern::computeFillBoxesOverlap()</a>, <a class="el" href="FirstLayerSideVariableFillPattern_8C_source.html#l00160">SAMRAI::pdat::FirstLayerSideVariableFillPattern::computeFillBoxesOverlap()</a>, <a class="el" href="FirstLayerNodeVariableFillPattern_8C_source.html#l00150">SAMRAI::pdat::FirstLayerNodeVariableFillPattern::computeFillBoxesOverlap()</a>, <a class="el" href="FirstLayerEdgeVariableFillPattern_8C_source.html#l00160">SAMRAI::pdat::FirstLayerEdgeVariableFillPattern::computeFillBoxesOverlap()</a>, <a class="el" href="BoxLevelConnectorUtils_8C_source.html#l01486">SAMRAI::hier::BoxLevelConnectorUtils::computeNonIntersectingParts()</a>, <a class="el" href="BaseGridGeometry_8C_source.html#l01225">SAMRAI::hier::BaseGridGeometry::computePhysicalDomain()</a>, <a class="el" href="Connector_8C_source.html#l00523">SAMRAI::hier::Connector::computeTransposeOf()</a>, <a class="el" href="BalanceBoxBreaker_8C_source.html#l00967">SAMRAI::mesh::BalanceBoxBreaker::computeWidthScore()</a>, <a class="el" href="BalanceUtilities_8C_source.html#l02137">SAMRAI::mesh::BalanceUtilities::constrainMaxBoxSizes()</a>, <a class="el" href="BoxContainer_8C_source.html#l01539">contains()</a>, <a class="el" href="ArrayData_8C_source.html#l00351">SAMRAI::pdat::ArrayData&lt; TYPE &gt;::copy()</a>, <a class="el" href="BoxContainerSingleBlockIterator_8C_source.html#l00071">SAMRAI::hier::BoxContainerSingleBlockIterator::count()</a>, <a class="el" href="Connector_8C_source.html#l01189">SAMRAI::hier::Connector::doLocalTransposeWork()</a>, <a class="el" href="BoxNeighborhoodCollection_8C_source.html#l00303">SAMRAI::hier::BoxNeighborhoodCollection::erase()</a>, <a class="el" href="BoxLevel_8C_source.html#l01241">SAMRAI::hier::BoxLevel::eraseBox()</a>, <a class="el" href="BoxUtilities_8C_source.html#l00536">SAMRAI::hier::BoxUtilities::extendBoxToDomainBoundary()</a>, <a class="el" href="OverlapConnectorAlgorithm_8C_source.html#l00147">SAMRAI::hier::OverlapConnectorAlgorithm::extractNeighbors()</a>, <a class="el" href="BoxLevel_8C_source.html#l00307">SAMRAI::hier::BoxLevel::finalize()</a>, <a class="el" href="BoxUtilities_8C_source.html#l01336">SAMRAI::hier::BoxUtilities::findBadCutPointsForDirection()</a>, <a class="el" href="TileClustering_8C_source.html#l00125">SAMRAI::mesh::TileClustering::findBoxesContainingTags()</a>, <a class="el" href="BergerRigoutsos_8C_source.html#l00251">SAMRAI::mesh::BergerRigoutsos::findBoxesContainingTags()</a>, <a class="el" href="BoxContainer_8C_source.html#l01788">findOverlapBoxes()</a>, <a class="el" href="OverlapConnectorAlgorithm_8C_source.html#l00490">SAMRAI::hier::OverlapConnectorAlgorithm::findOverlaps_assumedPartition()</a>, <a class="el" href="BalanceUtilities_8C_source.html#l01871">SAMRAI::mesh::BalanceUtilities::findSmallBoxesInPostbalance()</a>, <a class="el" href="FlattenedHierarchy_8C_source.html#l00027">SAMRAI::hier::FlattenedHierarchy::FlattenedHierarchy()</a>, <a class="el" href="BaseGridGeometry_8C_source.html#l01075">SAMRAI::hier::BaseGridGeometry::getBoundaryBoxes()</a>, <a class="el" href="BoxContainer_8C_source.html#l00676">getBoundingBox()</a>, <a class="el" href="PatchLevel_8C_source.html#l00708">SAMRAI::hier::PatchLevel::getBoxes()</a>, <a class="el" href="BoxLevel_8C_source.html#l01425">SAMRAI::hier::BoxLevel::getBoxStrict()</a>, <a class="el" href="IndexData_8C_source.html#l00350">SAMRAI::pdat::IndexData&lt; TYPE, BOX_GEOMETRY &gt;::getDataStreamSize()</a>, <a class="el" href="BoxLevel_8C_source.html#l01359">SAMRAI::hier::BoxLevel::getFirstLocalId()</a>, <a class="el" href="BoxContainer_8C_source.html#l01686">getFromRestart()</a>, <a class="el" href="BoxLevel_8C_source.html#l01502">SAMRAI::hier::BoxLevel::getGlobalBoxes()</a>, <a class="el" href="BoxLevel_8C_source.html#l01376">SAMRAI::hier::BoxLevel::getLastLocalId()</a>, <a class="el" href="BoxLevel_8C_source.html#l00746">SAMRAI::hier::BoxLevel::getLocalNumberOfBoxes()</a>, <a class="el" href="BoxLevel_8C_source.html#l00775">SAMRAI::hier::BoxLevel::getLocalNumberOfCells()</a>, <a class="el" href="BoxContainer_8C_source.html#l01348">getOwners()</a>, <a class="el" href="SideOverlap_8C_source.html#l00052">SAMRAI::pdat::SideOverlap::getSourceBoxContainer()</a>, <a class="el" href="FaceOverlap_8C_source.html#l00053">SAMRAI::pdat::FaceOverlap::getSourceBoxContainer()</a>, <a class="el" href="EdgeOverlap_8C_source.html#l00052">SAMRAI::pdat::EdgeOverlap::getSourceBoxContainer()</a>, <a class="el" href="BoxLevel_8C_source.html#l00804">SAMRAI::hier::BoxLevel::getSpatiallyEqualBox()</a>, <a class="el" href="BoxContainer_8C_source.html#l01523">getTotalSizeOfBoxes()</a>, <a class="el" href="BoxContainer_8C_source.html#l01560">grow()</a>, <a class="el" href="BoxUtilities_8C_source.html#l00622">SAMRAI::hier::BoxUtilities::growBoxesWithinDomain()</a>, <a class="el" href="BoxUtilities_8C_source.html#l00741">SAMRAI::hier::BoxUtilities::growBoxWithinDomain()</a>, <a class="el" href="BoxLevel_8C_source.html#l01399">SAMRAI::hier::BoxLevel::hasBox()</a>, <a class="el" href="BoxContainer_8C_source.html#l01621">hasBoxInBlock()</a>, <a class="el" href="BoxContainer_8C_source.html#l01878">hasOverlap()</a>, <a class="el" href="HierarchyNeighbors_8C_source.html#l00023">SAMRAI::hier::HierarchyNeighbors::HierarchyNeighbors()</a>, <a class="el" href="BoxNeighborhoodCollection_8C_source.html#l00245">SAMRAI::hier::BoxNeighborhoodCollection::insert()</a>, <a class="el" href="BoxContainer_8h_source.html#l01159">insertAfter()</a>, <a class="el" href="VoucherTransitLoad_8C_source.html#l00117">SAMRAI::mesh::VoucherTransitLoad::insertAll()</a>, <a class="el" href="BoxTransitSet_8C_source.html#l00128">SAMRAI::mesh::BoxTransitSet::insertAll()</a>, <a class="el" href="BoxTransitSet_8C_source.html#l00162">SAMRAI::mesh::BoxTransitSet::insertAllWithExistingLoads()</a>, <a class="el" href="BoxContainer_8C_source.html#l01050">intersectBoxes()</a>, <a class="el" href="GraphLoadBalancer_8C_source.html#l00072">SAMRAI::mesh::GraphLoadBalancer::loadBalanceBoxLevel()</a>, <a class="el" href="ChopAndPackLoadBalancer_8C_source.html#l00240">SAMRAI::mesh::ChopAndPackLoadBalancer::loadBalanceBoxLevel()</a>, <a class="el" href="BoxUtilities_8C_source.html#l01773">SAMRAI::hier::BoxUtilities::makeNonOverlappingBoxContainers()</a>, <a class="el" href="BoxLevelConnectorUtils_8C_source.html#l01085">SAMRAI::hier::BoxLevelConnectorUtils::makeRemainderMap()</a>, <a class="el" href="BoxLevelConnectorUtils_8C_source.html#l00357">SAMRAI::hier::BoxLevelConnectorUtils::makeSortingMap()</a>, <a class="el" href="RealBoxConstIterator_8C_source.html#l00040">SAMRAI::hier::RealBoxConstIterator::operator++()</a>, <a class="el" href="BoxContainerSingleOwnerIterator_8C_source.html#l00043">SAMRAI::hier::BoxContainerSingleOwnerIterator::operator++()</a>, <a class="el" href="BoxContainerSingleBlockIterator_8C_source.html#l00043">SAMRAI::hier::BoxContainerSingleBlockIterator::operator++()</a>, <a class="el" href="UncoveredBoxIterator_8C_source.html#l00122">SAMRAI::hier::UncoveredBoxIterator::operator=()</a>, <a class="el" href="BoxContainer_8C_source.html#l01412">order()</a>, <a class="el" href="BaseConnectorAlgorithm_8C_source.html#l00119">SAMRAI::hier::BaseConnectorAlgorithm::packReferencedNeighbors()</a>, <a class="el" href="OutersideData_8C_source.html#l00388">SAMRAI::pdat::OutersideData&lt; TYPE &gt;::packStream()</a>, <a class="el" href="OuternodeData_8C_source.html#l00496">SAMRAI::pdat::OuternodeData&lt; TYPE &gt;::packStream()</a>, <a class="el" href="OuterfaceData_8C_source.html#l00408">SAMRAI::pdat::OuterfaceData&lt; TYPE &gt;::packStream()</a>, <a class="el" href="OuteredgeData_8C_source.html#l00601">SAMRAI::pdat::OuteredgeData&lt; TYPE &gt;::packStream()</a>, <a class="el" href="IndexData_8C_source.html#l00390">SAMRAI::pdat::IndexData&lt; TYPE, BOX_GEOMETRY &gt;::packStream()</a>, <a class="el" href="ArrayData_8C_source.html#l00641">SAMRAI::pdat::ArrayData&lt; TYPE &gt;::packStream()</a>, <a class="el" href="AssumedPartition_8C_source.html#l00068">SAMRAI::hier::AssumedPartition::partition()</a>, <a class="el" href="RefinePatchStrategy_8h_source.html#l00226">SAMRAI::xfer::RefinePatchStrategy::postprocessRefineBoxes()</a>, <a class="el" href="BalanceUtilities_8C_source.html#l02242">SAMRAI::mesh::BalanceUtilities::prebalanceBoxLevel()</a>, <a class="el" href="RefinePatchStrategy_8h_source.html#l00194">SAMRAI::xfer::RefinePatchStrategy::preprocessRefineBoxes()</a>, <a class="el" href="CellOverlap_8C_source.html#l00069">SAMRAI::pdat::CellOverlap::print()</a>, <a class="el" href="BoxContainer_8C_source.html#l01728">print()</a>, <a class="el" href="BaseGridGeometry_8C_source.html#l03290">SAMRAI::hier::BaseGridGeometry::printClassData()</a>, <a class="el" href="BoxContainer_8C_source.html#l01642">putToRestart()</a>, <a class="el" href="BaseGridGeometry_8C_source.html#l01870">SAMRAI::hier::BaseGridGeometry::readBlockDataFromInput()</a>, <a class="el" href="BalanceUtilities_8C_source.html#l01325">SAMRAI::mesh::BalanceUtilities::recursiveBisectionUniform()</a>, <a class="el" href="BoxLevel_8C_source.html#l01670">SAMRAI::hier::BoxLevel::recursivePrint()</a>, <a class="el" href="BoxContainer_8C_source.html#l01585">refine()</a>, <a class="el" href="BaseGridGeometry_8C_source.html#l02260">SAMRAI::hier::BaseGridGeometry::registerNeighbors()</a>, <a class="el" href="BoxContainer_8C_source.html#l00781">removeIntersections()</a>, <a class="el" href="BoxContainer_8C_source.html#l00580">removePeriodicImageBoxes()</a>, <a class="el" href="BoxContainer_8C_source.html#l00638">rotate()</a>, <a class="el" href="AssumedPartitionBox_8C_source.html#l00286">SAMRAI::hier::AssumedPartitionBox::selfCheck()</a>, <a class="el" href="BoxContainer_8C_source.html#l00606">separatePeriodicImages()</a>, <a class="el" href="CartesianGridGeometry_8C_source.html#l00281">SAMRAI::geom::CartesianGridGeometry::setGeometryData()</a>, <a class="el" href="BaseGridGeometry_8C_source.html#l01472">SAMRAI::hier::BaseGridGeometry::setPhysicalDomain()</a>, <a class="el" href="SideGeometry_8C_source.html#l00269">SAMRAI::pdat::SideGeometry::setUpOverlap()</a>, <a class="el" href="OutersideGeometry_8C_source.html#l00356">SAMRAI::pdat::OutersideGeometry::setUpOverlap()</a>, <a class="el" href="OuternodeGeometry_8C_source.html#l00467">SAMRAI::pdat::OuternodeGeometry::setUpOverlap()</a>, <a class="el" href="OuterfaceGeometry_8C_source.html#l00335">SAMRAI::pdat::OuterfaceGeometry::setUpOverlap()</a>, <a class="el" href="OuteredgeGeometry_8C_source.html#l00433">SAMRAI::pdat::OuteredgeGeometry::setUpOverlap()</a>, <a class="el" href="NodeGeometry_8C_source.html#l00152">SAMRAI::pdat::NodeGeometry::setUpOverlap()</a>, <a class="el" href="FaceGeometry_8C_source.html#l00241">SAMRAI::pdat::FaceGeometry::setUpOverlap()</a>, <a class="el" href="EdgeGeometry_8C_source.html#l00238">SAMRAI::pdat::EdgeGeometry::setUpOverlap()</a>, <a class="el" href="BoxContainer_8C_source.html#l01573">shift()</a>, <a class="el" href="Connector_8C_source.html#l00382">SAMRAI::hier::Connector::shrinkWidth()</a>, <a class="el" href="BoxContainer_8C_source.html#l00401">simplify()</a>, <a class="el" href="BalanceUtilities_8C_source.html#l01725">SAMRAI::mesh::BalanceUtilities::sortDescendingBoxWorkloads()</a>, <a class="el" href="BalanceUtilities_8C_source.html#l01149">SAMRAI::mesh::BalanceUtilities::spatialBinPack()</a>, <a class="el" href="ArrayData_8C_source.html#l00567">SAMRAI::pdat::ArrayData&lt; TYPE &gt;::sum()</a>, <a class="el" href="BaseGridGeometry_8C_source.html#l02764">SAMRAI::hier::BaseGridGeometry::transformBoxContainer()</a>, <a class="el" href="UncoveredBoxIterator_8C_source.html#l00066">SAMRAI::hier::UncoveredBoxIterator::UncoveredBoxIterator()</a>, <a class="el" href="OutersideData_8C_source.html#l00416">SAMRAI::pdat::OutersideData&lt; TYPE &gt;::unpackStream()</a>, <a class="el" href="OuternodeData_8C_source.html#l00525">SAMRAI::pdat::OuternodeData&lt; TYPE &gt;::unpackStream()</a>, <a class="el" href="OuterfaceData_8C_source.html#l00454">SAMRAI::pdat::OuterfaceData&lt; TYPE &gt;::unpackStream()</a>, <a class="el" href="OuteredgeData_8C_source.html#l00655">SAMRAI::pdat::OuteredgeData&lt; TYPE &gt;::unpackStream()</a>, <a class="el" href="IndexData_8C_source.html#l00440">SAMRAI::pdat::IndexData&lt; TYPE, BOX_GEOMETRY &gt;::unpackStream()</a>, <a class="el" href="ArrayData_8C_source.html#l00742">SAMRAI::pdat::ArrayData&lt; TYPE &gt;::unpackStream()</a>, <a class="el" href="OuternodeData_8C_source.html#l00560">SAMRAI::pdat::OuternodeData&lt; TYPE &gt;::unpackStreamAndSum()</a>, <a class="el" href="OuteredgeData_8C_source.html#l00713">SAMRAI::pdat::OuteredgeData&lt; TYPE &gt;::unpackStreamAndSum()</a>, <a class="el" href="ArrayData_8C_source.html#l00797">SAMRAI::pdat::ArrayData&lt; TYPE &gt;::unpackStreamAndSum()</a>, and <a class="el" href="BoxContainer_8C_source.html#l01377">unshiftPeriodicImageBoxes()</a>.</p>

</div>
</div>
<a class="anchor" id="a9177f688d517d8106664d509c6851f86"></a><!-- doxytag: member="SAMRAI::hier::BoxContainer::begin" ref="a9177f688d517d8106664d509c6851f86" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer_1_1BoxContainerIterator.html">iterator</a> SAMRAI::hier::BoxContainer::begin </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return an iterator pointing to the start of the container. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>A mutable iterator pointing to the first box. </dd></dl>

</div>
</div>
<a class="anchor" id="a9c566195352afe03c2c1b2ef8d19e55c"></a><!-- doxytag: member="SAMRAI::hier::BoxContainer::end" ref="a9c566195352afe03c2c1b2ef8d19e55c" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer_1_1BoxContainerIterator.html">iterator</a> SAMRAI::hier::BoxContainer::end </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return an iterator pointing to the end of the container. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>A mutable iterator pointing beyond the last box. </dd></dl>

</div>
</div>
<a class="anchor" id="a109bd0cce2a5b8f69e5ea1f971294ca2"></a><!-- doxytag: member="SAMRAI::hier::BoxContainer::begin" ref="a109bd0cce2a5b8f69e5ea1f971294ca2" args="(const BlockId &amp;block_id) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainerSingleBlockIterator.html">BoxContainerSingleBlockIterator</a> SAMRAI::hier::BoxContainer::begin </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1BlockId.html">BlockId</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>block_id</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return a <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainerSingleBlockIterator.html" title="BoxContainer iterator picking items with a specified BlockId.">BoxContainerSingleBlockIterator</a> pointing to the first box in the container with the given <a class="el" href="classSAMRAI_1_1hier_1_1BlockId.html" title="Generic identifier for identifying the block id.">BlockId</a>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>block_id</em>&nbsp;</td><td>The <a class="el" href="classSAMRAI_1_1hier_1_1BlockId.html" title="Generic identifier for identifying the block id.">BlockId</a> of the boxes we want.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A mutable iterator pointing to the first box with the given <a class="el" href="classSAMRAI_1_1hier_1_1BlockId.html" title="Generic identifier for identifying the block id.">BlockId</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="a830399bd31f98ef38c7df25180486f9f"></a><!-- doxytag: member="SAMRAI::hier::BoxContainer::end" ref="a830399bd31f98ef38c7df25180486f9f" args="(const BlockId &amp;block_id) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainerSingleBlockIterator.html">BoxContainerSingleBlockIterator</a> SAMRAI::hier::BoxContainer::end </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1BlockId.html">BlockId</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>block_id</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return a <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainerSingleBlockIterator.html" title="BoxContainer iterator picking items with a specified BlockId.">BoxContainerSingleBlockIterator</a> pointing to the end of the container. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>block_id</em>&nbsp;</td><td>The <a class="el" href="classSAMRAI_1_1hier_1_1BlockId.html" title="Generic identifier for identifying the block id.">BlockId</a> of the boxes we want.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A mutable iterator pointing beyond the last box. </dd></dl>

</div>
</div>
<a class="anchor" id="af0a3a4e59efb7b20fdc43ea27a375582"></a><!-- doxytag: member="SAMRAI::hier::BoxContainer::begin" ref="af0a3a4e59efb7b20fdc43ea27a375582" args="(const int &amp;owner_rank) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainerSingleOwnerIterator.html">BoxContainerSingleOwnerIterator</a> SAMRAI::hier::BoxContainer::begin </td>
          <td>(</td>
          <td class="paramtype">const int &amp;&nbsp;</td>
          <td class="paramname"> <em>owner_rank</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return a <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainerSingleOwnerIterator.html" title="BoxContainer iterator picking items with a specified owner rank.">BoxContainerSingleOwnerIterator</a> pointing to the first box in the container having the given owner. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>owner_rank</em>&nbsp;</td><td>The processaor whose boxes we want.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A mutable iterator pointing to the first box having the given owner. </dd></dl>

</div>
</div>
<a class="anchor" id="a6de540684a35466938f821a940d459e9"></a><!-- doxytag: member="SAMRAI::hier::BoxContainer::end" ref="a6de540684a35466938f821a940d459e9" args="(const int &amp;owner_rank) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainerSingleOwnerIterator.html">BoxContainerSingleOwnerIterator</a> SAMRAI::hier::BoxContainer::end </td>
          <td>(</td>
          <td class="paramtype">const int &amp;&nbsp;</td>
          <td class="paramname"> <em>owner_rank</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return a <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainerSingleOwnerIterator.html" title="BoxContainer iterator picking items with a specified owner rank.">BoxContainerSingleOwnerIterator</a> pointing to the end of the container. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>owner_rank</em>&nbsp;</td><td>The processaor whose boxes we want.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A mutable iterator pointing beyond the last box. </dd></dl>

</div>
</div>
<a class="anchor" id="a42c5c13e9f4ddb913215f12a030c761e"></a><!-- doxytag: member="SAMRAI::hier::BoxContainer::realBegin" ref="a42c5c13e9f4ddb913215f12a030c761e" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSAMRAI_1_1hier_1_1RealBoxConstIterator.html">RealBoxConstIterator</a> SAMRAI::hier::BoxContainer::realBegin </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return a <a class="el" href="classSAMRAI_1_1hier_1_1RealBoxConstIterator.html" title="Iterator through real Boxes (not periodic images) in a const BoxContainer.">RealBoxConstIterator</a> pointing to the first real (non-periodic) box in the container. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>A mutable iterator pointing to the first non-periodic box. </dd></dl>

<p>Referenced by <a class="el" href="BoxLevel_8C_source.html#l00626">SAMRAI::hier::BoxLevel::cacheGlobalReducedData()</a>, <a class="el" href="PatchLevelInteriorFillPattern_8C_source.html#l00061">SAMRAI::xfer::PatchLevelInteriorFillPattern::computeFillBoxesAndNeighborhoodSets()</a>, <a class="el" href="PatchLevelFullFillPattern_8C_source.html#l00060">SAMRAI::xfer::PatchLevelFullFillPattern::computeFillBoxesAndNeighborhoodSets()</a>, <a class="el" href="PatchLevelBorderFillPattern_8C_source.html#l00053">SAMRAI::xfer::PatchLevelBorderFillPattern::computeFillBoxesAndNeighborhoodSets()</a>, <a class="el" href="PatchLevelBorderAndInteriorFillPattern_8C_source.html#l00052">SAMRAI::xfer::PatchLevelBorderAndInteriorFillPattern::computeFillBoxesAndNeighborhoodSets()</a>, <a class="el" href="MappingConnector_8C_source.html#l00165">SAMRAI::hier::MappingConnector::findMappingErrors()</a>, <a class="el" href="FlattenedHierarchy_8C_source.html#l00027">SAMRAI::hier::FlattenedHierarchy::FlattenedHierarchy()</a>, <a class="el" href="PatchLevel_8C_source.html#l00736">SAMRAI::hier::PatchLevel::getFromRestart()</a>, <a class="el" href="PatchLevel_8C_source.html#l00087">SAMRAI::hier::PatchLevel::PatchLevel()</a>, <a class="el" href="PatchLevel_8C_source.html#l00539">SAMRAI::hier::PatchLevel::setCoarsenedPatchLevel()</a>, and <a class="el" href="PatchLevel_8C_source.html#l00375">SAMRAI::hier::PatchLevel::setRefinedPatchLevel()</a>.</p>

</div>
</div>
<a class="anchor" id="a7dae366456c18c63846ffd42a0fbc542"></a><!-- doxytag: member="SAMRAI::hier::BoxContainer::realEnd" ref="a7dae366456c18c63846ffd42a0fbc542" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSAMRAI_1_1hier_1_1RealBoxConstIterator.html">RealBoxConstIterator</a> SAMRAI::hier::BoxContainer::realEnd </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return a <a class="el" href="classSAMRAI_1_1hier_1_1RealBoxConstIterator.html" title="Iterator through real Boxes (not periodic images) in a const BoxContainer.">RealBoxConstIterator</a> pointing to the end of the container. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>A mutable iterator pointing beyond the last box. </dd></dl>

<p>Referenced by <a class="el" href="BoxLevel_8C_source.html#l00626">SAMRAI::hier::BoxLevel::cacheGlobalReducedData()</a>, <a class="el" href="PatchLevelInteriorFillPattern_8C_source.html#l00061">SAMRAI::xfer::PatchLevelInteriorFillPattern::computeFillBoxesAndNeighborhoodSets()</a>, <a class="el" href="PatchLevelFullFillPattern_8C_source.html#l00060">SAMRAI::xfer::PatchLevelFullFillPattern::computeFillBoxesAndNeighborhoodSets()</a>, <a class="el" href="PatchLevelBorderFillPattern_8C_source.html#l00053">SAMRAI::xfer::PatchLevelBorderFillPattern::computeFillBoxesAndNeighborhoodSets()</a>, <a class="el" href="PatchLevelBorderAndInteriorFillPattern_8C_source.html#l00052">SAMRAI::xfer::PatchLevelBorderAndInteriorFillPattern::computeFillBoxesAndNeighborhoodSets()</a>, <a class="el" href="MappingConnector_8C_source.html#l00165">SAMRAI::hier::MappingConnector::findMappingErrors()</a>, <a class="el" href="FlattenedHierarchy_8C_source.html#l00027">SAMRAI::hier::FlattenedHierarchy::FlattenedHierarchy()</a>, <a class="el" href="PatchLevel_8C_source.html#l00736">SAMRAI::hier::PatchLevel::getFromRestart()</a>, <a class="el" href="PatchLevel_8C_source.html#l00087">SAMRAI::hier::PatchLevel::PatchLevel()</a>, <a class="el" href="PatchLevel_8C_source.html#l00539">SAMRAI::hier::PatchLevel::setCoarsenedPatchLevel()</a>, and <a class="el" href="PatchLevel_8C_source.html#l00375">SAMRAI::hier::PatchLevel::setRefinedPatchLevel()</a>.</p>

</div>
</div>
<a class="anchor" id="aacb30f477c077d265d20b477e5adc0f3"></a><!-- doxytag: member="SAMRAI::hier::BoxContainer::front" ref="aacb30f477c077d265d20b477e5adc0f3" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a>&amp; SAMRAI::hier::BoxContainer::front </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the first element in the container. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>A const reference to the first <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> in the container. </dd></dl>

<p>Referenced by <a class="el" href="BoxUtilities_8C_source.html#l00417">SAMRAI::hier::BoxUtilities::chopBox()</a>, <a class="el" href="BoxContainer_8C_source.html#l00528">coalesce()</a>, <a class="el" href="BalanceUtilities_8C_source.html#l02137">SAMRAI::mesh::BalanceUtilities::constrainMaxBoxSizes()</a>, <a class="el" href="BoxUtilities_8C_source.html#l00506">SAMRAI::hier::BoxUtilities::extendBoxesToDomainBoundary()</a>, <a class="el" href="TileClustering_8C_source.html#l00125">SAMRAI::mesh::TileClustering::findBoxesContainingTags()</a>, <a class="el" href="NodeOverlap_8C_source.html#l00041">SAMRAI::pdat::NodeOverlap::getSourceBoxContainer()</a>, <a class="el" href="BoxUtilities_8C_source.html#l01817">SAMRAI::hier::BoxUtilities::growAndAdjustAcrossBlockBoundary()</a>, <a class="el" href="BoxUtilities_8C_source.html#l00622">SAMRAI::hier::BoxUtilities::growBoxesWithinDomain()</a>, <a class="el" href="BoxContainer_8C_source.html#l00248">insert()</a>, <a class="el" href="BoxContainer_8h_source.html#l01127">insertBefore()</a>, <a class="el" href="BoxContainer_8C_source.html#l01160">intersectBoxes()</a>, <a class="el" href="BoxContainer_8h_source.html#l01076">pushBack()</a>, <a class="el" href="BoxContainer_8h_source.html#l01046">pushFront()</a>, <a class="el" href="BoxContainer_8C_source.html#l00401">simplify()</a>, <a class="el" href="BalanceUtilities_8C_source.html#l01725">SAMRAI::mesh::BalanceUtilities::sortDescendingBoxWorkloads()</a>, <a class="el" href="BalanceUtilities_8C_source.html#l01149">SAMRAI::mesh::BalanceUtilities::spatialBinPack()</a>, <a class="el" href="BoxContainer_8h_source.html#l01223">spliceBack()</a>, and <a class="el" href="BoxContainer_8h_source.html#l01192">spliceFront()</a>.</p>

</div>
</div>
<a class="anchor" id="a1a00d37886fa41bd01c6741568ab5bb6"></a><!-- doxytag: member="SAMRAI::hier::BoxContainer::back" ref="a1a00d37886fa41bd01c6741568ab5bb6" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a>&amp; SAMRAI::hier::BoxContainer::back </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the first element in the container. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>A const reference to the last <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> in the container. </dd></dl>

<p>Referenced by <a class="el" href="OverlapConnectorAlgorithm_8C_source.html#l00490">SAMRAI::hier::OverlapConnectorAlgorithm::findOverlaps_assumedPartition()</a>, and <a class="el" href="GraphLoadBalancer_8C_source.html#l00072">SAMRAI::mesh::GraphLoadBalancer::loadBalanceBoxLevel()</a>.</p>

</div>
</div>
<a class="anchor" id="ac4efcb7ab3ef052fa78b468ecb26cf44"></a><!-- doxytag: member="SAMRAI::hier::BoxContainer::erase" ref="ac4efcb7ab3ef052fa78b468ecb26cf44" args="(iterator iter)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::hier::BoxContainer::erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer_1_1BoxContainerIterator.html">iterator</a>&nbsp;</td>
          <td class="paramname"> <em>iter</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Remove the member of the container pointed to by "iter". </p>
<p>Can be called on ordered or unordered containers.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>iter</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="Box_8h_source.html#l00315">SAMRAI::hier::Box::getBoxId()</a>.</p>

<p>Referenced by <a class="el" href="BoxContainer_8C_source.html#l00528">coalesce()</a>, <a class="el" href="BoxContainer_8C_source.html#l01475">erase()</a>, <a class="el" href="BoxLevel_8C_source.html#l01241">SAMRAI::hier::BoxLevel::eraseBox()</a>, <a class="el" href="BoxLevel_8h_source.html#l01131">SAMRAI::hier::BoxLevel::eraseBoxWithoutUpdate()</a>, <a class="el" href="BoxLevel_8C_source.html#l00307">SAMRAI::hier::BoxLevel::finalize()</a>, <a class="el" href="BoxContainer_8C_source.html#l01050">intersectBoxes()</a>, <a class="el" href="BoxContainer_8C_source.html#l00781">removeIntersections()</a>, <a class="el" href="BoxContainer_8C_source.html#l00580">removePeriodicImageBoxes()</a>, <a class="el" href="AssumedPartitionBox_8C_source.html#l00286">SAMRAI::hier::AssumedPartitionBox::selfCheck()</a>, and <a class="el" href="BoxContainer_8C_source.html#l00401">simplify()</a>.</p>

</div>
</div>
<a class="anchor" id="a0c1648bbd364c5d25c1c4b1a99de0f1c"></a><!-- doxytag: member="SAMRAI::hier::BoxContainer::erase" ref="a0c1648bbd364c5d25c1c4b1a99de0f1c" args="(iterator first, iterator last)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::hier::BoxContainer::erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer_1_1BoxContainerIterator.html">iterator</a>&nbsp;</td>
          <td class="paramname"> <em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer_1_1BoxContainerIterator.html">iterator</a>&nbsp;</td>
          <td class="paramname"> <em>last</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Remove the members of the container in the range [first, last). </p>
<p>Can be called on ordered or unordered containers.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>first</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>last</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="BoxContainer_8C_source.html#l01452">erase()</a>.</p>

</div>
</div>
<a class="anchor" id="a36eeafbcb7e07afea2806d64a2f0d4c3"></a><!-- doxytag: member="SAMRAI::hier::BoxContainer::clear" ref="a36eeafbcb7e07afea2806d64a2f0d4c3" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::hier::BoxContainer::clear </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Removes all the members of the container. </p>
<p>Can be called on unordered or unordered containers. Sets the state to unordered. </p>

<p>Referenced by <a class="el" href="BalanceBoxBreaker_8C_source.html#l00072">SAMRAI::mesh::BalanceBoxBreaker::breakOffLoad()</a>, <a class="el" href="BalanceBoxBreaker_8C_source.html#l00882">SAMRAI::mesh::BalanceBoxBreaker::burstBox()</a>, <a class="el" href="BoxUtilities_8C_source.html#l01202">SAMRAI::hier::BoxUtilities::checkBoxForBadCutPointsInDirection()</a>, <a class="el" href="BoxUtilities_8C_source.html#l00417">SAMRAI::hier::BoxUtilities::chopBox()</a>, <a class="el" href="BoxUtilities_8C_source.html#l00326">SAMRAI::hier::BoxUtilities::chopBoxes()</a>, <a class="el" href="BoxLevel_8C_source.html#l00464">SAMRAI::hier::BoxLevel::clear()</a>, <a class="el" href="BoxLevelConnectorUtils_8C_source.html#l00880">SAMRAI::hier::BoxLevelConnectorUtils::computeBoxesAroundBoundary()</a>, <a class="el" href="BaseGridGeometry_8C_source.html#l01225">SAMRAI::hier::BaseGridGeometry::computePhysicalDomain()</a>, <a class="el" href="Connector_8C_source.html#l00523">SAMRAI::hier::Connector::computeTransposeOf()</a>, <a class="el" href="OverlapConnectorAlgorithm_8C_source.html#l00147">SAMRAI::hier::OverlapConnectorAlgorithm::extractNeighbors()</a>, <a class="el" href="BoxUtilities_8C_source.html#l01336">SAMRAI::hier::BoxUtilities::findBadCutPointsForDirection()</a>, <a class="el" href="OverlapConnectorAlgorithm_8C_source.html#l00490">SAMRAI::hier::OverlapConnectorAlgorithm::findOverlaps_assumedPartition()</a>, <a class="el" href="PatchLevel_8C_source.html#l00708">SAMRAI::hier::PatchLevel::getBoxes()</a>, <a class="el" href="BoxUtilities_8C_source.html#l01817">SAMRAI::hier::BoxUtilities::growAndAdjustAcrossBlockBoundary()</a>, <a class="el" href="BoxUtilities_8C_source.html#l00741">SAMRAI::hier::BoxUtilities::growBoxWithinDomain()</a>, <a class="el" href="BoxContainer_8C_source.html#l01160">intersectBoxes()</a>, <a class="el" href="BoxContainer_8C_source.html#l00148">operator=()</a>, <a class="el" href="BalanceUtilities_8C_source.html#l01418">SAMRAI::mesh::BalanceUtilities::recursiveBisectionNonuniform()</a>, <a class="el" href="BalanceUtilities_8C_source.html#l01325">SAMRAI::mesh::BalanceUtilities::recursiveBisectionUniform()</a>, <a class="el" href="AssumedPartitionBox_8C_source.html#l00286">SAMRAI::hier::AssumedPartitionBox::selfCheck()</a>, <a class="el" href="BoxLevel_8C_source.html#l00827">SAMRAI::hier::BoxLevel::setParallelState()</a>, and <a class="el" href="BaseGridGeometry_8C_source.html#l01472">SAMRAI::hier::BaseGridGeometry::setPhysicalDomain()</a>.</p>

</div>
</div>
<a class="anchor" id="a9aa7f1ff4dacf6c075e4eadb7363ea3c"></a><!-- doxytag: member="SAMRAI::hier::BoxContainer::swap" ref="a9aa7f1ff4dacf6c075e4eadb7363ea3c" args="(BoxContainer &amp;other)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::hier::BoxContainer::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>other</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Swap all contents and state with another <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html" title="A container for Boxes.">BoxContainer</a>. </p>
<p>This container and other container exchange all member Boxes and ordered/unordered state.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>other</em>&nbsp;</td><td>Other container for swap. </td></tr>
  </table>
  </dd>
</dl>

<p>Referenced by <a class="el" href="BalanceBoxBreaker_8C_source.html#l00072">SAMRAI::mesh::BalanceBoxBreaker::breakOffLoad()</a>, <a class="el" href="BoxLevel_8C_source.html#l00498">SAMRAI::hier::BoxLevel::swap()</a>, and <a class="el" href="BoxLevel_8C_source.html#l00286">SAMRAI::hier::BoxLevel::swapInitialize()</a>.</p>

</div>
</div>
<a class="anchor" id="a8f32186ba3fc0bb9df9f73ed746ebc92"></a><!-- doxytag: member="SAMRAI::hier::BoxContainer::getOwners" ref="a8f32186ba3fc0bb9df9f73ed746ebc92" args="(std::set&lt; int &gt; &amp;owners) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::hier::BoxContainer::getOwners </td>
          <td>(</td>
          <td class="paramtype">std::set&lt; int &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>owners</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get all of the ranks that own Boxes in this container. </p>
<p>The rank of every member of this container is inserted into the set.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>owners</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="pre"><dt><b>Precondition:</b></dt><dd><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html#ab60e3636df51eb5997471a5520c7884b" title="Return whether this container is ordered.">isOrdered()</a> || for each box in container has valid <a class="el" href="classSAMRAI_1_1hier_1_1BoxId.html" title="Identifier for a Box, consisting of a GlobalId and a PeriodicId.">BoxId</a> </dd></dl>

<p>References <a class="el" href="BoxContainer_8h_source.html#l00706">begin()</a>, <a class="el" href="BoxContainer_8h_source.html#l00717">end()</a>, and <a class="el" href="Utilities_8h_source.html#l00060">TBOX_ERROR</a>.</p>

</div>
</div>
<a class="anchor" id="a4e0ebf36f1800ef69be70eddfeb9e638"></a><!-- doxytag: member="SAMRAI::hier::BoxContainer::grow" ref="a4e0ebf36f1800ef69be70eddfeb9e638" args="(const IntVector &amp;ghosts)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::hier::BoxContainer::grow </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>ghosts</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Grow boxes in the container by the specified ghost cell width. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>ghosts</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="BoxContainer_8h_source.html#l00706">begin()</a>, and <a class="el" href="BoxContainer_8h_source.html#l00717">end()</a>.</p>

<p>Referenced by <a class="el" href="BoxLevelConnectorUtils_8C_source.html#l00880">SAMRAI::hier::BoxLevelConnectorUtils::computeBoxesAroundBoundary()</a>, <a class="el" href="BaseGridGeometry_8C_source.html#l00361">SAMRAI::hier::BaseGridGeometry::computeBoxTouchingBoundaries()</a>, <a class="el" href="OverlapConnectorAlgorithm_8C_source.html#l00490">SAMRAI::hier::OverlapConnectorAlgorithm::findOverlaps_assumedPartition()</a>, <a class="el" href="BaseGridGeometry_8C_source.html#l01075">SAMRAI::hier::BaseGridGeometry::getBoundaryBoxes()</a>, <a class="el" href="BoxUtilities_8C_source.html#l00622">SAMRAI::hier::BoxUtilities::growBoxesWithinDomain()</a>, and <a class="el" href="BaseGridGeometry_8C_source.html#l01870">SAMRAI::hier::BaseGridGeometry::readBlockDataFromInput()</a>.</p>

</div>
</div>
<a class="anchor" id="a28ac3b63bd66820c89449634de6e69c1"></a><!-- doxytag: member="SAMRAI::hier::BoxContainer::shift" ref="a28ac3b63bd66820c89449634de6e69c1" args="(const IntVector &amp;offset)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::hier::BoxContainer::shift </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>offset</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Shift boxes in the container by the specified offset. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>offset</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="BoxContainer_8h_source.html#l00706">begin()</a>, and <a class="el" href="BoxContainer_8h_source.html#l00717">end()</a>.</p>

<p>Referenced by <a class="el" href="BaseGridGeometry_8C_source.html#l01075">SAMRAI::hier::BaseGridGeometry::getBoundaryBoxes()</a>, <a class="el" href="BaseGridGeometry_8C_source.html#l02260">SAMRAI::hier::BaseGridGeometry::registerNeighbors()</a>, and <a class="el" href="BaseGridGeometry_8C_source.html#l02764">SAMRAI::hier::BaseGridGeometry::transformBoxContainer()</a>.</p>

</div>
</div>
<a class="anchor" id="aef570e52b1dedc50e0e2f607f02ef113"></a><!-- doxytag: member="SAMRAI::hier::BoxContainer::refine" ref="aef570e52b1dedc50e0e2f607f02ef113" args="(const IntVector &amp;ratio)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::hier::BoxContainer::refine </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>ratio</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Refine boxes in container by the specified refinement ratio. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>ratio</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="BoxContainer_8h_source.html#l00706">begin()</a>, and <a class="el" href="BoxContainer_8h_source.html#l00717">end()</a>.</p>

<p>Referenced by <a class="el" href="BoxLevelConnectorUtils_8C_source.html#l01271">SAMRAI::hier::BoxLevelConnectorUtils::addPeriodicImagesAndRelationships()</a>, <a class="el" href="BaseGridGeometry_8C_source.html#l02820">SAMRAI::hier::BaseGridGeometry::adjustMultiblockPatchLevelBoundaries()</a>, <a class="el" href="BaseGridGeometry_8C_source.html#l01225">SAMRAI::hier::BaseGridGeometry::computePhysicalDomain()</a>, <a class="el" href="OverlapConnectorAlgorithm_8C_source.html#l00490">SAMRAI::hier::OverlapConnectorAlgorithm::findOverlaps_assumedPartition()</a>, <a class="el" href="BaseGridGeometry_8C_source.html#l00306">SAMRAI::hier::BaseGridGeometry::findPatchesTouchingBoundaries()</a>, <a class="el" href="BoxUtilities_8C_source.html#l01817">SAMRAI::hier::BoxUtilities::growAndAdjustAcrossBlockBoundary()</a>, <a class="el" href="GridGeometry_8C_source.html#l00217">SAMRAI::geom::GridGeometry::makeRefinedGridGeometry()</a>, <a class="el" href="CartesianGridGeometry_8C_source.html#l00186">SAMRAI::geom::CartesianGridGeometry::makeRefinedGridGeometry()</a>, <a class="el" href="PatchHierarchy_8C_source.html#l00640">SAMRAI::hier::PatchHierarchy::makeRefinedPatchHierarchy()</a>, <a class="el" href="BoxLevel_8h_source.html#l00880">SAMRAI::hier::BoxLevel::refineBoxes()</a>, and <a class="el" href="PatchLevel_8C_source.html#l00375">SAMRAI::hier::PatchLevel::setRefinedPatchLevel()</a>.</p>

</div>
</div>
<a class="anchor" id="a9906f066cab6279e709490b50245313e"></a><!-- doxytag: member="SAMRAI::hier::BoxContainer::coarsen" ref="a9906f066cab6279e709490b50245313e" args="(const IntVector &amp;ratio)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::hier::BoxContainer::coarsen </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>ratio</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Coarsen boxes in container by the specified coarsening ratio. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>ratio</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="BoxContainer_8h_source.html#l00706">begin()</a>, and <a class="el" href="BoxContainer_8h_source.html#l00717">end()</a>.</p>

<p>Referenced by <a class="el" href="BoxLevel_8h_source.html#l00910">SAMRAI::hier::BoxLevel::coarsenBoxes()</a>, <a class="el" href="BaseGridGeometry_8C_source.html#l01225">SAMRAI::hier::BaseGridGeometry::computePhysicalDomain()</a>, <a class="el" href="OverlapConnectorAlgorithm_8C_source.html#l00490">SAMRAI::hier::OverlapConnectorAlgorithm::findOverlaps_assumedPartition()</a>, <a class="el" href="FlattenedHierarchy_8C_source.html#l00027">SAMRAI::hier::FlattenedHierarchy::FlattenedHierarchy()</a>, <a class="el" href="GridGeometry_8C_source.html#l00151">SAMRAI::geom::GridGeometry::makeCoarsenedGridGeometry()</a>, <a class="el" href="CartesianGridGeometry_8C_source.html#l00221">SAMRAI::geom::CartesianGridGeometry::makeCoarsenedGridGeometry()</a>, <a class="el" href="PatchHierarchy_8C_source.html#l00704">SAMRAI::hier::PatchHierarchy::makeCoarsenedPatchHierarchy()</a>, and <a class="el" href="PatchLevel_8C_source.html#l00539">SAMRAI::hier::PatchLevel::setCoarsenedPatchLevel()</a>.</p>

</div>
</div>
<a class="anchor" id="adaf04b91b7439bc7cb9f61734871e930"></a><!-- doxytag: member="SAMRAI::hier::BoxContainer::getTotalSizeOfBoxes" ref="adaf04b91b7439bc7cb9f61734871e930" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t SAMRAI::hier::BoxContainer::getTotalSizeOfBoxes </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Count total number of indices in the boxes in the container. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Total number of indices of all boxes in the container. </dd></dl>

<p>References <a class="el" href="BoxContainer_8h_source.html#l00706">begin()</a>, <a class="el" href="BoxContainer_8h_source.html#l00717">end()</a>, and <a class="el" href="BoxContainer_8h_source.html#l00663">size()</a>.</p>

<p>Referenced by <a class="el" href="ArrayData_8C_source.html#l00580">SAMRAI::pdat::ArrayData&lt; TYPE &gt;::getDataStreamSize()</a>, <a class="el" href="ArrayData_8C_source.html#l00641">SAMRAI::pdat::ArrayData&lt; TYPE &gt;::packStream()</a>, <a class="el" href="ArrayData_8C_source.html#l00742">SAMRAI::pdat::ArrayData&lt; TYPE &gt;::unpackStream()</a>, and <a class="el" href="ArrayData_8C_source.html#l00797">SAMRAI::pdat::ArrayData&lt; TYPE &gt;::unpackStreamAndSum()</a>.</p>

</div>
</div>
<a class="anchor" id="ab302f3413aca7d08ae39eb765e0f91d2"></a><!-- doxytag: member="SAMRAI::hier::BoxContainer::contains" ref="ab302f3413aca7d08ae39eb765e0f91d2" args="(const Index &amp;idx, const BlockId &amp;block_id) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SAMRAI::hier::BoxContainer::contains </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1Index.html">Index</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1BlockId.html">BlockId</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>block_id</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Determine if "idx" lies within bounds of boxes in container. </p>
<p>Only boxes of the given <a class="el" href="classSAMRAI_1_1hier_1_1BlockId.html" title="Generic identifier for identifying the block id.">BlockId</a> will be checked.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if idx lies within bounds of boxes in container.</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>idx</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>block_id</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>each box in container must have a valid <a class="el" href="classSAMRAI_1_1hier_1_1BlockId.html" title="Generic identifier for identifying the block id.">BlockId</a> </dd></dl>

<p>References <a class="el" href="BoxContainer_8h_source.html#l00706">begin()</a>, <a class="el" href="BoxContainer_8h_source.html#l00717">end()</a>, and <a class="el" href="Utilities_8h_source.html#l00110">TBOX_ASSERT</a>.</p>

</div>
</div>
<a class="anchor" id="a6440b7e06427fd365eb05604e7dc99f6"></a><!-- doxytag: member="SAMRAI::hier::BoxContainer::getBoundingBox" ref="a6440b7e06427fd365eb05604e7dc99f6" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> SAMRAI::hier::BoxContainer::getBoundingBox </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the bounding box for all the boxes in the container. </p>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>!empty() </dd>
<dd>
each <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> in container has same <a class="el" href="classSAMRAI_1_1hier_1_1BlockId.html" title="Generic identifier for identifying the block id.">BlockId</a> </dd></dl>

<p>References <a class="el" href="BoxContainer_8h_source.html#l00706">begin()</a>, <a class="el" href="BoxContainer_8h_source.html#l00695">empty()</a>, <a class="el" href="BoxContainer_8h_source.html#l00717">end()</a>, <a class="el" href="Box_8h_source.html#l00330">SAMRAI::hier::Box::getBlockId()</a>, and <a class="el" href="Utilities_8h_source.html#l00060">TBOX_ERROR</a>.</p>

<p>Referenced by <a class="el" href="BoxUtilities_8C_source.html#l01336">SAMRAI::hier::BoxUtilities::findBadCutPointsForDirection()</a>, <a class="el" href="BoxUtilities_8C_source.html#l00622">SAMRAI::hier::BoxUtilities::growBoxesWithinDomain()</a>, and <a class="el" href="BaseGridGeometry_8C_source.html#l01472">SAMRAI::hier::BaseGridGeometry::setPhysicalDomain()</a>.</p>

</div>
</div>
<a class="anchor" id="a300c7b4246e444e698f719d8df4b61c6"></a><!-- doxytag: member="SAMRAI::hier::BoxContainer::getBoundingBox" ref="a300c7b4246e444e698f719d8df4b61c6" args="(const BlockId &amp;block_id) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> SAMRAI::hier::BoxContainer::getBoundingBox </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1BlockId.html">BlockId</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>block_id</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the bounding box for all the boxes in the container having the given <a class="el" href="classSAMRAI_1_1hier_1_1BlockId.html" title="Generic identifier for identifying the block id.">BlockId</a>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>block_id</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>!empty() </dd></dl>

<p>References <a class="el" href="BoxContainer_8h_source.html#l00706">begin()</a>, <a class="el" href="BoxContainer_8h_source.html#l00695">empty()</a>, <a class="el" href="BoxContainer_8h_source.html#l00717">end()</a>, <a class="el" href="Utilities_8h_source.html#l00060">TBOX_ERROR</a>, and <a class="el" href="Utilities_8h_source.html#l00070">TBOX_WARNING</a>.</p>

</div>
</div>
<a class="anchor" id="a14358caff71c9fb7dd8d8b3e3e193ea1"></a><!-- doxytag: member="SAMRAI::hier::BoxContainer::boxesIntersect" ref="a14358caff71c9fb7dd8d8b3e3e193ea1" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SAMRAI::hier::BoxContainer::boxesIntersect </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Check for non-empty intersection among boxes in container. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Returns true if there exists any non-empty intersection among the boxes in the container. </dd></dl>

<p>References <a class="el" href="BoxContainer_8h_source.html#l00706">begin()</a>, <a class="el" href="BoxContainer_8h_source.html#l00717">end()</a>, and <a class="el" href="BoxContainer_8h_source.html#l00663">size()</a>.</p>

</div>
</div>
<a class="anchor" id="a8a554081bd049c99de1e0d6ad53d1cba"></a><!-- doxytag: member="SAMRAI::hier::BoxContainer::order" ref="a8a554081bd049c99de1e0d6ad53d1cba" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::hier::BoxContainer::order </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Changes state of this container to ordered. </p>
<p>If called on a container that is already ordered, nothing changes.</p>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>each box in container must have valid and unique <a class="el" href="classSAMRAI_1_1hier_1_1BoxId.html" title="Identifier for a Box, consisting of a GlobalId and a PeriodicId.">BoxId</a> </dd></dl>

<p>References <a class="el" href="BoxContainer_8h_source.html#l00706">begin()</a>, <a class="el" href="BoxContainer_8h_source.html#l00717">end()</a>, and <a class="el" href="Utilities_8h_source.html#l00060">TBOX_ERROR</a>.</p>

<p>Referenced by <a class="el" href="BoxContainer_8C_source.html#l00048">BoxContainer()</a>, <a class="el" href="BaseGridGeometry_8C_source.html#l02512">SAMRAI::hier::BaseGridGeometry::chopDomain()</a>, <a class="el" href="BoxLevel_8C_source.html#l00264">SAMRAI::hier::BoxLevel::initialize()</a>, <a class="el" href="BoxContainer_8C_source.html#l00248">insert()</a>, <a class="el" href="BoxContainer_8C_source.html#l00148">operator=()</a>, <a class="el" href="AssumedPartitionBox_8C_source.html#l00286">SAMRAI::hier::AssumedPartitionBox::selfCheck()</a>, and <a class="el" href="BoxLevel_8C_source.html#l00286">SAMRAI::hier::BoxLevel::swapInitialize()</a>.</p>

</div>
</div>
<a class="anchor" id="ad3fc42e7710adae0c5d1d5a1c0a1698d"></a><!-- doxytag: member="SAMRAI::hier::BoxContainer::unorder" ref="ad3fc42e7710adae0c5d1d5a1c0a1698d" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::hier::BoxContainer::unorder </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Changes state of this container to unordered. </p>
<p>This method can be called on any container. </p>

<p>Referenced by <a class="el" href="BoxLevelConnectorUtils_8C_source.html#l00880">SAMRAI::hier::BoxLevelConnectorUtils::computeBoxesAroundBoundary()</a>, <a class="el" href="BoxUtilities_8C_source.html#l01817">SAMRAI::hier::BoxUtilities::growAndAdjustAcrossBlockBoundary()</a>, <a class="el" href="BoxUtilities_8C_source.html#l00622">SAMRAI::hier::BoxUtilities::growBoxesWithinDomain()</a>, <a class="el" href="BaseGridGeometry_8C_source.html#l01870">SAMRAI::hier::BaseGridGeometry::readBlockDataFromInput()</a>, <a class="el" href="BaseGridGeometry_8C_source.html#l02260">SAMRAI::hier::BaseGridGeometry::registerNeighbors()</a>, and <a class="el" href="AssumedPartitionBox_8C_source.html#l00286">SAMRAI::hier::AssumedPartitionBox::selfCheck()</a>.</p>

</div>
</div>
<a class="anchor" id="ab60e3636df51eb5997471a5520c7884b"></a><!-- doxytag: member="SAMRAI::hier::BoxContainer::isOrdered" ref="ab60e3636df51eb5997471a5520c7884b" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SAMRAI::hier::BoxContainer::isOrdered </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return whether this container is ordered. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>True if ordered, false if unordered. </dd></dl>

<p>Referenced by <a class="el" href="BoxUtilities_8C_source.html#l00326">SAMRAI::hier::BoxUtilities::chopBoxes()</a>, <a class="el" href="BoxContainer_8C_source.html#l01788">findOverlapBoxes()</a>, and <a class="el" href="BoxNeighborhoodCollection_8C_source.html#l00471">SAMRAI::hier::BoxNeighborhoodCollection::getNeighbors()</a>.</p>

</div>
</div>
<a class="anchor" id="a9dac68baead6e75db214c8b120f0730e"></a><!-- doxytag: member="SAMRAI::hier::BoxContainer::pushFront" ref="a9dac68baead6e75db214c8b120f0730e" args="(const Box &amp;item)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::hier::BoxContainer::pushFront </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>item</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Adds "item" to the "front" of the container. </p>
<p>Makes "item" the member of the container that will be returned by <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html#aacb30f477c077d265d20b477e5adc0f3" title="Returns the first element in the container.">front()</a> in an unordered container.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>item</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="pre"><dt><b>Precondition:</b></dt><dd><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html#ad871f3c0557760094807290656e33750" title="Returns true if there are no boxes in the container.">empty()</a> || (<a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html#aacb30f477c077d265d20b477e5adc0f3" title="Returns the first element in the container.">front()</a>.getDim() == item.getDim()) </dd>
<dd>
!isOrdered() </dd></dl>

<p>References <a class="el" href="BoxContainer_8h_source.html#l00695">empty()</a>, <a class="el" href="BoxContainer_8h_source.html#l00818">front()</a>, <a class="el" href="Utilities_8h_source.html#l00182">TBOX_ASSERT_OBJDIM_EQUALITY2</a>, and <a class="el" href="Utilities_8h_source.html#l00060">TBOX_ERROR</a>.</p>

<p>Referenced by <a class="el" href="BoxContainer_8h_source.html#l01098">push_front()</a>, <a class="el" href="BalanceUtilities_8C_source.html#l01418">SAMRAI::mesh::BalanceUtilities::recursiveBisectionNonuniform()</a>, and <a class="el" href="BalanceUtilities_8C_source.html#l01325">SAMRAI::mesh::BalanceUtilities::recursiveBisectionUniform()</a>.</p>

</div>
</div>
<a class="anchor" id="a236e2463d9ec5964135861de73f16324"></a><!-- doxytag: member="SAMRAI::hier::BoxContainer::pushBack" ref="a236e2463d9ec5964135861de73f16324" args="(const Box &amp;item)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::hier::BoxContainer::pushBack </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>item</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Adds "item" to the "end" of the container. </p>
<p>Makes "item" the member of the container that will be returned by <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html#a1a00d37886fa41bd01c6741568ab5bb6" title="Returns the first element in the container.">back()</a> in an unordered container.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>item</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="pre"><dt><b>Precondition:</b></dt><dd><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html#ad871f3c0557760094807290656e33750" title="Returns true if there are no boxes in the container.">empty()</a> || (<a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html#aacb30f477c077d265d20b477e5adc0f3" title="Returns the first element in the container.">front()</a>.getDim() == item.getDim()) </dd>
<dd>
!isOrdered() </dd></dl>

<p>References <a class="el" href="BoxContainer_8h_source.html#l00695">empty()</a>, <a class="el" href="BoxContainer_8h_source.html#l00818">front()</a>, <a class="el" href="Utilities_8h_source.html#l00182">TBOX_ASSERT_OBJDIM_EQUALITY2</a>, and <a class="el" href="Utilities_8h_source.html#l00060">TBOX_ERROR</a>.</p>

<p>Referenced by <a class="el" href="BoxContainer_8C_source.html#l00078">BoxContainer()</a>, <a class="el" href="BoxUtilities_8C_source.html#l01202">SAMRAI::hier::BoxUtilities::checkBoxForBadCutPointsInDirection()</a>, <a class="el" href="BoxUtilities_8C_source.html#l00417">SAMRAI::hier::BoxUtilities::chopBox()</a>, <a class="el" href="BoxUtilities_8C_source.html#l00326">SAMRAI::hier::BoxUtilities::chopBoxes()</a>, <a class="el" href="SideGeometry_8C_source.html#l00120">SAMRAI::pdat::SideGeometry::computeDestinationBoxes()</a>, <a class="el" href="NodeGeometry_8C_source.html#l00095">SAMRAI::pdat::NodeGeometry::computeDestinationBoxes()</a>, <a class="el" href="FaceGeometry_8C_source.html#l00132">SAMRAI::pdat::FaceGeometry::computeDestinationBoxes()</a>, <a class="el" href="EdgeGeometry_8C_source.html#l00098">SAMRAI::pdat::EdgeGeometry::computeDestinationBoxes()</a>, <a class="el" href="CellGeometry_8C_source.html#l00094">SAMRAI::pdat::CellGeometry::computeDestinationBoxes()</a>, <a class="el" href="PatchLevelEnhancedFillPattern_8C_source.html#l00052">SAMRAI::xfer::PatchLevelEnhancedFillPattern::computeFillBoxesAndNeighborhoodSets()</a>, <a class="el" href="BoxUtilities_8C_source.html#l00506">SAMRAI::hier::BoxUtilities::extendBoxesToDomainBoundary()</a>, <a class="el" href="OverlapConnectorAlgorithm_8C_source.html#l00147">SAMRAI::hier::OverlapConnectorAlgorithm::extractNeighbors()</a>, <a class="el" href="BoxUtilities_8C_source.html#l01336">SAMRAI::hier::BoxUtilities::findBadCutPointsForDirection()</a>, <a class="el" href="BoxContainer_8C_source.html#l01788">findOverlapBoxes()</a>, <a class="el" href="FlattenedHierarchy_8C_source.html#l00027">SAMRAI::hier::FlattenedHierarchy::FlattenedHierarchy()</a>, <a class="el" href="PatchLevel_8C_source.html#l00708">SAMRAI::hier::PatchLevel::getBoxes()</a>, <a class="el" href="BoxLevel_8C_source.html#l01502">SAMRAI::hier::BoxLevel::getGlobalBoxes()</a>, <a class="el" href="BoxNeighborhoodCollection_8C_source.html#l00471">SAMRAI::hier::BoxNeighborhoodCollection::getNeighbors()</a>, <a class="el" href="BoxUtilities_8C_source.html#l00622">SAMRAI::hier::BoxUtilities::growBoxesWithinDomain()</a>, <a class="el" href="BoxContainer_8h_source.html#l01159">insertAfter()</a>, <a class="el" href="ChopAndPackLoadBalancer_8C_source.html#l00240">SAMRAI::mesh::ChopAndPackLoadBalancer::loadBalanceBoxLevel()</a>, <a class="el" href="BoxContainer_8C_source.html#l00164">operator=()</a>, <a class="el" href="BoxContainer_8h_source.html#l01108">push_back()</a>, <a class="el" href="AssumedPartitionBox_8C_source.html#l00552">SAMRAI::hier::AssumedPartitionBox::recursivePrint()</a>, <a class="el" href="BoxContainer_8C_source.html#l00931">removeIntersections()</a>, <a class="el" href="AssumedPartitionBox_8C_source.html#l00286">SAMRAI::hier::AssumedPartitionBox::selfCheck()</a>, <a class="el" href="BaseGridGeometry_8C_source.html#l01472">SAMRAI::hier::BaseGridGeometry::setPhysicalDomain()</a>, <a class="el" href="OuternodeGeometry_8C_source.html#l00467">SAMRAI::pdat::OuternodeGeometry::setUpOverlap()</a>, <a class="el" href="NodeGeometry_8C_source.html#l00152">SAMRAI::pdat::NodeGeometry::setUpOverlap()</a>, and <a class="el" href="BoxContainer_8C_source.html#l00401">simplify()</a>.</p>

</div>
</div>
<a class="anchor" id="ad73c72c593ada860cc4e354753f4914e"></a><!-- doxytag: member="SAMRAI::hier::BoxContainer::push_front" ref="ad73c72c593ada860cc4e354753f4914e" args="(const Box &amp;item)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::hier::BoxContainer::push_front </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>item</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>STL-named version of <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html#a9dac68baead6e75db214c8b120f0730e" title="Adds &quot;item&quot; to the &quot;front&quot; of the container.">pushFront()</a>. </p>

<p>References <a class="el" href="BoxContainer_8h_source.html#l01046">pushFront()</a>.</p>

</div>
</div>
<a class="anchor" id="ac7036801c26c07f0eec66853f2f6fd2d"></a><!-- doxytag: member="SAMRAI::hier::BoxContainer::push_back" ref="ac7036801c26c07f0eec66853f2f6fd2d" args="(const Box &amp;item)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::hier::BoxContainer::push_back </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>item</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>STL-named version of <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html#a236e2463d9ec5964135861de73f16324" title="Adds &quot;item&quot; to the &quot;end&quot; of the container.">pushBack()</a>. </p>

<p>References <a class="el" href="BoxContainer_8h_source.html#l01076">pushBack()</a>.</p>

<p>Referenced by <a class="el" href="BalanceBoxBreaker_8C_source.html#l00882">SAMRAI::mesh::BalanceBoxBreaker::burstBox()</a>, <a class="el" href="OverlapConnectorAlgorithm_8C_source.html#l00490">SAMRAI::hier::OverlapConnectorAlgorithm::findOverlaps_assumedPartition()</a>, <a class="el" href="AssumedPartitionBox_8C_source.html#l00229">SAMRAI::hier::AssumedPartitionBox::getAllBoxes()</a>, <a class="el" href="AssumedPartition_8C_source.html#l00224">SAMRAI::hier::AssumedPartition::getAllBoxes()</a>, and <a class="el" href="BoxUtilities_8C_source.html#l00741">SAMRAI::hier::BoxUtilities::growBoxWithinDomain()</a>.</p>

</div>
</div>
<a class="anchor" id="a3f9ea6e1242029ed5b0bec7ebfc55ecb"></a><!-- doxytag: member="SAMRAI::hier::BoxContainer::insertBefore" ref="a3f9ea6e1242029ed5b0bec7ebfc55ecb" args="(iterator iter, const Box &amp;item)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::hier::BoxContainer::insertBefore </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer_1_1BoxContainerIterator.html">iterator</a>&nbsp;</td>
          <td class="paramname"> <em>iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>item</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Add "item" to specific place in the container. </p>
<p>Places "item" immediately before the member of the container pointed to by "iter" in an unordered container.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>iter</em>&nbsp;</td><td>Location to add item before. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>item</em>&nbsp;</td><td><a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> to add to container.</td></tr>
  </table>
  </dd>
</dl>
<dl class="pre"><dt><b>Precondition:</b></dt><dd><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html#ad871f3c0557760094807290656e33750" title="Returns true if there are no boxes in the container.">empty()</a> || (<a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html#aacb30f477c077d265d20b477e5adc0f3" title="Returns the first element in the container.">front()</a>.getDim() == item.getDim()) </dd>
<dd>
!isOrdered() </dd></dl>

<p>References <a class="el" href="BoxContainer_8h_source.html#l00695">empty()</a>, <a class="el" href="BoxContainer_8h_source.html#l00818">front()</a>, <a class="el" href="Utilities_8h_source.html#l00182">TBOX_ASSERT_OBJDIM_EQUALITY2</a>, and <a class="el" href="Utilities_8h_source.html#l00060">TBOX_ERROR</a>.</p>

<p>Referenced by <a class="el" href="BoxContainer_8h_source.html#l01159">insertAfter()</a>.</p>

</div>
</div>
<a class="anchor" id="a3229998b188dfe40a9bddb47d737da4f"></a><!-- doxytag: member="SAMRAI::hier::BoxContainer::insertAfter" ref="a3229998b188dfe40a9bddb47d737da4f" args="(iterator iter, const Box &amp;item)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::hier::BoxContainer::insertAfter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer_1_1BoxContainerIterator.html">iterator</a>&nbsp;</td>
          <td class="paramname"> <em>iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>item</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Add "item" to specific place in the container. </p>
<p>Places "item" immediately after the member of the container pointed to by "iter" in an unordered container.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>iter</em>&nbsp;</td><td>Location to add item after. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>item</em>&nbsp;</td><td><a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> to add to container.</td></tr>
  </table>
  </dd>
</dl>
<dl class="pre"><dt><b>Precondition:</b></dt><dd><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html#ad871f3c0557760094807290656e33750" title="Returns true if there are no boxes in the container.">empty()</a> || (<a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html#aacb30f477c077d265d20b477e5adc0f3" title="Returns the first element in the container.">front()</a>.getDim() == item.getDim()) </dd>
<dd>
!isOrdered() </dd></dl>

<p>References <a class="el" href="BoxContainer_8h_source.html#l00717">end()</a>, <a class="el" href="BoxContainer_8h_source.html#l01127">insertBefore()</a>, <a class="el" href="BoxContainer_8h_source.html#l01076">pushBack()</a>, and <a class="el" href="Utilities_8h_source.html#l00060">TBOX_ERROR</a>.</p>

<p>Referenced by <a class="el" href="BoxContainer_8C_source.html#l01083">intersectBoxes()</a>.</p>

</div>
</div>
<a class="anchor" id="aba38984af87d838459be4b85d0638bb9"></a><!-- doxytag: member="SAMRAI::hier::BoxContainer::spliceFront" ref="aba38984af87d838459be4b85d0638bb9" args="(BoxContainer &amp;boxes)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::hier::BoxContainer::spliceFront </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>boxes</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Prepends the Boxes in "boxes" to this <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html" title="A container for Boxes.">BoxContainer</a>. </p>
<p>"boxes" will be empty following this operation.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>boxes</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="pre"><dt><b>Precondition:</b></dt><dd><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html#ad871f3c0557760094807290656e33750" title="Returns true if there are no boxes in the container.">empty()</a> || (<a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html#aacb30f477c077d265d20b477e5adc0f3" title="Returns the first element in the container.">front()</a>.getDim() == item.getDim()) </dd>
<dd>
!isOrdered()</dd></dl>
<dl class="post"><dt><b>Postcondition:</b></dt><dd>boxes.empty() </dd></dl>

<p>References <a class="el" href="BoxContainer_8h_source.html#l00706">begin()</a>, <a class="el" href="BoxContainer_8h_source.html#l00695">empty()</a>, <a class="el" href="BoxContainer_8h_source.html#l00818">front()</a>, <a class="el" href="Utilities_8h_source.html#l00182">TBOX_ASSERT_OBJDIM_EQUALITY2</a>, and <a class="el" href="Utilities_8h_source.html#l00060">TBOX_ERROR</a>.</p>

<p>Referenced by <a class="el" href="BaseGridGeometry_8C_source.html#l02820">SAMRAI::hier::BaseGridGeometry::adjustMultiblockPatchLevelBoundaries()</a>, <a class="el" href="BaseGridGeometry_8C_source.html#l02238">SAMRAI::hier::BaseGridGeometry::getDomainOutsideBlock()</a>, and <a class="el" href="BoxContainer_8h_source.html#l01223">spliceBack()</a>.</p>

</div>
</div>
<a class="anchor" id="ad0766ee251b631b81cd2333e71dd33f2"></a><!-- doxytag: member="SAMRAI::hier::BoxContainer::spliceBack" ref="ad0766ee251b631b81cd2333e71dd33f2" args="(BoxContainer &amp;boxes)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::hier::BoxContainer::spliceBack </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>boxes</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Appends the Boxes in "boxes" to this <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html" title="A container for Boxes.">BoxContainer</a>. </p>
<p>"boxes" will be empty following this operation.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>boxes</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="pre"><dt><b>Precondition:</b></dt><dd><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html#ad871f3c0557760094807290656e33750" title="Returns true if there are no boxes in the container.">empty()</a> || (<a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html#aacb30f477c077d265d20b477e5adc0f3" title="Returns the first element in the container.">front()</a>.getDim() == item.getDim()) </dd>
<dd>
!isOrdered()</dd></dl>
<dl class="post"><dt><b>Postcondition:</b></dt><dd>boxes.empty() </dd></dl>

<p>References <a class="el" href="BoxContainer_8h_source.html#l00695">empty()</a>, <a class="el" href="BoxContainer_8h_source.html#l00818">front()</a>, <a class="el" href="BoxContainer_8h_source.html#l01192">spliceFront()</a>, <a class="el" href="Utilities_8h_source.html#l00182">TBOX_ASSERT_OBJDIM_EQUALITY2</a>, and <a class="el" href="Utilities_8h_source.html#l00060">TBOX_ERROR</a>.</p>

<p>Referenced by <a class="el" href="BoxUtilities_8C_source.html#l00326">SAMRAI::hier::BoxUtilities::chopBoxes()</a>, <a class="el" href="BoxLevelConnectorUtils_8C_source.html#l00880">SAMRAI::hier::BoxLevelConnectorUtils::computeBoxesAroundBoundary()</a>, <a class="el" href="BoxUtilities_8C_source.html#l01817">SAMRAI::hier::BoxUtilities::growAndAdjustAcrossBlockBoundary()</a>, <a class="el" href="BalanceUtilities_8C_source.html#l01418">SAMRAI::mesh::BalanceUtilities::recursiveBisectionNonuniform()</a>, and <a class="el" href="BalanceUtilities_8C_source.html#l01325">SAMRAI::mesh::BalanceUtilities::recursiveBisectionUniform()</a>.</p>

</div>
</div>
<a class="anchor" id="aa26e34c146a2e4d3db594350d030682c"></a><!-- doxytag: member="SAMRAI::hier::BoxContainer::popFront" ref="aa26e34c146a2e4d3db594350d030682c" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::hier::BoxContainer::popFront </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Remove the first member of the unordered container. </p>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>!isOrdered() </dd></dl>

<p>References <a class="el" href="Utilities_8h_source.html#l00060">TBOX_ERROR</a>.</p>

<p>Referenced by <a class="el" href="BoxUtilities_8C_source.html#l00417">SAMRAI::hier::BoxUtilities::chopBox()</a>, <a class="el" href="BoxUtilities_8C_source.html#l00506">SAMRAI::hier::BoxUtilities::extendBoxesToDomainBoundary()</a>, and <a class="el" href="BoxUtilities_8C_source.html#l00622">SAMRAI::hier::BoxUtilities::growBoxesWithinDomain()</a>.</p>

</div>
</div>
<a class="anchor" id="a09990007ee046ca5b308cdeea9bf9302"></a><!-- doxytag: member="SAMRAI::hier::BoxContainer::popBack" ref="a09990007ee046ca5b308cdeea9bf9302" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::hier::BoxContainer::popBack </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Remove the last member of the unordered container. </p>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>!isOrdered() </dd></dl>

<p>References <a class="el" href="Utilities_8h_source.html#l00060">TBOX_ERROR</a>.</p>

</div>
</div>
<a class="anchor" id="acf2587b68a7d1a7d2a2134d9f87c0fca"></a><!-- doxytag: member="SAMRAI::hier::BoxContainer::simplify" ref="acf2587b68a7d1a7d2a2134d9f87c0fca" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::hier::BoxContainer::simplify </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Place the boxes in the container into a canonical ordering. </p>
<p>The canonical ordering for boxes is defined such that boxes that lie next to each other in higher directions are coalesced together before boxes that lie next to each other in lower directions. This ordering provides a standard representation that can be used to compare box containers. The canonical ordering also does not allow any overlap between the boxes in the container. This routine is potentially expensive, since the running time is <img class="formulaInl" alt="$O(N^2)$" src="form_0.png"/> for N boxes. None of the domain calculus routines call <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html#acf2587b68a7d1a7d2a2134d9f87c0fca" title="Place the boxes in the container into a canonical ordering.">simplify()</a>; all calls to simplify the boxes must be explicit. Note that this routine is distinct from <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html#a4f65643b3d30a7bc24dbac9a22abb5c7" title="Combine any boxes in the container which may be coalesced.">coalesce()</a>, which is not guaranteed to produce a canonical ordering.</p>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>!isOrdered() </dd>
<dd>
<a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html#ad871f3c0557760094807290656e33750" title="Returns true if there are no boxes in the container.">empty()</a> || all Boxes in container have same <a class="el" href="classSAMRAI_1_1hier_1_1BlockId.html" title="Generic identifier for identifying the block id.">BlockId</a> </dd></dl>

<p>References <a class="el" href="BoxContainer_8h_source.html#l00706">begin()</a>, <a class="el" href="Box_8h_source.html#l00613">SAMRAI::hier::Box::empty()</a>, <a class="el" href="BoxContainer_8h_source.html#l00695">empty()</a>, <a class="el" href="BoxContainer_8h_source.html#l00717">end()</a>, <a class="el" href="BoxContainer_8C_source.html#l01452">erase()</a>, <a class="el" href="BoxContainer_8h_source.html#l00818">front()</a>, <a class="el" href="Box_8h_source.html#l00330">SAMRAI::hier::Box::getBlockId()</a>, <a class="el" href="Box_8h_source.html#l00495">SAMRAI::hier::Box::lower()</a>, <a class="el" href="BoxContainer_8h_source.html#l01076">pushBack()</a>, <a class="el" href="Utilities_8h_source.html#l00110">TBOX_ASSERT</a>, <a class="el" href="Utilities_8h_source.html#l00060">TBOX_ERROR</a>, and <a class="el" href="Box_8h_source.html#l00515">SAMRAI::hier::Box::upper()</a>.</p>

<p>Referenced by <a class="el" href="BoxUtilities_8C_source.html#l00116">SAMRAI::hier::BoxUtilities::checkBoxConstraints()</a>, <a class="el" href="BoxUtilities_8C_source.html#l01202">SAMRAI::hier::BoxUtilities::checkBoxForBadCutPointsInDirection()</a>, <a class="el" href="BoxUtilities_8C_source.html#l01336">SAMRAI::hier::BoxUtilities::findBadCutPointsForDirection()</a>, <a class="el" href="BoxUtilities_8C_source.html#l01817">SAMRAI::hier::BoxUtilities::growAndAdjustAcrossBlockBoundary()</a>, and <a class="el" href="BaseGridGeometry_8C_source.html#l01870">SAMRAI::hier::BaseGridGeometry::readBlockDataFromInput()</a>.</p>

</div>
</div>
<a class="anchor" id="a4f65643b3d30a7bc24dbac9a22abb5c7"></a><!-- doxytag: member="SAMRAI::hier::BoxContainer::coalesce" ref="a4f65643b3d30a7bc24dbac9a22abb5c7" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::hier::BoxContainer::coalesce </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Combine any boxes in the container which may be coalesced. </p>
<p>Two boxes may be coalesced if their union is a box (recall that boxes are not closed under index set unions). Empty boxes in the container are removed during this process. Note that this is potentially an expensive calculation (e.g., it will require <img class="formulaInl" alt="$(N-1)!$" src="form_1.png"/> box comparisons for a box container with <img class="formulaInl" alt="$N$" src="form_2.png"/> boxes in the worst possible case). So this routine should be used sparingly. Also note that this routine is different than <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html#acf2587b68a7d1a7d2a2134d9f87c0fca" title="Place the boxes in the container into a canonical ordering.">simplify()</a> since it does not produce a canonical ordering. In particular, this routine processes the boxes in the order in which they appear in the container, rather than attempting to coalesce boxes along specific coordinate directions before others.</p>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>!isOrdered() </dd>
<dd>
<a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html#ad871f3c0557760094807290656e33750" title="Returns true if there are no boxes in the container.">empty()</a> || all Boxes in container have same <a class="el" href="classSAMRAI_1_1hier_1_1BlockId.html" title="Generic identifier for identifying the block id.">BlockId</a> </dd></dl>

<p>References <a class="el" href="BoxContainer_8h_source.html#l00706">begin()</a>, <a class="el" href="BoxContainer_8h_source.html#l00695">empty()</a>, <a class="el" href="BoxContainer_8h_source.html#l00717">end()</a>, <a class="el" href="BoxContainer_8C_source.html#l01452">erase()</a>, <a class="el" href="BoxContainer_8h_source.html#l00818">front()</a>, <a class="el" href="Box_8h_source.html#l00330">SAMRAI::hier::Box::getBlockId()</a>, <a class="el" href="Utilities_8h_source.html#l00110">TBOX_ASSERT</a>, and <a class="el" href="Utilities_8h_source.html#l00060">TBOX_ERROR</a>.</p>

<p>Referenced by <a class="el" href="BaseGridGeometry_8C_source.html#l02820">SAMRAI::hier::BaseGridGeometry::adjustMultiblockPatchLevelBoundaries()</a>, <a class="el" href="SecondLayerNodeVariableFillPattern_8C_source.html#l00157">SAMRAI::pdat::SecondLayerNodeVariableFillPattern::computeFillBoxesOverlap()</a>, <a class="el" href="SecondLayerNodeNoCornersVariableFillPattern_8C_source.html#l00167">SAMRAI::pdat::SecondLayerNodeNoCornersVariableFillPattern::computeFillBoxesOverlap()</a>, <a class="el" href="FirstLayerNodeVariableFillPattern_8C_source.html#l00150">SAMRAI::pdat::FirstLayerNodeVariableFillPattern::computeFillBoxesOverlap()</a>, <a class="el" href="FlattenedHierarchy_8C_source.html#l00027">SAMRAI::hier::FlattenedHierarchy::FlattenedHierarchy()</a>, <a class="el" href="BaseGridGeometry_8C_source.html#l01075">SAMRAI::hier::BaseGridGeometry::getBoundaryBoxes()</a>, <a class="el" href="BoxUtilities_8C_source.html#l01817">SAMRAI::hier::BoxUtilities::growAndAdjustAcrossBlockBoundary()</a>, <a class="el" href="BoxLevelConnectorUtils_8C_source.html#l01085">SAMRAI::hier::BoxLevelConnectorUtils::makeRemainderMap()</a>, and <a class="el" href="BaseGridGeometry_8C_source.html#l01870">SAMRAI::hier::BaseGridGeometry::readBlockDataFromInput()</a>.</p>

</div>
</div>
<a class="anchor" id="a610b4fa87a46fb7225d10a76014d4c86"></a><!-- doxytag: member="SAMRAI::hier::BoxContainer::rotate" ref="a610b4fa87a46fb7225d10a76014d4c86" args="(const Transformation::RotationIdentifier rotation_ident)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::hier::BoxContainer::rotate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1Transformation.html#a2dd7d97a19db7c8e97402e8518c0af8d">Transformation::RotationIdentifier</a>&nbsp;</td>
          <td class="paramname"> <em>rotation_ident</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Rotate boxes in container according to a RotationIdentifier. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>Works only in 2D or 3D.</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>rotation_ident</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>each <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> in container has dim 2 or 3 </dd>
<dd>
each <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> in container has same <a class="el" href="classSAMRAI_1_1hier_1_1BlockId.html" title="Generic identifier for identifying the block id.">BlockId</a> </dd></dl>

<p>References <a class="el" href="BoxContainer_8h_source.html#l00706">begin()</a>, <a class="el" href="BoxContainer_8h_source.html#l00695">empty()</a>, <a class="el" href="BoxContainer_8h_source.html#l00717">end()</a>, <a class="el" href="Dimension_8h_source.html#l00136">SAMRAI::tbox::Dimension::getValue()</a>, <a class="el" href="Utilities_8h_source.html#l00050">NULL_USE</a>, and <a class="el" href="Utilities_8h_source.html#l00060">TBOX_ERROR</a>.</p>

<p>Referenced by <a class="el" href="BaseGridGeometry_8C_source.html#l02260">SAMRAI::hier::BaseGridGeometry::registerNeighbors()</a>, and <a class="el" href="BaseGridGeometry_8C_source.html#l02764">SAMRAI::hier::BaseGridGeometry::transformBoxContainer()</a>.</p>

</div>
</div>
<a class="anchor" id="ab7efb9cecef0461f129c18f41fa06402"></a><!-- doxytag: member="SAMRAI::hier::BoxContainer::removeIntersections" ref="ab7efb9cecef0461f129c18f41fa06402" args="(const Box &amp;takeaway)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::hier::BoxContainer::removeIntersections </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>takeaway</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Remove from each box the portions that intersect takeaway. </p>
<p>This operation can be thought of as a set difference defined over the abstract AMR box index space. Performing the set difference will require <img class="formulaInl" alt="$O(N)$" src="form_3.png"/> time for a container with <img class="formulaInl" alt="$N$" src="form_2.png"/> boxes. For each box, b, in this container this operation computes b-(b^takeaway) where '^' indicates intersection.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>takeaway</em>&nbsp;</td><td>What to exclude from each box in the container.</td></tr>
  </table>
  </dd>
</dl>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>!isOrdered() </dd></dl>

<p>References <a class="el" href="BoxContainer_8h_source.html#l00706">begin()</a>, <a class="el" href="BoxContainer_8h_source.html#l00695">empty()</a>, <a class="el" href="BoxContainer_8h_source.html#l00717">end()</a>, <a class="el" href="BoxContainer_8C_source.html#l01452">erase()</a>, <a class="el" href="Box_8h_source.html#l01313">SAMRAI::hier::Box::getDim()</a>, <a class="el" href="Dimension_8h_source.html#l00136">SAMRAI::tbox::Dimension::getValue()</a>, <a class="el" href="Box_8C_source.html#l00530">SAMRAI::hier::Box::intersects()</a>, and <a class="el" href="Utilities_8h_source.html#l00060">TBOX_ERROR</a>.</p>

<p>Referenced by <a class="el" href="BoxUtilities_8C_source.html#l00116">SAMRAI::hier::BoxUtilities::checkBoxConstraints()</a>, <a class="el" href="BoxUtilities_8C_source.html#l01202">SAMRAI::hier::BoxUtilities::checkBoxForBadCutPointsInDirection()</a>, <a class="el" href="BoxLevelConnectorUtils_8C_source.html#l00880">SAMRAI::hier::BoxLevelConnectorUtils::computeBoxesAroundBoundary()</a>, <a class="el" href="BaseGridGeometry_8C_source.html#l00361">SAMRAI::hier::BaseGridGeometry::computeBoxTouchingBoundaries()</a>, <a class="el" href="NodeGeometry_8C_source.html#l00095">SAMRAI::pdat::NodeGeometry::computeDestinationBoxes()</a>, <a class="el" href="CellGeometry_8C_source.html#l00094">SAMRAI::pdat::CellGeometry::computeDestinationBoxes()</a>, <a class="el" href="PatchLevelBorderFillPattern_8C_source.html#l00053">SAMRAI::xfer::PatchLevelBorderFillPattern::computeFillBoxesAndNeighborhoodSets()</a>, <a class="el" href="PatchLevelBorderAndInteriorFillPattern_8C_source.html#l00052">SAMRAI::xfer::PatchLevelBorderAndInteriorFillPattern::computeFillBoxesAndNeighborhoodSets()</a>, <a class="el" href="BoxUtilities_8C_source.html#l00536">SAMRAI::hier::BoxUtilities::extendBoxToDomainBoundary()</a>, <a class="el" href="BoxUtilities_8C_source.html#l01336">SAMRAI::hier::BoxUtilities::findBadCutPointsForDirection()</a>, <a class="el" href="FlattenedHierarchy_8C_source.html#l00027">SAMRAI::hier::FlattenedHierarchy::FlattenedHierarchy()</a>, <a class="el" href="BaseGridGeometry_8C_source.html#l01075">SAMRAI::hier::BaseGridGeometry::getBoundaryBoxes()</a>, <a class="el" href="BoxUtilities_8C_source.html#l00622">SAMRAI::hier::BoxUtilities::growBoxesWithinDomain()</a>, <a class="el" href="BoxUtilities_8C_source.html#l01773">SAMRAI::hier::BoxUtilities::makeNonOverlappingBoxContainers()</a>, <a class="el" href="BoxLevelConnectorUtils_8C_source.html#l01085">SAMRAI::hier::BoxLevelConnectorUtils::makeRemainderMap()</a>, <a class="el" href="BoxContainer_8C_source.html#l00820">removeIntersections()</a>, and <a class="el" href="AssumedPartitionBox_8C_source.html#l00286">SAMRAI::hier::AssumedPartitionBox::selfCheck()</a>.</p>

</div>
</div>
<a class="anchor" id="a140cd0612e724e550fecb567f38c760b"></a><!-- doxytag: member="SAMRAI::hier::BoxContainer::removeIntersections" ref="a140cd0612e724e550fecb567f38c760b" args="(const BoxContainer &amp;takeaway)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::hier::BoxContainer::removeIntersections </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>takeaway</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Remove from each box portions intersecting boxes in takeaway. </p>
<p>For each box, b, in this container and for each box, t, in takeaway this operation computes b-(b^t) where '^' indicates intersection.</p>
<p>This only works if all boxes in this <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html" title="A container for Boxes.">BoxContainer</a> and the takeaway <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html" title="A container for Boxes.">BoxContainer</a> have the same <a class="el" href="classSAMRAI_1_1hier_1_1BlockId.html" title="Generic identifier for identifying the block id.">BlockId</a>. An error will occur otherwise.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>takeaway</em>&nbsp;</td><td>What to exclude from each box in the container.</td></tr>
  </table>
  </dd>
</dl>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>!isOrdered() </dd></dl>

<p>References <a class="el" href="BoxContainer_8h_source.html#l00706">begin()</a>, <a class="el" href="BoxContainer_8h_source.html#l00695">empty()</a>, <a class="el" href="BoxContainer_8h_source.html#l00717">end()</a>, <a class="el" href="BoxContainer_8C_source.html#l00781">removeIntersections()</a>, and <a class="el" href="Utilities_8h_source.html#l00060">TBOX_ERROR</a>.</p>

</div>
</div>
<a class="anchor" id="a9eae3c6a62fc8e46c2cb3430b72966ec"></a><!-- doxytag: member="SAMRAI::hier::BoxContainer::removeIntersections" ref="a9eae3c6a62fc8e46c2cb3430b72966ec" args="(const IntVector &amp;refinement_ratio, const BoxContainer &amp;takeaway, const bool include_singularity_block_neighbors=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::hier::BoxContainer::removeIntersections </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>refinement_ratio</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>takeaway</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&nbsp;</td>
          <td class="paramname"> <em>include_singularity_block_neighbors</em> = <code>false</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Remove from each box portions intersecting boxes in takeaway. </p>
<p>Uses refinement ratio and grid geometry to handle intersections across block boundaries if needed.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>refinement_ratio</em>&nbsp;</td><td>All boxes in this <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html" title="A container for Boxes.">BoxContainer</a> are assumed to exist in index space that has this refinement ratio relative to the coarse-level domain.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>takeaway</em>&nbsp;</td><td>The boxes to take away from this <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html" title="A container for Boxes.">BoxContainer</a>. An error will occur if makeTree with a non-null <a class="el" href="classSAMRAI_1_1hier_1_1BaseGridGeometry.html" title="Class BaseGridGeometry manages the index space that determines the extent of the...">BaseGridGeometry</a> argument has not been previously called on this container.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>include_singularity_block_neighbors</em>&nbsp;</td><td>If true, intersections with neighboring blocks that touch only across an enhanced connectivity singularity will be removed. If false, those intersections are ignored.</td></tr>
  </table>
  </dd>
</dl>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>!isOrdered() </dd>
<dd>
takeaway.hasTree() </dd></dl>

<p>References <a class="el" href="BoxContainer_8h_source.html#l00706">begin()</a>, <a class="el" href="BoxContainer_8h_source.html#l00695">empty()</a>, <a class="el" href="BoxContainer_8h_source.html#l00717">end()</a>, and <a class="el" href="Utilities_8h_source.html#l00060">TBOX_ERROR</a>.</p>

</div>
</div>
<a class="anchor" id="ad98c16c6d4f4d7a3d748dcc08fd3a010"></a><!-- doxytag: member="SAMRAI::hier::BoxContainer::removeIntersections" ref="ad98c16c6d4f4d7a3d748dcc08fd3a010" args="(const Box &amp;box, const Box &amp;takeaway)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::hier::BoxContainer::removeIntersections </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>box</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>takeaway</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Remove from box the portions intersecting takeaway. </p>
<p>This is special version for the case where the container is empty initially. Upon completion this container contains the result of the removal from box of the intersection of box with takeaway. If the boxes do not intersect, box is simply added to this container. This routine is primarily suited for applications which are looking only for the intersection of two boxes. This operation computes box-(box^takeaway) where '^' indicates intersection.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>box</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>takeaway</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>!isOrdered() </dd>
<dd>
<a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html#ad871f3c0557760094807290656e33750" title="Returns true if there are no boxes in the container.">empty()</a> </dd>
<dd>
box.getBlockId() == takeaway.getBlockId() </dd></dl>

<p>References <a class="el" href="BoxContainer_8h_source.html#l00695">empty()</a>, <a class="el" href="Box_8h_source.html#l00330">SAMRAI::hier::Box::getBlockId()</a>, <a class="el" href="Box_8h_source.html#l01313">SAMRAI::hier::Box::getDim()</a>, <a class="el" href="Dimension_8h_source.html#l00136">SAMRAI::tbox::Dimension::getValue()</a>, <a class="el" href="Box_8C_source.html#l00530">SAMRAI::hier::Box::intersects()</a>, <a class="el" href="BoxContainer_8h_source.html#l01076">pushBack()</a>, <a class="el" href="Utilities_8h_source.html#l00110">TBOX_ASSERT</a>, and <a class="el" href="Utilities_8h_source.html#l00060">TBOX_ERROR</a>.</p>

</div>
</div>
<a class="anchor" id="aafc53135623a761a92fc7053dd482810"></a><!-- doxytag: member="SAMRAI::hier::BoxContainer::intersectBoxes" ref="aafc53135623a761a92fc7053dd482810" args="(const Box &amp;keep)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::hier::BoxContainer::intersectBoxes </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>keep</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Keep the intersection of the container's boxes and keep. </p>
<p>Performing the intersection will require <img class="formulaInl" alt="$O(N)$" src="form_3.png"/> time for a container with <img class="formulaInl" alt="$N$" src="form_2.png"/> boxes. The complement of removeIntersections.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>keep</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>!isOrdered() </dd></dl>

<p>References <a class="el" href="BoxContainer_8h_source.html#l00706">begin()</a>, <a class="el" href="BoxContainer_8h_source.html#l00695">empty()</a>, <a class="el" href="BoxContainer_8h_source.html#l00717">end()</a>, <a class="el" href="BoxContainer_8C_source.html#l01452">erase()</a>, <a class="el" href="Box_8C_source.html#l00509">SAMRAI::hier::Box::intersect()</a>, and <a class="el" href="Utilities_8h_source.html#l00060">TBOX_ERROR</a>.</p>

<p>Referenced by <a class="el" href="SecondLayerNodeVariableFillPattern_8C_source.html#l00059">SAMRAI::pdat::SecondLayerNodeVariableFillPattern::calculateOverlap()</a>, <a class="el" href="SecondLayerNodeNoCornersVariableFillPattern_8C_source.html#l00061">SAMRAI::pdat::SecondLayerNodeNoCornersVariableFillPattern::calculateOverlap()</a>, <a class="el" href="FirstLayerNodeVariableFillPattern_8C_source.html#l00059">SAMRAI::pdat::FirstLayerNodeVariableFillPattern::calculateOverlap()</a>, <a class="el" href="BoxUtilities_8C_source.html#l00116">SAMRAI::hier::BoxUtilities::checkBoxConstraints()</a>, <a class="el" href="BaseGridGeometry_8C_source.html#l00361">SAMRAI::hier::BaseGridGeometry::computeBoxTouchingBoundaries()</a>, <a class="el" href="NodeGeometry_8C_source.html#l00095">SAMRAI::pdat::NodeGeometry::computeDestinationBoxes()</a>, <a class="el" href="CellGeometry_8C_source.html#l00094">SAMRAI::pdat::CellGeometry::computeDestinationBoxes()</a>, <a class="el" href="PatchInteriorVariableFillPattern_8C_source.html#l00083">SAMRAI::xfer::PatchInteriorVariableFillPattern::computeFillBoxesOverlap()</a>, <a class="el" href="BoxGeometryVariableFillPattern_8C_source.html#l00076">SAMRAI::xfer::BoxGeometryVariableFillPattern::computeFillBoxesOverlap()</a>, <a class="el" href="SecondLayerNodeVariableFillPattern_8C_source.html#l00157">SAMRAI::pdat::SecondLayerNodeVariableFillPattern::computeFillBoxesOverlap()</a>, <a class="el" href="SecondLayerNodeNoCornersVariableFillPattern_8C_source.html#l00167">SAMRAI::pdat::SecondLayerNodeNoCornersVariableFillPattern::computeFillBoxesOverlap()</a>, <a class="el" href="FirstLayerNodeVariableFillPattern_8C_source.html#l00150">SAMRAI::pdat::FirstLayerNodeVariableFillPattern::computeFillBoxesOverlap()</a>, <a class="el" href="FirstLayerCellVariableFillPattern_8C_source.html#l00135">SAMRAI::pdat::FirstLayerCellVariableFillPattern::computeFillBoxesOverlap()</a>, <a class="el" href="FirstLayerCellNoCornersVariableFillPattern_8C_source.html#l00148">SAMRAI::pdat::FirstLayerCellNoCornersVariableFillPattern::computeFillBoxesOverlap()</a>, <a class="el" href="BoxUtilities_8C_source.html#l00536">SAMRAI::hier::BoxUtilities::extendBoxToDomainBoundary()</a>, <a class="el" href="BaseGridGeometry_8C_source.html#l01075">SAMRAI::hier::BaseGridGeometry::getBoundaryBoxes()</a>, <a class="el" href="BoxUtilities_8C_source.html#l01817">SAMRAI::hier::BoxUtilities::growAndAdjustAcrossBlockBoundary()</a>, <a class="el" href="BoxUtilities_8C_source.html#l00622">SAMRAI::hier::BoxUtilities::growBoxesWithinDomain()</a>, <a class="el" href="BoxUtilities_8C_source.html#l00741">SAMRAI::hier::BoxUtilities::growBoxWithinDomain()</a>, <a class="el" href="BoxContainer_8C_source.html#l01083">intersectBoxes()</a>, and <a class="el" href="BaseGridGeometry_8C_source.html#l01870">SAMRAI::hier::BaseGridGeometry::readBlockDataFromInput()</a>.</p>

</div>
</div>
<a class="anchor" id="a2f7078f8f3e4024318d535717ed2cb34"></a><!-- doxytag: member="SAMRAI::hier::BoxContainer::intersectBoxes" ref="a2f7078f8f3e4024318d535717ed2cb34" args="(const BoxContainer &amp;keep)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::hier::BoxContainer::intersectBoxes </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>keep</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Keep the intersection of the container's boxes and keep's boxes. </p>
<p>Intersect the boxes in the current container against the boxes in the specified container. The intersection calculation will require <img class="formulaInl" alt="$O(N^2)$" src="form_0.png"/> time for containers with <img class="formulaInl" alt="$N$" src="form_2.png"/> boxes. The complement of removeIntersections.</p>
<p>This only works if all boxes in this <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html" title="A container for Boxes.">BoxContainer</a> and the keep <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html" title="A container for Boxes.">BoxContainer</a> have the same <a class="el" href="classSAMRAI_1_1hier_1_1BlockId.html" title="Generic identifier for identifying the block id.">BlockId</a>. An error will occur otherwise.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>keep</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>!isOrdered() </dd></dl>

<p>References <a class="el" href="BoxContainer_8h_source.html#l00706">begin()</a>, <a class="el" href="BoxContainer_8h_source.html#l00695">empty()</a>, <a class="el" href="BoxContainer_8h_source.html#l00717">end()</a>, <a class="el" href="BoxContainer_8C_source.html#l01452">erase()</a>, <a class="el" href="BoxContainer_8h_source.html#l01159">insertAfter()</a>, <a class="el" href="Box_8C_source.html#l00509">SAMRAI::hier::Box::intersect()</a>, <a class="el" href="BoxContainer_8C_source.html#l01050">intersectBoxes()</a>, and <a class="el" href="Utilities_8h_source.html#l00060">TBOX_ERROR</a>.</p>

</div>
</div>
<a class="anchor" id="a6332ff5ba2add3c55657b80d254a116e"></a><!-- doxytag: member="SAMRAI::hier::BoxContainer::intersectBoxes" ref="a6332ff5ba2add3c55657b80d254a116e" args="(const IntVector &amp;refinement_ratio, const BoxContainer &amp;keep, bool include_singularity_block_neighbors=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::hier::BoxContainer::intersectBoxes </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>refinement_ratio</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>keep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>include_singularity_block_neighbors</em> = <code>false</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Keep the intersection of the container's boxes and keep's boxes. </p>
<p>Uses refinement ratio and grid geometry to handle intersections across block boundaries if needed.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>refinement_ratio</em>&nbsp;</td><td>All boxes in this <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html" title="A container for Boxes.">BoxContainer</a> are assumed to exist in index space that has this refinement ratio relative to the coarse-level domain.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>keep</em>&nbsp;</td><td>The boxes to intersect with this <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html" title="A container for Boxes.">BoxContainer</a>. An error will occur if makeTree with a non-null <a class="el" href="classSAMRAI_1_1hier_1_1BaseGridGeometry.html" title="Class BaseGridGeometry manages the index space that determines the extent of the...">BaseGridGeometry</a> argument has not been previously called on this container.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>include_singularity_block_neighbors</em>&nbsp;</td><td>If true, intersections with neighboring blocks that touch only across an enhanced connectivity singularity will be kept. If false, those intersections are ignored.</td></tr>
  </table>
  </dd>
</dl>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>!isOrdered() </dd>
<dd>
keep.hasTree() </dd></dl>

<p>References <a class="el" href="BoxContainer_8h_source.html#l00706">begin()</a>, <a class="el" href="BoxContainer_8h_source.html#l00865">clear()</a>, <a class="el" href="Box_8h_source.html#l00613">SAMRAI::hier::Box::empty()</a>, <a class="el" href="BoxContainer_8h_source.html#l00695">empty()</a>, <a class="el" href="BoxContainer_8h_source.html#l00717">end()</a>, <a class="el" href="BoxContainer_8C_source.html#l01452">erase()</a>, <a class="el" href="BoxContainer_8h_source.html#l00818">front()</a>, <a class="el" href="Box_8h_source.html#l00330">SAMRAI::hier::Box::getBlockId()</a>, <a class="el" href="BoxContainer_8h_source.html#l01159">insertAfter()</a>, <a class="el" href="Box_8C_source.html#l00509">SAMRAI::hier::Box::intersect()</a>, and <a class="el" href="Utilities_8h_source.html#l00060">TBOX_ERROR</a>.</p>

</div>
</div>
<a class="anchor" id="a2c2d862cadd5ab8e61c1104b98d90fbe"></a><!-- doxytag: member="SAMRAI::hier::BoxContainer::insert" ref="a2c2d862cadd5ab8e61c1104b98d90fbe" args="(const Box &amp;box)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SAMRAI::hier::BoxContainer::insert </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>box</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Insert a single <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a>. </p>
<p>The insert methods are used to add Boxes to ordered containers. They may be called on an unordered container only if the size of the unordered container is zero. If called on such an empty unordered container, the state of the container will be changed to ordered. A run-time error will occur if called on a non-empty unordered container.</p>
<p>The <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> will be added to the container unless the container already contains a <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> with the same <a class="el" href="classSAMRAI_1_1hier_1_1BoxId.html" title="Identifier for a Box, consisting of a GlobalId and a PeriodicId.">BoxId</a>. If a <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> with the same <a class="el" href="classSAMRAI_1_1hier_1_1BoxId.html" title="Identifier for a Box, consisting of a GlobalId and a PeriodicId.">BoxId</a> does already exist in the contianer, the container will not be changed.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>True if the container did not already have a <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> with the same <a class="el" href="classSAMRAI_1_1hier_1_1BoxId.html" title="Identifier for a Box, consisting of a GlobalId and a PeriodicId.">BoxId</a>, false otherwise.</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>box</em>&nbsp;</td><td><a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> to attempt to insert into the container.</td></tr>
  </table>
  </dd>
</dl>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>box.getBoxId().isValid() </dd>
<dd>
<a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html#ad871f3c0557760094807290656e33750" title="Returns true if there are no boxes in the container.">empty()</a> || (<a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html#aacb30f477c077d265d20b477e5adc0f3" title="Returns the first element in the container.">front()</a>.getDim() == box.getDim()) </dd>
<dd>
<a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html#ad871f3c0557760094807290656e33750" title="Returns true if there are no boxes in the container.">empty()</a> || <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html#ab60e3636df51eb5997471a5520c7884b" title="Return whether this container is ordered.">isOrdered()</a> </dd></dl>

<p>References <a class="el" href="BoxContainer_8h_source.html#l00695">empty()</a>, <a class="el" href="BoxContainer_8h_source.html#l00818">front()</a>, <a class="el" href="Box_8h_source.html#l00315">SAMRAI::hier::Box::getBoxId()</a>, <a class="el" href="BoxId_8h_source.html#l00165">SAMRAI::hier::BoxId::isValid()</a>, <a class="el" href="Box_8h_source.html#l01323">SAMRAI::hier::Box::lockId()</a>, <a class="el" href="BoxContainer_8C_source.html#l01412">order()</a>, <a class="el" href="Utilities_8h_source.html#l00110">TBOX_ASSERT</a>, <a class="el" href="Utilities_8h_source.html#l00182">TBOX_ASSERT_OBJDIM_EQUALITY2</a>, and <a class="el" href="Utilities_8h_source.html#l00060">TBOX_ERROR</a>.</p>

<p>Referenced by <a class="el" href="BoxLevel_8C_source.html#l01045">SAMRAI::hier::BoxLevel::addBox()</a>, <a class="el" href="BoxLevel_8h_source.html#l01012">SAMRAI::hier::BoxLevel::addBoxWithoutUpdate()</a>, <a class="el" href="BoxLevel_8C_source.html#l01109">SAMRAI::hier::BoxLevel::addPeriodicBox()</a>, <a class="el" href="BaseGridGeometry_8C_source.html#l01225">SAMRAI::hier::BaseGridGeometry::computePhysicalDomain()</a>, <a class="el" href="Connector_8C_source.html#l00523">SAMRAI::hier::Connector::computeTransposeOf()</a>, <a class="el" href="OverlapConnectorAlgorithm_8C_source.html#l00147">SAMRAI::hier::OverlapConnectorAlgorithm::extractNeighbors()</a>, <a class="el" href="BoxContainer_8C_source.html#l01788">findOverlapBoxes()</a>, <a class="el" href="AssumedPartitionBox_8C_source.html#l00260">SAMRAI::hier::AssumedPartitionBox::findOverlaps()</a>, <a class="el" href="FlattenedHierarchy_8C_source.html#l00027">SAMRAI::hier::FlattenedHierarchy::FlattenedHierarchy()</a>, <a class="el" href="BoxContainer_8C_source.html#l01686">getFromRestart()</a>, <a class="el" href="BoxNeighborhoodCollection_8C_source.html#l00471">SAMRAI::hier::BoxNeighborhoodCollection::getNeighbors()</a>, <a class="el" href="BoxNeighborhoodCollection_8C_source.html#l00540">SAMRAI::hier::BoxNeighborhoodCollection::getPeriodicNeighbors()</a>, <a class="el" href="HierarchyNeighbors_8C_source.html#l00023">SAMRAI::hier::HierarchyNeighbors::HierarchyNeighbors()</a>, and <a class="el" href="BoxContainer_8C_source.html#l01377">unshiftPeriodicImageBoxes()</a>.</p>

</div>
</div>
<a class="anchor" id="a235e4cc65c93a2acc692838a0215e44f"></a><!-- doxytag: member="SAMRAI::hier::BoxContainer::insert" ref="a235e4cc65c93a2acc692838a0215e44f" args="(iterator position, const Box &amp;box)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer_1_1BoxContainerIterator.html">BoxContainer::iterator</a> SAMRAI::hier::BoxContainer::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer_1_1BoxContainerIterator.html">iterator</a>&nbsp;</td>
          <td class="paramname"> <em>position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>box</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Insert a single <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a>. </p>
<p>The <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> will be added to the container unless the container already contains a <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> with the same <a class="el" href="classSAMRAI_1_1hier_1_1BoxId.html" title="Identifier for a Box, consisting of a GlobalId and a PeriodicId.">BoxId</a>. If a <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> with the same <a class="el" href="classSAMRAI_1_1hier_1_1BoxId.html" title="Identifier for a Box, consisting of a GlobalId and a PeriodicId.">BoxId</a> does already exist in the contianer, the container will not be changed.</p>
<p>This version of insert includes an iterator argument pointing somewhere in this container. This iterator indicates a position in the ordered container where the search for the proper place to insert the given <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> will begin.</p>
<p>The iterator argument does not determine the place the <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> will end up in the ordered container, as that is always determined by <a class="el" href="classSAMRAI_1_1hier_1_1BoxId.html" title="Identifier for a Box, consisting of a GlobalId and a PeriodicId.">BoxId</a>; it is intended only to provide a means of optimization when the calling code knows something about the ordering of the container.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>iterator pointing to the newly-added <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> if the container did not already have a <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> with the same <a class="el" href="classSAMRAI_1_1hier_1_1BoxId.html" title="Identifier for a Box, consisting of a GlobalId and a PeriodicId.">BoxId</a>. If the container did have a <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> with the same <a class="el" href="classSAMRAI_1_1hier_1_1BoxId.html" title="Identifier for a Box, consisting of a GlobalId and a PeriodicId.">BoxId</a>, the returned iterator points to that <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a>.</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>position</em>&nbsp;</td><td>Location to begin searching for place to insert <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>box</em>&nbsp;</td><td><a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> to attempt to insert into the container</td></tr>
  </table>
  </dd>
</dl>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>box.getBoxId().isValid() </dd>
<dd>
box.getBlockId() != <a class="el" href="classSAMRAI_1_1hier_1_1BlockId.html#af5ec2c3b87256cd021571cd78a897d92" title="Get the designated invalid value for this class.">BlockId::invalidId()</a> </dd>
<dd>
<a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html#ad871f3c0557760094807290656e33750" title="Returns true if there are no boxes in the container.">empty()</a> || (<a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html#aacb30f477c077d265d20b477e5adc0f3" title="Returns the first element in the container.">front()</a>.getDim() == box.getDim()) </dd>
<dd>
<a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html#ad871f3c0557760094807290656e33750" title="Returns true if there are no boxes in the container.">empty()</a> || <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html#ab60e3636df51eb5997471a5520c7884b" title="Return whether this container is ordered.">isOrdered()</a> </dd></dl>

<p>References <a class="el" href="BoxContainer_8h_source.html#l00695">empty()</a>, <a class="el" href="BoxContainer_8h_source.html#l00818">front()</a>, <a class="el" href="Box_8h_source.html#l00330">SAMRAI::hier::Box::getBlockId()</a>, <a class="el" href="Box_8h_source.html#l00315">SAMRAI::hier::Box::getBoxId()</a>, <a class="el" href="BlockId_8h_source.html#l00136">SAMRAI::hier::BlockId::invalidId()</a>, <a class="el" href="BoxId_8h_source.html#l00165">SAMRAI::hier::BoxId::isValid()</a>, <a class="el" href="BoxContainer_8C_source.html#l01412">order()</a>, <a class="el" href="Utilities_8h_source.html#l00110">TBOX_ASSERT</a>, <a class="el" href="Utilities_8h_source.html#l00182">TBOX_ASSERT_OBJDIM_EQUALITY2</a>, and <a class="el" href="Utilities_8h_source.html#l00060">TBOX_ERROR</a>.</p>

</div>
</div>
<a class="anchor" id="ae043c3cad663f7ff9ec97ee02b9a2bd3"></a><!-- doxytag: member="SAMRAI::hier::BoxContainer::insert" ref="ae043c3cad663f7ff9ec97ee02b9a2bd3" args="(const_iterator first, const_iterator last)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::hier::BoxContainer::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer_1_1BoxContainerConstIterator.html">const_iterator</a>&nbsp;</td>
          <td class="paramname"> <em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer_1_1BoxContainerConstIterator.html">const_iterator</a>&nbsp;</td>
          <td class="paramname"> <em>last</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Insert all Boxes within a range. </p>
<p>Boxes in the range [first, last) are added to the ordered container, as long as they do not have a <a class="el" href="classSAMRAI_1_1hier_1_1BoxId.html" title="Identifier for a Box, consisting of a GlobalId and a PeriodicId.">BoxId</a> matching that of a <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> already in the container.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>first</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>last</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="pre"><dt><b>Precondition:</b></dt><dd><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html#ad871f3c0557760094807290656e33750" title="Returns true if there are no boxes in the container.">empty()</a> || <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html#ab60e3636df51eb5997471a5520c7884b" title="Return whether this container is ordered.">isOrdered()</a> </dd>
<dd>
for each box in [first, last), box.getBoxId().isValid() &amp;&amp; (empty || <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html#aacb30f477c077d265d20b477e5adc0f3" title="Returns the first element in the container.">front()</a>.getDim() == box.getDim()) </dd></dl>

<p>References <a class="el" href="BoxContainer_8h_source.html#l00695">empty()</a>, <a class="el" href="BoxContainer_8h_source.html#l00818">front()</a>, <a class="el" href="BoxContainer_8C_source.html#l01412">order()</a>, <a class="el" href="Utilities_8h_source.html#l00110">TBOX_ASSERT</a>, <a class="el" href="Utilities_8h_source.html#l00182">TBOX_ASSERT_OBJDIM_EQUALITY2</a>, and <a class="el" href="Utilities_8h_source.html#l00060">TBOX_ERROR</a>.</p>

</div>
</div>
<a class="anchor" id="a4460be7ce26be1bc5ce2ffc09b0efc9d"></a><!-- doxytag: member="SAMRAI::hier::BoxContainer::find" ref="a4460be7ce26be1bc5ce2ffc09b0efc9d" args="(const Box &amp;box) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer_1_1BoxContainerIterator.html">iterator</a> SAMRAI::hier::BoxContainer::find </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>box</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Find a box in an ordered container. </p>
<p>Search for a <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> having the same <a class="el" href="classSAMRAI_1_1hier_1_1BoxId.html" title="Identifier for a Box, consisting of a GlobalId and a PeriodicId.">BoxId</a> as the given box argument. This may only be called on an ordered container.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>If a <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> with the same <a class="el" href="classSAMRAI_1_1hier_1_1BoxId.html" title="Identifier for a Box, consisting of a GlobalId and a PeriodicId.">BoxId</a> as the argument is found, the iterator points to that <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> in this container, otherwise <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html#a9c566195352afe03c2c1b2ef8d19e55c" title="Return an iterator pointing to the end of the container.">end()</a> for this container is returned.</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>box</em>&nbsp;</td><td><a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> serving as key for the find operation. Only its <a class="el" href="classSAMRAI_1_1hier_1_1BoxId.html" title="Identifier for a Box, consisting of a GlobalId and a PeriodicId.">BoxId</a> is compared to members of this container.</td></tr>
  </table>
  </dd>
</dl>
<dl class="pre"><dt><b>Precondition:</b></dt><dd><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html#ab60e3636df51eb5997471a5520c7884b" title="Return whether this container is ordered.">isOrdered()</a> </dd></dl>

<p>References <a class="el" href="Utilities_8h_source.html#l00060">TBOX_ERROR</a>.</p>

<p>Referenced by <a class="el" href="BoxLevel_8C_source.html#l01167">SAMRAI::hier::BoxLevel::addBox()</a>, <a class="el" href="BoxLevel_8C_source.html#l01109">SAMRAI::hier::BoxLevel::addPeriodicBox()</a>, <a class="el" href="Connector_8C_source.html#l01999">SAMRAI::hier::Connector::checkConsistencyWithHead()</a>, <a class="el" href="BoxLevelConnectorUtils_8C_source.html#l01486">SAMRAI::hier::BoxLevelConnectorUtils::computeNonIntersectingParts()</a>, <a class="el" href="Connector_8C_source.html#l01265">SAMRAI::hier::Connector::doTransposeWork()</a>, <a class="el" href="BoxLevel_8C_source.html#l01241">SAMRAI::hier::BoxLevel::eraseBox()</a>, <a class="el" href="SingularityFinder_8C_source.html#l00141">SAMRAI::hier::SingularityFinder::findSingularities()</a>, <a class="el" href="BoxLevel_8h_source.html#l01159">SAMRAI::hier::BoxLevel::getBox()</a>, <a class="el" href="BoxLevel_8C_source.html#l01425">SAMRAI::hier::BoxLevel::getBoxStrict()</a>, <a class="el" href="BoxLevel_8C_source.html#l01399">SAMRAI::hier::BoxLevel::hasBox()</a>, <a class="el" href="BoxTransitSet_8C_source.html#l00162">SAMRAI::mesh::BoxTransitSet::insertAllWithExistingLoads()</a>, <a class="el" href="BoxLevelConnectorUtils_8C_source.html#l00357">SAMRAI::hier::BoxLevelConnectorUtils::makeSortingMap()</a>, and <a class="el" href="AssumedPartitionBox_8C_source.html#l00286">SAMRAI::hier::AssumedPartitionBox::selfCheck()</a>.</p>

</div>
</div>
<a class="anchor" id="a7e31c87c644fd9666c1bf1517f49d935"></a><!-- doxytag: member="SAMRAI::hier::BoxContainer::lowerBound" ref="a7e31c87c644fd9666c1bf1517f49d935" args="(const Box &amp;box) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer_1_1BoxContainerIterator.html">iterator</a> SAMRAI::hier::BoxContainer::lowerBound </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>box</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get lower bound iterator for a given <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a>. </p>
<p>This may only be called on an ordered container.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>iterator pointing to the first member of this container with a <a class="el" href="classSAMRAI_1_1hier_1_1BoxId.html" title="Identifier for a Box, consisting of a GlobalId and a PeriodicId.">BoxId</a> value greater than or equal to the <a class="el" href="classSAMRAI_1_1hier_1_1BoxId.html" title="Identifier for a Box, consisting of a GlobalId and a PeriodicId.">BoxId</a> of the argument <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a>.</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>box</em>&nbsp;</td><td><a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> serving as key for the lower bound search.</td></tr>
  </table>
  </dd>
</dl>
<dl class="pre"><dt><b>Precondition:</b></dt><dd><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html#ab60e3636df51eb5997471a5520c7884b" title="Return whether this container is ordered.">isOrdered()</a> </dd></dl>

<p>References <a class="el" href="Utilities_8h_source.html#l00060">TBOX_ERROR</a>.</p>

</div>
</div>
<a class="anchor" id="a0b375d7cb0766e9db20fa442c3d67cb3"></a><!-- doxytag: member="SAMRAI::hier::BoxContainer::upperBound" ref="a0b375d7cb0766e9db20fa442c3d67cb3" args="(const Box &amp;box) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer_1_1BoxContainerIterator.html">iterator</a> SAMRAI::hier::BoxContainer::upperBound </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>box</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get upper bound iterator for a given <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a>. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>iterator pointing to the first member of this container with a <a class="el" href="classSAMRAI_1_1hier_1_1BoxId.html" title="Identifier for a Box, consisting of a GlobalId and a PeriodicId.">BoxId</a> value greater than the <a class="el" href="classSAMRAI_1_1hier_1_1BoxId.html" title="Identifier for a Box, consisting of a GlobalId and a PeriodicId.">BoxId</a> of the argument <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a>. Will return <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html#a9c566195352afe03c2c1b2ef8d19e55c" title="Return an iterator pointing to the end of the container.">end()</a> if there are no members with a greater <a class="el" href="classSAMRAI_1_1hier_1_1BoxId.html" title="Identifier for a Box, consisting of a GlobalId and a PeriodicId.">BoxId</a> value.</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>box</em>&nbsp;</td><td><a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> serving as key for the upper bound search.</td></tr>
  </table>
  </dd>
</dl>
<dl class="pre"><dt><b>Precondition:</b></dt><dd><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html#ab60e3636df51eb5997471a5520c7884b" title="Return whether this container is ordered.">isOrdered()</a> </dd></dl>

<p>References <a class="el" href="Utilities_8h_source.html#l00060">TBOX_ERROR</a>.</p>

</div>
</div>
<a class="anchor" id="a72fdf350374069c52b2a36c715e9fc88"></a><!-- doxytag: member="SAMRAI::hier::BoxContainer::erase" ref="a72fdf350374069c52b2a36c715e9fc88" args="(const Box &amp;box)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int SAMRAI::hier::BoxContainer::erase </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>box</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Erase a <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> from the container. </p>
<p>If a member of the container has the same <a class="el" href="classSAMRAI_1_1hier_1_1BoxId.html" title="Identifier for a Box, consisting of a GlobalId and a PeriodicId.">BoxId</a> as the argument <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a>, it will be erased from the container. If no such member is found, the container is unchanged.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>1 if a <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> is erased, 0 otherwise.</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>box</em>&nbsp;</td><td><a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> serving as key to find a <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> to be erased.</td></tr>
  </table>
  </dd>
</dl>
<dl class="pre"><dt><b>Precondition:</b></dt><dd><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html#ab60e3636df51eb5997471a5520c7884b" title="Return whether this container is ordered.">isOrdered()</a> </dd></dl>

<p>References <a class="el" href="Box_8h_source.html#l00315">SAMRAI::hier::Box::getBoxId()</a>, and <a class="el" href="Utilities_8h_source.html#l00060">TBOX_ERROR</a>.</p>

</div>
</div>
<a class="anchor" id="ae92dc83a2539e418b81f92e63a5c77ab"></a><!-- doxytag: member="SAMRAI::hier::BoxContainer::separatePeriodicImages" ref="ae92dc83a2539e418b81f92e63a5c77ab" args="(std::vector&lt; Box &gt; &amp;real_box_vector, std::vector&lt; Box &gt; &amp;periodic_image_box_vector, const PeriodicShiftCatalog &amp;shift_catalog) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::hier::BoxContainer::separatePeriodicImages </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>real_box_vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>periodic_image_box_vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1PeriodicShiftCatalog.html">PeriodicShiftCatalog</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>shift_catalog</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Copy the members of this <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html" title="A container for Boxes.">BoxContainer</a> into two vector&lt;Box&gt; objects, one containing real Boxes and one containing their periodic images. </p>
<p>Put the results in the output vectors. For flexibility and efficiency, the output containers are NOT cleared first, so users may want to clear them before calling this method.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>real_box_vector</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>periodic_image_box_vector</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>shift_catalog</em>&nbsp;</td><td><a class="el" href="classSAMRAI_1_1hier_1_1PeriodicShiftCatalog.html" title="Catalogs periodic shifts and assigns each one a unique PeriodicId.">PeriodicShiftCatalog</a> object that maps the <a class="el" href="classSAMRAI_1_1hier_1_1PeriodicId.html" title="Generic identifier for identifying the periodic shift.">PeriodicId</a> to a specific shift.</td></tr>
  </table>
  </dd>
</dl>
<dl class="pre"><dt><b>Precondition:</b></dt><dd><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html#ab60e3636df51eb5997471a5520c7884b" title="Return whether this container is ordered.">isOrdered()</a> </dd></dl>

<p>References <a class="el" href="BoxContainer_8h_source.html#l00706">begin()</a>, <a class="el" href="BoxContainer_8h_source.html#l00695">empty()</a>, <a class="el" href="BoxContainer_8h_source.html#l00717">end()</a>, <a class="el" href="Box_8h_source.html#l00369">SAMRAI::hier::Box::getPeriodicId()</a>, <a class="el" href="PeriodicShiftCatalog_8h_source.html#l00150">SAMRAI::hier::PeriodicShiftCatalog::getZeroShiftNumber()</a>, <a class="el" href="BoxContainer_8h_source.html#l00663">size()</a>, and <a class="el" href="Utilities_8h_source.html#l00060">TBOX_ERROR</a>.</p>

<p>Referenced by <a class="el" href="BoxLevelConnectorUtils_8C_source.html#l00357">SAMRAI::hier::BoxLevelConnectorUtils::makeSortingMap()</a>.</p>

</div>
</div>
<a class="anchor" id="ae6c69e1e6065a9b4e0b88384cd7cf49f"></a><!-- doxytag: member="SAMRAI::hier::BoxContainer::removePeriodicImageBoxes" ref="ae6c69e1e6065a9b4e0b88384cd7cf49f" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::hier::BoxContainer::removePeriodicImageBoxes </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Any members of this container that are periodic images will be erased. </p>
<dl class="pre"><dt><b>Precondition:</b></dt><dd><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html#ad871f3c0557760094807290656e33750" title="Returns true if there are no boxes in the container.">empty()</a> || <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html#ab60e3636df51eb5997471a5520c7884b" title="Return whether this container is ordered.">isOrdered()</a> </dd></dl>

<p>References <a class="el" href="BoxContainer_8h_source.html#l00706">begin()</a>, <a class="el" href="BoxContainer_8h_source.html#l00695">empty()</a>, <a class="el" href="BoxContainer_8h_source.html#l00717">end()</a>, <a class="el" href="BoxContainer_8C_source.html#l01452">erase()</a>, and <a class="el" href="Utilities_8h_source.html#l00060">TBOX_ERROR</a>.</p>

<p>Referenced by <a class="el" href="BoxLevel_8C_source.html#l00440">SAMRAI::hier::BoxLevel::removePeriodicImageBoxes()</a>.</p>

</div>
</div>
<a class="anchor" id="a14be836a0a040a017c670c27537f8c30"></a><!-- doxytag: member="SAMRAI::hier::BoxContainer::unshiftPeriodicImageBoxes" ref="a14be836a0a040a017c670c27537f8c30" args="(BoxContainer &amp;output_boxes, const IntVector &amp;refinement_ratio, const PeriodicShiftCatalog &amp;shift_catalog) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::hier::BoxContainer::unshiftPeriodicImageBoxes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>output_boxes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>refinement_ratio</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1PeriodicShiftCatalog.html">PeriodicShiftCatalog</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>shift_catalog</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Place unshifted versions of Boxes into a <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html" title="A container for Boxes.">BoxContainer</a>. </p>
<p>For all members of this container that are periodic images, create an unshifted copy the member box and add insert it the output container. Additionally, insert all members of the container that are not periodic images to the output container.</p>
<p>For flexibility and efficiency, the output container is NOT cleared first, so users may want to clear it before calling this method.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>output_boxes</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>refinement_ratio</em>&nbsp;</td><td>Refinement ratio where the boxes live.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>shift_catalog</em>&nbsp;</td><td><a class="el" href="classSAMRAI_1_1hier_1_1PeriodicShiftCatalog.html" title="Catalogs periodic shifts and assigns each one a unique PeriodicId.">PeriodicShiftCatalog</a> object that maps the <a class="el" href="classSAMRAI_1_1hier_1_1PeriodicId.html" title="Generic identifier for identifying the periodic shift.">PeriodicId</a> to a specific shift.</td></tr>
  </table>
  </dd>
</dl>
<dl class="pre"><dt><b>Precondition:</b></dt><dd><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html#ab60e3636df51eb5997471a5520c7884b" title="Return whether this container is ordered.">isOrdered()</a> </dd></dl>

<p>References <a class="el" href="BoxContainer_8h_source.html#l00706">begin()</a>, <a class="el" href="BoxContainer_8h_source.html#l00695">empty()</a>, <a class="el" href="BoxContainer_8h_source.html#l00717">end()</a>, <a class="el" href="PeriodicShiftCatalog_8h_source.html#l00150">SAMRAI::hier::PeriodicShiftCatalog::getZeroShiftNumber()</a>, <a class="el" href="BoxContainer_8C_source.html#l00290">insert()</a>, and <a class="el" href="Utilities_8h_source.html#l00060">TBOX_ERROR</a>.</p>

<p>Referenced by <a class="el" href="PatchLevelInteriorFillPattern_8C_source.html#l00105">SAMRAI::xfer::PatchLevelInteriorFillPattern::computeDestinationFillBoxesOnSourceProc()</a>, and <a class="el" href="PatchLevelFullFillPattern_8C_source.html#l00102">SAMRAI::xfer::PatchLevelFullFillPattern::computeDestinationFillBoxesOnSourceProc()</a>.</p>

</div>
</div>
<a class="anchor" id="ad795e5b89220de39c135f35a67cdd9f4"></a><!-- doxytag: member="SAMRAI::hier::BoxContainer::operator==" ref="ad795e5b89220de39c135f35a67cdd9f4" args="(const BoxContainer &amp;rhs) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SAMRAI::hier::BoxContainer::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Equality operator. </p>
<p>If the container is ordered, then this checks if all boxes have identical BoxIds and are spatially equal to the boxes in rhs. If unordered, then this checks only the spatial equality of the boxes.</p>
<p>Addtionally to be considered equal, both containers must contain the same number of boxes and have the same ordered/unordered state.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>true only if the containers meet the equality conditions.</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>rhs</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="BoxContainer_8C_source.html#l00204">isIdEqual()</a>, and <a class="el" href="BoxContainer_8C_source.html#l00221">isSpatiallyEqual()</a>.</p>

</div>
</div>
<a class="anchor" id="addbc2e3fd0573678cd793bcfe4e0258c"></a><!-- doxytag: member="SAMRAI::hier::BoxContainer::isIdEqual" ref="addbc2e3fd0573678cd793bcfe4e0258c" args="(const BoxContainer &amp;other) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SAMRAI::hier::BoxContainer::isIdEqual </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>other</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Check for equality of BoxIds in ordered containers. </p>
<p>An error will occur if this operator is called with either <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html" title="A container for Boxes.">BoxContainer</a> in unordered state.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if both containers are the same size and the boxes have identical BoxIds.</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>other</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="pre"><dt><b>Precondition:</b></dt><dd><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html#ab60e3636df51eb5997471a5520c7884b" title="Return whether this container is ordered.">isOrdered()</a> &amp;&amp; other.isOrdered() </dd></dl>

<p>References <a class="el" href="BoxContainer_8h_source.html#l00663">size()</a>, and <a class="el" href="Utilities_8h_source.html#l00060">TBOX_ERROR</a>.</p>

<p>Referenced by <a class="el" href="BoxContainer_8C_source.html#l00185">operator==()</a>.</p>

</div>
</div>
<a class="anchor" id="a8c5e154d95a5cc990613062dc62c70d0"></a><!-- doxytag: member="SAMRAI::hier::BoxContainer::isSpatiallyEqual" ref="a8c5e154d95a5cc990613062dc62c70d0" args="(const BoxContainer &amp;other) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SAMRAI::hier::BoxContainer::isSpatiallyEqual </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>other</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Check for spatial equality of all boxes. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if both containers are the same size and the boxes are spatially equal (same extents and same <a class="el" href="classSAMRAI_1_1hier_1_1BlockId.html" title="Generic identifier for identifying the block id.">BlockId</a>).</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>other</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="BoxContainer_8h_source.html#l00663">size()</a>.</p>

<p>Referenced by <a class="el" href="BoxContainer_8C_source.html#l00185">operator==()</a>.</p>

</div>
</div>
<a class="anchor" id="a3388a48a209f9b2d08f51bc64f1b33f5"></a><!-- doxytag: member="SAMRAI::hier::BoxContainer::operator!=" ref="a3388a48a209f9b2d08f51bc64f1b33f5" args="(const BoxContainer &amp;rhs) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SAMRAI::hier::BoxContainer::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Inequality operator. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Return true if operator== would return false.</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>rhs</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa24aaf0ff0de7a5a86e80ac1b2cfc96f"></a><!-- doxytag: member="SAMRAI::hier::BoxContainer::putToRestart" ref="aa24aaf0ff0de7a5a86e80ac1b2cfc96f" args="(const boost::shared_ptr&lt; tbox::Database &gt; &amp;restart_db) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::hier::BoxContainer::putToRestart </td>
          <td>(</td>
          <td class="paramtype">const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Database.html">tbox::Database</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>restart_db</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Write the <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html" title="A container for Boxes.">BoxContainer</a> to a restart database. </p>

<p>References <a class="el" href="BoxContainer_8h_source.html#l00706">begin()</a>, <a class="el" href="BoxContainer_8h_source.html#l00717">end()</a>, and <a class="el" href="BoxContainer_8h_source.html#l00663">size()</a>.</p>

<p>Referenced by <a class="el" href="BoxLevel_8C_source.html#l01519">SAMRAI::hier::BoxLevel::putToRestart()</a>, and <a class="el" href="BaseGridGeometry_8C_source.html#l00849">SAMRAI::hier::BaseGridGeometry::putToRestart()</a>.</p>

</div>
</div>
<a class="anchor" id="aa0928d91ef08c3bc5ff619be13351577"></a><!-- doxytag: member="SAMRAI::hier::BoxContainer::getFromRestart" ref="aa0928d91ef08c3bc5ff619be13351577" args="(tbox::Database &amp;restart_db)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::hier::BoxContainer::getFromRestart </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1tbox_1_1Database.html">tbox::Database</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>restart_db</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Read the <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html" title="A container for Boxes.">BoxContainer</a> from a restart database. </p>

<p>References <a class="el" href="BoxContainer_8h_source.html#l00717">end()</a>, <a class="el" href="classSAMRAI_1_1tbox_1_1Database.html#a39c6abb046d91a6ad4e8ba164435d34b">SAMRAI::tbox::Database::getDatabaseBoxVector()</a>, <a class="el" href="Database_8C_source.html#l00840">SAMRAI::tbox::Database::getInteger()</a>, <a class="el" href="classSAMRAI_1_1tbox_1_1Database.html#a733f2f103c28df889fc86cee6dfde9ed">SAMRAI::tbox::Database::getIntegerVector()</a>, <a class="el" href="BoxContainer_8C_source.html#l00290">insert()</a>, <a class="el" href="Box_8h_source.html#l00322">SAMRAI::hier::Box::setBlockId()</a>, <a class="el" href="Box_8h_source.html#l00307">SAMRAI::hier::Box::setId()</a>, and <a class="el" href="Utilities_8h_source.html#l00060">TBOX_ERROR</a>.</p>

</div>
</div>
<a class="anchor" id="a7e47dfbb2f2a4b41458315d14d8515ff"></a><!-- doxytag: member="SAMRAI::hier::BoxContainer::operator std::vector&lt; tbox::DatabaseBox &gt;" ref="a7e47dfbb2f2a4b41458315d14d8515ff" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SAMRAI::hier::BoxContainer::operator std::vector&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1DatabaseBox.html">tbox::DatabaseBox</a> &gt; </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Conversion from <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html" title="A container for Boxes.">BoxContainer</a> to std::vector&lt;tbox::DatabaseBox&gt;. </p>

</div>
</div>
<a class="anchor" id="abfff5008f021e5091f3eb192afa7aa8d"></a><!-- doxytag: member="SAMRAI::hier::BoxContainer::print" ref="abfff5008f021e5091f3eb192afa7aa8d" args="(std::ostream &amp;os=tbox::plog, const std::string &amp;border=std::string()) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::hier::BoxContainer::print </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&nbsp;</td>
          <td class="paramname"> <em>os</em> = <code><a class="el" href="namespaceSAMRAI_1_1tbox.html#ab84041705493761fb17a8127e3a2dca2">tbox::plog</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>border</em> = <code>std::string()</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Print each box in the container to the specified output stream. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>os</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>border</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="BoxContainer_8h_source.html#l00706">begin()</a>, <a class="el" href="BoxContainer_8h_source.html#l00717">end()</a>, <a class="el" href="Box_8h_source.html#l00636">SAMRAI::hier::Box::numberCells()</a>, <a class="el" href="Box_8h_source.html#l00667">SAMRAI::hier::Box::size()</a>, and <a class="el" href="BoxContainer_8h_source.html#l00663">size()</a>.</p>

<p>Referenced by <a class="el" href="BoxContainer_8C_source.html#l01765">SAMRAI::hier::operator&lt;&lt;()</a>, and <a class="el" href="BaseGridGeometry_8C_source.html#l03290">SAMRAI::hier::BaseGridGeometry::printClassData()</a>.</p>

</div>
</div>
<a class="anchor" id="a690469554c526eae84d5763ac0965e3c"></a><!-- doxytag: member="SAMRAI::hier::BoxContainer::format" ref="a690469554c526eae84d5763ac0965e3c" args="(const std::string &amp;border=std::string(), int detail_depth=2) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer_1_1Outputter.html">BoxContainer::Outputter</a> SAMRAI::hier::BoxContainer::format </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>border</em> = <code>std::string()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>detail_depth</em> = <code>2</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return a object to that can format the <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html" title="A container for Boxes.">BoxContainer</a> for inserting into output streams. </p>
<p>Usage example (printing with a tab indentation): </p>
<div class="fragment"><pre class="fragment">
    *    cout &lt;&lt; "my boxes:\n" &lt;&lt; boxes.format("\t") &lt;&lt; endl;
    * </pre></div><dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>border</em>&nbsp;</td><td>Left border of the output</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>detail_depth</em>&nbsp;</td><td>How much detail to print. </td></tr>
  </table>
  </dd>
</dl>

<p>Referenced by <a class="el" href="BalanceUtilities_8C_source.html#l01871">SAMRAI::mesh::BalanceUtilities::findSmallBoxesInPostbalance()</a>, <a class="el" href="BaseConnectorAlgorithm_8C_source.html#l00119">SAMRAI::hier::BaseConnectorAlgorithm::packReferencedNeighbors()</a>, <a class="el" href="AssumedPartitionBox_8C_source.html#l00552">SAMRAI::hier::AssumedPartitionBox::recursivePrint()</a>, and <a class="el" href="AssumedPartitionBox_8C_source.html#l00286">SAMRAI::hier::AssumedPartitionBox::selfCheck()</a>.</p>

</div>
</div>
<a class="anchor" id="afaa3a4f83b2f6714087926aea2d21664"></a><!-- doxytag: member="SAMRAI::hier::BoxContainer::makeTree" ref="afaa3a4f83b2f6714087926aea2d21664" args="(const BaseGridGeometry *grid_geometry=0, const int min_number=10) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::hier::BoxContainer::makeTree </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1BaseGridGeometry.html">BaseGridGeometry</a> *&nbsp;</td>
          <td class="paramname"> <em>grid_geometry</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>min_number</em> = <code>10</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create a search tree representation of the boxes in this container. </p>
<p>If the size of this container is greater than the min_number argument, then an internal <a class="el" href="classSAMRAI_1_1hier_1_1BoxTree.html" title="Utility sorting Boxes into tree-like form for finding box overlaps.">BoxTree</a> representation of the boxes will be created and held by the container.</p>
<p>This method may only be used if all members of this container have the same <a class="el" href="classSAMRAI_1_1hier_1_1BlockId.html" title="Generic identifier for identifying the block id.">BlockId</a>. An assertion failure will occur if this condition is not met.</p>
<p>The building of the tree is an O(N log(N)) operation, but it reduces the cost of the search methods <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html#aa6e83d2ee9cc30cc14da50cc398e89c2" title="Find all boxes that intersect with a given box.">findOverlapBoxes()</a> and <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html#ab161e5c0d9cb1ef48c0b06016f6ec78f" title="Determine if a given box intersects with the BoxContainer.">hasOverlap()</a> to O(log(N)), rather than O(N). The tree representation is intended for when these search methods are called multiple times on the same <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html" title="A container for Boxes.">BoxContainer</a> which is not changing, so that the benefit of more efficient search should outweigh the cost of building the tree.</p>
<p>The min_number argument is used to indicate a container size below which there is no benefit from building the tree, so no tree is created when the size is less than or equal to this value.</p>
<p>If a tree representation has been created via this method, and then any other <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html" title="A container for Boxes.">BoxContainer</a> method is called that changes the container by adding or removing boxes, or by changing the spatial coordinates of the boxes, the tree representation is destroyed.</p>
<p>A non-null pointer to a <a class="el" href="classSAMRAI_1_1hier_1_1BaseGridGeometry.html" title="Class BaseGridGeometry manages the index space that determines the extent of the...">BaseGridGeometry</a> must be provided if this container is going to be used in any of the methods that handle multiblock transformations. If this container is used only in a single-block context, no <a class="el" href="classSAMRAI_1_1hier_1_1BaseGridGeometry.html" title="Class BaseGridGeometry manages the index space that determines the extent of the...">BaseGridGeometry</a> argument is necessary.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>The grid_geometry argument is required for multiblock. It must be the GridGeometry from which the Boxes stored in the container came from.</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>grid_geometry</em>&nbsp;</td><td>To handle multiblock transformations if needed. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>min_number</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>min_number &gt; 0 </dd></dl>

<p>References <a class="el" href="BoxContainer_8h_source.html#l00695">empty()</a>, and <a class="el" href="Utilities_8h_source.html#l00110">TBOX_ASSERT</a>.</p>

<p>Referenced by <a class="el" href="BoxLevelConnectorUtils_8C_source.html#l01271">SAMRAI::hier::BoxLevelConnectorUtils::addPeriodicImagesAndRelationships()</a>, <a class="el" href="BoxContainer_8C_source.html#l00059">BoxContainer()</a>, <a class="el" href="BoxLevelConnectorUtils_8C_source.html#l00880">SAMRAI::hier::BoxLevelConnectorUtils::computeBoxesAroundBoundary()</a>, <a class="el" href="TileClustering_8C_source.html#l00125">SAMRAI::mesh::TileClustering::findBoxesContainingTags()</a>, <a class="el" href="BaseGridGeometry_8C_source.html#l00306">SAMRAI::hier::BaseGridGeometry::findPatchesTouchingBoundaries()</a>, <a class="el" href="BaseGridGeometry_8C_source.html#l01075">SAMRAI::hier::BaseGridGeometry::getBoundaryBoxes()</a>, and <a class="el" href="AssumedPartitionBox_8C_source.html#l00286">SAMRAI::hier::AssumedPartitionBox::selfCheck()</a>.</p>

</div>
</div>
<a class="anchor" id="a6583a10f3562655a992cc0108222dd3e"></a><!-- doxytag: member="SAMRAI::hier::BoxContainer::hasTree" ref="a6583a10f3562655a992cc0108222dd3e" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SAMRAI::hier::BoxContainer::hasTree </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Query if the search tree representation exists. </p>

<p>Referenced by <a class="el" href="BaseGridGeometry_8C_source.html#l01075">SAMRAI::hier::BaseGridGeometry::getBoundaryBoxes()</a>.</p>

</div>
</div>
<a class="anchor" id="a8f29006cbc555f91394a5b641d99027a"></a><!-- doxytag: member="SAMRAI::hier::BoxContainer::hasBoxInBlock" ref="a8f29006cbc555f91394a5b641d99027a" args="(const BlockId &amp;block_id) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SAMRAI::hier::BoxContainer::hasBoxInBlock </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1BlockId.html">BlockId</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>block_id</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Query if this <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html" title="A container for Boxes.">BoxContainer</a> contains any <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> with the given <a class="el" href="classSAMRAI_1_1hier_1_1BlockId.html" title="Generic identifier for identifying the block id.">BlockId</a>. </p>
<p>This is an efficient query if the the tree representation of this container has been constructed. If not, it requires a linear search over the entire container and may not be efficient. </p>

<p>References <a class="el" href="BoxContainer_8h_source.html#l00706">begin()</a>, and <a class="el" href="BoxContainer_8h_source.html#l00717">end()</a>.</p>

<p>Referenced by <a class="el" href="BoxLevelConnectorUtils_8C_source.html#l00880">SAMRAI::hier::BoxLevelConnectorUtils::computeBoxesAroundBoundary()</a>.</p>

</div>
</div>
<a class="anchor" id="aa6e83d2ee9cc30cc14da50cc398e89c2"></a><!-- doxytag: member="SAMRAI::hier::BoxContainer::findOverlapBoxes" ref="aa6e83d2ee9cc30cc14da50cc398e89c2" args="(BoxContainer &amp;overlap_boxes, const Box &amp;box) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::hier::BoxContainer::findOverlapBoxes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>overlap_boxes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>box</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Find all boxes that intersect with a given box. </p>
<p>Every <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> in this <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html" title="A container for Boxes.">BoxContainer</a> that intersects with the box argument will be added to the overlap_boxes output container. The output container will retain the same ordered/unordered state that it had prior to being passed into this method.</p>
<p>If this method is used multiple times on the same <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html" title="A container for Boxes.">BoxContainer</a>, it is recommended for efficiency's sake to call <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html#afaa3a4f83b2f6714087926aea2d21664" title="Create a search tree representation of the boxes in this container.">makeTree()</a> on this <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html" title="A container for Boxes.">BoxContainer</a> before calling this method.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>overlap_boxes</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>box</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="BoxContainer_8h_source.html#l00706">begin()</a>, <a class="el" href="BoxContainer_8h_source.html#l00717">end()</a>, <a class="el" href="BoxContainer_8C_source.html#l00290">insert()</a>, <a class="el" href="Box_8C_source.html#l00530">SAMRAI::hier::Box::intersects()</a>, <a class="el" href="BoxContainer_8h_source.html#l01025">isOrdered()</a>, and <a class="el" href="BoxContainer_8h_source.html#l01076">pushBack()</a>.</p>

<p>Referenced by <a class="el" href="TileClustering_8C_source.html#l00125">SAMRAI::mesh::TileClustering::findBoxesContainingTags()</a>, and <a class="el" href="AssumedPartitionBox_8C_source.html#l00286">SAMRAI::hier::AssumedPartitionBox::selfCheck()</a>.</p>

</div>
</div>
<a class="anchor" id="ad254ff6fa6afdaa32c7539dcef0749c4"></a><!-- doxytag: member="SAMRAI::hier::BoxContainer::findOverlapBoxes" ref="ad254ff6fa6afdaa32c7539dcef0749c4" args="(std::vector&lt; const Box * &gt; &amp;overlap_boxes, const Box &amp;box) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::hier::BoxContainer::findOverlapBoxes </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> * &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>overlap_boxes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>box</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Find all boxes that intersect with a given box. </p>
<p>A pointer to every <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> in this <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html" title="A container for Boxes.">BoxContainer</a> that intersects with the box argument will be copied to the overlap_boxes output vector. The vector is not sorted in any way.</p>
<p>If this method is used multiple times on the same <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html" title="A container for Boxes.">BoxContainer</a>, it is recommended for efficiency's sake to call <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html#afaa3a4f83b2f6714087926aea2d21664" title="Create a search tree representation of the boxes in this container.">makeTree()</a> on this <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html" title="A container for Boxes.">BoxContainer</a> before calling this method.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>overlap_boxes</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>box</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>!hasTree() || (d_tree-&gt;getNumberBlocksInTree() == 1) </dd></dl>

<p>References <a class="el" href="BoxContainer_8h_source.html#l00706">begin()</a>, <a class="el" href="BoxContainer_8h_source.html#l00717">end()</a>, <a class="el" href="Box_8C_source.html#l00530">SAMRAI::hier::Box::intersects()</a>, and <a class="el" href="Utilities_8h_source.html#l00110">TBOX_ASSERT</a>.</p>

</div>
</div>
<a class="anchor" id="a046d85a16e8923c8e7493a128c27595e"></a><!-- doxytag: member="SAMRAI::hier::BoxContainer::findOverlapBoxes" ref="a046d85a16e8923c8e7493a128c27595e" args="(BoxContainer &amp;overlap_boxes, const Box &amp;box, const IntVector &amp;refinement_ratio, bool include_singularity_block_neighbors=false) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::hier::BoxContainer::findOverlapBoxes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>overlap_boxes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>box</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>refinement_ratio</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>include_singularity_block_neighbors</em> = <code>false</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Find all boxes that intersect with a given box. </p>
<p>Uses refinement ratio and grid geometry to handle intersections across block boundaries if needed. The makeTree method with a non-null <a class="el" href="classSAMRAI_1_1hier_1_1BaseGridGeometry.html" title="Class BaseGridGeometry manages the index space that determines the extent of the...">BaseGridGeometry</a> pointer must be called on this container before calling this version of findOverlapBoxes.</p>
<p>Every <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> in this <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html" title="A container for Boxes.">BoxContainer</a> that intersects with the box argument will be copied to the overlap_boxes output container. The output container will retain the same ordered/unordered state that it had prior to being passed into this method.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>overlap_boxes</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>box</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>refinement_ratio</em>&nbsp;</td><td>All boxes in this <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html" title="A container for Boxes.">BoxContainer</a> are assumed to exist in index space that has this refinement ratio relative to the coarse-level domain.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>include_singularity_block_neighbors</em>&nbsp;</td><td>If true, intersections with neighboring blocks that touch only across an enhanced connectivity singularity will be added to output. If false, those intersections are ignored.</td></tr>
  </table>
  </dd>
</dl>
<dl class="pre"><dt><b>Precondition:</b></dt><dd><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html#a6583a10f3562655a992cc0108222dd3e" title="Query if the search tree representation exists.">hasTree()</a> </dd></dl>

<p>References <a class="el" href="BoxContainer_8h_source.html#l00695">empty()</a>, and <a class="el" href="Utilities_8h_source.html#l00060">TBOX_ERROR</a>.</p>

</div>
</div>
<a class="anchor" id="aa97cea6ce26cd7669d8cda4898b91b95"></a><!-- doxytag: member="SAMRAI::hier::BoxContainer::findOverlapBoxes" ref="aa97cea6ce26cd7669d8cda4898b91b95" args="(std::vector&lt; const Box * &gt; &amp;overlap_boxes, const Box &amp;box, const IntVector &amp;refinement_ratio, bool include_singularity_block_neighbors=false) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::hier::BoxContainer::findOverlapBoxes </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> * &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>overlap_boxes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>box</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>refinement_ratio</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>include_singularity_block_neighbors</em> = <code>false</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>References <a class="el" href="BoxContainer_8h_source.html#l00695">empty()</a>, and <a class="el" href="Utilities_8h_source.html#l00060">TBOX_ERROR</a>.</p>

</div>
</div>
<a class="anchor" id="ab161e5c0d9cb1ef48c0b06016f6ec78f"></a><!-- doxytag: member="SAMRAI::hier::BoxContainer::hasOverlap" ref="ab161e5c0d9cb1ef48c0b06016f6ec78f" args="(const Box &amp;box) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SAMRAI::hier::BoxContainer::hasOverlap </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>box</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Determine if a given box intersects with the <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html" title="A container for Boxes.">BoxContainer</a>. </p>
<p>If this method is used multiple times on the same <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html" title="A container for Boxes.">BoxContainer</a>, it is recommended for efficiency's sake to call <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html#afaa3a4f83b2f6714087926aea2d21664" title="Create a search tree representation of the boxes in this container.">makeTree()</a> on this <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html" title="A container for Boxes.">BoxContainer</a> before calling this method.</p>
<p>This only works if all boxes in this <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html" title="A container for Boxes.">BoxContainer</a> have the same <a class="el" href="classSAMRAI_1_1hier_1_1BlockId.html" title="Generic identifier for identifying the block id.">BlockId</a>, and the argument box also has that same <a class="el" href="classSAMRAI_1_1hier_1_1BlockId.html" title="Generic identifier for identifying the block id.">BlockId</a>. An error will occur if these conditions are not met.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>True if box intersects with any member of the <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html" title="A container for Boxes.">BoxContainer</a>, false otherwise.</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>box</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="BoxContainer_8h_source.html#l00706">begin()</a>, <a class="el" href="BoxContainer_8h_source.html#l00717">end()</a>, and <a class="el" href="Box_8C_source.html#l00530">SAMRAI::hier::Box::intersects()</a>.</p>

<p>Referenced by <a class="el" href="BoxLevelConnectorUtils_8C_source.html#l01211">SAMRAI::hier::BoxLevelConnectorUtils::addPeriodicImages()</a>, and <a class="el" href="BoxLevelConnectorUtils_8C_source.html#l01271">SAMRAI::hier::BoxLevelConnectorUtils::addPeriodicImagesAndRelationships()</a>.</p>

</div>
</div>
<hr/><h2>Friends And Related Function Documentation</h2>
<a class="anchor" id="acf9e3e89ec00844bde233c296adf4db5"></a><!-- doxytag: member="SAMRAI::hier::BoxContainer::BoxContainerIterator" ref="acf9e3e89ec00844bde233c296adf4db5" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer_1_1BoxContainerIterator.html">BoxContainerIterator</a><code> [friend]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ab605c1f6e8e543714f20820b93d2d556"></a><!-- doxytag: member="SAMRAI::hier::BoxContainer::BoxContainerConstIterator" ref="ab605c1f6e8e543714f20820b93d2d556" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer_1_1BoxContainerConstIterator.html">BoxContainerConstIterator</a><code> [friend]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>source/SAMRAI/hier/<a class="el" href="BoxContainer_8h.html">BoxContainer.h</a></li>
<li>source/SAMRAI/hier/<a class="el" href="BoxContainer_8C.html">BoxContainer.C</a></li>
</ul>
</div>
<hr size="1"/><address style="text-align: right;"><small>Generated on 21 Jan 2016 for SAMRAI by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.1 </small></address>
</body>
</html>
