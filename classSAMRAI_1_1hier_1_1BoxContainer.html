<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>SAMRAI: SAMRAI::hier::BoxContainer Class Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.7 -->
<div class="tabs">
  <ul>
    <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="namespaces.html"><span>Namespaces</span></a></li>
    <li id="current"><a href="annotated.html"><span>Classes</span></a></li>
    <li><a href="files.html"><span>Files</span></a></li>
    <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
  </ul></div>
<div class="tabs">
  <ul>
    <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
    <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
    <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
  </ul></div>
<div class="nav">
<a class="el" href="namespaceSAMRAI.html">SAMRAI</a>::<a class="el" href="namespaceSAMRAI_1_1hier.html">hier</a>::<a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a></div>
<h1>SAMRAI::hier::BoxContainer Class Reference</h1><!-- doxytag: class="SAMRAI::hier::BoxContainer" -->A container for Boxes.  
<a href="#_details">More...</a>
<p>
<code>#include &lt;source/SAMRAI/hier/BoxContainer.h&gt;</code>
<p>
<a href="classSAMRAI_1_1hier_1_1BoxContainer-members.html">List of all members.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Types</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer_1_1BoxContainerIterator.html">BoxContainerIterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html#ff3fe3b8197b28da1ce580dd10a80d04">iterator</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The iterator for class <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a>.  <a href="#ff3fe3b8197b28da1ce580dd10a80d04"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer_1_1BoxContainerConstIterator.html">BoxContainerConstIterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html#9029557738c2cf06d5e00b072a5606a2">const_iterator</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The const iterator for class <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a>.  <a href="#9029557738c2cf06d5e00b072a5606a2"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html#d795e5b89220de39c135f35a67cdd9f4">operator==</a> (const <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a> &amp;rhs) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Equality operator.  <a href="#d795e5b89220de39c135f35a67cdd9f4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html#3388a48a209f9b2d08f51bc64f1b33f5">operator!=</a> (const <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a> &amp;rhs) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Inequality operator.  <a href="#3388a48a209f9b2d08f51bc64f1b33f5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html#faa3a4f83b2f6714087926aea2d21664">makeTree</a> (const <a class="el" href="classSAMRAI_1_1hier_1_1BaseGridGeometry.html">BaseGridGeometry</a> *grid_geometry=0, const int min_number=10) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a search tree representation of the boxes in this container.  <a href="#faa3a4f83b2f6714087926aea2d21664"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html#6583a10f3562655a992cc0108222dd3e">hasTree</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Query if the search tree representation exists.  <a href="#6583a10f3562655a992cc0108222dd3e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html#8f29006cbc555f91394a5b641d99027a">hasBoxInBlock</a> (const <a class="el" href="classSAMRAI_1_1hier_1_1BlockId.html">BlockId</a> &amp;block_id) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Query if this <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a> contains any <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> with the given <a class="el" href="classSAMRAI_1_1hier_1_1BlockId.html">BlockId</a>.  <a href="#8f29006cbc555f91394a5b641d99027a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html#a6e83d2ee9cc30cc14da50cc398e89c2">findOverlapBoxes</a> (<a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a> &amp;overlap_boxes, const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> &amp;box) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Find all boxes that intersect with a given box.  <a href="#a6e83d2ee9cc30cc14da50cc398e89c2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html#d254ff6fa6afdaa32c7539dcef0749c4">findOverlapBoxes</a> (std::vector&lt; const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> * &gt; &amp;overlap_boxes, const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> &amp;box) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Find all boxes that intersect with a given box.  <a href="#d254ff6fa6afdaa32c7539dcef0749c4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html#046d85a16e8923c8e7493a128c27595e">findOverlapBoxes</a> (<a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a> &amp;overlap_boxes, const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> &amp;box, const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;refinement_ratio, bool include_singularity_block_neighbors=false) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Find all boxes that intersect with a given box.  <a href="#046d85a16e8923c8e7493a128c27595e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html#b161e5c0d9cb1ef48c0b06016f6ec78f">hasOverlap</a> (const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> &amp;box) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Determine if a given box intersects with the <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a>.  <a href="#b161e5c0d9cb1ef48c0b06016f6ec78f"></a><br></td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html#7b71e640373c9fdc6c7a5caca13a1077">BoxContainer</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Default constructor creates empty container in unordered state.  <a href="#7b71e640373c9fdc6c7a5caca13a1077"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html#3c485123fcf0afa0f3fda4b0769cafa0">BoxContainer</a> (const bool ordered)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates empty container in state determined by boolean.  <a href="#3c485123fcf0afa0f3fda4b0769cafa0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html#41fe31cad64a3b15ed599a910d2f8273">BoxContainer</a> (<a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer_1_1BoxContainerConstIterator.html">const_iterator</a> first, <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer_1_1BoxContainerConstIterator.html">const_iterator</a> last, const bool ordered=false)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create container containing members from another container.  <a href="#41fe31cad64a3b15ed599a910d2f8273"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html#d63ddcd7165e1b411faafc10452056ac">BoxContainer</a> (const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> &amp;box, const bool ordered=false)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a container with 1 box.  <a href="#d63ddcd7165e1b411faafc10452056ac"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html#dcb9a691b0d39407ddc04c21014d1892">BoxContainer</a> (const <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a> &amp;other)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copy constructor from another <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a>.  <a href="#dcb9a691b0d39407ddc04c21014d1892"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html#29fc338ed644a6253c87a55215a7d953">BoxContainer</a> (const <a class="el" href="classSAMRAI_1_1tbox_1_1Array.html">tbox::Array</a>&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1DatabaseBox.html">tbox::DatabaseBox</a> &gt; &amp;other)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copy constructor from an array of <a class="el" href="classSAMRAI_1_1tbox_1_1DatabaseBox.html">tbox::DatabaseBox</a> objects.  <a href="#29fc338ed644a6253c87a55215a7d953"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html#fe2288d97c15f402d9b0f2d999de9c47">BoxContainer</a> (const <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a> &amp;other, const <a class="el" href="classSAMRAI_1_1hier_1_1BlockId.html">BlockId</a> &amp;block_id)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Constructor that copies only Boxes having the given <a class="el" href="classSAMRAI_1_1hier_1_1BlockId.html">BlockId</a> from the other container.  <a href="#fe2288d97c15f402d9b0f2d999de9c47"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html#ff2f982d2652d67aeb3ff8100dfdc163">operator=</a> (const <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a> &amp;rhs)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Assignment from other <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a>.  <a href="#ff2f982d2652d67aeb3ff8100dfdc163"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html#92c16d34623368d0a35579e1decedd7e">operator=</a> (const <a class="el" href="classSAMRAI_1_1tbox_1_1Array.html">tbox::Array</a>&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1DatabaseBox.html">tbox::DatabaseBox</a> &gt; &amp;rhs)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Assignment from an array of <a class="el" href="classSAMRAI_1_1tbox_1_1DatabaseBox.html">tbox::DatabaseBox</a> objects.  <a href="#92c16d34623368d0a35579e1decedd7e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html#4e7ae9ea3a7700f61efc722c56d9ed40">~BoxContainer</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The destructor releases all storage.  <a href="#4e7ae9ea3a7700f61efc722c56d9ed40"></a><br></td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html#2471b46bb9a12ca391187ac781240ba3">size</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the number of boxes in the container.  <a href="#2471b46bb9a12ca391187ac781240ba3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html#7371af1cb3790c297440cec6dda6a72e">isEmpty</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns true if there are no boxes in the container.  <a href="#7371af1cb3790c297440cec6dda6a72e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer_1_1BoxContainerConstIterator.html">const_iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html#7d67bdccb18882a276659b5c2851edc0">begin</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return a const_iterator pointing to the start of the container.  <a href="#7d67bdccb18882a276659b5c2851edc0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer_1_1BoxContainerConstIterator.html">const_iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html#192b7c4c41e41cdb9466afb9005136e5">end</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return a const_iterator pointing to the end of the container.  <a href="#192b7c4c41e41cdb9466afb9005136e5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer_1_1BoxContainerIterator.html">iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html#9177f688d517d8106664d509c6851f86">begin</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return an iterator pointing to the start of the container.  <a href="#9177f688d517d8106664d509c6851f86"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer_1_1BoxContainerIterator.html">iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html#9c566195352afe03c2c1b2ef8d19e55c">end</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return an iterator pointing to the end of the container.  <a href="#9c566195352afe03c2c1b2ef8d19e55c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainerSingleBlockIterator.html">BoxContainerSingleBlockIterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html#109bd0cce2a5b8f69e5ea1f971294ca2">begin</a> (const <a class="el" href="classSAMRAI_1_1hier_1_1BlockId.html">BlockId</a> &amp;block_id) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return a <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainerSingleBlockIterator.html">BoxContainerSingleBlockIterator</a> pointing to the first box in the container with the given <a class="el" href="classSAMRAI_1_1hier_1_1BlockId.html">BlockId</a>.  <a href="#109bd0cce2a5b8f69e5ea1f971294ca2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainerSingleBlockIterator.html">BoxContainerSingleBlockIterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html#830399bd31f98ef38c7df25180486f9f">end</a> (const <a class="el" href="classSAMRAI_1_1hier_1_1BlockId.html">BlockId</a> &amp;block_id) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return a <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainerSingleBlockIterator.html">BoxContainerSingleBlockIterator</a> pointing to the end of the container.  <a href="#830399bd31f98ef38c7df25180486f9f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainerSingleOwnerIterator.html">BoxContainerSingleOwnerIterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html#f0a3a4e59efb7b20fdc43ea27a375582">begin</a> (const int &amp;owner_rank) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return a <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainerSingleOwnerIterator.html">BoxContainerSingleOwnerIterator</a> pointing to the first box in the container having the given owner.  <a href="#f0a3a4e59efb7b20fdc43ea27a375582"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainerSingleOwnerIterator.html">BoxContainerSingleOwnerIterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html#6de540684a35466938f821a940d459e9">end</a> (const int &amp;owner_rank) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return a <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainerSingleOwnerIterator.html">BoxContainerSingleOwnerIterator</a> pointing to the end of the container.  <a href="#6de540684a35466938f821a940d459e9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classSAMRAI_1_1hier_1_1RealBoxConstIterator.html">RealBoxConstIterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html#42c5c13e9f4ddb913215f12a030c761e">realBegin</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return a <a class="el" href="classSAMRAI_1_1hier_1_1RealBoxConstIterator.html">RealBoxConstIterator</a> pointing to the first real (non-periodic) box in the container.  <a href="#42c5c13e9f4ddb913215f12a030c761e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classSAMRAI_1_1hier_1_1RealBoxConstIterator.html">RealBoxConstIterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html#7dae366456c18c63846ffd42a0fbc542">realEnd</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return a <a class="el" href="classSAMRAI_1_1hier_1_1RealBoxConstIterator.html">RealBoxConstIterator</a> pointing to the end of the container.  <a href="#7dae366456c18c63846ffd42a0fbc542"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html#acb30f477c077d265d20b477e5adc0f3">front</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the first element in the container.  <a href="#acb30f477c077d265d20b477e5adc0f3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html#1a00d37886fa41bd01c6741568ab5bb6">back</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the first element in the container.  <a href="#1a00d37886fa41bd01c6741568ab5bb6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html#c4efcb7ab3ef052fa78b468ecb26cf44">erase</a> (<a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer_1_1BoxContainerIterator.html">iterator</a> iter)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Remove the member of the container pointed to by "iter".  <a href="#c4efcb7ab3ef052fa78b468ecb26cf44"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html#0c1648bbd364c5d25c1c4b1a99de0f1c">erase</a> (<a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer_1_1BoxContainerIterator.html">iterator</a> first, <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer_1_1BoxContainerIterator.html">iterator</a> last)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Remove the members of the container in the range [first, last).  <a href="#0c1648bbd364c5d25c1c4b1a99de0f1c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html#36eeafbcb7e07afea2806d64a2f0d4c3">clear</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Removes all the members of the container.  <a href="#36eeafbcb7e07afea2806d64a2f0d4c3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html#9aa7f1ff4dacf6c075e4eadb7363ea3c">swap</a> (<a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a> &amp;other)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Swap all contents and state with another <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a>.  <a href="#9aa7f1ff4dacf6c075e4eadb7363ea3c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html#8f32186ba3fc0bb9df9f73ed746ebc92">getOwners</a> (std::set&lt; int &gt; &amp;owners) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get all of the ranks that own Boxes in this container.  <a href="#8f32186ba3fc0bb9df9f73ed746ebc92"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html#4e0ebf36f1800ef69be70eddfeb9e638">grow</a> (const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;ghosts)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Grow boxes in the container by the specified ghost cell width.  <a href="#4e0ebf36f1800ef69be70eddfeb9e638"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html#28ac3b63bd66820c89449634de6e69c1">shift</a> (const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;offset)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Shift boxes in the container by the specified offset.  <a href="#28ac3b63bd66820c89449634de6e69c1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html#ef570e52b1dedc50e0e2f607f02ef113">refine</a> (const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;ratio)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Refine boxes in container by the specified refinement ratio.  <a href="#ef570e52b1dedc50e0e2f607f02ef113"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html#9906f066cab6279e709490b50245313e">coarsen</a> (const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;ratio)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Coarsen boxes in container by the specified coarsening ratio.  <a href="#9906f066cab6279e709490b50245313e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html#550d0e8debdb1f2fbf998210fbe5ce8d">getTotalSizeOfBoxes</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Count total number of indices in the boxes in the container.  <a href="#550d0e8debdb1f2fbf998210fbe5ce8d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html#b302f3413aca7d08ae39eb765e0f91d2">contains</a> (const <a class="el" href="classSAMRAI_1_1hier_1_1Index.html">Index</a> &amp;idx, const <a class="el" href="classSAMRAI_1_1hier_1_1BlockId.html">BlockId</a> &amp;block_id) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Determine if "idx" lies within bounds of boxes in container.  <a href="#b302f3413aca7d08ae39eb765e0f91d2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html#6440b7e06427fd365eb05604e7dc99f6">getBoundingBox</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the bounding box for all the boxes in the container.  <a href="#6440b7e06427fd365eb05604e7dc99f6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html#300c7b4246e444e698f719d8df4b61c6">getBoundingBox</a> (const <a class="el" href="classSAMRAI_1_1hier_1_1BlockId.html">BlockId</a> &amp;block_id) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the bounding box for all the boxes in the container having the given <a class="el" href="classSAMRAI_1_1hier_1_1BlockId.html">BlockId</a>.  <a href="#300c7b4246e444e698f719d8df4b61c6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html#14358caff71c9fb7dd8d8b3e3e193ea1">boxesIntersect</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Check for non-empty intersection among boxes in container.  <a href="#14358caff71c9fb7dd8d8b3e3e193ea1"></a><br></td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html#8a554081bd049c99de1e0d6ad53d1cba">order</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Changes state of this container to ordered.  <a href="#8a554081bd049c99de1e0d6ad53d1cba"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html#d3fc42e7710adae0c5d1d5a1c0a1698d">unorder</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Changes state of this container to unordered.  <a href="#d3fc42e7710adae0c5d1d5a1c0a1698d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html#b60e3636df51eb5997471a5520c7884b">isOrdered</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return whether this container is ordered.  <a href="#b60e3636df51eb5997471a5520c7884b"></a><br></td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html#9dac68baead6e75db214c8b120f0730e">pushFront</a> (const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> &amp;item)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adds "item" to the "front" of the container.  <a href="#9dac68baead6e75db214c8b120f0730e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html#236e2463d9ec5964135861de73f16324">pushBack</a> (const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> &amp;item)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adds "item" to the "end" of the container.  <a href="#236e2463d9ec5964135861de73f16324"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html#3f9ea6e1242029ed5b0bec7ebfc55ecb">insertBefore</a> (<a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer_1_1BoxContainerIterator.html">iterator</a> iter, const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> &amp;item)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Add "item" to specific place in the container.  <a href="#3f9ea6e1242029ed5b0bec7ebfc55ecb"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html#3229998b188dfe40a9bddb47d737da4f">insertAfter</a> (<a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer_1_1BoxContainerIterator.html">iterator</a> iter, const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> &amp;item)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Add "item" to specific place in the container.  <a href="#3229998b188dfe40a9bddb47d737da4f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html#ba38984af87d838459be4b85d0638bb9">spliceFront</a> (<a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a> &amp;boxes)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Prepends the Boxes in "boxes" to this <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a>.  <a href="#ba38984af87d838459be4b85d0638bb9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html#d0766ee251b631b81cd2333e71dd33f2">spliceBack</a> (<a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a> &amp;boxes)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Appends the Boxes in "boxes" to this <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a>.  <a href="#d0766ee251b631b81cd2333e71dd33f2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html#a26e34c146a2e4d3db594350d030682c">popFront</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Remove the first member of the unordered container.  <a href="#a26e34c146a2e4d3db594350d030682c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html#09990007ee046ca5b308cdeea9bf9302">popBack</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Remove the last member of the unordered container.  <a href="#09990007ee046ca5b308cdeea9bf9302"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html#cf2587b68a7d1a7d2a2134d9f87c0fca">simplify</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Place the boxes in the container into a canonical ordering.  <a href="#cf2587b68a7d1a7d2a2134d9f87c0fca"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html#4f65643b3d30a7bc24dbac9a22abb5c7">coalesce</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Combine any boxes in the container which may be coalesced.  <a href="#4f65643b3d30a7bc24dbac9a22abb5c7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html#610b4fa87a46fb7225d10a76014d4c86">rotate</a> (const <a class="el" href="classSAMRAI_1_1hier_1_1Transformation.html#2dd7d97a19db7c8e97402e8518c0af8d">Transformation::RotationIdentifier</a> rotation_ident)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Rotate boxes in container according to a RotationIdentifier.  <a href="#610b4fa87a46fb7225d10a76014d4c86"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html#b7efb9cecef0461f129c18f41fa06402">removeIntersections</a> (const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> &amp;takeaway)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Remove from each box the portions that intersect takeaway.  <a href="#b7efb9cecef0461f129c18f41fa06402"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html#140cd0612e724e550fecb567f38c760b">removeIntersections</a> (const <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a> &amp;takeaway)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Remove from each box portions intersecting boxes in takeaway.  <a href="#140cd0612e724e550fecb567f38c760b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html#9eae3c6a62fc8e46c2cb3430b72966ec">removeIntersections</a> (const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;refinement_ratio, const <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a> &amp;takeaway, const bool include_singularity_block_neighbors=false)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Remove from each box portions intersecting boxes in takeaway.  <a href="#9eae3c6a62fc8e46c2cb3430b72966ec"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html#d98c16c6d4f4d7a3d748dcc08fd3a010">removeIntersections</a> (const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> &amp;box, const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> &amp;takeaway)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Remove from box the portions intersecting takeaway.  <a href="#d98c16c6d4f4d7a3d748dcc08fd3a010"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html#afc53135623a761a92fc7053dd482810">intersectBoxes</a> (const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> &amp;keep)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Keep the intersection of the container's boxes and keep.  <a href="#afc53135623a761a92fc7053dd482810"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html#2f7078f8f3e4024318d535717ed2cb34">intersectBoxes</a> (const <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a> &amp;keep)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Keep the intersection of the container's boxes and keep's boxes.  <a href="#2f7078f8f3e4024318d535717ed2cb34"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html#6332ff5ba2add3c55657b80d254a116e">intersectBoxes</a> (const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;refinement_ratio, const <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a> &amp;keep, bool include_singularity_block_neighbors=false)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Keep the intersection of the container's boxes and keep's boxes.  <a href="#6332ff5ba2add3c55657b80d254a116e"></a><br></td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html#2c2d862cadd5ab8e61c1104b98d90fbe">insert</a> (const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> &amp;box)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Insert a single <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a>.  <a href="#2c2d862cadd5ab8e61c1104b98d90fbe"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer_1_1BoxContainerIterator.html">iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html#235e4cc65c93a2acc692838a0215e44f">insert</a> (<a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer_1_1BoxContainerIterator.html">iterator</a> position, const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> &amp;box)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Insert a single <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a>.  <a href="#235e4cc65c93a2acc692838a0215e44f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html#e043c3cad663f7ff9ec97ee02b9a2bd3">insert</a> (<a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer_1_1BoxContainerConstIterator.html">const_iterator</a> first, <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer_1_1BoxContainerConstIterator.html">const_iterator</a> last)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Insert all Boxes within a range.  <a href="#e043c3cad663f7ff9ec97ee02b9a2bd3"></a><br></td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer_1_1BoxContainerIterator.html">iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html#4460be7ce26be1bc5ce2ffc09b0efc9d">find</a> (const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> &amp;box) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Find a box in an ordered container.  <a href="#4460be7ce26be1bc5ce2ffc09b0efc9d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer_1_1BoxContainerIterator.html">iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html#7e31c87c644fd9666c1bf1517f49d935">lowerBound</a> (const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> &amp;box) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get lower bound iterator for a given <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a>.  <a href="#7e31c87c644fd9666c1bf1517f49d935"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer_1_1BoxContainerIterator.html">iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html#0b375d7cb0766e9db20fa442c3d67cb3">upperBound</a> (const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> &amp;box) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get upper bound iterator for a given <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a>.  <a href="#0b375d7cb0766e9db20fa442c3d67cb3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html#72fdf350374069c52b2a36c715e9fc88">erase</a> (const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> &amp;box)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Erase a <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> from the container.  <a href="#72fdf350374069c52b2a36c715e9fc88"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html#0e67b13f4abe3c0de489e094bf27b5c3">separatePeriodicImages</a> (std::vector&lt; <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> &gt; &amp;real_box_vector, std::vector&lt; <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> &gt; &amp;periodic_image_box_vector) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copy the members of this <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a> into two vector&lt;Box&gt; objects, one containing real Boxes and one containing their periodic images.  <a href="#0e67b13f4abe3c0de489e094bf27b5c3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html#e6c69e1e6065a9b4e0b88384cd7cf49f">removePeriodicImageBoxes</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Any members of this container that are periodic images will be erased.  <a href="#e6c69e1e6065a9b4e0b88384cd7cf49f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html#5cd6f3f9e98de5b1b6171438e6d5db74">unshiftPeriodicImageBoxes</a> (<a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a> &amp;output_boxes, const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;refinement_ratio) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Place unshifted versions of Boxes into a <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a>.  <a href="#5cd6f3f9e98de5b1b6171438e6d5db74"></a><br></td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html#a24aaf0ff0de7a5a86e80ac1b2cfc96f">putToRestart</a> (const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Database.html">tbox::Database</a> &gt; &amp;restart_db) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Write the <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a> to a restart database.  <a href="#a24aaf0ff0de7a5a86e80ac1b2cfc96f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html#a0928d91ef08c3bc5ff619be13351577">getFromRestart</a> (<a class="el" href="classSAMRAI_1_1tbox_1_1Database.html">tbox::Database</a> &amp;restart_db)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Read the <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a> from a restart database.  <a href="#a0928d91ef08c3bc5ff619be13351577"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html#e7dc204d3baaf9b32488d4c25aac8d8d">operator tbox::Array</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Conversion from <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a> to tbox::Array&lt;tbox::DatabaseBox&gt;.  <a href="#e7dc204d3baaf9b32488d4c25aac8d8d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html#0e018adef09a9d3631b2105015689da3">print</a> (std::ostream &amp;os=<a class="el" href="namespaceSAMRAI_1_1tbox.html#b84041705493761fb17a8127e3a2dca2">tbox::plog</a>) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Print each box in the container to the specified output stream.  <a href="#0e018adef09a9d3631b2105015689da3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer_1_1Outputter.html">Outputter</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html#19f443ba4410bb46337cd71578f2f740">format</a> (const std::string &amp;border=std::string(), int detail_depth=0) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return a object to that can format the <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a> for inserting into output streams.  <a href="#19f443ba4410bb46337cd71578f2f740"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Friends</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html#cf9e3e89ec00844bde233c296adf4db5">BoxContainerIterator</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html#b605c1f6e8e543714f20820b93d2d556">BoxContainerConstIterator</a></td></tr>

<tr><td colspan="2"><br><h2>Classes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer_1_1BoxContainerConstIterator.html">BoxContainerConstIterator</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A immutable iterator over the boxes in a <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a>.  <a href="classSAMRAI_1_1hier_1_1BoxContainer_1_1BoxContainerConstIterator.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer_1_1BoxContainerIterator.html">BoxContainerIterator</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A mutable iterator over the boxes in a <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a>.  <a href="classSAMRAI_1_1hier_1_1BoxContainer_1_1BoxContainerIterator.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer_1_1Outputter.html">Outputter</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Intermediary between <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a> and output streams, adding ability to control the output. See <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html#19f443ba4410bb46337cd71578f2f740">BoxContainer::format()</a>.  <a href="classSAMRAI_1_1hier_1_1BoxContainer_1_1Outputter.html#_details">More...</a><br></td></tr>
</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
A container for Boxes. 
<p>
The <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a> stores a collection of Boxes and provides methods for access and manipulation of that collection.<p>
A <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a> exists in either an "ordered" or "unordered" state. The ordered state means that the Boxes have been ordered according to the comparison operators defined in the <a class="el" href="classSAMRAI_1_1hier_1_1BoxId.html">BoxId</a> class, while the unordered state has no meaningful ordering of the Boxes besides the sequence that the Boxes were added to the container. Additionally the ordered state requires that all Boxes in the container have a valid and unique <a class="el" href="classSAMRAI_1_1hier_1_1BoxId.html">BoxId</a>, while there is no such restriction for unordered containers.<p>
An ordered container can always have its state switched to unordered by a call to the <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html#d3fc42e7710adae0c5d1d5a1c0a1698d">unorder()</a> method. An unordered container can also have its state switched to ordered by a call to the <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html#8a554081bd049c99de1e0d6ad53d1cba">order()</a> method, but only under certain conditions specified below in the comments for <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html#8a554081bd049c99de1e0d6ad53d1cba">order()</a>.<p>
Certain methods in this class can only be called on ordered containers while others can only be called on unordered containers. Violating these restrictions will result in a run-time error.<p>
Regardless of unordered/unordered state, all Boxes within a <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a> must be of the same Dimension. If a new <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> added to a container has a different Dimension than the Boxes already in the container, an assertion failure will occur.<p>
An option exists to create an internal search tree representation based on the spatial coordinates of the Boxes in the container. This option can be used to reduce the cost of searching operations in the methods <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html#b7efb9cecef0461f129c18f41fa06402">removeIntersections()</a>, <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html#afc53135623a761a92fc7053dd482810">intersectBoxes()</a>, <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html#a6e83d2ee9cc30cc14da50cc398e89c2">findOverlapBoxes()</a> and <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html#b161e5c0d9cb1ef48c0b06016f6ec78f">hasOverlap()</a>. This option is invoked by calling the method <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html#faa3a4f83b2f6714087926aea2d21664">makeTree()</a>. This option should only be used in cases where the listed search methods will be called multiple times on the same unchanging <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a>. The cost of building the tree representaion is O(N(log(N)), while the tree reduces the cost of the search operations to O(log(N)) rather than O(N), thus it is adviseable to only use the tree representation when the reduction in search cost is expected to outweigh the increased cost of building the tree.<p>
Constructing the tree represenation via <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html#faa3a4f83b2f6714087926aea2d21664">makeTree()</a> will change nothing about the Boxes stored in the container, nor will it change the ordered/unordered state of the container.<p>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classSAMRAI_1_1hier_1_1BoxId.html">BoxId</a> </dd></dl>

<p>
<hr><h2>Member Typedef Documentation</h2>
<a class="anchor" name="ff3fe3b8197b28da1ce580dd10a80d04"></a><!-- doxytag: member="SAMRAI::hier::BoxContainer::iterator" ref="ff3fe3b8197b28da1ce580dd10a80d04" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer_1_1BoxContainerIterator.html">BoxContainerIterator</a> <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer_1_1BoxContainerIterator.html">SAMRAI::hier::BoxContainer::iterator</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The iterator for class <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a>. 
<p>

</div>
</div><p>
<a class="anchor" name="9029557738c2cf06d5e00b072a5606a2"></a><!-- doxytag: member="SAMRAI::hier::BoxContainer::const_iterator" ref="9029557738c2cf06d5e00b072a5606a2" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer_1_1BoxContainerConstIterator.html">BoxContainerConstIterator</a> <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer_1_1BoxContainerConstIterator.html">SAMRAI::hier::BoxContainer::const_iterator</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The const iterator for class <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a>. 
<p>

</div>
</div><p>
<hr><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" name="7b71e640373c9fdc6c7a5caca13a1077"></a><!-- doxytag: member="SAMRAI::hier::BoxContainer::BoxContainer" ref="7b71e640373c9fdc6c7a5caca13a1077" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SAMRAI::hier::BoxContainer::BoxContainer           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Default constructor creates empty container in unordered state. 
<p>

</div>
</div><p>
<a class="anchor" name="3c485123fcf0afa0f3fda4b0769cafa0"></a><!-- doxytag: member="SAMRAI::hier::BoxContainer::BoxContainer" ref="3c485123fcf0afa0f3fda4b0769cafa0" args="(const bool ordered)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SAMRAI::hier::BoxContainer::BoxContainer           </td>
          <td>(</td>
          <td class="paramtype">const bool&nbsp;</td>
          <td class="paramname"> <em>ordered</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates empty container in state determined by boolean. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>ordered</em>&nbsp;</td><td>Container will be ordered if true, unordered if false. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="41fe31cad64a3b15ed599a910d2f8273"></a><!-- doxytag: member="SAMRAI::hier::BoxContainer::BoxContainer" ref="41fe31cad64a3b15ed599a910d2f8273" args="(const_iterator first, const_iterator last, const bool ordered=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SAMRAI::hier::BoxContainer::BoxContainer           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer_1_1BoxContainerConstIterator.html">const_iterator</a>&nbsp;</td>
          <td class="paramname"> <em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer_1_1BoxContainerConstIterator.html">const_iterator</a>&nbsp;</td>
          <td class="paramname"> <em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&nbsp;</td>
          <td class="paramname"> <em>ordered</em> = <code>false</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Create container containing members from another container. 
<p>
Members in the range [first, last) are copied to new container.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>first</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>last</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>ordered</em>&nbsp;</td><td>Container will be ordered if true, unordered if false. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="d63ddcd7165e1b411faafc10452056ac"></a><!-- doxytag: member="SAMRAI::hier::BoxContainer::BoxContainer" ref="d63ddcd7165e1b411faafc10452056ac" args="(const Box &amp;box, const bool ordered=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SAMRAI::hier::BoxContainer::BoxContainer           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>box</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&nbsp;</td>
          <td class="paramname"> <em>ordered</em> = <code>false</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Create a container with 1 box. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>box</em>&nbsp;</td><td><a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> to copy into new container. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>ordered</em>&nbsp;</td><td>Container will be ordered if true, unordered if false. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="dcb9a691b0d39407ddc04c21014d1892"></a><!-- doxytag: member="SAMRAI::hier::BoxContainer::BoxContainer" ref="dcb9a691b0d39407ddc04c21014d1892" args="(const BoxContainer &amp;other)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SAMRAI::hier::BoxContainer::BoxContainer           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>other</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Copy constructor from another <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a>. 
<p>
All boxes and the ordered/unordered state will be copied to the new <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a>.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>other</em>&nbsp;</td><td></td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="29fc338ed644a6253c87a55215a7d953"></a><!-- doxytag: member="SAMRAI::hier::BoxContainer::BoxContainer" ref="29fc338ed644a6253c87a55215a7d953" args="(const tbox::Array&lt; tbox::DatabaseBox &gt; &amp;other)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SAMRAI::hier::BoxContainer::BoxContainer           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1tbox_1_1Array.html">tbox::Array</a>&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1DatabaseBox.html">tbox::DatabaseBox</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>other</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Copy constructor from an array of <a class="el" href="classSAMRAI_1_1tbox_1_1DatabaseBox.html">tbox::DatabaseBox</a> objects. 
<p>
The new <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a> will be unordered.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>other</em>&nbsp;</td><td></td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="fe2288d97c15f402d9b0f2d999de9c47"></a><!-- doxytag: member="SAMRAI::hier::BoxContainer::BoxContainer" ref="fe2288d97c15f402d9b0f2d999de9c47" args="(const BoxContainer &amp;other, const BlockId &amp;block_id)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SAMRAI::hier::BoxContainer::BoxContainer           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1BlockId.html">BlockId</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>block_id</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Constructor that copies only Boxes having the given <a class="el" href="classSAMRAI_1_1hier_1_1BlockId.html">BlockId</a> from the other container. 
<p>
The unordered or ordered state will be the same as that of the argument container.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>other</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>block_id</em>&nbsp;</td><td></td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="4e7ae9ea3a7700f61efc722c56d9ed40"></a><!-- doxytag: member="SAMRAI::hier::BoxContainer::~BoxContainer" ref="4e7ae9ea3a7700f61efc722c56d9ed40" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SAMRAI::hier::BoxContainer::~BoxContainer           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The destructor releases all storage. 
<p>

</div>
</div><p>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="ff2f982d2652d67aeb3ff8100dfdc163"></a><!-- doxytag: member="SAMRAI::hier::BoxContainer::operator=" ref="ff2f982d2652d67aeb3ff8100dfdc163" args="(const BoxContainer &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a> &amp; SAMRAI::hier::BoxContainer::operator=           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Assignment from other <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a>. 
<p>
All boxes and the ordered/unordered state will be copied to the assigned <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a>. Any previous state of the assigned <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a> is discarded.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>rhs</em>&nbsp;</td><td></td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="92c16d34623368d0a35579e1decedd7e"></a><!-- doxytag: member="SAMRAI::hier::BoxContainer::operator=" ref="92c16d34623368d0a35579e1decedd7e" args="(const tbox::Array&lt; tbox::DatabaseBox &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a> &amp; SAMRAI::hier::BoxContainer::operator=           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1tbox_1_1Array.html">tbox::Array</a>&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1DatabaseBox.html">tbox::DatabaseBox</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Assignment from an array of <a class="el" href="classSAMRAI_1_1tbox_1_1DatabaseBox.html">tbox::DatabaseBox</a> objects. 
<p>
The assigned <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a> will be unordered. Any previous state of the assigned <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a> is discarded.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>rhs</em>&nbsp;</td><td></td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="2471b46bb9a12ca391187ac781240ba3"></a><!-- doxytag: member="SAMRAI::hier::BoxContainer::size" ref="2471b46bb9a12ca391187ac781240ba3" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int SAMRAI::hier::BoxContainer::size           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return the number of boxes in the container. 
<p>
<dl compact><dt><b>Returns:</b></dt><dd>The number of boxes in the container. </dd></dl>

</div>
</div><p>
<a class="anchor" name="7371af1cb3790c297440cec6dda6a72e"></a><!-- doxytag: member="SAMRAI::hier::BoxContainer::isEmpty" ref="7371af1cb3790c297440cec6dda6a72e" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SAMRAI::hier::BoxContainer::isEmpty           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns true if there are no boxes in the container. 
<p>
<dl compact><dt><b>Returns:</b></dt><dd>True if the container is empty. </dd></dl>

</div>
</div><p>
<a class="anchor" name="7d67bdccb18882a276659b5c2851edc0"></a><!-- doxytag: member="SAMRAI::hier::BoxContainer::begin" ref="7d67bdccb18882a276659b5c2851edc0" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer_1_1BoxContainerConstIterator.html">const_iterator</a> SAMRAI::hier::BoxContainer::begin           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return a const_iterator pointing to the start of the container. 
<p>
<dl compact><dt><b>Returns:</b></dt><dd>An immutable iterator pointing to the first box. </dd></dl>

</div>
</div><p>
<a class="anchor" name="192b7c4c41e41cdb9466afb9005136e5"></a><!-- doxytag: member="SAMRAI::hier::BoxContainer::end" ref="192b7c4c41e41cdb9466afb9005136e5" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer_1_1BoxContainerConstIterator.html">const_iterator</a> SAMRAI::hier::BoxContainer::end           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return a const_iterator pointing to the end of the container. 
<p>
<dl compact><dt><b>Returns:</b></dt><dd>An immutable iterator pointing beyond the last box. </dd></dl>

</div>
</div><p>
<a class="anchor" name="9177f688d517d8106664d509c6851f86"></a><!-- doxytag: member="SAMRAI::hier::BoxContainer::begin" ref="9177f688d517d8106664d509c6851f86" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer_1_1BoxContainerIterator.html">iterator</a> SAMRAI::hier::BoxContainer::begin           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return an iterator pointing to the start of the container. 
<p>
<dl compact><dt><b>Returns:</b></dt><dd>A mutable iterator pointing to the first box. </dd></dl>

</div>
</div><p>
<a class="anchor" name="9c566195352afe03c2c1b2ef8d19e55c"></a><!-- doxytag: member="SAMRAI::hier::BoxContainer::end" ref="9c566195352afe03c2c1b2ef8d19e55c" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer_1_1BoxContainerIterator.html">iterator</a> SAMRAI::hier::BoxContainer::end           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return an iterator pointing to the end of the container. 
<p>
<dl compact><dt><b>Returns:</b></dt><dd>A mutable iterator pointing beyond the last box. </dd></dl>

</div>
</div><p>
<a class="anchor" name="109bd0cce2a5b8f69e5ea1f971294ca2"></a><!-- doxytag: member="SAMRAI::hier::BoxContainer::begin" ref="109bd0cce2a5b8f69e5ea1f971294ca2" args="(const BlockId &amp;block_id) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainerSingleBlockIterator.html">BoxContainerSingleBlockIterator</a> SAMRAI::hier::BoxContainer::begin           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1BlockId.html">BlockId</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>block_id</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return a <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainerSingleBlockIterator.html">BoxContainerSingleBlockIterator</a> pointing to the first box in the container with the given <a class="el" href="classSAMRAI_1_1hier_1_1BlockId.html">BlockId</a>. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>block_id</em>&nbsp;</td><td>The <a class="el" href="classSAMRAI_1_1hier_1_1BlockId.html">BlockId</a> of the boxes we want.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>A mutable iterator pointing to the first box with the given <a class="el" href="classSAMRAI_1_1hier_1_1BlockId.html">BlockId</a>. </dd></dl>

</div>
</div><p>
<a class="anchor" name="830399bd31f98ef38c7df25180486f9f"></a><!-- doxytag: member="SAMRAI::hier::BoxContainer::end" ref="830399bd31f98ef38c7df25180486f9f" args="(const BlockId &amp;block_id) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainerSingleBlockIterator.html">BoxContainerSingleBlockIterator</a> SAMRAI::hier::BoxContainer::end           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1BlockId.html">BlockId</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>block_id</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return a <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainerSingleBlockIterator.html">BoxContainerSingleBlockIterator</a> pointing to the end of the container. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>block_id</em>&nbsp;</td><td>The <a class="el" href="classSAMRAI_1_1hier_1_1BlockId.html">BlockId</a> of the boxes we want.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>A mutable iterator pointing beyond the last box. </dd></dl>

</div>
</div><p>
<a class="anchor" name="f0a3a4e59efb7b20fdc43ea27a375582"></a><!-- doxytag: member="SAMRAI::hier::BoxContainer::begin" ref="f0a3a4e59efb7b20fdc43ea27a375582" args="(const int &amp;owner_rank) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainerSingleOwnerIterator.html">BoxContainerSingleOwnerIterator</a> SAMRAI::hier::BoxContainer::begin           </td>
          <td>(</td>
          <td class="paramtype">const int &amp;&nbsp;</td>
          <td class="paramname"> <em>owner_rank</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return a <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainerSingleOwnerIterator.html">BoxContainerSingleOwnerIterator</a> pointing to the first box in the container having the given owner. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>owner_rank</em>&nbsp;</td><td>The processaor whose boxes we want.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>A mutable iterator pointing to the first box having the given owner. </dd></dl>

</div>
</div><p>
<a class="anchor" name="6de540684a35466938f821a940d459e9"></a><!-- doxytag: member="SAMRAI::hier::BoxContainer::end" ref="6de540684a35466938f821a940d459e9" args="(const int &amp;owner_rank) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainerSingleOwnerIterator.html">BoxContainerSingleOwnerIterator</a> SAMRAI::hier::BoxContainer::end           </td>
          <td>(</td>
          <td class="paramtype">const int &amp;&nbsp;</td>
          <td class="paramname"> <em>owner_rank</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return a <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainerSingleOwnerIterator.html">BoxContainerSingleOwnerIterator</a> pointing to the end of the container. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>owner_rank</em>&nbsp;</td><td>The processaor whose boxes we want.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>A mutable iterator pointing beyond the last box. </dd></dl>

</div>
</div><p>
<a class="anchor" name="42c5c13e9f4ddb913215f12a030c761e"></a><!-- doxytag: member="SAMRAI::hier::BoxContainer::realBegin" ref="42c5c13e9f4ddb913215f12a030c761e" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSAMRAI_1_1hier_1_1RealBoxConstIterator.html">RealBoxConstIterator</a> SAMRAI::hier::BoxContainer::realBegin           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return a <a class="el" href="classSAMRAI_1_1hier_1_1RealBoxConstIterator.html">RealBoxConstIterator</a> pointing to the first real (non-periodic) box in the container. 
<p>
<dl compact><dt><b>Returns:</b></dt><dd>A mutable iterator pointing to the first non-periodic box. </dd></dl>

</div>
</div><p>
<a class="anchor" name="7dae366456c18c63846ffd42a0fbc542"></a><!-- doxytag: member="SAMRAI::hier::BoxContainer::realEnd" ref="7dae366456c18c63846ffd42a0fbc542" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSAMRAI_1_1hier_1_1RealBoxConstIterator.html">RealBoxConstIterator</a> SAMRAI::hier::BoxContainer::realEnd           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return a <a class="el" href="classSAMRAI_1_1hier_1_1RealBoxConstIterator.html">RealBoxConstIterator</a> pointing to the end of the container. 
<p>
<dl compact><dt><b>Returns:</b></dt><dd>A mutable iterator pointing beyond the last box. </dd></dl>

</div>
</div><p>
<a class="anchor" name="acb30f477c077d265d20b477e5adc0f3"></a><!-- doxytag: member="SAMRAI::hier::BoxContainer::front" ref="acb30f477c077d265d20b477e5adc0f3" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a>&amp; SAMRAI::hier::BoxContainer::front           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the first element in the container. 
<p>
<dl compact><dt><b>Returns:</b></dt><dd>A const reference to the first <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> in the container. </dd></dl>

</div>
</div><p>
<a class="anchor" name="1a00d37886fa41bd01c6741568ab5bb6"></a><!-- doxytag: member="SAMRAI::hier::BoxContainer::back" ref="1a00d37886fa41bd01c6741568ab5bb6" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a>&amp; SAMRAI::hier::BoxContainer::back           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the first element in the container. 
<p>
<dl compact><dt><b>Returns:</b></dt><dd>A const reference to the last <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> in the container. </dd></dl>

</div>
</div><p>
<a class="anchor" name="c4efcb7ab3ef052fa78b468ecb26cf44"></a><!-- doxytag: member="SAMRAI::hier::BoxContainer::erase" ref="c4efcb7ab3ef052fa78b468ecb26cf44" args="(iterator iter)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::hier::BoxContainer::erase           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer_1_1BoxContainerIterator.html">iterator</a>&nbsp;</td>
          <td class="paramname"> <em>iter</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Remove the member of the container pointed to by "iter". 
<p>
Can be called on ordered or unordered containers.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>iter</em>&nbsp;</td><td></td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="0c1648bbd364c5d25c1c4b1a99de0f1c"></a><!-- doxytag: member="SAMRAI::hier::BoxContainer::erase" ref="0c1648bbd364c5d25c1c4b1a99de0f1c" args="(iterator first, iterator last)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::hier::BoxContainer::erase           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer_1_1BoxContainerIterator.html">iterator</a>&nbsp;</td>
          <td class="paramname"> <em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer_1_1BoxContainerIterator.html">iterator</a>&nbsp;</td>
          <td class="paramname"> <em>last</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Remove the members of the container in the range [first, last). 
<p>
Can be called on ordered or unordered containers.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>first</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>last</em>&nbsp;</td><td></td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="36eeafbcb7e07afea2806d64a2f0d4c3"></a><!-- doxytag: member="SAMRAI::hier::BoxContainer::clear" ref="36eeafbcb7e07afea2806d64a2f0d4c3" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::hier::BoxContainer::clear           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Removes all the members of the container. 
<p>
Can be called on unordered or unordered containers. Sets the state to unordered. 
</div>
</div><p>
<a class="anchor" name="9aa7f1ff4dacf6c075e4eadb7363ea3c"></a><!-- doxytag: member="SAMRAI::hier::BoxContainer::swap" ref="9aa7f1ff4dacf6c075e4eadb7363ea3c" args="(BoxContainer &amp;other)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::hier::BoxContainer::swap           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>other</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Swap all contents and state with another <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a>. 
<p>
This container and other container exchange all member Boxes and ordered/unordered state.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>other</em>&nbsp;</td><td>Other container for swap. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="8f32186ba3fc0bb9df9f73ed746ebc92"></a><!-- doxytag: member="SAMRAI::hier::BoxContainer::getOwners" ref="8f32186ba3fc0bb9df9f73ed746ebc92" args="(std::set&lt; int &gt; &amp;owners) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::hier::BoxContainer::getOwners           </td>
          <td>(</td>
          <td class="paramtype">std::set&lt; int &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>owners</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get all of the ranks that own Boxes in this container. 
<p>
The rank of every member of this container is inserted into the set.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>owners</em>&nbsp;</td><td></td></tr>
  </table>
</dl>
<dl compact><dt><b>Precondition:</b></dt><dd><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html#b60e3636df51eb5997471a5520c7884b">isOrdered()</a> || for each box in container has valid <a class="el" href="classSAMRAI_1_1hier_1_1BoxId.html">BoxId</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="4e0ebf36f1800ef69be70eddfeb9e638"></a><!-- doxytag: member="SAMRAI::hier::BoxContainer::grow" ref="4e0ebf36f1800ef69be70eddfeb9e638" args="(const IntVector &amp;ghosts)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::hier::BoxContainer::grow           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>ghosts</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Grow boxes in the container by the specified ghost cell width. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>ghosts</em>&nbsp;</td><td></td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="28ac3b63bd66820c89449634de6e69c1"></a><!-- doxytag: member="SAMRAI::hier::BoxContainer::shift" ref="28ac3b63bd66820c89449634de6e69c1" args="(const IntVector &amp;offset)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::hier::BoxContainer::shift           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>offset</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Shift boxes in the container by the specified offset. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>offset</em>&nbsp;</td><td></td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="ef570e52b1dedc50e0e2f607f02ef113"></a><!-- doxytag: member="SAMRAI::hier::BoxContainer::refine" ref="ef570e52b1dedc50e0e2f607f02ef113" args="(const IntVector &amp;ratio)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::hier::BoxContainer::refine           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>ratio</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Refine boxes in container by the specified refinement ratio. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>ratio</em>&nbsp;</td><td></td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="9906f066cab6279e709490b50245313e"></a><!-- doxytag: member="SAMRAI::hier::BoxContainer::coarsen" ref="9906f066cab6279e709490b50245313e" args="(const IntVector &amp;ratio)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::hier::BoxContainer::coarsen           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>ratio</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Coarsen boxes in container by the specified coarsening ratio. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>ratio</em>&nbsp;</td><td></td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="550d0e8debdb1f2fbf998210fbe5ce8d"></a><!-- doxytag: member="SAMRAI::hier::BoxContainer::getTotalSizeOfBoxes" ref="550d0e8debdb1f2fbf998210fbe5ce8d" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int SAMRAI::hier::BoxContainer::getTotalSizeOfBoxes           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Count total number of indices in the boxes in the container. 
<p>
<dl compact><dt><b>Returns:</b></dt><dd>Total number of indices of all boxes in the container. </dd></dl>

</div>
</div><p>
<a class="anchor" name="b302f3413aca7d08ae39eb765e0f91d2"></a><!-- doxytag: member="SAMRAI::hier::BoxContainer::contains" ref="b302f3413aca7d08ae39eb765e0f91d2" args="(const Index &amp;idx, const BlockId &amp;block_id) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SAMRAI::hier::BoxContainer::contains           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1Index.html">Index</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1BlockId.html">BlockId</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>block_id</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Determine if "idx" lies within bounds of boxes in container. 
<p>
Only boxes of the given <a class="el" href="classSAMRAI_1_1hier_1_1BlockId.html">BlockId</a> will be checked.<p>
<dl compact><dt><b>Returns:</b></dt><dd>true if idx lies within bounds of boxes in container.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>idx</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>block_id</em>&nbsp;</td><td></td></tr>
  </table>
</dl>
<dl compact><dt><b>Precondition:</b></dt><dd>each box in container must have a valid <a class="el" href="classSAMRAI_1_1hier_1_1BlockId.html">BlockId</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="6440b7e06427fd365eb05604e7dc99f6"></a><!-- doxytag: member="SAMRAI::hier::BoxContainer::getBoundingBox" ref="6440b7e06427fd365eb05604e7dc99f6" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> SAMRAI::hier::BoxContainer::getBoundingBox           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the bounding box for all the boxes in the container. 
<p>
<dl compact><dt><b>Precondition:</b></dt><dd>!isEmpty() <p>
each <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> in container has same <a class="el" href="classSAMRAI_1_1hier_1_1BlockId.html">BlockId</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="300c7b4246e444e698f719d8df4b61c6"></a><!-- doxytag: member="SAMRAI::hier::BoxContainer::getBoundingBox" ref="300c7b4246e444e698f719d8df4b61c6" args="(const BlockId &amp;block_id) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> SAMRAI::hier::BoxContainer::getBoundingBox           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1BlockId.html">BlockId</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>block_id</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the bounding box for all the boxes in the container having the given <a class="el" href="classSAMRAI_1_1hier_1_1BlockId.html">BlockId</a>. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>block_id</em>&nbsp;</td><td></td></tr>
  </table>
</dl>
<dl compact><dt><b>Precondition:</b></dt><dd>!isEmpty() </dd></dl>

</div>
</div><p>
<a class="anchor" name="14358caff71c9fb7dd8d8b3e3e193ea1"></a><!-- doxytag: member="SAMRAI::hier::BoxContainer::boxesIntersect" ref="14358caff71c9fb7dd8d8b3e3e193ea1" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SAMRAI::hier::BoxContainer::boxesIntersect           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Check for non-empty intersection among boxes in container. 
<p>
<dl compact><dt><b>Returns:</b></dt><dd>Returns true if there exists any non-empty intersection among the boxes in the container. </dd></dl>

</div>
</div><p>
<a class="anchor" name="8a554081bd049c99de1e0d6ad53d1cba"></a><!-- doxytag: member="SAMRAI::hier::BoxContainer::order" ref="8a554081bd049c99de1e0d6ad53d1cba" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::hier::BoxContainer::order           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Changes state of this container to ordered. 
<p>
If called on a container that is already ordered, nothing changes.<p>
<dl compact><dt><b>Precondition:</b></dt><dd>each box in container must have valid and unique <a class="el" href="classSAMRAI_1_1hier_1_1BoxId.html">BoxId</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="d3fc42e7710adae0c5d1d5a1c0a1698d"></a><!-- doxytag: member="SAMRAI::hier::BoxContainer::unorder" ref="d3fc42e7710adae0c5d1d5a1c0a1698d" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::hier::BoxContainer::unorder           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Changes state of this container to unordered. 
<p>
This method can be called on any container. 
</div>
</div><p>
<a class="anchor" name="b60e3636df51eb5997471a5520c7884b"></a><!-- doxytag: member="SAMRAI::hier::BoxContainer::isOrdered" ref="b60e3636df51eb5997471a5520c7884b" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SAMRAI::hier::BoxContainer::isOrdered           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return whether this container is ordered. 
<p>
<dl compact><dt><b>Returns:</b></dt><dd>True if ordered, false if unordered. </dd></dl>

</div>
</div><p>
<a class="anchor" name="9dac68baead6e75db214c8b120f0730e"></a><!-- doxytag: member="SAMRAI::hier::BoxContainer::pushFront" ref="9dac68baead6e75db214c8b120f0730e" args="(const Box &amp;item)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::hier::BoxContainer::pushFront           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>item</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Adds "item" to the "front" of the container. 
<p>
Makes "item" the member of the container that will be returned by <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html#acb30f477c077d265d20b477e5adc0f3">front()</a> in an unordered container.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>item</em>&nbsp;</td><td></td></tr>
  </table>
</dl>
<dl compact><dt><b>Precondition:</b></dt><dd><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html#7371af1cb3790c297440cec6dda6a72e">isEmpty()</a> || (<a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html#acb30f477c077d265d20b477e5adc0f3">front()</a>.getDim() == item.getDim()) <p>
!isOrdered() </dd></dl>

</div>
</div><p>
<a class="anchor" name="236e2463d9ec5964135861de73f16324"></a><!-- doxytag: member="SAMRAI::hier::BoxContainer::pushBack" ref="236e2463d9ec5964135861de73f16324" args="(const Box &amp;item)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::hier::BoxContainer::pushBack           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>item</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Adds "item" to the "end" of the container. 
<p>
Makes "item" the member of the container that will be returned by <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html#1a00d37886fa41bd01c6741568ab5bb6">back()</a> in an unordered container.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>item</em>&nbsp;</td><td></td></tr>
  </table>
</dl>
<dl compact><dt><b>Precondition:</b></dt><dd><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html#7371af1cb3790c297440cec6dda6a72e">isEmpty()</a> || (<a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html#acb30f477c077d265d20b477e5adc0f3">front()</a>.getDim() == item.getDim()) <p>
!isOrdered() </dd></dl>

</div>
</div><p>
<a class="anchor" name="3f9ea6e1242029ed5b0bec7ebfc55ecb"></a><!-- doxytag: member="SAMRAI::hier::BoxContainer::insertBefore" ref="3f9ea6e1242029ed5b0bec7ebfc55ecb" args="(iterator iter, const Box &amp;item)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::hier::BoxContainer::insertBefore           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer_1_1BoxContainerIterator.html">iterator</a>&nbsp;</td>
          <td class="paramname"> <em>iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>item</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Add "item" to specific place in the container. 
<p>
Places "item" immediately before the member of the container pointed to by "iter" in an unordered container.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>iter</em>&nbsp;</td><td>Location to add item before. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>item</em>&nbsp;</td><td><a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> to add to container.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Precondition:</b></dt><dd><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html#7371af1cb3790c297440cec6dda6a72e">isEmpty()</a> || (<a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html#acb30f477c077d265d20b477e5adc0f3">front()</a>.getDim() == item.getDim()) <p>
!isOrdered() </dd></dl>

</div>
</div><p>
<a class="anchor" name="3229998b188dfe40a9bddb47d737da4f"></a><!-- doxytag: member="SAMRAI::hier::BoxContainer::insertAfter" ref="3229998b188dfe40a9bddb47d737da4f" args="(iterator iter, const Box &amp;item)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::hier::BoxContainer::insertAfter           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer_1_1BoxContainerIterator.html">iterator</a>&nbsp;</td>
          <td class="paramname"> <em>iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>item</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Add "item" to specific place in the container. 
<p>
Places "item" immediately after the member of the container pointed to by "iter" in an unordered container.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>iter</em>&nbsp;</td><td>Location to add item after. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>item</em>&nbsp;</td><td><a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> to add to container.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Precondition:</b></dt><dd><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html#7371af1cb3790c297440cec6dda6a72e">isEmpty()</a> || (<a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html#acb30f477c077d265d20b477e5adc0f3">front()</a>.getDim() == item.getDim()) <p>
!isOrdered() </dd></dl>

</div>
</div><p>
<a class="anchor" name="ba38984af87d838459be4b85d0638bb9"></a><!-- doxytag: member="SAMRAI::hier::BoxContainer::spliceFront" ref="ba38984af87d838459be4b85d0638bb9" args="(BoxContainer &amp;boxes)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::hier::BoxContainer::spliceFront           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>boxes</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Prepends the Boxes in "boxes" to this <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a>. 
<p>
"boxes" will be empty following this operation.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>boxes</em>&nbsp;</td><td></td></tr>
  </table>
</dl>
<dl compact><dt><b>Precondition:</b></dt><dd><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html#7371af1cb3790c297440cec6dda6a72e">isEmpty()</a> || (<a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html#acb30f477c077d265d20b477e5adc0f3">front()</a>.getDim() == item.getDim()) <p>
!isOrdered()</dd></dl>
<dl compact><dt><b>Postcondition:</b></dt><dd>boxes.isEmpty() </dd></dl>

</div>
</div><p>
<a class="anchor" name="d0766ee251b631b81cd2333e71dd33f2"></a><!-- doxytag: member="SAMRAI::hier::BoxContainer::spliceBack" ref="d0766ee251b631b81cd2333e71dd33f2" args="(BoxContainer &amp;boxes)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::hier::BoxContainer::spliceBack           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>boxes</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Appends the Boxes in "boxes" to this <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a>. 
<p>
"boxes" will be empty following this operation.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>boxes</em>&nbsp;</td><td></td></tr>
  </table>
</dl>
<dl compact><dt><b>Precondition:</b></dt><dd><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html#7371af1cb3790c297440cec6dda6a72e">isEmpty()</a> || (<a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html#acb30f477c077d265d20b477e5adc0f3">front()</a>.getDim() == item.getDim()) <p>
!isOrdered()</dd></dl>
<dl compact><dt><b>Postcondition:</b></dt><dd>boxes.isEmpty() </dd></dl>

</div>
</div><p>
<a class="anchor" name="a26e34c146a2e4d3db594350d030682c"></a><!-- doxytag: member="SAMRAI::hier::BoxContainer::popFront" ref="a26e34c146a2e4d3db594350d030682c" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::hier::BoxContainer::popFront           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Remove the first member of the unordered container. 
<p>
<dl compact><dt><b>Precondition:</b></dt><dd>!isOrdered() </dd></dl>

</div>
</div><p>
<a class="anchor" name="09990007ee046ca5b308cdeea9bf9302"></a><!-- doxytag: member="SAMRAI::hier::BoxContainer::popBack" ref="09990007ee046ca5b308cdeea9bf9302" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::hier::BoxContainer::popBack           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Remove the last member of the unordered container. 
<p>
<dl compact><dt><b>Precondition:</b></dt><dd>!isOrdered() </dd></dl>

</div>
</div><p>
<a class="anchor" name="cf2587b68a7d1a7d2a2134d9f87c0fca"></a><!-- doxytag: member="SAMRAI::hier::BoxContainer::simplify" ref="cf2587b68a7d1a7d2a2134d9f87c0fca" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::hier::BoxContainer::simplify           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Place the boxes in the container into a canonical ordering. 
<p>
The canonical ordering for boxes is defined such that boxes that lie next to each other in higher directions are coalesced together before boxes that lie next to each other in lower directions. This ordering provides a standard representation that can be used to compare box containers. The canonical ordering also does not allow any overlap between the boxes in the container. This routine is potentially expensive, since the running time is <img class="formulaInl" alt="$O(N^2)$" src="form_0.png"> for N boxes. None of the domain calculus routines call <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html#cf2587b68a7d1a7d2a2134d9f87c0fca">simplify()</a>; all calls to simplify the boxes must be explicit. Note that this routine is distinct from <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html#4f65643b3d30a7bc24dbac9a22abb5c7">coalesce()</a>, which is not guaranteed to produce a canonical ordering.<p>
<dl compact><dt><b>Precondition:</b></dt><dd>!isOrdered() <p>
<a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html#7371af1cb3790c297440cec6dda6a72e">isEmpty()</a> || all Boxes in container have same <a class="el" href="classSAMRAI_1_1hier_1_1BlockId.html">BlockId</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="4f65643b3d30a7bc24dbac9a22abb5c7"></a><!-- doxytag: member="SAMRAI::hier::BoxContainer::coalesce" ref="4f65643b3d30a7bc24dbac9a22abb5c7" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::hier::BoxContainer::coalesce           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Combine any boxes in the container which may be coalesced. 
<p>
Two boxes may be coalesced if their union is a box (recall that boxes are not closed under index set unions). Empty boxes in the container are removed during this process. Note that this is potentially an expensive calculation (e.g., it will require <img class="formulaInl" alt="$(N-1)!$" src="form_1.png"> box comparisons for a box container with <img class="formulaInl" alt="$N$" src="form_2.png"> boxes in the worst possible case). So this routine should be used sparingly. Also note that this routine is different than <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html#cf2587b68a7d1a7d2a2134d9f87c0fca">simplify()</a> since it does not produce a canonical ordering. In particular, this routine processes the boxes in the order in which they appear in the container, rather than attempting to coalesce boxes along specific coordinate directions before others.<p>
<dl compact><dt><b>Precondition:</b></dt><dd>!isOrdered() <p>
<a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html#7371af1cb3790c297440cec6dda6a72e">isEmpty()</a> || all Boxes in container have same <a class="el" href="classSAMRAI_1_1hier_1_1BlockId.html">BlockId</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="610b4fa87a46fb7225d10a76014d4c86"></a><!-- doxytag: member="SAMRAI::hier::BoxContainer::rotate" ref="610b4fa87a46fb7225d10a76014d4c86" args="(const Transformation::RotationIdentifier rotation_ident)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::hier::BoxContainer::rotate           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1Transformation.html#2dd7d97a19db7c8e97402e8518c0af8d">Transformation::RotationIdentifier</a>&nbsp;</td>
          <td class="paramname"> <em>rotation_ident</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Rotate boxes in container according to a RotationIdentifier. 
<p>
<dl compact><dt><b>Note:</b></dt><dd>Works only in 2D or 3D.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>rotation_ident</em>&nbsp;</td><td></td></tr>
  </table>
</dl>
<dl compact><dt><b>Precondition:</b></dt><dd>each <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> in container has dim 2 or 3 <p>
each <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> in container has same <a class="el" href="classSAMRAI_1_1hier_1_1BlockId.html">BlockId</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="b7efb9cecef0461f129c18f41fa06402"></a><!-- doxytag: member="SAMRAI::hier::BoxContainer::removeIntersections" ref="b7efb9cecef0461f129c18f41fa06402" args="(const Box &amp;takeaway)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::hier::BoxContainer::removeIntersections           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>takeaway</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Remove from each box the portions that intersect takeaway. 
<p>
This operation can be thought of as a set difference defined over the abstract AMR box index space. Performing the set difference will require <img class="formulaInl" alt="$O(N)$" src="form_3.png"> time for a container with <img class="formulaInl" alt="$N$" src="form_2.png"> boxes. For each box, b, in this container this operation computes b-(b^takeaway) where '^' indicates intersection.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>takeaway</em>&nbsp;</td><td>What to exclude from each box in the container.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Precondition:</b></dt><dd>!isOrdered() </dd></dl>

</div>
</div><p>
<a class="anchor" name="140cd0612e724e550fecb567f38c760b"></a><!-- doxytag: member="SAMRAI::hier::BoxContainer::removeIntersections" ref="140cd0612e724e550fecb567f38c760b" args="(const BoxContainer &amp;takeaway)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::hier::BoxContainer::removeIntersections           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>takeaway</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Remove from each box portions intersecting boxes in takeaway. 
<p>
For each box, b, in this container and for each box, t, in takeaway this operation computes b-(b^t) where '^' indicates intersection.<p>
This only works if all boxes in this <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a> and the takeaway <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a> have the same <a class="el" href="classSAMRAI_1_1hier_1_1BlockId.html">BlockId</a>. An error will occur otherwise.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>takeaway</em>&nbsp;</td><td>What to exclude from each box in the container.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Precondition:</b></dt><dd>!isOrdered() </dd></dl>

</div>
</div><p>
<a class="anchor" name="9eae3c6a62fc8e46c2cb3430b72966ec"></a><!-- doxytag: member="SAMRAI::hier::BoxContainer::removeIntersections" ref="9eae3c6a62fc8e46c2cb3430b72966ec" args="(const IntVector &amp;refinement_ratio, const BoxContainer &amp;takeaway, const bool include_singularity_block_neighbors=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::hier::BoxContainer::removeIntersections           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>refinement_ratio</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>takeaway</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&nbsp;</td>
          <td class="paramname"> <em>include_singularity_block_neighbors</em> = <code>false</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Remove from each box portions intersecting boxes in takeaway. 
<p>
Uses refinement ratio and grid geometry to handle intersections across block boundaries if needed.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>refinement_ratio</em>&nbsp;</td><td>All boxes in this <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a> are assumed to exist in index space that has this refinement ratio relative to the coarse-level domain.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>takeaway</em>&nbsp;</td><td>The boxes to take away from this <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a>. An error will occur if makeTree with a non-null <a class="el" href="classSAMRAI_1_1hier_1_1BaseGridGeometry.html">BaseGridGeometry</a> argument has not been previously called on this container.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>include_singularity_block_neighbors</em>&nbsp;</td><td>If true, intersections with neighboring blocks that touch only across an enhanced connectivity singularity will be removed. If false, those intersections are ignored.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Precondition:</b></dt><dd>!isOrdered() <p>
takeaway.hasTree() </dd></dl>

</div>
</div><p>
<a class="anchor" name="d98c16c6d4f4d7a3d748dcc08fd3a010"></a><!-- doxytag: member="SAMRAI::hier::BoxContainer::removeIntersections" ref="d98c16c6d4f4d7a3d748dcc08fd3a010" args="(const Box &amp;box, const Box &amp;takeaway)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::hier::BoxContainer::removeIntersections           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>box</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>takeaway</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Remove from box the portions intersecting takeaway. 
<p>
This is special version for the case where the container is empty initially. Upon completion this container contains the result of the removal from box of the intersection of box with takeaway. If the boxes do not intersect, box is simply added to this container. This routine is primarily suited for applications which are looking only for the intersection of two boxes. This operation computes box-(box^takeaway) where '^' indicates intersection.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>box</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>takeaway</em>&nbsp;</td><td></td></tr>
  </table>
</dl>
<dl compact><dt><b>Precondition:</b></dt><dd>!isOrdered() <p>
<a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html#7371af1cb3790c297440cec6dda6a72e">isEmpty()</a> <p>
box.getBlockId() == takeaway.getBlockId() </dd></dl>

</div>
</div><p>
<a class="anchor" name="afc53135623a761a92fc7053dd482810"></a><!-- doxytag: member="SAMRAI::hier::BoxContainer::intersectBoxes" ref="afc53135623a761a92fc7053dd482810" args="(const Box &amp;keep)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::hier::BoxContainer::intersectBoxes           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>keep</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Keep the intersection of the container's boxes and keep. 
<p>
Performing the intersection will require <img class="formulaInl" alt="$O(N)$" src="form_3.png"> time for a container with <img class="formulaInl" alt="$N$" src="form_2.png"> boxes. The complement of removeIntersections.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>keep</em>&nbsp;</td><td></td></tr>
  </table>
</dl>
<dl compact><dt><b>Precondition:</b></dt><dd>!isOrdered() </dd></dl>

</div>
</div><p>
<a class="anchor" name="2f7078f8f3e4024318d535717ed2cb34"></a><!-- doxytag: member="SAMRAI::hier::BoxContainer::intersectBoxes" ref="2f7078f8f3e4024318d535717ed2cb34" args="(const BoxContainer &amp;keep)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::hier::BoxContainer::intersectBoxes           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>keep</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Keep the intersection of the container's boxes and keep's boxes. 
<p>
Intersect the boxes in the current container against the boxes in the specified container. The intersection calculation will require <img class="formulaInl" alt="$O(N^2)$" src="form_0.png"> time for containers with <img class="formulaInl" alt="$N$" src="form_2.png"> boxes. The complement of removeIntersections.<p>
This only works if all boxes in this <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a> and the keep <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a> have the same <a class="el" href="classSAMRAI_1_1hier_1_1BlockId.html">BlockId</a>. An error will occur otherwise.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>keep</em>&nbsp;</td><td></td></tr>
  </table>
</dl>
<dl compact><dt><b>Precondition:</b></dt><dd>!isOrdered() </dd></dl>

</div>
</div><p>
<a class="anchor" name="6332ff5ba2add3c55657b80d254a116e"></a><!-- doxytag: member="SAMRAI::hier::BoxContainer::intersectBoxes" ref="6332ff5ba2add3c55657b80d254a116e" args="(const IntVector &amp;refinement_ratio, const BoxContainer &amp;keep, bool include_singularity_block_neighbors=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::hier::BoxContainer::intersectBoxes           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>refinement_ratio</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>keep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>include_singularity_block_neighbors</em> = <code>false</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Keep the intersection of the container's boxes and keep's boxes. 
<p>
Uses refinement ratio and grid geometry to handle intersections across block boundaries if needed.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>refinement_ratio</em>&nbsp;</td><td>All boxes in this <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a> are assumed to exist in index space that has this refinement ratio relative to the coarse-level domain.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>keep</em>&nbsp;</td><td>The boxes to intersect with this <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a>. An error will occur if makeTree with a non-null <a class="el" href="classSAMRAI_1_1hier_1_1BaseGridGeometry.html">BaseGridGeometry</a> argument has not been previously called on this container.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>include_singularity_block_neighbors</em>&nbsp;</td><td>If true, intersections with neighboring blocks that touch only across an enhanced connectivity singularity will be kept. If false, those intersections are ignored.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Precondition:</b></dt><dd>!isOrdered() <p>
keep.hasTree() </dd></dl>

</div>
</div><p>
<a class="anchor" name="2c2d862cadd5ab8e61c1104b98d90fbe"></a><!-- doxytag: member="SAMRAI::hier::BoxContainer::insert" ref="2c2d862cadd5ab8e61c1104b98d90fbe" args="(const Box &amp;box)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SAMRAI::hier::BoxContainer::insert           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>box</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Insert a single <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a>. 
<p>
The <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> will be added to the container unless the container already contains a <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> with the same <a class="el" href="classSAMRAI_1_1hier_1_1BoxId.html">BoxId</a>. If a <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> with the same <a class="el" href="classSAMRAI_1_1hier_1_1BoxId.html">BoxId</a> does already exist in the contianer, the container will not be changed.<p>
<dl compact><dt><b>Returns:</b></dt><dd>True if the container did not already have a <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> with the same <a class="el" href="classSAMRAI_1_1hier_1_1BoxId.html">BoxId</a>, false otherwise.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>box</em>&nbsp;</td><td><a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> to attempt to insert into the container.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Precondition:</b></dt><dd>box.getBoxId().isValid() <p>
<a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html#7371af1cb3790c297440cec6dda6a72e">isEmpty()</a> || (<a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html#acb30f477c077d265d20b477e5adc0f3">front()</a>.getDim() == box.getDim()) <p>
<a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html#7371af1cb3790c297440cec6dda6a72e">isEmpty()</a> || <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html#b60e3636df51eb5997471a5520c7884b">isOrdered()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="235e4cc65c93a2acc692838a0215e44f"></a><!-- doxytag: member="SAMRAI::hier::BoxContainer::insert" ref="235e4cc65c93a2acc692838a0215e44f" args="(iterator position, const Box &amp;box)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer_1_1BoxContainerIterator.html">BoxContainer::iterator</a> SAMRAI::hier::BoxContainer::insert           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer_1_1BoxContainerIterator.html">iterator</a>&nbsp;</td>
          <td class="paramname"> <em>position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>box</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Insert a single <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a>. 
<p>
The <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> will be added to the container unless the container already contains a <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> with the same <a class="el" href="classSAMRAI_1_1hier_1_1BoxId.html">BoxId</a>. If a <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> with the same <a class="el" href="classSAMRAI_1_1hier_1_1BoxId.html">BoxId</a> does already exist in the contianer, the container will not be changed.<p>
This version of insert includes an iterator argument pointing somewhere in this container. This iterator indicates a position in the ordered container where the search for the proper place to insert the given <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> will begin.<p>
The iterator argument does not determine the place the <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> will end up in the ordered container, as that is always determined by <a class="el" href="classSAMRAI_1_1hier_1_1BoxId.html">BoxId</a>; it is intended only to provide a means of optimization when the calling code knows something about the ordering of the container.<p>
<dl compact><dt><b>Returns:</b></dt><dd>iterator pointing to the newly-added <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> if the container did not already have a <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> with the same <a class="el" href="classSAMRAI_1_1hier_1_1BoxId.html">BoxId</a>. If the container did have a <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> with the same <a class="el" href="classSAMRAI_1_1hier_1_1BoxId.html">BoxId</a>, the returned iterator points to that <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a>.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>position</em>&nbsp;</td><td>Location to begin searching for place to insert <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>box</em>&nbsp;</td><td><a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> to attempt to insert into the container</td></tr>
  </table>
</dl>
<dl compact><dt><b>Precondition:</b></dt><dd>box.getBoxId().isValid() <p>
box.getBlockId() != <a class="el" href="classSAMRAI_1_1hier_1_1BlockId.html#f5ec2c3b87256cd021571cd78a897d92">BlockId::invalidId()</a> <p>
<a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html#7371af1cb3790c297440cec6dda6a72e">isEmpty()</a> || (<a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html#acb30f477c077d265d20b477e5adc0f3">front()</a>.getDim() == box.getDim()) <p>
<a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html#7371af1cb3790c297440cec6dda6a72e">isEmpty()</a> || <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html#b60e3636df51eb5997471a5520c7884b">isOrdered()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="e043c3cad663f7ff9ec97ee02b9a2bd3"></a><!-- doxytag: member="SAMRAI::hier::BoxContainer::insert" ref="e043c3cad663f7ff9ec97ee02b9a2bd3" args="(const_iterator first, const_iterator last)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::hier::BoxContainer::insert           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer_1_1BoxContainerConstIterator.html">const_iterator</a>&nbsp;</td>
          <td class="paramname"> <em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer_1_1BoxContainerConstIterator.html">const_iterator</a>&nbsp;</td>
          <td class="paramname"> <em>last</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Insert all Boxes within a range. 
<p>
Boxes in the range [first, last) are added to the ordered container, as long as they do not have a <a class="el" href="classSAMRAI_1_1hier_1_1BoxId.html">BoxId</a> matching that of a <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> already in the container.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>first</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>last</em>&nbsp;</td><td></td></tr>
  </table>
</dl>
<dl compact><dt><b>Precondition:</b></dt><dd><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html#7371af1cb3790c297440cec6dda6a72e">isEmpty()</a> || <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html#b60e3636df51eb5997471a5520c7884b">isOrdered()</a> <p>
for each box in [first, last), box.getBoxId().isValid() &amp;&amp; (isEmpty || <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html#acb30f477c077d265d20b477e5adc0f3">front()</a>.getDim() == box.getDim()) </dd></dl>

</div>
</div><p>
<a class="anchor" name="4460be7ce26be1bc5ce2ffc09b0efc9d"></a><!-- doxytag: member="SAMRAI::hier::BoxContainer::find" ref="4460be7ce26be1bc5ce2ffc09b0efc9d" args="(const Box &amp;box) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer_1_1BoxContainerIterator.html">iterator</a> SAMRAI::hier::BoxContainer::find           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>box</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Find a box in an ordered container. 
<p>
Search for a <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> having the same <a class="el" href="classSAMRAI_1_1hier_1_1BoxId.html">BoxId</a> as the given box argument. This may only be called on an ordered container.<p>
<dl compact><dt><b>Returns:</b></dt><dd>If a <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> with the same <a class="el" href="classSAMRAI_1_1hier_1_1BoxId.html">BoxId</a> as the argument is found, the iterator points to that <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> in this container, otherwise <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html#9c566195352afe03c2c1b2ef8d19e55c">end()</a> for this container is returned.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>box</em>&nbsp;</td><td><a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> serving as key for the find operation. Only its <a class="el" href="classSAMRAI_1_1hier_1_1BoxId.html">BoxId</a> is compared to members of this container.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Precondition:</b></dt><dd><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html#b60e3636df51eb5997471a5520c7884b">isOrdered()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="7e31c87c644fd9666c1bf1517f49d935"></a><!-- doxytag: member="SAMRAI::hier::BoxContainer::lowerBound" ref="7e31c87c644fd9666c1bf1517f49d935" args="(const Box &amp;box) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer_1_1BoxContainerIterator.html">iterator</a> SAMRAI::hier::BoxContainer::lowerBound           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>box</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get lower bound iterator for a given <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a>. 
<p>
This may only be called on an ordered container.<p>
<dl compact><dt><b>Returns:</b></dt><dd>iterator pointing to the first member of this container with a <a class="el" href="classSAMRAI_1_1hier_1_1BoxId.html">BoxId</a> value greater than or equal to the <a class="el" href="classSAMRAI_1_1hier_1_1BoxId.html">BoxId</a> of the argument <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a>.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>box</em>&nbsp;</td><td><a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> serving as key for the lower bound search.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Precondition:</b></dt><dd><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html#b60e3636df51eb5997471a5520c7884b">isOrdered()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="0b375d7cb0766e9db20fa442c3d67cb3"></a><!-- doxytag: member="SAMRAI::hier::BoxContainer::upperBound" ref="0b375d7cb0766e9db20fa442c3d67cb3" args="(const Box &amp;box) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer_1_1BoxContainerIterator.html">iterator</a> SAMRAI::hier::BoxContainer::upperBound           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>box</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get upper bound iterator for a given <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a>. 
<p>
<dl compact><dt><b>Returns:</b></dt><dd>iterator pointing to the first member of this container with a <a class="el" href="classSAMRAI_1_1hier_1_1BoxId.html">BoxId</a> value greater than the <a class="el" href="classSAMRAI_1_1hier_1_1BoxId.html">BoxId</a> of the argument <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a>. Will return <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html#9c566195352afe03c2c1b2ef8d19e55c">end()</a> if there are no members with a greater <a class="el" href="classSAMRAI_1_1hier_1_1BoxId.html">BoxId</a> value.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>box</em>&nbsp;</td><td><a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> serving as key for the upper bound search.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Precondition:</b></dt><dd><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html#b60e3636df51eb5997471a5520c7884b">isOrdered()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="72fdf350374069c52b2a36c715e9fc88"></a><!-- doxytag: member="SAMRAI::hier::BoxContainer::erase" ref="72fdf350374069c52b2a36c715e9fc88" args="(const Box &amp;box)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int SAMRAI::hier::BoxContainer::erase           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>box</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Erase a <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> from the container. 
<p>
If a member of the container has the same <a class="el" href="classSAMRAI_1_1hier_1_1BoxId.html">BoxId</a> as the argument <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a>, it will be erased from the container. If no such member is found, the container is unchanged.<p>
<dl compact><dt><b>Returns:</b></dt><dd>1 if a <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> is erased, 0 otherwise.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>box</em>&nbsp;</td><td><a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> serving as key to find a <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> to be erased.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Precondition:</b></dt><dd><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html#b60e3636df51eb5997471a5520c7884b">isOrdered()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="0e67b13f4abe3c0de489e094bf27b5c3"></a><!-- doxytag: member="SAMRAI::hier::BoxContainer::separatePeriodicImages" ref="0e67b13f4abe3c0de489e094bf27b5c3" args="(std::vector&lt; Box &gt; &amp;real_box_vector, std::vector&lt; Box &gt; &amp;periodic_image_box_vector) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::hier::BoxContainer::separatePeriodicImages           </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>real_box_vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>periodic_image_box_vector</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Copy the members of this <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a> into two vector&lt;Box&gt; objects, one containing real Boxes and one containing their periodic images. 
<p>
Put the results in the output vectors. For flexibility and efficiency, the output containers are NOT cleared first, so users may want to clear them before calling this method.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>real_box_vector</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>periodic_image_box_vector</em>&nbsp;</td><td></td></tr>
  </table>
</dl>
<dl compact><dt><b>Precondition:</b></dt><dd><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html#b60e3636df51eb5997471a5520c7884b">isOrdered()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="e6c69e1e6065a9b4e0b88384cd7cf49f"></a><!-- doxytag: member="SAMRAI::hier::BoxContainer::removePeriodicImageBoxes" ref="e6c69e1e6065a9b4e0b88384cd7cf49f" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::hier::BoxContainer::removePeriodicImageBoxes           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Any members of this container that are periodic images will be erased. 
<p>
<dl compact><dt><b>Precondition:</b></dt><dd><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html#7371af1cb3790c297440cec6dda6a72e">isEmpty()</a> || <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html#b60e3636df51eb5997471a5520c7884b">isOrdered()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="5cd6f3f9e98de5b1b6171438e6d5db74"></a><!-- doxytag: member="SAMRAI::hier::BoxContainer::unshiftPeriodicImageBoxes" ref="5cd6f3f9e98de5b1b6171438e6d5db74" args="(BoxContainer &amp;output_boxes, const IntVector &amp;refinement_ratio) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::hier::BoxContainer::unshiftPeriodicImageBoxes           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>output_boxes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>refinement_ratio</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Place unshifted versions of Boxes into a <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a>. 
<p>
For all members of this container that are periodic images, create an unshifted copy the member box and add insert it the output container. Additionally, insert all members of the container that are not periodic images to the output container.<p>
For flexibility and efficiency, the output container is NOT cleared first, so users may want to clear it before calling this method.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>output_boxes</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>refinement_ratio</em>&nbsp;</td><td>Refinement ratio where the boxes live.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Precondition:</b></dt><dd><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html#b60e3636df51eb5997471a5520c7884b">isOrdered()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="d795e5b89220de39c135f35a67cdd9f4"></a><!-- doxytag: member="SAMRAI::hier::BoxContainer::operator==" ref="d795e5b89220de39c135f35a67cdd9f4" args="(const BoxContainer &amp;rhs) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SAMRAI::hier::BoxContainer::operator==           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Equality operator. 
<p>
<dl compact><dt><b>Returns:</b></dt><dd>If ordered, return true if all BoxIds in this and rhs are identical. If unordered, return true if a Boxes in this and rhs are spatially equal.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>rhs</em>&nbsp;</td><td></td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="3388a48a209f9b2d08f51bc64f1b33f5"></a><!-- doxytag: member="SAMRAI::hier::BoxContainer::operator!=" ref="3388a48a209f9b2d08f51bc64f1b33f5" args="(const BoxContainer &amp;rhs) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SAMRAI::hier::BoxContainer::operator!=           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Inequality operator. 
<p>
<dl compact><dt><b>Returns:</b></dt><dd>Return true if operator== would return false.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>rhs</em>&nbsp;</td><td></td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="a24aaf0ff0de7a5a86e80ac1b2cfc96f"></a><!-- doxytag: member="SAMRAI::hier::BoxContainer::putToRestart" ref="a24aaf0ff0de7a5a86e80ac1b2cfc96f" args="(const boost::shared_ptr&lt; tbox::Database &gt; &amp;restart_db) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::hier::BoxContainer::putToRestart           </td>
          <td>(</td>
          <td class="paramtype">const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Database.html">tbox::Database</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>restart_db</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Write the <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a> to a restart database. 
<p>

</div>
</div><p>
<a class="anchor" name="a0928d91ef08c3bc5ff619be13351577"></a><!-- doxytag: member="SAMRAI::hier::BoxContainer::getFromRestart" ref="a0928d91ef08c3bc5ff619be13351577" args="(tbox::Database &amp;restart_db)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::hier::BoxContainer::getFromRestart           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1tbox_1_1Database.html">tbox::Database</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>restart_db</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Read the <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a> from a restart database. 
<p>

</div>
</div><p>
<a class="anchor" name="e7dc204d3baaf9b32488d4c25aac8d8d"></a><!-- doxytag: member="SAMRAI::hier::BoxContainer::operator tbox::Array" ref="e7dc204d3baaf9b32488d4c25aac8d8d" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SAMRAI::hier::BoxContainer::operator <a class="el" href="classSAMRAI_1_1tbox_1_1Array.html">tbox::Array</a>           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Conversion from <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a> to tbox::Array&lt;tbox::DatabaseBox&gt;. 
<p>

</div>
</div><p>
<a class="anchor" name="0e018adef09a9d3631b2105015689da3"></a><!-- doxytag: member="SAMRAI::hier::BoxContainer::print" ref="0e018adef09a9d3631b2105015689da3" args="(std::ostream &amp;os=tbox::plog) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::hier::BoxContainer::print           </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&nbsp;</td>
          <td class="paramname"> <em>os</em> = <code><a class="el" href="namespaceSAMRAI_1_1tbox.html#b84041705493761fb17a8127e3a2dca2">tbox::plog</a></code>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Print each box in the container to the specified output stream. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>os</em>&nbsp;</td><td></td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="19f443ba4410bb46337cd71578f2f740"></a><!-- doxytag: member="SAMRAI::hier::BoxContainer::format" ref="19f443ba4410bb46337cd71578f2f740" args="(const std::string &amp;border=std::string(), int detail_depth=0) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer_1_1Outputter.html">BoxContainer::Outputter</a> SAMRAI::hier::BoxContainer::format           </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>border</em> = <code>std::string()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>detail_depth</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return a object to that can format the <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a> for inserting into output streams. 
<p>
Usage example (printing with a tab indentation): <div class="fragment"><pre class="fragment">    *    cout &lt;&lt; "my boxes:\n" &lt;&lt; boxes.format("\t") &lt;&lt; endl;
    * </pre></div><p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>border</em>&nbsp;</td><td>Left border of the output</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>detail_depth</em>&nbsp;</td><td>How much detail to print. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="faa3a4f83b2f6714087926aea2d21664"></a><!-- doxytag: member="SAMRAI::hier::BoxContainer::makeTree" ref="faa3a4f83b2f6714087926aea2d21664" args="(const BaseGridGeometry *grid_geometry=0, const int min_number=10) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::hier::BoxContainer::makeTree           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1BaseGridGeometry.html">BaseGridGeometry</a> *&nbsp;</td>
          <td class="paramname"> <em>grid_geometry</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>min_number</em> = <code>10</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Create a search tree representation of the boxes in this container. 
<p>
If the size of this container is greater than the min_number argument, then an internal <a class="el" href="classSAMRAI_1_1hier_1_1BoxTree.html">BoxTree</a> representation of the boxes will be created and held by the container.<p>
This method may only be used if all members of this container have the same <a class="el" href="classSAMRAI_1_1hier_1_1BlockId.html">BlockId</a>. An assertion failure will occur if this condition is not met.<p>
The building of the tree is an O(N log(N)) operation, but it reduces the cost of the search methods <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html#a6e83d2ee9cc30cc14da50cc398e89c2">findOverlapBoxes()</a> and <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html#b161e5c0d9cb1ef48c0b06016f6ec78f">hasOverlap()</a> to O(log(N)), rather than O(N). The tree representation is intended for when these search methods are called multiple times on the same <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a> which is not changing, so that the benefit of more efficient search should outweigh the cost of building the tree.<p>
The min_number argument is used to indicate a container size below which there is no benefit from building the tree, so no tree is created when the size is less than or equal to this value.<p>
If a tree representation has been created via this method, and then any other <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a> method is called that changes the container by adding or removing boxes, or by changing the spatial coordinates of the boxes, the tree representation is destroyed.<p>
A non-null pointer to a <a class="el" href="classSAMRAI_1_1hier_1_1BaseGridGeometry.html">BaseGridGeometry</a> must be provided if this container is going to be used in any of the methods that handle multiblock transformations. If this container is used only in a single-block context, no <a class="el" href="classSAMRAI_1_1hier_1_1BaseGridGeometry.html">BaseGridGeometry</a> argument is necessary.<p>
<dl compact><dt><b>Note:</b></dt><dd>The grid_geometry argument is required for multiblock. It must be the GridGeometry from which the Boxes stored in the container came from.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>grid_geometry</em>&nbsp;</td><td>To handle multiblock transformations if needed. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>min_number</em>&nbsp;</td><td></td></tr>
  </table>
</dl>
<dl compact><dt><b>Precondition:</b></dt><dd>min_number &gt; 0 </dd></dl>

</div>
</div><p>
<a class="anchor" name="6583a10f3562655a992cc0108222dd3e"></a><!-- doxytag: member="SAMRAI::hier::BoxContainer::hasTree" ref="6583a10f3562655a992cc0108222dd3e" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SAMRAI::hier::BoxContainer::hasTree           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Query if the search tree representation exists. 
<p>

</div>
</div><p>
<a class="anchor" name="8f29006cbc555f91394a5b641d99027a"></a><!-- doxytag: member="SAMRAI::hier::BoxContainer::hasBoxInBlock" ref="8f29006cbc555f91394a5b641d99027a" args="(const BlockId &amp;block_id) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SAMRAI::hier::BoxContainer::hasBoxInBlock           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1BlockId.html">BlockId</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>block_id</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Query if this <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a> contains any <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> with the given <a class="el" href="classSAMRAI_1_1hier_1_1BlockId.html">BlockId</a>. 
<p>
This is an efficient query if the the tree representation of this container has been constructed. If not, it requires a linear search over the entire container and may not be efficient. 
</div>
</div><p>
<a class="anchor" name="a6e83d2ee9cc30cc14da50cc398e89c2"></a><!-- doxytag: member="SAMRAI::hier::BoxContainer::findOverlapBoxes" ref="a6e83d2ee9cc30cc14da50cc398e89c2" args="(BoxContainer &amp;overlap_boxes, const Box &amp;box) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::hier::BoxContainer::findOverlapBoxes           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>overlap_boxes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>box</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Find all boxes that intersect with a given box. 
<p>
Every <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> in this <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a> that intersects with the box argument will be added to the overlap_boxes output container. The output container will retain the same ordered/unordered state that it had prior to being passed into this method.<p>
If this method is used multiple times on the same <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a>, it is recommended for efficiency's sake to call <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html#faa3a4f83b2f6714087926aea2d21664">makeTree()</a> on this <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a> before calling this method.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>overlap_boxes</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>box</em>&nbsp;</td><td></td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="d254ff6fa6afdaa32c7539dcef0749c4"></a><!-- doxytag: member="SAMRAI::hier::BoxContainer::findOverlapBoxes" ref="d254ff6fa6afdaa32c7539dcef0749c4" args="(std::vector&lt; const Box * &gt; &amp;overlap_boxes, const Box &amp;box) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::hier::BoxContainer::findOverlapBoxes           </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> * &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>overlap_boxes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>box</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Find all boxes that intersect with a given box. 
<p>
A pointer to every <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> in this <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a> that intersects with the box argument will be copied to the overlap_boxes output vector. The vector is not sorted in any way.<p>
If this method is used multiple times on the same <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a>, it is recommended for efficiency's sake to call <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html#faa3a4f83b2f6714087926aea2d21664">makeTree()</a> on this <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a> before calling this method.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>overlap_boxes</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>box</em>&nbsp;</td><td></td></tr>
  </table>
</dl>
<dl compact><dt><b>Precondition:</b></dt><dd>!hasTree() || (d_tree-&gt;getNumberBlocksInTree() == 1) </dd></dl>

</div>
</div><p>
<a class="anchor" name="046d85a16e8923c8e7493a128c27595e"></a><!-- doxytag: member="SAMRAI::hier::BoxContainer::findOverlapBoxes" ref="046d85a16e8923c8e7493a128c27595e" args="(BoxContainer &amp;overlap_boxes, const Box &amp;box, const IntVector &amp;refinement_ratio, bool include_singularity_block_neighbors=false) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::hier::BoxContainer::findOverlapBoxes           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>overlap_boxes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>box</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>refinement_ratio</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>include_singularity_block_neighbors</em> = <code>false</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Find all boxes that intersect with a given box. 
<p>
Uses refinement ratio and grid geometry to handle intersections across block boundaries if needed. The makeTree method with a non-null <a class="el" href="classSAMRAI_1_1hier_1_1BaseGridGeometry.html">BaseGridGeometry</a> pointer must be called on this container before calling this version of findOverlapBoxes.<p>
Every <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> in this <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a> that intersects with the box argument will be copied to the overlap_boxes output container. The output container will retain the same ordered/unordered state that it had prior to being passed into this method.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>overlap_boxes</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>box</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>refinement_ratio</em>&nbsp;</td><td>All boxes in this <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a> are assumed to exist in index space that has this refinement ratio relative to the coarse-level domain.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>include_singularity_block_neighbors</em>&nbsp;</td><td>If true, intersections with neighboring blocks that touch only across an enhanced connectivity singularity will be added to output. If false, those intersections are ignored.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Precondition:</b></dt><dd><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html#6583a10f3562655a992cc0108222dd3e">hasTree()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="b161e5c0d9cb1ef48c0b06016f6ec78f"></a><!-- doxytag: member="SAMRAI::hier::BoxContainer::hasOverlap" ref="b161e5c0d9cb1ef48c0b06016f6ec78f" args="(const Box &amp;box) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SAMRAI::hier::BoxContainer::hasOverlap           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>box</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Determine if a given box intersects with the <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a>. 
<p>
If this method is used multiple times on the same <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a>, it is recommended for efficiency's sake to call <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html#faa3a4f83b2f6714087926aea2d21664">makeTree()</a> on this <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a> before calling this method.<p>
This only works if all boxes in this <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a> have the same <a class="el" href="classSAMRAI_1_1hier_1_1BlockId.html">BlockId</a>, and the argument box also has that same <a class="el" href="classSAMRAI_1_1hier_1_1BlockId.html">BlockId</a>. An error will occur if these conditions are not met.<p>
<dl compact><dt><b>Returns:</b></dt><dd>True if box intersects with any member of the <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a>, false otherwise.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>box</em>&nbsp;</td><td></td></tr>
  </table>
</dl>

</div>
</div><p>
<hr><h2>Friends And Related Function Documentation</h2>
<a class="anchor" name="cf9e3e89ec00844bde233c296adf4db5"></a><!-- doxytag: member="SAMRAI::hier::BoxContainer::BoxContainerIterator" ref="cf9e3e89ec00844bde233c296adf4db5" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer_1_1BoxContainerIterator.html">BoxContainerIterator</a><code> [friend]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="b605c1f6e8e543714f20820b93d2d556"></a><!-- doxytag: member="SAMRAI::hier::BoxContainer::BoxContainerConstIterator" ref="b605c1f6e8e543714f20820b93d2d556" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer_1_1BoxContainerConstIterator.html">BoxContainerConstIterator</a><code> [friend]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<hr>The documentation for this class was generated from the following files:<ul>
<li>source/SAMRAI/hier/<a class="el" href="BoxContainer_8h.html">BoxContainer.h</a><li>source/SAMRAI/hier/<a class="el" href="BoxContainer_8C.html">BoxContainer.C</a></ul>
<hr size="1"><address style="align: right;"><small>Generated on 16 Jan 2013 for SAMRAI by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.7 </small></address>
</body>
</html>
