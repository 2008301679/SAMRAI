<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>SAMRAI: SAMRAI::solv::CellPoissonFACSolver Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath"><a class="el" href="namespaceSAMRAI.html">SAMRAI</a>::<a class="el" href="namespaceSAMRAI_1_1solv.html">solv</a>::<a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonFACSolver.html">CellPoissonFACSolver</a>
  </div>
</div>
<div class="contents">
<h1>SAMRAI::solv::CellPoissonFACSolver Class Reference</h1><!-- doxytag: class="SAMRAI::solv::CellPoissonFACSolver" -->
<p>Class for solving scalar Poisson's equation on SAMR grid, wrapping up lower-level components (FAC cycling, Poisson equation operations and boundary conditions) in a single high-level interface.  
<a href="#_details">More...</a></p>

<p><code>#include &lt;source/SAMRAI/solv/CellPoissonFACSolver.h&gt;</code></p>

<p><a href="classSAMRAI_1_1solv_1_1CellPoissonFACSolver-members.html">List of all members.</a></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonFACSolver.html#a515e2d1f0d79dfca102d027e05b4cece">CellPoissonFACSolver</a> (const <a class="el" href="classSAMRAI_1_1tbox_1_1Dimension.html">tbox::Dimension</a> &amp;dim, const std::string &amp;object_name, const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1solv_1_1FACPreconditioner.html">FACPreconditioner</a> &gt; &amp;fac_precond, const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonFACOps.html">CellPoissonFACOps</a> &gt; &amp;fac_ops, const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Database.html">tbox::Database</a> &gt; &amp;input_db=boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Database.html">tbox::Database</a> &gt;())</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Construct a solver.  <a href="#a515e2d1f0d79dfca102d027e05b4cece"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonFACSolver.html#abc2ee793aa8277c8ab6827fcb3608728">~CellPoissonFACSolver</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Destructor.  <a href="#abc2ee793aa8277c8ab6827fcb3608728"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonFACSolver.html#a3c0c29fd06d0ccc69a04aaf76d9a227e">solveSystem</a> (const int solution, const int rhs, const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchHierarchy.html">hier::PatchHierarchy</a> &gt; &amp;hierarchy, int coarse_ln=-1, int fine_ln=-1)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Solve Poisson's equation, assuming an uninitialized solver state.  <a href="#a3c0c29fd06d0ccc69a04aaf76d9a227e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonFACSolver.html#afe212d42581fa8eb90e2720a18bf4588">solveSystem</a> (const int solution, const int rhs)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Solve Poisson's equation using the current solver state set by <a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonFACSolver.html#a32daa5602688c39a0064e75ed7d0946b" title="Prepare the solver&#39;s internal state for solving.">initializeSolverState()</a>.  <a href="#afe212d42581fa8eb90e2720a18bf4588"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonFACSolver.html#a10ba8ef6e09bb7b7107d1fac2fa64357">setBoundaries</a> (const std::string &amp;boundary_type, const int fluxes=-1, const int flags=-1, int *bdry_types=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Specify the boundary conditions that are to be used at the physical domain boundary.  <a href="#a10ba8ef6e09bb7b7107d1fac2fa64357"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonFACSolver.html#a759f60c6823f3bb41770ecb245ba7061">setBcObject</a> (const <a class="el" href="classSAMRAI_1_1solv_1_1RobinBcCoefStrategy.html">RobinBcCoefStrategy</a> *bc_object)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Override internal implementation to set boundary condition coefficients with user-provided implementation.  <a href="#a759f60c6823f3bb41770ecb245ba7061"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonFACSolver.html#a32daa5602688c39a0064e75ed7d0946b">initializeSolverState</a> (const int solution, const int rhs, const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchHierarchy.html">hier::PatchHierarchy</a> &gt; &amp;hierarchy, const int coarse_level=-1, const int fine_level=-1)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Prepare the solver's internal state for solving.  <a href="#a32daa5602688c39a0064e75ed7d0946b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonFACSolver.html#a6c5f98f4b42b2446883f04752f76a95c">deallocateSolverState</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Remove the solver's internal state data.  <a href="#a6c5f98f4b42b2446883f04752f76a95c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const std::string &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonFACSolver.html#afe8f84e7a59998876d1ff2b7897f7a28">getObjectName</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the name of this object.  <a href="#afe8f84e7a59998876d1ff2b7897f7a28"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Specifying PDE parameters</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrp3832b2f5efe5082bb2c92d69c800378c"></a> </p>
<br/><br/></div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonFACSolver.html#a02e2265ae025e7a6d25f4d3c30139e8a">setDPatchDataId</a> (int id)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the patch data index for variable D.  <a href="#a02e2265ae025e7a6d25f4d3c30139e8a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonFACSolver.html#a9d832f909635027d485493549c5f15df">setDConstant</a> (double scalar)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the scalar value variable D.  <a href="#a9d832f909635027d485493549c5f15df"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonFACSolver.html#ad06fc5fe77447208383b32d020823527">setCPatchDataId</a> (int id)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the scalar value variable C.  <a href="#ad06fc5fe77447208383b32d020823527"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonFACSolver.html#a1a87be7fc6c0c22ad6a0ed6efe00c081">setCConstant</a> (double scalar)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the patch data index for variable C.  <a href="#a1a87be7fc6c0c22ad6a0ed6efe00c081"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Functions to get data on last solve.</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrp078f825dc8700dacde24990dc6c590b3"></a> </p>
<br/><br/></div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonFACSolver.html#a1473cf46923fc542b71dc67ecc2e6e9a">getNumberOfIterations</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return FAC iteration count from last (or current if there is one) FAC iteration process.  <a href="#a1473cf46923fc542b71dc67ecc2e6e9a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonFACSolver.html#a1f76649c08ddb84aa2617672e2653a62">getConvergenceFactors</a> (double &amp;avg_factor, double &amp;final_factor) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get average convergance rate and convergence rate of the last (or current if there is one) FAC solve.  <a href="#a1f76649c08ddb84aa2617672e2653a62"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonFACSolver.html#a0d95e95d2b7e26370b5cfc50964a91e1">getResidualNorm</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return residual norm from the just-completed FAC iteration.  <a href="#a0d95e95d2b7e26370b5cfc50964a91e1"></a><br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>Class for solving scalar Poisson's equation on SAMR grid, wrapping up lower-level components (FAC cycling, Poisson equation operations and boundary conditions) in a single high-level interface. </p>
<p>We solve the equation div(D grad(u)) + Cu = f where D is a side-centered array and C is a cell-centered array. u and f are also cell-centered. Boundary conditions supported are Dirichlet, Neumann and mixed (Dirichlet on some faces and Neumann on others).</p>
<p>This class is a wrapper, providing a single class that coordinates three major components: the FAC solver, the cell-centered Poisson FAC operator and a default Robin bc coefficient implelemtation. It is perfectly acceptable to use those classes outside of this class.</p>
<p>The underlying solver is an FAC solver using cell-centered discretization. The difference scheme is second-order central-difference. On coarse-fine boundaries within the solution levels, the composite grid operator uses, by default, the discretization method of Ewing, Lazarov and Vassilevski ("Local Refinement Techniques for Elliptic Problems on
 Cell-Centered Grids, I. Error Analysis", Mathematics of Computation, Vol. 56, No. 194, April 1991, pp. 437-461).</p>
<p>Typical use of this class is:</p>
<ol type="1">
<li>Construct a <a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonFACSolver.html" title="Class for solving scalar Poisson&#39;s equation on SAMR grid, wrapping up lower-level...">CellPoissonFACSolver</a> object, providing it the hierarchy and range of levels participating in the solve.</li>
<li>Set the parameters C and D using the functions named <code>setC</code>... and <code>setD</code>... By default, D=1 and C=0 everywhere.</li>
<li>Call <a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonFACSolver.html#a10ba8ef6e09bb7b7107d1fac2fa64357" title="Specify the boundary conditions that are to be used at the physical domain boundary...">setBoundaries()</a> to state the types boundary conditions, along with supplemental data for setting those boundary conditions.</li>
<li>Call <a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonFACSolver.html#a32daa5602688c39a0064e75ed7d0946b" title="Prepare the solver&#39;s internal state for solving.">initializeSolverState()</a> to set up information internal to the solver. This is step is not required but will save setup costs if you are making multiple solves. This commits the object to the current hierarchy state and the specific <em>types</em> of boundary conditions you selected, It does NOT commit to the specific <em>values</em> of the boundary condition. A hierarchy change (through adaption or other means) invalidates the state, thus you must reinitialize or <a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonFACSolver.html#a6c5f98f4b42b2446883f04752f76a95c" title="Remove the solver&#39;s internal state data.">deallocateSolverState()</a> the state before another solve.</li>
<li>Solve the equation with <a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonFACSolver.html#a3c0c29fd06d0ccc69a04aaf76d9a227e" title="Solve Poisson&#39;s equation, assuming an uninitialized solver state.">solveSystem()</a>. You provide the patch data indices for the solution u and the right hand side f. u must have at least one ghost cell and where a Dirichlet boundary condition applies, those cells must be set to the value on the boundary. If only Neumann boundary conditions are used, the ghost cell values do not matter.</li>
<li>Call <a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonFACSolver.html#a6c5f98f4b42b2446883f04752f76a95c" title="Remove the solver&#39;s internal state data.">deallocateSolverState()</a> to free up internal resources, if <a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonFACSolver.html#a32daa5602688c39a0064e75ed7d0946b" title="Prepare the solver&#39;s internal state for solving.">initializeSolverState()</a> was called before the solve.</li>
</ol>
<p>After the solve, information on the solve can be obtained by calling one of these functions:</p>
<ul>
<li><a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonFACSolver.html#a1473cf46923fc542b71dc67ecc2e6e9a" title="Return FAC iteration count from last (or current if there is one) FAC iteration process...">getNumberOfIterations()</a> gives the number of FAC cycles used.</li>
<li><a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonFACSolver.html#a1f76649c08ddb84aa2617672e2653a62" title="Get average convergance rate and convergence rate of the last (or current if there...">getConvergenceFactors()</a> gives the average and final convergence factors for the solve.</li>
<li><a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonFACSolver.html#a0d95e95d2b7e26370b5cfc50964a91e1" title="Return residual norm from the just-completed FAC iteration.">getResidualNorm()</a> gives the final residual</li>
</ul>
<p>Finer solver controls can be set using the functions in this class.</p>
<p><b> Input Parameters </b></p>
<p><b> Definitions: </b></p>
<ul>
<li><b>enable_logging</b> turn logging on or off</li>
</ul>
<p><b> Details: </b> <br/>
 </p>
<table border="1" cellspacing="3" cellpadding="3">
<tr>
<th><p>parameter </p>
</th><th><p>type </p>
</th><th><p>default </p>
</th><th><p>range </p>
</th><th><p>opt/req </p>
</th><th><p>behavior on restart  </p>
</th></tr>
<tr>
<td><p>enable_logging </p>
</td><td><p>bool </p>
</td><td><p>FALSE </p>
</td><td><p>TRUE, FALSE </p>
</td><td><p>opt </p>
</td><td><p>Not written to restart. Value in input db used.  </p>
</td></tr>
</table>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a515e2d1f0d79dfca102d027e05b4cece"></a><!-- doxytag: member="SAMRAI::solv::CellPoissonFACSolver::CellPoissonFACSolver" ref="a515e2d1f0d79dfca102d027e05b4cece" args="(const tbox::Dimension &amp;dim, const std::string &amp;object_name, const boost::shared_ptr&lt; FACPreconditioner &gt; &amp;fac_precond, const boost::shared_ptr&lt; CellPoissonFACOps &gt; &amp;fac_ops, const boost::shared_ptr&lt; tbox::Database &gt; &amp;input_db=boost::shared_ptr&lt; tbox::Database &gt;())" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SAMRAI::solv::CellPoissonFACSolver::CellPoissonFACSolver </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1tbox_1_1Dimension.html">tbox::Dimension</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>dim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>object_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1solv_1_1FACPreconditioner.html">FACPreconditioner</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>fac_precond</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonFACOps.html">CellPoissonFACOps</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>fac_ops</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Database.html">tbox::Database</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>input_db</em> = <code>boost::shared_ptr&lt;<a class="el" href="classSAMRAI_1_1tbox_1_1Database.html">tbox::Database</a>&gt;()</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Construct a solver. </p>
<p>If the database is not NULL, initial settings will be set using the database. The solver is uninitialized until <a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonFACSolver.html#a32daa5602688c39a0064e75ed7d0946b" title="Prepare the solver&#39;s internal state for solving.">initializeSolverState()</a> is called.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dim</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>object_name</em>&nbsp;</td><td>Name of object used in outputs </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>fac_precond</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>fac_ops</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>input_db</em>&nbsp;</td><td><a class="el" href="classSAMRAI_1_1tbox_1_1Database.html" title="Class Database is an abstract base class for the input, restart, and visualization...">tbox::Database</a> for initialization (may be NULL) </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="VariableDatabase_8C_source.html#l00044">SAMRAI::hier::VariableDatabase::getDatabase()</a>, <a class="el" href="Dimension_8h_source.html#l00136">SAMRAI::tbox::Dimension::getValue()</a>, <a class="el" href="VariableDatabase_8C_source.html#l00214">SAMRAI::hier::VariableDatabase::getVariable()</a>, <a class="el" href="IntVector_8h_source.html#l01130">SAMRAI::hier::IntVector::getZero()</a>, and <a class="el" href="VariableDatabase_8C_source.html#l00747">SAMRAI::hier::VariableDatabase::registerInternalSAMRAIVariable()</a>.</p>

</div>
</div>
<a class="anchor" id="abc2ee793aa8277c8ab6827fcb3608728"></a><!-- doxytag: member="SAMRAI::solv::CellPoissonFACSolver::~CellPoissonFACSolver" ref="abc2ee793aa8277c8ab6827fcb3608728" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SAMRAI::solv::CellPoissonFACSolver::~CellPoissonFACSolver </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Destructor. </p>

<p>References <a class="el" href="CellPoissonFACSolver_8C_source.html#l00242">deallocateSolverState()</a>, <a class="el" href="VariableDatabase_8C_source.html#l00044">SAMRAI::hier::VariableDatabase::getDatabase()</a>, and <a class="el" href="Dimension_8h_source.html#l00136">SAMRAI::tbox::Dimension::getValue()</a>.</p>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a3c0c29fd06d0ccc69a04aaf76d9a227e"></a><!-- doxytag: member="SAMRAI::solv::CellPoissonFACSolver::solveSystem" ref="a3c0c29fd06d0ccc69a04aaf76d9a227e" args="(const int solution, const int rhs, const boost::shared_ptr&lt; hier::PatchHierarchy &gt; &amp;hierarchy, int coarse_ln=&#45;1, int fine_ln=&#45;1)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SAMRAI::solv::CellPoissonFACSolver::solveSystem </td>
          <td>(</td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>solution</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchHierarchy.html">hier::PatchHierarchy</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>hierarchy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>coarse_ln</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>fine_ln</em> = <code>-1</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Solve Poisson's equation, assuming an uninitialized solver state. </p>
<p>Here, u is the "solution" patch data index and f is the right hand side patch data index. The return value is true if the solver converged and false otherwise.</p>
<p>This function is a wrapper. It simply initializes the solver state, call the <a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonFACSolver.html#afe212d42581fa8eb90e2720a18bf4588" title="Solve Poisson&#39;s equation using the current solver state set by initializeSolverState()...">solveSystem(const int,const int)</a> for the initialized solver then deallocates the solver state.</p>
<p>Upon return from this function, solution will contain the result of the solve.</p>
<p>See <a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonFACSolver.html#a32daa5602688c39a0064e75ed7d0946b" title="Prepare the solver&#39;s internal state for solving.">initializeSolverState()</a> for opportunities to save overhead when using multiple consecutive solves.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonFACSolver.html#afe212d42581fa8eb90e2720a18bf4588" title="Solve Poisson&#39;s equation using the current solver state set by initializeSolverState()...">solveSystem(const int,const int)</a></dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>solution</em>&nbsp;</td><td><a class="el" href="classSAMRAI_1_1hier_1_1Patch.html" title="A container for patch data objects defined over a box.">hier::Patch</a> data index for solution u </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>rhs</em>&nbsp;</td><td><a class="el" href="classSAMRAI_1_1hier_1_1Patch.html" title="A container for patch data objects defined over a box.">hier::Patch</a> data index for right hand side f </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>hierarchy</em>&nbsp;</td><td>The patch hierarchy to solve on </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>coarse_ln</em>&nbsp;</td><td>The coarsest level in the solve. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>fine_ln</em>&nbsp;</td><td>The finest level in the solve.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>whether solver converged to specified level</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonFACSolver.html#a32daa5602688c39a0064e75ed7d0946b" title="Prepare the solver&#39;s internal state for solving.">initializeSolverState</a></dd></dl>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>hierarchy </dd>
<dd>
d_dim == hierarchy-&gt;getDim() </dd>
<dd>
!d_solver_is_initialized </dd></dl>

<p>References <a class="el" href="CellPoissonFACSolver_8C_source.html#l00242">deallocateSolverState()</a>, <a class="el" href="CellPoissonFACSolver_8C_source.html#l00169">initializeSolverState()</a>, <a class="el" href="namespaceSAMRAI_1_1tbox.html#ab84041705493761fb17a8127e3a2dca2">SAMRAI::tbox::plog</a>, <a class="el" href="PoissonSpecifications_8C_source.html#l00058">SAMRAI::solv::PoissonSpecifications::printClassData()</a>, <a class="el" href="Utilities_8h_source.html#l00110">TBOX_ASSERT</a>, <a class="el" href="Utilities_8h_source.html#l00233">TBOX_ASSERT_DIM_OBJDIM_EQUALITY1</a>, and <a class="el" href="Utilities_8h_source.html#l00060">TBOX_ERROR</a>.</p>

</div>
</div>
<a class="anchor" id="afe212d42581fa8eb90e2720a18bf4588"></a><!-- doxytag: member="SAMRAI::solv::CellPoissonFACSolver::solveSystem" ref="afe212d42581fa8eb90e2720a18bf4588" args="(const int solution, const int rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SAMRAI::solv::CellPoissonFACSolver::solveSystem </td>
          <td>(</td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>solution</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Solve Poisson's equation using the current solver state set by <a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonFACSolver.html#a32daa5602688c39a0064e75ed7d0946b" title="Prepare the solver&#39;s internal state for solving.">initializeSolverState()</a>. </p>
<p>When the solver state has been initialized, this function may be called repeadedly with different values on the rhs. There is some cost savings for multiple solves when this is done.</p>
<p>Before calling this function, the solution and right-hand-side quantities should be set properly by the user on all patch interiors on the range of levels covered by the FAC iteration. All data for these patch data index should be allocated. Thus, the user is responsible for managing the storage for the solution and right-hand-side.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>whether solver converged to specified level</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd>solveSystem( const int, const int, boost::shared_ptr&lt; hier::PatchHierarchy &gt;, int, int);</dd></dl>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>d_solver_is_initialized </dd>
<dd>
(solution &gt;= 0) || (rhs &gt;= 0) </dd></dl>

<p>References <a class="el" href="SimpleCellRobinBcCoefs_8C_source.html#l00513">SAMRAI::solv::SimpleCellRobinBcCoefs::cacheDirichletData()</a>, <a class="el" href="SimpleCellRobinBcCoefs_8C_source.html#l00598">SAMRAI::solv::SimpleCellRobinBcCoefs::restoreDirichletData()</a>, and <a class="el" href="Utilities_8h_source.html#l00060">TBOX_ERROR</a>.</p>

</div>
</div>
<a class="anchor" id="a10ba8ef6e09bb7b7107d1fac2fa64357"></a><!-- doxytag: member="SAMRAI::solv::CellPoissonFACSolver::setBoundaries" ref="a10ba8ef6e09bb7b7107d1fac2fa64357" args="(const std::string &amp;boundary_type, const int fluxes=&#45;1, const int flags=&#45;1, int *bdry_types=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::solv::CellPoissonFACSolver::setBoundaries </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>boundary_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>fluxes</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>flags</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>bdry_types</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Specify the boundary conditions that are to be used at the physical domain boundary. </p>
<p>This method is used to set up the default <a class="el" href="classSAMRAI_1_1solv_1_1SimpleCellRobinBcCoefs.html" title="A prefabricated Robin boundary condition coefficients with an interface like the...">SimpleCellRobinBcCoefs</a> object for specifying boundary conditions. Note that you may alternatively provide your own implementation of the Robin boundary condition coefficients using the <a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonFACSolver.html#a759f60c6823f3bb41770ecb245ba7061" title="Override internal implementation to set boundary condition coefficients with user-provided...">setBcObject()</a> method.</p>
<p>The boundary conditions specified as the std::string argument "boundary_type." The boundary type argument can be "Dirichlet", "Neumann", or "Mixed".</p>
<p>If using Dirichlet boundary conditions, then before the solver is called, the storage for the unknown u must have a box_level of ghost cells at least one cell wide that includes the Dirichlet boundary values.</p>
<p>If using Neumann boundary conditions, then before the solver is called, the outerface boundary flux data must be set for the Neumann conditions. The fluxes argument gives the patch data index of this flux data.</p>
<p>The mixed boundary type is for a mixture of Dirichlet and Neumann boundary conditions are used at the physical domain boundary. The fluxes argument gives the patch data index of the outerface data that specifies the flux data for the Neumann conditions. The flags array is an outerface data array of integer flags that specifies whether Dirichlet (flag == zero) or Neumann (flag == one) conditions are to be used at a particular cell boundary face. Note that the flag data must be set before the matrix entries can be computed and the flux data must be set before the solver is called. The bdry_types argument can be used if the boundary conditions are mixed but one or more of the faces of the physical boundary are entirely either Dirichlet or Neumann boundaries. The bdry_types argument should be an array of 2*DIM integers, specifying the boundary conditions on each side of the physical domain. It should be ordered {x_lo, x_hi, y_lo, y_hi, z_lo, z_hi}, with the values for each face being 0 for Dirichlet conditions, 1 for Neumann conditions, and 2 for mixed boundary conditions. The bdry_type argument is never required, but if used it can sometimes make the PoissonHYPRESolver class more efficient.</p>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>(d_bc_object == 0) || (d_bc_object == &amp;d_simple_bc) </dd></dl>

<p>References <a class="el" href="SimpleCellRobinBcCoefs_8C_source.html#l00088">SAMRAI::solv::SimpleCellRobinBcCoefs::setBoundaries()</a>, and <a class="el" href="Utilities_8h_source.html#l00060">TBOX_ERROR</a>.</p>

</div>
</div>
<a class="anchor" id="a759f60c6823f3bb41770ecb245ba7061"></a><!-- doxytag: member="SAMRAI::solv::CellPoissonFACSolver::setBcObject" ref="a759f60c6823f3bb41770ecb245ba7061" args="(const RobinBcCoefStrategy *bc_object)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::solv::CellPoissonFACSolver::setBcObject </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1solv_1_1RobinBcCoefStrategy.html">RobinBcCoefStrategy</a> *&nbsp;</td>
          <td class="paramname"> <em>bc_object</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Override internal implementation to set boundary condition coefficients with user-provided implementation. </p>
<p>This function is used to override the default internal object for setting Robin boundary condition coefficients. You should override when you need to avoid the limitations of the <a class="el" href="classSAMRAI_1_1solv_1_1SimpleCellRobinBcCoefs.html" title="A prefabricated Robin boundary condition coefficients with an interface like the...">SimpleCellRobinBcCoefs</a> class or you prefer to use your own implementation.</p>
<p>Note that an important limitation of the <a class="el" href="classSAMRAI_1_1solv_1_1SimpleCellRobinBcCoefs.html" title="A prefabricated Robin boundary condition coefficients with an interface like the...">SimpleCellRobinBcCoefs</a> class is the inability to support linear interpolation in the prolongation step.</p>
<p>Once the boundary condition object is overwritten by this method, you must no longer call the <a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonFACSolver.html#a10ba8ef6e09bb7b7107d1fac2fa64357" title="Specify the boundary conditions that are to be used at the physical domain boundary...">setBoundaries()</a> method.</p>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>bc_object </dd></dl>

<p>References <a class="el" href="Utilities_8h_source.html#l00060">TBOX_ERROR</a>.</p>

</div>
</div>
<a class="anchor" id="a02e2265ae025e7a6d25f4d3c30139e8a"></a><!-- doxytag: member="SAMRAI::solv::CellPoissonFACSolver::setDPatchDataId" ref="a02e2265ae025e7a6d25f4d3c30139e8a" args="(int id)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::solv::CellPoissonFACSolver::setDPatchDataId </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>id</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set the patch data index for variable D. </p>
<p>In addition, disregard any previous D specified by <a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonFACSolver.html#a9d832f909635027d485493549c5f15df" title="Set the scalar value variable D.">setDConstant()</a>. </p>

<p>References <a class="el" href="PoissonSpecifications_8h_source.html#l00102">SAMRAI::solv::PoissonSpecifications::setDPatchDataId()</a>.</p>

</div>
</div>
<a class="anchor" id="a9d832f909635027d485493549c5f15df"></a><!-- doxytag: member="SAMRAI::solv::CellPoissonFACSolver::setDConstant" ref="a9d832f909635027d485493549c5f15df" args="(double scalar)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::solv::CellPoissonFACSolver::setDConstant </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>scalar</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set the scalar value variable D. </p>
<p>In addition, disregard any previous D specified by <a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonFACSolver.html#a02e2265ae025e7a6d25f4d3c30139e8a" title="Set the patch data index for variable D.">setDPatchDataId()</a>. </p>

<p>References <a class="el" href="PoissonSpecifications_8h_source.html#l00121">SAMRAI::solv::PoissonSpecifications::setDConstant()</a>.</p>

</div>
</div>
<a class="anchor" id="ad06fc5fe77447208383b32d020823527"></a><!-- doxytag: member="SAMRAI::solv::CellPoissonFACSolver::setCPatchDataId" ref="ad06fc5fe77447208383b32d020823527" args="(int id)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::solv::CellPoissonFACSolver::setCPatchDataId </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>id</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set the scalar value variable C. </p>
<p>In addition, disregard any previous C specified by <a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonFACSolver.html#a1a87be7fc6c0c22ad6a0ed6efe00c081" title="Set the patch data index for variable C.">setCConstant()</a>. </p>

<p>References <a class="el" href="PoissonSpecifications_8h_source.html#l00205">SAMRAI::solv::PoissonSpecifications::setCPatchDataId()</a>.</p>

</div>
</div>
<a class="anchor" id="a1a87be7fc6c0c22ad6a0ed6efe00c081"></a><!-- doxytag: member="SAMRAI::solv::CellPoissonFACSolver::setCConstant" ref="a1a87be7fc6c0c22ad6a0ed6efe00c081" args="(double scalar)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::solv::CellPoissonFACSolver::setCConstant </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>scalar</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set the patch data index for variable C. </p>
<p>In addition, disregard any previous C specified by <a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonFACSolver.html#a1a87be7fc6c0c22ad6a0ed6efe00c081" title="Set the patch data index for variable C.">setCConstant()</a>. </p>

<p>References <a class="el" href="PoissonSpecifications_8h_source.html#l00228">SAMRAI::solv::PoissonSpecifications::setCConstant()</a>, and <a class="el" href="PoissonSpecifications_8h_source.html#l00244">SAMRAI::solv::PoissonSpecifications::setCZero()</a>.</p>

</div>
</div>
<a class="anchor" id="a32daa5602688c39a0064e75ed7d0946b"></a><!-- doxytag: member="SAMRAI::solv::CellPoissonFACSolver::initializeSolverState" ref="a32daa5602688c39a0064e75ed7d0946b" args="(const int solution, const int rhs, const boost::shared_ptr&lt; hier::PatchHierarchy &gt; &amp;hierarchy, const int coarse_level=&#45;1, const int fine_level=&#45;1)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::solv::CellPoissonFACSolver::initializeSolverState </td>
          <td>(</td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>solution</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchHierarchy.html">hier::PatchHierarchy</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>hierarchy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>coarse_level</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>fine_level</em> = <code>-1</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Prepare the solver's internal state for solving. </p>
<p>In the interest of efficiency, this class may prepare and cache some hierarchy-dependent objects. Though it is not required, initializing the solver state makes for greater efficiency when you are doing multiple solves on the same system of equation. If you do not initialize the state, it is initialized and deallocated each time you call <a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonFACSolver.html#afe212d42581fa8eb90e2720a18bf4588" title="Solve Poisson&#39;s equation using the current solver state set by initializeSolverState()...">solveSystem(const int, const int)</a>. The state must be reinitialized if the hierarchy or a boundary condition type changes.</p>
<p>To unset the data set in this function, see <a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonFACSolver.html#a6c5f98f4b42b2446883f04752f76a95c" title="Remove the solver&#39;s internal state data.">deallocateSolverState()</a>.</p>
<p>The <code>solution</code> and <code>rhs</code> patch data indices in the argument list are used to determine the <em>form</em> of the data you plan to use in the solve. They need not be the same data you solve on, but they should be similar. Both must represent cell-centered double data. The solution must have at least one ghost cell width, though this is not checked in the initialize phase, because data is not required yet.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>solution</em>&nbsp;</td><td>solution patch data index for u </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>rhs</em>&nbsp;</td><td>right hand side patch data index for f </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>hierarchy</em>&nbsp;</td><td>The patch hierarchy to solve on </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>coarse_level</em>&nbsp;</td><td>The coarsest level in the solve </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>fine_level</em>&nbsp;</td><td>The finest level in the solve</td></tr>
  </table>
  </dd>
</dl>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>hierarchy </dd>
<dd>
d_dim == hierarchy-&gt;getDim() </dd>
<dd>
d_bc_object != 0 </dd>
<dd>
(solution &gt;= 0) || (rhs &gt;= 0) </dd></dl>

<p>References <a class="el" href="PoissonSpecifications_8h_source.html#l00146">SAMRAI::solv::PoissonSpecifications::dIsConstant()</a>, <a class="el" href="PoissonSpecifications_8h_source.html#l00181">SAMRAI::solv::PoissonSpecifications::getDConstant()</a>, <a class="el" href="PoissonSpecifications_8h_source.html#l00161">SAMRAI::solv::PoissonSpecifications::getDPatchDataId()</a>, <a class="el" href="Dimension_8h_source.html#l00136">SAMRAI::tbox::Dimension::getValue()</a>, <a class="el" href="SimpleCellRobinBcCoefs_8h_source.html#l00253">SAMRAI::solv::SimpleCellRobinBcCoefs::setDiffusionCoefConstant()</a>, <a class="el" href="SimpleCellRobinBcCoefs_8h_source.html#l00236">SAMRAI::solv::SimpleCellRobinBcCoefs::setDiffusionCoefId()</a>, <a class="el" href="SimpleCellRobinBcCoefs_8C_source.html#l00059">SAMRAI::solv::SimpleCellRobinBcCoefs::setHierarchy()</a>, <a class="el" href="Utilities_8h_source.html#l00110">TBOX_ASSERT</a>, <a class="el" href="Utilities_8h_source.html#l00233">TBOX_ASSERT_DIM_OBJDIM_EQUALITY1</a>, and <a class="el" href="Utilities_8h_source.html#l00060">TBOX_ERROR</a>.</p>

<p>Referenced by <a class="el" href="CellPoissonFACSolver_8C_source.html#l00361">solveSystem()</a>.</p>

</div>
</div>
<a class="anchor" id="a6c5f98f4b42b2446883f04752f76a95c"></a><!-- doxytag: member="SAMRAI::solv::CellPoissonFACSolver::deallocateSolverState" ref="a6c5f98f4b42b2446883f04752f76a95c" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::solv::CellPoissonFACSolver::deallocateSolverState </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Remove the solver's internal state data. </p>
<p>Remove all hierarchy-dependent data set by initializeSolverState. It is safe to call <a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonFACSolver.html#a6c5f98f4b42b2446883f04752f76a95c" title="Remove the solver&#39;s internal state data.">deallocateSolverState()</a> even state is already deallocated, but nothing is done in that case.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonFACSolver.html#a32daa5602688c39a0064e75ed7d0946b" title="Prepare the solver&#39;s internal state for solving.">initializeSolverState()</a> </dd></dl>

<p>References <a class="el" href="Dimension_8h_source.html#l00136">SAMRAI::tbox::Dimension::getValue()</a>.</p>

<p>Referenced by <a class="el" href="CellPoissonFACSolver_8C_source.html#l00361">solveSystem()</a>, and <a class="el" href="CellPoissonFACSolver_8C_source.html#l00119">~CellPoissonFACSolver()</a>.</p>

</div>
</div>
<a class="anchor" id="a1473cf46923fc542b71dc67ecc2e6e9a"></a><!-- doxytag: member="SAMRAI::solv::CellPoissonFACSolver::getNumberOfIterations" ref="a1473cf46923fc542b71dc67ecc2e6e9a" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int SAMRAI::solv::CellPoissonFACSolver::getNumberOfIterations </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return FAC iteration count from last (or current if there is one) FAC iteration process. </p>

</div>
</div>
<a class="anchor" id="a1f76649c08ddb84aa2617672e2653a62"></a><!-- doxytag: member="SAMRAI::solv::CellPoissonFACSolver::getConvergenceFactors" ref="a1f76649c08ddb84aa2617672e2653a62" args="(double &amp;avg_factor, double &amp;final_factor) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::solv::CellPoissonFACSolver::getConvergenceFactors </td>
          <td>(</td>
          <td class="paramtype">double &amp;&nbsp;</td>
          <td class="paramname"> <em>avg_factor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&nbsp;</td>
          <td class="paramname"> <em>final_factor</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get average convergance rate and convergence rate of the last (or current if there is one) FAC solve. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>avg_factor</em>&nbsp;</td><td>average convergence factor over current FAC cycles </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>final_factor</em>&nbsp;</td><td>convergence factor of the last FAC cycle </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0d95e95d2b7e26370b5cfc50964a91e1"></a><!-- doxytag: member="SAMRAI::solv::CellPoissonFACSolver::getResidualNorm" ref="a0d95e95d2b7e26370b5cfc50964a91e1" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double SAMRAI::solv::CellPoissonFACSolver::getResidualNorm </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return residual norm from the just-completed FAC iteration. </p>
<p>The norm return value is computed as the maximum norm over all patch levels involved in the solve. The value corresponds to the norm applied in the user-defined residual computation.</p>
<p>The latest computed norm is the one returned. </p>

</div>
</div>
<a class="anchor" id="afe8f84e7a59998876d1ff2b7897f7a28"></a><!-- doxytag: member="SAMRAI::solv::CellPoissonFACSolver::getObjectName" ref="afe8f84e7a59998876d1ff2b7897f7a28" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::string&amp; SAMRAI::solv::CellPoissonFACSolver::getObjectName </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the name of this object. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>The name of this object. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>source/SAMRAI/solv/<a class="el" href="CellPoissonFACSolver_8h.html">CellPoissonFACSolver.h</a></li>
<li>source/SAMRAI/solv/<a class="el" href="CellPoissonFACSolver_8C.html">CellPoissonFACSolver.C</a></li>
</ul>
</div>
<hr size="1"/><address style="text-align: right;"><small>Generated on 21 Jan 2016 for SAMRAI by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.1 </small></address>
</body>
</html>
