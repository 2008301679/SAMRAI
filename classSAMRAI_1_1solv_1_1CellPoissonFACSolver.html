<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>SAMRAI: SAMRAI::solv::CellPoissonFACSolver Class Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.7 -->
<div class="tabs">
  <ul>
    <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="namespaces.html"><span>Namespaces</span></a></li>
    <li id="current"><a href="annotated.html"><span>Classes</span></a></li>
    <li><a href="files.html"><span>Files</span></a></li>
    <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
  </ul></div>
<div class="tabs">
  <ul>
    <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
    <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
    <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
  </ul></div>
<div class="nav">
<a class="el" href="namespaceSAMRAI.html">SAMRAI</a>::<a class="el" href="namespaceSAMRAI_1_1solv.html">solv</a>::<a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonFACSolver.html">CellPoissonFACSolver</a></div>
<h1>SAMRAI::solv::CellPoissonFACSolver Class Reference</h1><!-- doxytag: class="SAMRAI::solv::CellPoissonFACSolver" -->Class for solving scalar Poisson's equation on SAMR grid, wrapping up lower-level components (FAC cycling, Poisson equation operations and boundary conditions) in a single high-level interface.  
<a href="#_details">More...</a>
<p>
<code>#include &lt;source/SAMRAI/solv/CellPoissonFACSolver.h&gt;</code>
<p>
<a href="classSAMRAI_1_1solv_1_1CellPoissonFACSolver-members.html">List of all members.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonFACSolver.html#24b917173ba66d851c45ae4e1d9de14a">CellPoissonFACSolver</a> (const <a class="el" href="classSAMRAI_1_1tbox_1_1Dimension.html">tbox::Dimension</a> &amp;dim, const std::string &amp;object_name, const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Database.html">tbox::Database</a> &gt; &amp;database=boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Database.html">tbox::Database</a> &gt;())</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Construct a solver.  <a href="#24b917173ba66d851c45ae4e1d9de14a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonFACSolver.html#64ceaaebaecc22cc229e9af7dcfa5e70">~CellPoissonFACSolver</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Destructor.  <a href="#64ceaaebaecc22cc229e9af7dcfa5e70"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonFACSolver.html#1a53dd35c21b776b65d20355a4003cd7">enableLogging</a> (bool logging)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Enable logging.  <a href="#1a53dd35c21b776b65d20355a4003cd7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonFACSolver.html#2a957bb187d3b63c5fe717dd2d830a79">solveSystem</a> (const int solution, const int rhs, const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchHierarchy.html">hier::PatchHierarchy</a> &gt; &amp;hierarchy, int coarse_ln=-1, int fine_ln=-1)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Solve Poisson's equation, assuming an uninitialized solver state.  <a href="#2a957bb187d3b63c5fe717dd2d830a79"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonFACSolver.html#aac02784e9cbcb1aac14e3200c6ec45b">solveSystem</a> (const int solution, const int rhs)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Solve Poisson's equation using the current solver state set by <a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonFACSolver.html#a307091f8fc0501fcef233fa8cf7a817">initializeSolverState()</a>.  <a href="#aac02784e9cbcb1aac14e3200c6ec45b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonFACSolver.html#dce4cbfccddba8482bb4513ed369cffb">setBoundaries</a> (const std::string &amp;boundary_type, const int fluxes=-1, const int flags=-1, int *bdry_types=NULL)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Specify the boundary conditions that are to be used at the physical domain boundary.  <a href="#dce4cbfccddba8482bb4513ed369cffb"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonFACSolver.html#c48d798320cedd1a0761b00666882bce">setBcObject</a> (const <a class="el" href="classSAMRAI_1_1solv_1_1RobinBcCoefStrategy.html">RobinBcCoefStrategy</a> *bc_object)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Override internal implementation to set boundary condition coefficients with user-provided implementation.  <a href="#c48d798320cedd1a0761b00666882bce"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonFACSolver.html#a307091f8fc0501fcef233fa8cf7a817">initializeSolverState</a> (const int solution, const int rhs, const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchHierarchy.html">hier::PatchHierarchy</a> &gt; &amp;hierarchy, const int coarse_level=-1, const int fine_level=-1)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Prepare the solver's internal state for solving.  <a href="#a307091f8fc0501fcef233fa8cf7a817"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonFACSolver.html#29641296b35a31d68627c52bfd5371f0">deallocateSolverState</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Remove the solver's internal state data.  <a href="#29641296b35a31d68627c52bfd5371f0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">const std::string &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonFACSolver.html#d68aff6e5610391b028d44ed5bac5f8e">getObjectName</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the name of this object.  <a href="#d68aff6e5610391b028d44ed5bac5f8e"></a><br></td></tr>
<tr><td colspan="2"><div class="groupHeader">Specifying PDE parameters</div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonFACSolver.html#ebc803b1d2016fb8cce53a679ea07c7a">setDPatchDataId</a> (int id)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the patch data index for variable D.  <a href="#ebc803b1d2016fb8cce53a679ea07c7a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonFACSolver.html#88743b1fa623d1344724fba7533487a3">setDConstant</a> (double scalar)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the scalar value variable D.  <a href="#88743b1fa623d1344724fba7533487a3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonFACSolver.html#81cd4ff98db2648352f0e230f8ebf301">setCPatchDataId</a> (int id)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the scalar value variable C.  <a href="#81cd4ff98db2648352f0e230f8ebf301"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonFACSolver.html#dfdb55e97439fe7172da4e397789060a">setCConstant</a> (double scalar)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the patch data index for variable C.  <a href="#dfdb55e97439fe7172da4e397789060a"></a><br></td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonFACSolver.html#1888facbf5428b887c41f61291945528">setCoarsestLevelSolverChoice</a> (const std::string &amp;choice)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set coarse level solver.  <a href="#1888facbf5428b887c41f61291945528"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonFACSolver.html#9ae6cf394d3e92da088718923a8ed9c8">setCoarsestLevelSolverTolerance</a> (double tol)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set tolerance for coarse level solve.  <a href="#9ae6cf394d3e92da088718923a8ed9c8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonFACSolver.html#c17f9500ad33f6f91a912d073cb0e00c">setCoarsestLevelSolverMaxIterations</a> (int max_iterations)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set max iterations for coarse level solve.  <a href="#c17f9500ad33f6f91a912d073cb0e00c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonFACSolver.html#299fa193b2c6236119cba88ff7ccf0f0">setUseSMG</a> (bool use_smg)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set whether to use HYPRe's PFMG algorithm instead of the SMG algorithm.  <a href="#299fa193b2c6236119cba88ff7ccf0f0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonFACSolver.html#07411d1dae611abb3e87b93ea9329058">setCoarseFineDiscretization</a> (const std::string &amp;coarsefine_method)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the coarse-fine boundary discretization method.  <a href="#07411d1dae611abb3e87b93ea9329058"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonFACSolver.html#4051286a90b49e8cdef05cda287360a6">setProlongationMethod</a> (const std::string &amp;prolongation_method)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the name of the prolongation method.  <a href="#4051286a90b49e8cdef05cda287360a6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonFACSolver.html#b2b2ad1245fc78aa4a885edfc2ad2135">setPresmoothingSweeps</a> (int num_pre_sweeps)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the number of pre-smoothing sweeps during FAC iteration process.  <a href="#b2b2ad1245fc78aa4a885edfc2ad2135"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonFACSolver.html#dd1bb32372d25357303d12d51f604655">setPostsmoothingSweeps</a> (int num_post_sweeps)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the number of post-smoothing sweeps during FAC iteration process.  <a href="#dd1bb32372d25357303d12d51f604655"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonFACSolver.html#2756a57368bf09c129786f1fe9334118">setMaxCycles</a> (int max_cycles)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the max number of iterations (cycles) to use per solve.  <a href="#2756a57368bf09c129786f1fe9334118"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonFACSolver.html#ac7da779cd9270a552a49c7795aafdb1">setResidualTolerance</a> (double residual_tol)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the residual tolerance for stopping.  <a href="#ac7da779cd9270a552a49c7795aafdb1"></a><br></td></tr>
<tr><td colspan="2"><div class="groupHeader">Functions to get data on last solve.</div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonFACSolver.html#aebd721a089d38a1e2b64362909fff80">getNumberOfIterations</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return FAC iteration count from last (or current if there is one) FAC iteration process.  <a href="#aebd721a089d38a1e2b64362909fff80"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonFACSolver.html#d039daa0ba1472a87429fc6216889a08">getConvergenceFactors</a> (double &amp;avg_factor, double &amp;final_factor) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get average convergance rate and convergence rate of the last (or current if there is one) FAC solve.  <a href="#d039daa0ba1472a87429fc6216889a08"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonFACSolver.html#9368b2be26b1b09591766c675f799140">getResidualNorm</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return residual norm from the just-completed FAC iteration.  <a href="#9368b2be26b1b09591766c675f799140"></a><br></td></tr>
</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
Class for solving scalar Poisson's equation on SAMR grid, wrapping up lower-level components (FAC cycling, Poisson equation operations and boundary conditions) in a single high-level interface. 
<p>
Note: this class provides a backward-compatible interface to the soon-to-be obsolete PoissonHierarchySolver&lt;DIM&gt; class. Although this class hides the lower-level components (FAC cycling, Poisson equation operations and boundary conditions), it is perfectly acceptable to use those lower-level components directly.<p>
We solve the equation div(D grad(u)) + Cu = f where D is a side-centered array and C is a cell-centered array. u and f are also cell-centered. Boundary conditions supported are Dirichlet, Neumann and mixed (Dirichlet on some faces and Neumann on others).<p>
This class is a wrapper, providing a single class that coordinates three major components: the FAC solver, the cell-centered Poisson FAC operator and a default Robin bc coefficient implelemtation. It is perfectly acceptable to use those classes outside of this class.<p>
The underlying solver is an FAC solver using cell-centered discretization. The difference scheme is second-order central-difference. On coarse-fine boundaries within the solution levels, the composite grid operator uses, by default, the discretization method of Ewing, Lazarov and Vassilevski ("Local Refinement Techniques for Elliptic Problems on Cell-Centered Grids, I. Error Analysis", Mathematics of Computation, Vol. 56, No. 194, April 1991, pp. 437-461).<p>
Typical use of this class is:<ol type=1>
<li>Construct a <a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonFACSolver.html">CellPoissonFACSolver</a> object, providing it the hierarchy and range of levels participating in the solve.</li><li>Set the parameters C and D using the functions named <code>setC</code>... and <code>setD</code>... By default, D=1 and C=0 everywhere.</li><li>Call <a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonFACSolver.html#dce4cbfccddba8482bb4513ed369cffb">setBoundaries()</a> to state the types boundary conditions, along with supplemental data for setting those boundary conditions.</li><li>Call <a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonFACSolver.html#a307091f8fc0501fcef233fa8cf7a817">initializeSolverState()</a> to set up information internal to the solver. This is step is not required but will save setup costs if you are making multiple solves. This commits the object to the current hierarchy state and the specific <em>types</em> of boundary conditions you selected, It does NOT commit to the specific <em>values</em> of the boundary condition. A hierarchy change (through adaption or other means) invalidates the state, thus you must reinitialize or <a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonFACSolver.html#29641296b35a31d68627c52bfd5371f0">deallocateSolverState()</a> the state before another solve.</li><li>Solve the equation with <a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonFACSolver.html#2a957bb187d3b63c5fe717dd2d830a79">solveSystem()</a>. You provide the patch data indices for the solution u and the right hand side f. u must have at least one ghost cell and where a Dirichlet boundary condition applies, those cells must be set to the value on the boundary. If only Neumann boundary conditions are used, the ghost cell values do not matter.</li><li>Call <a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonFACSolver.html#29641296b35a31d68627c52bfd5371f0">deallocateSolverState()</a> to free up internal resources, if <a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonFACSolver.html#a307091f8fc0501fcef233fa8cf7a817">initializeSolverState()</a> was called before the solve.</li></ol>
<p>
After the solve, information on the solve can be obtained by calling one of these functions:<ul>
<li><a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonFACSolver.html#aebd721a089d38a1e2b64362909fff80">getNumberOfIterations()</a> gives the number of FAC cycles used.</li><li><a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonFACSolver.html#d039daa0ba1472a87429fc6216889a08">getConvergenceFactors()</a> gives the average and final convergence factors for the solve.</li><li><a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonFACSolver.html#9368b2be26b1b09591766c675f799140">getResidualNorm()</a> gives the final residual</li></ul>
<p>
Finer solver controls can be set using the functions in this class.<p>
Object of this class can be set using input databases. The following parameters can be set. Each is shown with its default value in the case where hypre is used. <div class="fragment"><pre class="fragment"> * enable_logging = TRUE // Bool flag to switch logging on/off
 * max_cycles = 10       // Integer number of max FAC cycles to use
 * residual_tol = 1.e-6  // Residual tolerance to solve for
 * num_pre_sweeps = 1    // Number of presmoothing sweeps to use
 * num_post_sweeps = 1   // Number of postsmoothing sweeps to use
 * coarse_fine_discretization = "Ewing" // Name of coarse-fine discretization
 * prolongation_method = "CONSTANT_REFINE" // Name of prolongation method
 * coarse_solver_choice = "hypre"  // Name of coarse level solver
 * coarse_solver_tolerance = 1e-10 // Coarse level tolerance
 * coarse_solver_max_iterations = 20 // Coarse level max iterations
 * use_smg = "FALSE"     // Whether to use hypre's smg solver
 *                       // (alternative is the pfmg solver)
 * </pre></div> 
<p>
<hr><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" name="24b917173ba66d851c45ae4e1d9de14a"></a><!-- doxytag: member="SAMRAI::solv::CellPoissonFACSolver::CellPoissonFACSolver" ref="24b917173ba66d851c45ae4e1d9de14a" args="(const tbox::Dimension &amp;dim, const std::string &amp;object_name, const boost::shared_ptr&lt; tbox::Database &gt; &amp;database=boost::shared_ptr&lt; tbox::Database &gt;())" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SAMRAI::solv::CellPoissonFACSolver::CellPoissonFACSolver           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1tbox_1_1Dimension.html">tbox::Dimension</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>dim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>object_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Database.html">tbox::Database</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>database</em> = <code>boost::shared_ptr&lt;&nbsp;<a class="el" href="classSAMRAI_1_1tbox_1_1Database.html">tbox::Database</a>&nbsp;&gt;()</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Construct a solver. 
<p>
If the database is not NULL, initial settings will be set using the database. The solver is uninitialized until <a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonFACSolver.html#a307091f8fc0501fcef233fa8cf7a817">initializeSolverState()</a> is called.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dim</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>object_name</em>&nbsp;</td><td>Name of object used in outputs </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>database</em>&nbsp;</td><td><a class="el" href="classSAMRAI_1_1tbox_1_1Database.html">tbox::Database</a> for initialization (may be NULL) </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="64ceaaebaecc22cc229e9af7dcfa5e70"></a><!-- doxytag: member="SAMRAI::solv::CellPoissonFACSolver::~CellPoissonFACSolver" ref="64ceaaebaecc22cc229e9af7dcfa5e70" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SAMRAI::solv::CellPoissonFACSolver::~CellPoissonFACSolver           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Destructor. 
<p>

</div>
</div><p>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="1a53dd35c21b776b65d20355a4003cd7"></a><!-- doxytag: member="SAMRAI::solv::CellPoissonFACSolver::enableLogging" ref="1a53dd35c21b776b65d20355a4003cd7" args="(bool logging)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::solv::CellPoissonFACSolver::enableLogging           </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>logging</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Enable logging. 
<p>
To disable, pass in <code>false</code>. 
</div>
</div><p>
<a class="anchor" name="2a957bb187d3b63c5fe717dd2d830a79"></a><!-- doxytag: member="SAMRAI::solv::CellPoissonFACSolver::solveSystem" ref="2a957bb187d3b63c5fe717dd2d830a79" args="(const int solution, const int rhs, const boost::shared_ptr&lt; hier::PatchHierarchy &gt; &amp;hierarchy, int coarse_ln=-1, int fine_ln=-1)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SAMRAI::solv::CellPoissonFACSolver::solveSystem           </td>
          <td>(</td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>solution</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchHierarchy.html">hier::PatchHierarchy</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>hierarchy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>coarse_ln</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>fine_ln</em> = <code>-1</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Solve Poisson's equation, assuming an uninitialized solver state. 
<p>
Here, u is the "solution" patch data index and f is the right hand side patch data index. The return value is true if the solver converged and false otherwise.<p>
This function is a wrapper. It simply initializes the solver state, call the <a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonFACSolver.html#aac02784e9cbcb1aac14e3200c6ec45b">solveSystem(const int,const int)</a> for the initialized solver then deallocates the solver state.<p>
Upon return from this function, solution will contain the result of the solve.<p>
See <a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonFACSolver.html#a307091f8fc0501fcef233fa8cf7a817">initializeSolverState()</a> for opportunities to save overhead when using multiple consecutive solves.<p>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonFACSolver.html#aac02784e9cbcb1aac14e3200c6ec45b">solveSystem(const int,const int)</a></dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>solution</em>&nbsp;</td><td><a class="el" href="classSAMRAI_1_1hier_1_1Patch.html">hier::Patch</a> data index for solution u </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>rhs</em>&nbsp;</td><td><a class="el" href="classSAMRAI_1_1hier_1_1Patch.html">hier::Patch</a> data index for right hand side f </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>hierarchy</em>&nbsp;</td><td>The patch hierarchy to solve on </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>coarse_ln</em>&nbsp;</td><td>The coarsest level in the solve. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>fine_ln</em>&nbsp;</td><td>The finest level in the solve.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>whether solver converged to specified level</dd></dl>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonFACSolver.html#a307091f8fc0501fcef233fa8cf7a817">initializeSolverState</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="aac02784e9cbcb1aac14e3200c6ec45b"></a><!-- doxytag: member="SAMRAI::solv::CellPoissonFACSolver::solveSystem" ref="aac02784e9cbcb1aac14e3200c6ec45b" args="(const int solution, const int rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SAMRAI::solv::CellPoissonFACSolver::solveSystem           </td>
          <td>(</td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>solution</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Solve Poisson's equation using the current solver state set by <a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonFACSolver.html#a307091f8fc0501fcef233fa8cf7a817">initializeSolverState()</a>. 
<p>
When the solver state has been initialized, this function may be called repeadedly with different values on the rhs. There is some cost savings for multiple solves when this is done.<p>
Before calling this function, the solution and right-hand-side quantities should be set properly by the user on all patch interiors on the range of levels covered by the FAC iteration. All data for these patch data index should be allocated. Thus, the user is responsible for managing the storage for the solution and right-hand-side.<p>
<dl compact><dt><b>Returns:</b></dt><dd>whether solver converged to specified level</dd></dl>
<dl compact><dt><b>See also:</b></dt><dd>solveSystem( const int, const int, boost::shared_ptr&lt; hier::PatchHierarchy &gt;, int, int); </dd></dl>

</div>
</div><p>
<a class="anchor" name="dce4cbfccddba8482bb4513ed369cffb"></a><!-- doxytag: member="SAMRAI::solv::CellPoissonFACSolver::setBoundaries" ref="dce4cbfccddba8482bb4513ed369cffb" args="(const std::string &amp;boundary_type, const int fluxes=-1, const int flags=-1, int *bdry_types=NULL)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::solv::CellPoissonFACSolver::setBoundaries           </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>boundary_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>fluxes</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>flags</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>bdry_types</em> = <code>NULL</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Specify the boundary conditions that are to be used at the physical domain boundary. 
<p>
This method is used to set up the default <a class="el" href="classSAMRAI_1_1solv_1_1SimpleCellRobinBcCoefs.html">SimpleCellRobinBcCoefs</a> object for specifying boundary conditions. Note that you may alternatively provide your own implementation of the Robin boundary condition coefficients using the <a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonFACSolver.html#c48d798320cedd1a0761b00666882bce">setBcObject()</a> method.<p>
The boundary conditions specified as the std::string argument "boundary_type." The boundary type argument can be "Dirichlet", "Neumann", or "Mixed".<p>
If using Dirichlet boundary conditions, then before the solver is called, the storage for the unknown u must have a mapped_box_level of ghost cells at least one cell wide that includes the Dirichlet boundary values.<p>
If using Neumann boundary conditions, then before the solver is called, the outerface boundary flux data must be set for the Neumann conditions. The fluxes argument gives the patch data index of this flux data.<p>
The mixed boundary type is for a mixture of Dirichlet and Neumann boundary conditions are used at the physical domain boundary. The fluxes argument gives the patch data index of the outerface data that specifies the flux data for the Neumann conditions. The flags array is an outerface data array of integer flags that specifies whether Dirichlet (flag == zero) or Neumann (flag == one) conditions are to be used at a particular cell boundary face. Note that the flag data must be set before the matrix entries can be computed and the flux data must be set before the solver is called. The bdry_types argument can be used if the boundary conditions are mixed but one or more of the faces of the physical boundary are entirely either Dirichlet or Neumann boundaries. The bdry_types argument should be an array of 2*DIM integers, specifying the boundary conditions on each side of the physical domain. It should be ordered {x_lo, x_hi, y_lo, y_hi, z_lo, z_hi}, with the values for each face being 0 for Dirichlet conditions, 1 for Neumann conditions, and 2 for mixed boundary conditions. The bdry_type argument is never required, but if used it can sometimes make the PoissonHYPRESolver class more efficient. 
</div>
</div><p>
<a class="anchor" name="c48d798320cedd1a0761b00666882bce"></a><!-- doxytag: member="SAMRAI::solv::CellPoissonFACSolver::setBcObject" ref="c48d798320cedd1a0761b00666882bce" args="(const RobinBcCoefStrategy *bc_object)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::solv::CellPoissonFACSolver::setBcObject           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1solv_1_1RobinBcCoefStrategy.html">RobinBcCoefStrategy</a> *&nbsp;</td>
          <td class="paramname"> <em>bc_object</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Override internal implementation to set boundary condition coefficients with user-provided implementation. 
<p>
This function is used to override the default internal object for setting Robin boundary condition coefficients. You should override when you need to avoid the limitations of the <a class="el" href="classSAMRAI_1_1solv_1_1SimpleCellRobinBcCoefs.html">SimpleCellRobinBcCoefs</a> class or you prefer to use your own implementation.<p>
Note that an important limitation of the <a class="el" href="classSAMRAI_1_1solv_1_1SimpleCellRobinBcCoefs.html">SimpleCellRobinBcCoefs</a> class is the inability to support linear interpolation in the prolongation step.<p>
Once the boundary condition object is overwritten by this method, you must no longer call the <a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonFACSolver.html#dce4cbfccddba8482bb4513ed369cffb">setBoundaries()</a> method. 
</div>
</div><p>
<a class="anchor" name="ebc803b1d2016fb8cce53a679ea07c7a"></a><!-- doxytag: member="SAMRAI::solv::CellPoissonFACSolver::setDPatchDataId" ref="ebc803b1d2016fb8cce53a679ea07c7a" args="(int id)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::solv::CellPoissonFACSolver::setDPatchDataId           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>id</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set the patch data index for variable D. 
<p>
In addition, disregard any previous D specified by <a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonFACSolver.html#88743b1fa623d1344724fba7533487a3">setDConstant()</a>. 
</div>
</div><p>
<a class="anchor" name="88743b1fa623d1344724fba7533487a3"></a><!-- doxytag: member="SAMRAI::solv::CellPoissonFACSolver::setDConstant" ref="88743b1fa623d1344724fba7533487a3" args="(double scalar)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::solv::CellPoissonFACSolver::setDConstant           </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>scalar</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set the scalar value variable D. 
<p>
In addition, disregard any previous D specified by <a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonFACSolver.html#ebc803b1d2016fb8cce53a679ea07c7a">setDPatchDataId()</a>. 
</div>
</div><p>
<a class="anchor" name="81cd4ff98db2648352f0e230f8ebf301"></a><!-- doxytag: member="SAMRAI::solv::CellPoissonFACSolver::setCPatchDataId" ref="81cd4ff98db2648352f0e230f8ebf301" args="(int id)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::solv::CellPoissonFACSolver::setCPatchDataId           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>id</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set the scalar value variable C. 
<p>
In addition, disregard any previous C specified by <a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonFACSolver.html#dfdb55e97439fe7172da4e397789060a">setCConstant()</a>. 
</div>
</div><p>
<a class="anchor" name="dfdb55e97439fe7172da4e397789060a"></a><!-- doxytag: member="SAMRAI::solv::CellPoissonFACSolver::setCConstant" ref="dfdb55e97439fe7172da4e397789060a" args="(double scalar)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::solv::CellPoissonFACSolver::setCConstant           </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>scalar</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set the patch data index for variable C. 
<p>
In addition, disregard any previous C specified by <a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonFACSolver.html#dfdb55e97439fe7172da4e397789060a">setCConstant()</a>. 
</div>
</div><p>
<a class="anchor" name="1888facbf5428b887c41f61291945528"></a><!-- doxytag: member="SAMRAI::solv::CellPoissonFACSolver::setCoarsestLevelSolverChoice" ref="1888facbf5428b887c41f61291945528" args="(const std::string &amp;choice)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::solv::CellPoissonFACSolver::setCoarsestLevelSolverChoice           </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>choice</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set coarse level solver. 
<p>
Select from these:<ul>
<li><code>"redblack"</code> </li><li><code>"hypre"</code> (only if the HYPRE library is available). </li></ul>

</div>
</div><p>
<a class="anchor" name="9ae6cf394d3e92da088718923a8ed9c8"></a><!-- doxytag: member="SAMRAI::solv::CellPoissonFACSolver::setCoarsestLevelSolverTolerance" ref="9ae6cf394d3e92da088718923a8ed9c8" args="(double tol)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::solv::CellPoissonFACSolver::setCoarsestLevelSolverTolerance           </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>tol</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set tolerance for coarse level solve. 
<p>
If the coarse level solver requires a tolerance (currently, they all do), the specified value is used. 
</div>
</div><p>
<a class="anchor" name="c17f9500ad33f6f91a912d073cb0e00c"></a><!-- doxytag: member="SAMRAI::solv::CellPoissonFACSolver::setCoarsestLevelSolverMaxIterations" ref="c17f9500ad33f6f91a912d073cb0e00c" args="(int max_iterations)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::solv::CellPoissonFACSolver::setCoarsestLevelSolverMaxIterations           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>max_iterations</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set max iterations for coarse level solve. 
<p>
If the coarse level solver requires a max iteration limit (currently, they all do), the specified value is used. 
</div>
</div><p>
<a class="anchor" name="299fa193b2c6236119cba88ff7ccf0f0"></a><!-- doxytag: member="SAMRAI::solv::CellPoissonFACSolver::setUseSMG" ref="299fa193b2c6236119cba88ff7ccf0f0" args="(bool use_smg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::solv::CellPoissonFACSolver::setUseSMG           </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>use_smg</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set whether to use HYPRe's PFMG algorithm instead of the SMG algorithm. 
<p>
The flag is used to select which of HYPRE's linear solver algorithms to use if true, the semicoarsening multigrid algorithm is used, and if false, the ``PF'' multigrid algorithm is used. By default, the SMG algorithm is used.<p>
This setting has effect only when HYPRe is chosen for the coarsest level solver. See <a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonFACSolver.html#1888facbf5428b887c41f61291945528">setCoarsestLevelSolverChoice()</a>.<p>
Changing the algorithm must be done before setting up the matrix coefficients. 
</div>
</div><p>
<a class="anchor" name="07411d1dae611abb3e87b93ea9329058"></a><!-- doxytag: member="SAMRAI::solv::CellPoissonFACSolver::setCoarseFineDiscretization" ref="07411d1dae611abb3e87b93ea9329058" args="(const std::string &amp;coarsefine_method)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::solv::CellPoissonFACSolver::setCoarseFineDiscretization           </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>coarsefine_method</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set the coarse-fine boundary discretization method. 
<p>
Specify the <code>op_name</code> std::string which will be passed to xfer::Geometry::lookupRefineOperator() to get the operator for setting fine grid ghost cells from the coarse grid. Note that chosing this operator implicitly choses the discretization method at the coarse-fine boundary.<p>
There is one important instance where this std::string is <em>not</em> passed to xfer::Geometry::lookupRefineOperator(). If this variable is set to "Ewing", a constant refinement method is used along with Ewing's correction. For a reference to the correction method, see "Local Refinement Techniques for Elliptic Problems on Cell-Centered Grids, I. Error Analysis", Mathematics of Computation, Vol. 56, No. 194, April 1991, pp. 437-461.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>coarsefine_method</em>&nbsp;</td><td>String selecting the coarse-fine discretization method. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="4051286a90b49e8cdef05cda287360a6"></a><!-- doxytag: member="SAMRAI::solv::CellPoissonFACSolver::setProlongationMethod" ref="4051286a90b49e8cdef05cda287360a6" args="(const std::string &amp;prolongation_method)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::solv::CellPoissonFACSolver::setProlongationMethod           </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>prolongation_method</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set the name of the prolongation method. 
<p>
Specify the <code>op_name</code> std::string which will be passed to xfer::Geometry::lookupRefineOperator() to get the operator for prolonging the coarse-grid correction.<p>
By default, "CONSTANT_REFINE" is used. "LINEAR_REFINE" seems to to lead to faster convergence, but it does NOT satisfy the Galerkin condition.<p>
Prolonging using linear refinement requires a Robin bc coefficient implementation that is capable of delivering coefficients for non-hierarchy data, because linear refinement requires boundary conditions to be set on temporary levels.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>prolongation_method</em>&nbsp;</td><td>String selecting the coarse-fine discretization method. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="b2b2ad1245fc78aa4a885edfc2ad2135"></a><!-- doxytag: member="SAMRAI::solv::CellPoissonFACSolver::setPresmoothingSweeps" ref="b2b2ad1245fc78aa4a885edfc2ad2135" args="(int num_pre_sweeps)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::solv::CellPoissonFACSolver::setPresmoothingSweeps           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>num_pre_sweeps</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set the number of pre-smoothing sweeps during FAC iteration process. 
<p>
Presmoothing is applied during the fine-to-coarse phase of the iteration. The default is to use one sweep.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>num_pre_sweeps</em>&nbsp;</td><td>Number of presmoothing sweeps </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="dd1bb32372d25357303d12d51f604655"></a><!-- doxytag: member="SAMRAI::solv::CellPoissonFACSolver::setPostsmoothingSweeps" ref="dd1bb32372d25357303d12d51f604655" args="(int num_post_sweeps)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::solv::CellPoissonFACSolver::setPostsmoothingSweeps           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>num_post_sweeps</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set the number of post-smoothing sweeps during FAC iteration process. 
<p>
Postsmoothing is applied during the coarse-to-fine phase of the iteration. The default is to use one sweep.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>num_post_sweeps</em>&nbsp;</td><td>Number of postsmoothing sweeps </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="2756a57368bf09c129786f1fe9334118"></a><!-- doxytag: member="SAMRAI::solv::CellPoissonFACSolver::setMaxCycles" ref="2756a57368bf09c129786f1fe9334118" args="(int max_cycles)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::solv::CellPoissonFACSolver::setMaxCycles           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>max_cycles</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set the max number of iterations (cycles) to use per solve. 
<p>

</div>
</div><p>
<a class="anchor" name="ac7da779cd9270a552a49c7795aafdb1"></a><!-- doxytag: member="SAMRAI::solv::CellPoissonFACSolver::setResidualTolerance" ref="ac7da779cd9270a552a49c7795aafdb1" args="(double residual_tol)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::solv::CellPoissonFACSolver::setResidualTolerance           </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>residual_tol</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set the residual tolerance for stopping. 
<p>
If you want the prescribed maximum number of cycles to always be taken, set the residual tolerance to a negative number. 
</div>
</div><p>
<a class="anchor" name="a307091f8fc0501fcef233fa8cf7a817"></a><!-- doxytag: member="SAMRAI::solv::CellPoissonFACSolver::initializeSolverState" ref="a307091f8fc0501fcef233fa8cf7a817" args="(const int solution, const int rhs, const boost::shared_ptr&lt; hier::PatchHierarchy &gt; &amp;hierarchy, const int coarse_level=-1, const int fine_level=-1)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::solv::CellPoissonFACSolver::initializeSolverState           </td>
          <td>(</td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>solution</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchHierarchy.html">hier::PatchHierarchy</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>hierarchy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>coarse_level</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>fine_level</em> = <code>-1</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Prepare the solver's internal state for solving. 
<p>
In the interest of efficiency, this class may prepare and cache some hierarchy-dependent objects. Though it is not required, initializing the solver state makes for greater efficiency when you are doing multiple solves on the same system of equation. If you do not initialize the state, it is initialized and deallocated each time you call <a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonFACSolver.html#aac02784e9cbcb1aac14e3200c6ec45b">solveSystem(const int, const int)</a>. The state must be reinitialized if the hierarchy or a boundary condition type changes.<p>
To unset the data set in this function, see <a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonFACSolver.html#29641296b35a31d68627c52bfd5371f0">deallocateSolverState()</a>.<p>
The <code>solution</code> and <code>rhs</code> patch data indices in the argument list are used to determine the <em>form</em> of the data you plan to use in the solve. They need not be the same data you solve on, but they should be similar. Both must represent cell-centered double data. The solution must have at least one ghost cell width, though this is not checked in the initialize phase, because data is not required yet.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>solution</em>&nbsp;</td><td>solution patch data index for u </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>rhs</em>&nbsp;</td><td>right hand side patch data index for f </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>hierarchy</em>&nbsp;</td><td>The patch hierarchy to solve on </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>coarse_level</em>&nbsp;</td><td>The coarsest level in the solve </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>fine_level</em>&nbsp;</td><td>The finest level in the solve </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="29641296b35a31d68627c52bfd5371f0"></a><!-- doxytag: member="SAMRAI::solv::CellPoissonFACSolver::deallocateSolverState" ref="29641296b35a31d68627c52bfd5371f0" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::solv::CellPoissonFACSolver::deallocateSolverState           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Remove the solver's internal state data. 
<p>
Remove all hierarchy-dependent data set by initializeSolverState. It is safe to call <a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonFACSolver.html#29641296b35a31d68627c52bfd5371f0">deallocateSolverState()</a> even state is already deallocated, but nothing is done in that case.<p>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonFACSolver.html#a307091f8fc0501fcef233fa8cf7a817">initializeSolverState()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="aebd721a089d38a1e2b64362909fff80"></a><!-- doxytag: member="SAMRAI::solv::CellPoissonFACSolver::getNumberOfIterations" ref="aebd721a089d38a1e2b64362909fff80" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int SAMRAI::solv::CellPoissonFACSolver::getNumberOfIterations           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return FAC iteration count from last (or current if there is one) FAC iteration process. 
<p>

</div>
</div><p>
<a class="anchor" name="d039daa0ba1472a87429fc6216889a08"></a><!-- doxytag: member="SAMRAI::solv::CellPoissonFACSolver::getConvergenceFactors" ref="d039daa0ba1472a87429fc6216889a08" args="(double &amp;avg_factor, double &amp;final_factor) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::solv::CellPoissonFACSolver::getConvergenceFactors           </td>
          <td>(</td>
          <td class="paramtype">double &amp;&nbsp;</td>
          <td class="paramname"> <em>avg_factor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&nbsp;</td>
          <td class="paramname"> <em>final_factor</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get average convergance rate and convergence rate of the last (or current if there is one) FAC solve. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>avg_factor</em>&nbsp;</td><td>average convergence factor over current FAC cycles </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>final_factor</em>&nbsp;</td><td>convergence factor of the last FAC cycle </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="9368b2be26b1b09591766c675f799140"></a><!-- doxytag: member="SAMRAI::solv::CellPoissonFACSolver::getResidualNorm" ref="9368b2be26b1b09591766c675f799140" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double SAMRAI::solv::CellPoissonFACSolver::getResidualNorm           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return residual norm from the just-completed FAC iteration. 
<p>
The norm return value is computed as the maximum norm over all patch levels involved in the solve. The value corresponds to the norm applied in the user-defined residual computation.<p>
The latest computed norm is the one returned. 
</div>
</div><p>
<a class="anchor" name="d68aff6e5610391b028d44ed5bac5f8e"></a><!-- doxytag: member="SAMRAI::solv::CellPoissonFACSolver::getObjectName" ref="d68aff6e5610391b028d44ed5bac5f8e" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::string&amp; SAMRAI::solv::CellPoissonFACSolver::getObjectName           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the name of this object. 
<p>
<dl compact><dt><b>Returns:</b></dt><dd>The name of this object. </dd></dl>

</div>
</div><p>
<hr>The documentation for this class was generated from the following files:<ul>
<li>source/SAMRAI/solv/<a class="el" href="CellPoissonFACSolver_8h.html">CellPoissonFACSolver.h</a><li>source/SAMRAI/solv/<a class="el" href="CellPoissonFACSolver_8C.html">CellPoissonFACSolver.C</a></ul>
<hr size="1"><address style="align: right;"><small>Generated on Thu Jun 21 13:42:58 2012 for SAMRAI by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.7 </small></address>
</body>
</html>
