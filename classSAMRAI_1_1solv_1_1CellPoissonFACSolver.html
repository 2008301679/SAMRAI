<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>SAMRAI: SAMRAI::solv::CellPoissonFACSolver Class Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.7 -->
<div class="tabs">
  <ul>
    <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="namespaces.html"><span>Namespaces</span></a></li>
    <li id="current"><a href="annotated.html"><span>Classes</span></a></li>
    <li><a href="files.html"><span>Files</span></a></li>
    <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
  </ul></div>
<div class="tabs">
  <ul>
    <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
    <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
    <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
  </ul></div>
<div class="nav">
<a class="el" href="namespaceSAMRAI.html">SAMRAI</a>::<a class="el" href="namespaceSAMRAI_1_1solv.html">solv</a>::<a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonFACSolver.html">CellPoissonFACSolver</a></div>
<h1>SAMRAI::solv::CellPoissonFACSolver Class Reference</h1><!-- doxytag: class="SAMRAI::solv::CellPoissonFACSolver" -->Class for solving scalar Poisson's equation on SAMR grid, wrapping up lower-level components (FAC cycling, Poisson equation operations and boundary conditions) in a single high-level interface.  
<a href="#_details">More...</a>
<p>
<code>#include &lt;source/SAMRAI/solv/CellPoissonFACSolver.h&gt;</code>
<p>
<a href="classSAMRAI_1_1solv_1_1CellPoissonFACSolver-members.html">List of all members.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonFACSolver.html#515e2d1f0d79dfca102d027e05b4cece">CellPoissonFACSolver</a> (const <a class="el" href="classSAMRAI_1_1tbox_1_1Dimension.html">tbox::Dimension</a> &amp;dim, const std::string &amp;object_name, const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1solv_1_1FACPreconditioner.html">FACPreconditioner</a> &gt; &amp;fac_precond, const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonFACOps.html">CellPoissonFACOps</a> &gt; &amp;fac_ops, const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Database.html">tbox::Database</a> &gt; &amp;input_db=boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Database.html">tbox::Database</a> &gt;())</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Construct a solver.  <a href="#515e2d1f0d79dfca102d027e05b4cece"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonFACSolver.html#bc2ee793aa8277c8ab6827fcb3608728">~CellPoissonFACSolver</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Destructor.  <a href="#bc2ee793aa8277c8ab6827fcb3608728"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonFACSolver.html#3c0c29fd06d0ccc69a04aaf76d9a227e">solveSystem</a> (const int solution, const int rhs, const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchHierarchy.html">hier::PatchHierarchy</a> &gt; &amp;hierarchy, int coarse_ln=-1, int fine_ln=-1)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Solve Poisson's equation, assuming an uninitialized solver state.  <a href="#3c0c29fd06d0ccc69a04aaf76d9a227e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonFACSolver.html#fe212d42581fa8eb90e2720a18bf4588">solveSystem</a> (const int solution, const int rhs)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Solve Poisson's equation using the current solver state set by <a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonFACSolver.html#32daa5602688c39a0064e75ed7d0946b">initializeSolverState()</a>.  <a href="#fe212d42581fa8eb90e2720a18bf4588"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonFACSolver.html#10ba8ef6e09bb7b7107d1fac2fa64357">setBoundaries</a> (const std::string &amp;boundary_type, const int fluxes=-1, const int flags=-1, int *bdry_types=0)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Specify the boundary conditions that are to be used at the physical domain boundary.  <a href="#10ba8ef6e09bb7b7107d1fac2fa64357"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonFACSolver.html#759f60c6823f3bb41770ecb245ba7061">setBcObject</a> (const <a class="el" href="classSAMRAI_1_1solv_1_1RobinBcCoefStrategy.html">RobinBcCoefStrategy</a> *bc_object)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Override internal implementation to set boundary condition coefficients with user-provided implementation.  <a href="#759f60c6823f3bb41770ecb245ba7061"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonFACSolver.html#32daa5602688c39a0064e75ed7d0946b">initializeSolverState</a> (const int solution, const int rhs, const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchHierarchy.html">hier::PatchHierarchy</a> &gt; &amp;hierarchy, const int coarse_level=-1, const int fine_level=-1)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Prepare the solver's internal state for solving.  <a href="#32daa5602688c39a0064e75ed7d0946b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonFACSolver.html#6c5f98f4b42b2446883f04752f76a95c">deallocateSolverState</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Remove the solver's internal state data.  <a href="#6c5f98f4b42b2446883f04752f76a95c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">const std::string &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonFACSolver.html#fe8f84e7a59998876d1ff2b7897f7a28">getObjectName</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the name of this object.  <a href="#fe8f84e7a59998876d1ff2b7897f7a28"></a><br></td></tr>
<tr><td colspan="2"><div class="groupHeader">Specifying PDE parameters</div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonFACSolver.html#02e2265ae025e7a6d25f4d3c30139e8a">setDPatchDataId</a> (int id)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the patch data index for variable D.  <a href="#02e2265ae025e7a6d25f4d3c30139e8a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonFACSolver.html#9d832f909635027d485493549c5f15df">setDConstant</a> (double scalar)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the scalar value variable D.  <a href="#9d832f909635027d485493549c5f15df"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonFACSolver.html#d06fc5fe77447208383b32d020823527">setCPatchDataId</a> (int id)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the scalar value variable C.  <a href="#d06fc5fe77447208383b32d020823527"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonFACSolver.html#1a87be7fc6c0c22ad6a0ed6efe00c081">setCConstant</a> (double scalar)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the patch data index for variable C.  <a href="#1a87be7fc6c0c22ad6a0ed6efe00c081"></a><br></td></tr>
<tr><td colspan="2"><div class="groupHeader">Functions to get data on last solve.</div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonFACSolver.html#1473cf46923fc542b71dc67ecc2e6e9a">getNumberOfIterations</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return FAC iteration count from last (or current if there is one) FAC iteration process.  <a href="#1473cf46923fc542b71dc67ecc2e6e9a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonFACSolver.html#1f76649c08ddb84aa2617672e2653a62">getConvergenceFactors</a> (double &amp;avg_factor, double &amp;final_factor) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get average convergance rate and convergence rate of the last (or current if there is one) FAC solve.  <a href="#1f76649c08ddb84aa2617672e2653a62"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonFACSolver.html#0d95e95d2b7e26370b5cfc50964a91e1">getResidualNorm</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return residual norm from the just-completed FAC iteration.  <a href="#0d95e95d2b7e26370b5cfc50964a91e1"></a><br></td></tr>
</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
Class for solving scalar Poisson's equation on SAMR grid, wrapping up lower-level components (FAC cycling, Poisson equation operations and boundary conditions) in a single high-level interface. 
<p>
We solve the equation div(D grad(u)) + Cu = f where D is a side-centered array and C is a cell-centered array. u and f are also cell-centered. Boundary conditions supported are Dirichlet, Neumann and mixed (Dirichlet on some faces and Neumann on others).<p>
This class is a wrapper, providing a single class that coordinates three major components: the FAC solver, the cell-centered Poisson FAC operator and a default Robin bc coefficient implelemtation. It is perfectly acceptable to use those classes outside of this class.<p>
The underlying solver is an FAC solver using cell-centered discretization. The difference scheme is second-order central-difference. On coarse-fine boundaries within the solution levels, the composite grid operator uses, by default, the discretization method of Ewing, Lazarov and Vassilevski ("Local Refinement Techniques for Elliptic Problems on Cell-Centered Grids, I. Error Analysis", Mathematics of Computation, Vol. 56, No. 194, April 1991, pp. 437-461).<p>
Typical use of this class is:<ol type=1>
<li>Construct a <a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonFACSolver.html">CellPoissonFACSolver</a> object, providing it the hierarchy and range of levels participating in the solve.</li><li>Set the parameters C and D using the functions named <code>setC</code>... and <code>setD</code>... By default, D=1 and C=0 everywhere.</li><li>Call <a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonFACSolver.html#10ba8ef6e09bb7b7107d1fac2fa64357">setBoundaries()</a> to state the types boundary conditions, along with supplemental data for setting those boundary conditions.</li><li>Call <a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonFACSolver.html#32daa5602688c39a0064e75ed7d0946b">initializeSolverState()</a> to set up information internal to the solver. This is step is not required but will save setup costs if you are making multiple solves. This commits the object to the current hierarchy state and the specific <em>types</em> of boundary conditions you selected, It does NOT commit to the specific <em>values</em> of the boundary condition. A hierarchy change (through adaption or other means) invalidates the state, thus you must reinitialize or <a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonFACSolver.html#6c5f98f4b42b2446883f04752f76a95c">deallocateSolverState()</a> the state before another solve.</li><li>Solve the equation with <a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonFACSolver.html#3c0c29fd06d0ccc69a04aaf76d9a227e">solveSystem()</a>. You provide the patch data indices for the solution u and the right hand side f. u must have at least one ghost cell and where a Dirichlet boundary condition applies, those cells must be set to the value on the boundary. If only Neumann boundary conditions are used, the ghost cell values do not matter.</li><li>Call <a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonFACSolver.html#6c5f98f4b42b2446883f04752f76a95c">deallocateSolverState()</a> to free up internal resources, if <a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonFACSolver.html#32daa5602688c39a0064e75ed7d0946b">initializeSolverState()</a> was called before the solve.</li></ol>
<p>
After the solve, information on the solve can be obtained by calling one of these functions:<ul>
<li><a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonFACSolver.html#1473cf46923fc542b71dc67ecc2e6e9a">getNumberOfIterations()</a> gives the number of FAC cycles used.</li><li><a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonFACSolver.html#1f76649c08ddb84aa2617672e2653a62">getConvergenceFactors()</a> gives the average and final convergence factors for the solve.</li><li><a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonFACSolver.html#0d95e95d2b7e26370b5cfc50964a91e1">getResidualNorm()</a> gives the final residual</li></ul>
<p>
Finer solver controls can be set using the functions in this class.<p>
<b> Input Parameters </b><p>
<b> Definitions: </b><ul>
<li><b>enable_logging</b> turn logging on or off</li></ul>
<p>
<b> Details: </b> <br>
 <table border="1" cellspacing="3" cellpadding="3">
<tr>
<th>parameter </th><th>type </th><th>default </th><th>range </th><th>opt/req </th><th>behavior on restart  </th></tr>
<tr>
<td>enable_logging </td><td>bool </td><td>FALSE </td><td>TRUE, FALSE </td><td>opt </td><td>Not written to restart. Value in input db used.  </td></tr>
</table>

<p>
<hr><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" name="515e2d1f0d79dfca102d027e05b4cece"></a><!-- doxytag: member="SAMRAI::solv::CellPoissonFACSolver::CellPoissonFACSolver" ref="515e2d1f0d79dfca102d027e05b4cece" args="(const tbox::Dimension &amp;dim, const std::string &amp;object_name, const boost::shared_ptr&lt; FACPreconditioner &gt; &amp;fac_precond, const boost::shared_ptr&lt; CellPoissonFACOps &gt; &amp;fac_ops, const boost::shared_ptr&lt; tbox::Database &gt; &amp;input_db=boost::shared_ptr&lt; tbox::Database &gt;())" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SAMRAI::solv::CellPoissonFACSolver::CellPoissonFACSolver           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1tbox_1_1Dimension.html">tbox::Dimension</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>dim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>object_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1solv_1_1FACPreconditioner.html">FACPreconditioner</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>fac_precond</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonFACOps.html">CellPoissonFACOps</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>fac_ops</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Database.html">tbox::Database</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>input_db</em> = <code>boost::shared_ptr&lt;&nbsp;<a class="el" href="classSAMRAI_1_1tbox_1_1Database.html">tbox::Database</a>&nbsp;&gt;()</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Construct a solver. 
<p>
If the database is not NULL, initial settings will be set using the database. The solver is uninitialized until <a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonFACSolver.html#32daa5602688c39a0064e75ed7d0946b">initializeSolverState()</a> is called.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dim</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>object_name</em>&nbsp;</td><td>Name of object used in outputs </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>fac_precond</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>fac_ops</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>input_db</em>&nbsp;</td><td><a class="el" href="classSAMRAI_1_1tbox_1_1Database.html">tbox::Database</a> for initialization (may be NULL) </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="bc2ee793aa8277c8ab6827fcb3608728"></a><!-- doxytag: member="SAMRAI::solv::CellPoissonFACSolver::~CellPoissonFACSolver" ref="bc2ee793aa8277c8ab6827fcb3608728" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SAMRAI::solv::CellPoissonFACSolver::~CellPoissonFACSolver           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Destructor. 
<p>

</div>
</div><p>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="3c0c29fd06d0ccc69a04aaf76d9a227e"></a><!-- doxytag: member="SAMRAI::solv::CellPoissonFACSolver::solveSystem" ref="3c0c29fd06d0ccc69a04aaf76d9a227e" args="(const int solution, const int rhs, const boost::shared_ptr&lt; hier::PatchHierarchy &gt; &amp;hierarchy, int coarse_ln=-1, int fine_ln=-1)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SAMRAI::solv::CellPoissonFACSolver::solveSystem           </td>
          <td>(</td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>solution</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchHierarchy.html">hier::PatchHierarchy</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>hierarchy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>coarse_ln</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>fine_ln</em> = <code>-1</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Solve Poisson's equation, assuming an uninitialized solver state. 
<p>
Here, u is the "solution" patch data index and f is the right hand side patch data index. The return value is true if the solver converged and false otherwise.<p>
This function is a wrapper. It simply initializes the solver state, call the <a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonFACSolver.html#fe212d42581fa8eb90e2720a18bf4588">solveSystem(const int,const int)</a> for the initialized solver then deallocates the solver state.<p>
Upon return from this function, solution will contain the result of the solve.<p>
See <a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonFACSolver.html#32daa5602688c39a0064e75ed7d0946b">initializeSolverState()</a> for opportunities to save overhead when using multiple consecutive solves.<p>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonFACSolver.html#fe212d42581fa8eb90e2720a18bf4588">solveSystem(const int,const int)</a></dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>solution</em>&nbsp;</td><td><a class="el" href="classSAMRAI_1_1hier_1_1Patch.html">hier::Patch</a> data index for solution u </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>rhs</em>&nbsp;</td><td><a class="el" href="classSAMRAI_1_1hier_1_1Patch.html">hier::Patch</a> data index for right hand side f </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>hierarchy</em>&nbsp;</td><td>The patch hierarchy to solve on </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>coarse_ln</em>&nbsp;</td><td>The coarsest level in the solve. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>fine_ln</em>&nbsp;</td><td>The finest level in the solve.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>whether solver converged to specified level</dd></dl>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonFACSolver.html#32daa5602688c39a0064e75ed7d0946b">initializeSolverState</a></dd></dl>
<dl compact><dt><b>Precondition:</b></dt><dd>hierarchy <p>
d_dim == hierarchy-&gt;getDim() <p>
!d_solver_is_initialized </dd></dl>

</div>
</div><p>
<a class="anchor" name="fe212d42581fa8eb90e2720a18bf4588"></a><!-- doxytag: member="SAMRAI::solv::CellPoissonFACSolver::solveSystem" ref="fe212d42581fa8eb90e2720a18bf4588" args="(const int solution, const int rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SAMRAI::solv::CellPoissonFACSolver::solveSystem           </td>
          <td>(</td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>solution</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Solve Poisson's equation using the current solver state set by <a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonFACSolver.html#32daa5602688c39a0064e75ed7d0946b">initializeSolverState()</a>. 
<p>
When the solver state has been initialized, this function may be called repeadedly with different values on the rhs. There is some cost savings for multiple solves when this is done.<p>
Before calling this function, the solution and right-hand-side quantities should be set properly by the user on all patch interiors on the range of levels covered by the FAC iteration. All data for these patch data index should be allocated. Thus, the user is responsible for managing the storage for the solution and right-hand-side.<p>
<dl compact><dt><b>Returns:</b></dt><dd>whether solver converged to specified level</dd></dl>
<dl compact><dt><b>See also:</b></dt><dd>solveSystem( const int, const int, boost::shared_ptr&lt; hier::PatchHierarchy &gt;, int, int);</dd></dl>
<dl compact><dt><b>Precondition:</b></dt><dd>d_solver_is_initialized <p>
(solution &gt;= 0) || (rhs &gt;= 0) </dd></dl>

</div>
</div><p>
<a class="anchor" name="10ba8ef6e09bb7b7107d1fac2fa64357"></a><!-- doxytag: member="SAMRAI::solv::CellPoissonFACSolver::setBoundaries" ref="10ba8ef6e09bb7b7107d1fac2fa64357" args="(const std::string &amp;boundary_type, const int fluxes=-1, const int flags=-1, int *bdry_types=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::solv::CellPoissonFACSolver::setBoundaries           </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>boundary_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>fluxes</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>flags</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>bdry_types</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Specify the boundary conditions that are to be used at the physical domain boundary. 
<p>
This method is used to set up the default <a class="el" href="classSAMRAI_1_1solv_1_1SimpleCellRobinBcCoefs.html">SimpleCellRobinBcCoefs</a> object for specifying boundary conditions. Note that you may alternatively provide your own implementation of the Robin boundary condition coefficients using the <a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonFACSolver.html#759f60c6823f3bb41770ecb245ba7061">setBcObject()</a> method.<p>
The boundary conditions specified as the std::string argument "boundary_type." The boundary type argument can be "Dirichlet", "Neumann", or "Mixed".<p>
If using Dirichlet boundary conditions, then before the solver is called, the storage for the unknown u must have a box_level of ghost cells at least one cell wide that includes the Dirichlet boundary values.<p>
If using Neumann boundary conditions, then before the solver is called, the outerface boundary flux data must be set for the Neumann conditions. The fluxes argument gives the patch data index of this flux data.<p>
The mixed boundary type is for a mixture of Dirichlet and Neumann boundary conditions are used at the physical domain boundary. The fluxes argument gives the patch data index of the outerface data that specifies the flux data for the Neumann conditions. The flags array is an outerface data array of integer flags that specifies whether Dirichlet (flag == zero) or Neumann (flag == one) conditions are to be used at a particular cell boundary face. Note that the flag data must be set before the matrix entries can be computed and the flux data must be set before the solver is called. The bdry_types argument can be used if the boundary conditions are mixed but one or more of the faces of the physical boundary are entirely either Dirichlet or Neumann boundaries. The bdry_types argument should be an array of 2*DIM integers, specifying the boundary conditions on each side of the physical domain. It should be ordered {x_lo, x_hi, y_lo, y_hi, z_lo, z_hi}, with the values for each face being 0 for Dirichlet conditions, 1 for Neumann conditions, and 2 for mixed boundary conditions. The bdry_type argument is never required, but if used it can sometimes make the PoissonHYPRESolver class more efficient.<p>
<dl compact><dt><b>Precondition:</b></dt><dd>(d_bc_object == 0) || (d_bc_object == &amp;d_simple_bc) </dd></dl>

</div>
</div><p>
<a class="anchor" name="759f60c6823f3bb41770ecb245ba7061"></a><!-- doxytag: member="SAMRAI::solv::CellPoissonFACSolver::setBcObject" ref="759f60c6823f3bb41770ecb245ba7061" args="(const RobinBcCoefStrategy *bc_object)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::solv::CellPoissonFACSolver::setBcObject           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1solv_1_1RobinBcCoefStrategy.html">RobinBcCoefStrategy</a> *&nbsp;</td>
          <td class="paramname"> <em>bc_object</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Override internal implementation to set boundary condition coefficients with user-provided implementation. 
<p>
This function is used to override the default internal object for setting Robin boundary condition coefficients. You should override when you need to avoid the limitations of the <a class="el" href="classSAMRAI_1_1solv_1_1SimpleCellRobinBcCoefs.html">SimpleCellRobinBcCoefs</a> class or you prefer to use your own implementation.<p>
Note that an important limitation of the <a class="el" href="classSAMRAI_1_1solv_1_1SimpleCellRobinBcCoefs.html">SimpleCellRobinBcCoefs</a> class is the inability to support linear interpolation in the prolongation step.<p>
Once the boundary condition object is overwritten by this method, you must no longer call the <a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonFACSolver.html#10ba8ef6e09bb7b7107d1fac2fa64357">setBoundaries()</a> method.<p>
<dl compact><dt><b>Precondition:</b></dt><dd>bc_object </dd></dl>

</div>
</div><p>
<a class="anchor" name="02e2265ae025e7a6d25f4d3c30139e8a"></a><!-- doxytag: member="SAMRAI::solv::CellPoissonFACSolver::setDPatchDataId" ref="02e2265ae025e7a6d25f4d3c30139e8a" args="(int id)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::solv::CellPoissonFACSolver::setDPatchDataId           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>id</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set the patch data index for variable D. 
<p>
In addition, disregard any previous D specified by <a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonFACSolver.html#9d832f909635027d485493549c5f15df">setDConstant()</a>. 
</div>
</div><p>
<a class="anchor" name="9d832f909635027d485493549c5f15df"></a><!-- doxytag: member="SAMRAI::solv::CellPoissonFACSolver::setDConstant" ref="9d832f909635027d485493549c5f15df" args="(double scalar)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::solv::CellPoissonFACSolver::setDConstant           </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>scalar</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set the scalar value variable D. 
<p>
In addition, disregard any previous D specified by <a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonFACSolver.html#02e2265ae025e7a6d25f4d3c30139e8a">setDPatchDataId()</a>. 
</div>
</div><p>
<a class="anchor" name="d06fc5fe77447208383b32d020823527"></a><!-- doxytag: member="SAMRAI::solv::CellPoissonFACSolver::setCPatchDataId" ref="d06fc5fe77447208383b32d020823527" args="(int id)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::solv::CellPoissonFACSolver::setCPatchDataId           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>id</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set the scalar value variable C. 
<p>
In addition, disregard any previous C specified by <a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonFACSolver.html#1a87be7fc6c0c22ad6a0ed6efe00c081">setCConstant()</a>. 
</div>
</div><p>
<a class="anchor" name="1a87be7fc6c0c22ad6a0ed6efe00c081"></a><!-- doxytag: member="SAMRAI::solv::CellPoissonFACSolver::setCConstant" ref="1a87be7fc6c0c22ad6a0ed6efe00c081" args="(double scalar)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::solv::CellPoissonFACSolver::setCConstant           </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>scalar</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set the patch data index for variable C. 
<p>
In addition, disregard any previous C specified by <a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonFACSolver.html#1a87be7fc6c0c22ad6a0ed6efe00c081">setCConstant()</a>. 
</div>
</div><p>
<a class="anchor" name="32daa5602688c39a0064e75ed7d0946b"></a><!-- doxytag: member="SAMRAI::solv::CellPoissonFACSolver::initializeSolverState" ref="32daa5602688c39a0064e75ed7d0946b" args="(const int solution, const int rhs, const boost::shared_ptr&lt; hier::PatchHierarchy &gt; &amp;hierarchy, const int coarse_level=-1, const int fine_level=-1)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::solv::CellPoissonFACSolver::initializeSolverState           </td>
          <td>(</td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>solution</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchHierarchy.html">hier::PatchHierarchy</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>hierarchy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>coarse_level</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>fine_level</em> = <code>-1</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Prepare the solver's internal state for solving. 
<p>
In the interest of efficiency, this class may prepare and cache some hierarchy-dependent objects. Though it is not required, initializing the solver state makes for greater efficiency when you are doing multiple solves on the same system of equation. If you do not initialize the state, it is initialized and deallocated each time you call <a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonFACSolver.html#fe212d42581fa8eb90e2720a18bf4588">solveSystem(const int, const int)</a>. The state must be reinitialized if the hierarchy or a boundary condition type changes.<p>
To unset the data set in this function, see <a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonFACSolver.html#6c5f98f4b42b2446883f04752f76a95c">deallocateSolverState()</a>.<p>
The <code>solution</code> and <code>rhs</code> patch data indices in the argument list are used to determine the <em>form</em> of the data you plan to use in the solve. They need not be the same data you solve on, but they should be similar. Both must represent cell-centered double data. The solution must have at least one ghost cell width, though this is not checked in the initialize phase, because data is not required yet.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>solution</em>&nbsp;</td><td>solution patch data index for u </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>rhs</em>&nbsp;</td><td>right hand side patch data index for f </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>hierarchy</em>&nbsp;</td><td>The patch hierarchy to solve on </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>coarse_level</em>&nbsp;</td><td>The coarsest level in the solve </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>fine_level</em>&nbsp;</td><td>The finest level in the solve</td></tr>
  </table>
</dl>
<dl compact><dt><b>Precondition:</b></dt><dd>hierarchy <p>
d_dim == hierarchy-&gt;getDim() <p>
d_bc_object != 0 <p>
(solution &gt;= 0) || (rhs &gt;= 0) </dd></dl>

</div>
</div><p>
<a class="anchor" name="6c5f98f4b42b2446883f04752f76a95c"></a><!-- doxytag: member="SAMRAI::solv::CellPoissonFACSolver::deallocateSolverState" ref="6c5f98f4b42b2446883f04752f76a95c" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::solv::CellPoissonFACSolver::deallocateSolverState           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Remove the solver's internal state data. 
<p>
Remove all hierarchy-dependent data set by initializeSolverState. It is safe to call <a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonFACSolver.html#6c5f98f4b42b2446883f04752f76a95c">deallocateSolverState()</a> even state is already deallocated, but nothing is done in that case.<p>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonFACSolver.html#32daa5602688c39a0064e75ed7d0946b">initializeSolverState()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="1473cf46923fc542b71dc67ecc2e6e9a"></a><!-- doxytag: member="SAMRAI::solv::CellPoissonFACSolver::getNumberOfIterations" ref="1473cf46923fc542b71dc67ecc2e6e9a" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int SAMRAI::solv::CellPoissonFACSolver::getNumberOfIterations           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return FAC iteration count from last (or current if there is one) FAC iteration process. 
<p>

</div>
</div><p>
<a class="anchor" name="1f76649c08ddb84aa2617672e2653a62"></a><!-- doxytag: member="SAMRAI::solv::CellPoissonFACSolver::getConvergenceFactors" ref="1f76649c08ddb84aa2617672e2653a62" args="(double &amp;avg_factor, double &amp;final_factor) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::solv::CellPoissonFACSolver::getConvergenceFactors           </td>
          <td>(</td>
          <td class="paramtype">double &amp;&nbsp;</td>
          <td class="paramname"> <em>avg_factor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&nbsp;</td>
          <td class="paramname"> <em>final_factor</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get average convergance rate and convergence rate of the last (or current if there is one) FAC solve. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>avg_factor</em>&nbsp;</td><td>average convergence factor over current FAC cycles </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>final_factor</em>&nbsp;</td><td>convergence factor of the last FAC cycle </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="0d95e95d2b7e26370b5cfc50964a91e1"></a><!-- doxytag: member="SAMRAI::solv::CellPoissonFACSolver::getResidualNorm" ref="0d95e95d2b7e26370b5cfc50964a91e1" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double SAMRAI::solv::CellPoissonFACSolver::getResidualNorm           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return residual norm from the just-completed FAC iteration. 
<p>
The norm return value is computed as the maximum norm over all patch levels involved in the solve. The value corresponds to the norm applied in the user-defined residual computation.<p>
The latest computed norm is the one returned. 
</div>
</div><p>
<a class="anchor" name="fe8f84e7a59998876d1ff2b7897f7a28"></a><!-- doxytag: member="SAMRAI::solv::CellPoissonFACSolver::getObjectName" ref="fe8f84e7a59998876d1ff2b7897f7a28" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::string&amp; SAMRAI::solv::CellPoissonFACSolver::getObjectName           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the name of this object. 
<p>
<dl compact><dt><b>Returns:</b></dt><dd>The name of this object. </dd></dl>

</div>
</div><p>
<hr>The documentation for this class was generated from the following files:<ul>
<li>source/SAMRAI/solv/<a class="el" href="CellPoissonFACSolver_8h.html">CellPoissonFACSolver.h</a><li>source/SAMRAI/solv/<a class="el" href="CellPoissonFACSolver_8C.html">CellPoissonFACSolver.C</a></ul>
<hr size="1"><address style="align: right;"><small>Generated on 16 Jan 2013 for SAMRAI by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.7 </small></address>
</body>
</html>
