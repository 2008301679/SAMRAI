<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>SAMRAI: SAMRAI::solv::SAMRAIVectorReal&lt; TYPE &gt; Class Template Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.7 -->
<div class="tabs">
  <ul>
    <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="namespaces.html"><span>Namespaces</span></a></li>
    <li id="current"><a href="annotated.html"><span>Classes</span></a></li>
    <li><a href="files.html"><span>Files</span></a></li>
    <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
  </ul></div>
<div class="tabs">
  <ul>
    <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
    <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
    <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
  </ul></div>
<div class="nav">
<a class="el" href="namespaceSAMRAI.html">SAMRAI</a>::<a class="el" href="namespaceSAMRAI_1_1solv.html">solv</a>::<a class="el" href="classSAMRAI_1_1solv_1_1SAMRAIVectorReal.html">SAMRAIVectorReal</a></div>
<h1>SAMRAI::solv::SAMRAIVectorReal&lt; TYPE &gt; Class Template Reference</h1><!-- doxytag: class="SAMRAI::solv::SAMRAIVectorReal" --><code>#include &lt;source/SAMRAI/solv/SAMRAIVectorReal.h&gt;</code>
<p>
<a href="classSAMRAI_1_1solv_1_1SAMRAIVectorReal-members.html">List of all members.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1SAMRAIVectorReal.html#948fab3dbac7d0f0035829c45c7bd1cd">SAMRAIVectorReal</a> (const std::string &amp;name, const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchHierarchy.html">hier::PatchHierarchy</a> &gt; &amp;hierarchy, const int coarsest_level, const int finest_level)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1SAMRAIVectorReal.html#581070ab4220ad5b2fbc3aa75f1e3eb9">~SAMRAIVectorReal</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1SAMRAIVectorReal.html#4be703d182bd7fcc3e0f51a927322722">setName</a> (const std::string &amp;name)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1SAMRAIVectorReal.html#8e51ed8352f8e2bc18a893e3e5d464b9">setOutputStream</a> (std::ostream &amp;s)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">std::ostream &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1SAMRAIVectorReal.html#9977b38622216d183c9db80ff9822a89">getOutputStream</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1SAMRAIVectorReal.html#671291b63ea703578b795083ba6bb8fd">resetLevels</a> (const int coarsest_level, const int finest_level)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">const std::string &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1SAMRAIVectorReal.html#93680dc20474c0732f63538b7a2b7c14">getName</a> () const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchHierarchy.html">hier::PatchHierarchy</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1SAMRAIVectorReal.html#3f9a08f47ef24d786a32e521452da9ca">getPatchHierarchy</a> () const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1SAMRAIVectorReal.html#f4b3b73a67a1095bcde945e7f5b77936">getCoarsestLevelNumber</a> () const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1SAMRAIVectorReal.html#d07315a091a9c33e692c289649abefe0">getFinestLevelNumber</a> () const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1SAMRAIVectorReal.html#a51ff0c70822b11f1986b97558d68b33">getNumberOfComponents</a> () const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchData.html">hier::PatchData</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1SAMRAIVectorReal.html#ef9e3db5f110db3ae892aec7250d374b">getComponentPatchData</a> (const int comp_id, const <a class="el" href="classSAMRAI_1_1hier_1_1Patch.html">hier::Patch</a> &amp;patch) const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchData.html">hier::PatchData</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1SAMRAIVectorReal.html#5537f677c4764c7a2bfc53419398b14f">getComponentPatchData</a> (const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1hier_1_1Variable.html">hier::Variable</a> &gt; &amp;var, const <a class="el" href="classSAMRAI_1_1hier_1_1Patch.html">hier::Patch</a> &amp;patch) const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1hier_1_1Variable.html">hier::Variable</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1SAMRAIVectorReal.html#ba6ad44e1f9ca56b642a72673e4e8090">getComponentVariable</a> (const int component) const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1SAMRAIVectorReal.html#edbbedcfba8bcca7ac456f7a6fa38b38">getComponentDescriptorIndex</a> (const int component) const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1SAMRAIVectorReal.html#a791818048ee13f7c156c9250340ec58">getControlVolumeIndex</a> (const int component) const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1solv_1_1SAMRAIVectorReal.html">SAMRAIVectorReal</a>&lt;<br>
 TYPE &gt; &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1SAMRAIVectorReal.html#25a88f92e5088abfd340741c699f71e9">cloneVector</a> (const std::string &amp;name) const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1SAMRAIVectorReal.html#b77193fdf529f2e4fd367b562ce171ad">freeVectorComponents</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1SAMRAIVectorReal.html#61dc105aa13f6118d3c7890099329a96">addComponent</a> (const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1hier_1_1Variable.html">hier::Variable</a> &gt; &amp;var, const int comp_data_id, const int control_vol_id=-1, const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1math_1_1HierarchyDataOpsReal.html">math::HierarchyDataOpsReal</a>&lt; TYPE &gt; &gt; &amp;vop=boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1math_1_1HierarchyDataOpsReal.html">math::HierarchyDataOpsReal</a>&lt; TYPE &gt; &gt;())</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1SAMRAIVectorReal.html#40d5da5c80161dd33e699a1ad8fe1666">allocateVectorData</a> (const double timestamp=0.0)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1SAMRAIVectorReal.html#b7eb91445678395d0d1cd09d4c234af4">deallocateVectorData</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1SAMRAIVectorReal.html#5d2a65e315281cd26c1017579c5b40f5">print</a> (std::ostream &amp;s=<a class="el" href="namespaceSAMRAI_1_1tbox.html#b84041705493761fb17a8127e3a2dca2">tbox::plog</a>, const bool interior_only=true) const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1SAMRAIVectorReal.html#6d12617e21f053e6c00cbb302f94a5a5">copyVector</a> (const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1solv_1_1SAMRAIVectorReal.html">SAMRAIVectorReal</a>&lt; TYPE &gt; &gt; &amp;src_vec, const bool interior_only=true)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1SAMRAIVectorReal.html#bb8b3d96cad3d31c64c0837175c38800">swapVectors</a> (const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1solv_1_1SAMRAIVectorReal.html">SAMRAIVectorReal</a>&lt; TYPE &gt; &gt; &amp;other)</td></tr>

<tr><td colspan="2"><div class="groupHeader">Vector arithmetic functions</div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1SAMRAIVectorReal.html#53713e997f15865ad62f59c4eee48ac9">setToScalar</a> (const TYPE &amp;alpha, const bool interior_only=true)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1SAMRAIVectorReal.html#dfa527030ec59ff32daf1bb841c5b4eb">scale</a> (const TYPE &amp;alpha, const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1solv_1_1SAMRAIVectorReal.html">SAMRAIVectorReal</a>&lt; TYPE &gt; &gt; &amp;x, const bool interior_only=true)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1SAMRAIVectorReal.html#3b19117454bb807e952be68b40a2cd34">addScalar</a> (const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1solv_1_1SAMRAIVectorReal.html">SAMRAIVectorReal</a>&lt; TYPE &gt; &gt; &amp;x, const TYPE &amp;alpha, const bool interior_only=true)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1SAMRAIVectorReal.html#90b4a3fe6ff354ca0a1cedbe54bd7356">add</a> (const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1solv_1_1SAMRAIVectorReal.html">SAMRAIVectorReal</a>&lt; TYPE &gt; &gt; &amp;x, const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1solv_1_1SAMRAIVectorReal.html">SAMRAIVectorReal</a>&lt; TYPE &gt; &gt; &amp;y, const bool interior_only=true)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1SAMRAIVectorReal.html#6d25272a3ba500f9c94a5fadaeea2a84">subtract</a> (const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1solv_1_1SAMRAIVectorReal.html">SAMRAIVectorReal</a>&lt; TYPE &gt; &gt; &amp;x, const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1solv_1_1SAMRAIVectorReal.html">SAMRAIVectorReal</a>&lt; TYPE &gt; &gt; &amp;y, const bool interior_only=true)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1SAMRAIVectorReal.html#edf8d979f8659ca6e1f9197a2603d058">multiply</a> (const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1solv_1_1SAMRAIVectorReal.html">SAMRAIVectorReal</a>&lt; TYPE &gt; &gt; &amp;x, const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1solv_1_1SAMRAIVectorReal.html">SAMRAIVectorReal</a>&lt; TYPE &gt; &gt; &amp;y, const bool interior_only=true)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1SAMRAIVectorReal.html#b0d3493281aeef979354435f893d3fbb">divide</a> (const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1solv_1_1SAMRAIVectorReal.html">SAMRAIVectorReal</a>&lt; TYPE &gt; &gt; &amp;x, const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1solv_1_1SAMRAIVectorReal.html">SAMRAIVectorReal</a>&lt; TYPE &gt; &gt; &amp;y, const bool interior_only=true)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1SAMRAIVectorReal.html#bd912c5f708387d842e8bb08fbaef9cb">reciprocal</a> (const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1solv_1_1SAMRAIVectorReal.html">SAMRAIVectorReal</a>&lt; TYPE &gt; &gt; &amp;x, const bool interior_only=true)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1SAMRAIVectorReal.html#58877a1b777af428f4cedffb04934e68">linearSum</a> (const TYPE &amp;alpha, const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1solv_1_1SAMRAIVectorReal.html">SAMRAIVectorReal</a>&lt; TYPE &gt; &gt; &amp;x, const TYPE &amp;beta, const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1solv_1_1SAMRAIVectorReal.html">SAMRAIVectorReal</a>&lt; TYPE &gt; &gt; &amp;y, const bool interior_only=true)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1SAMRAIVectorReal.html#0ff8c68bbb80684ed0206794699118ac">axpy</a> (const TYPE &amp;alpha, const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1solv_1_1SAMRAIVectorReal.html">SAMRAIVectorReal</a>&lt; TYPE &gt; &gt; &amp;x, const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1solv_1_1SAMRAIVectorReal.html">SAMRAIVectorReal</a>&lt; TYPE &gt; &gt; &amp;y, const bool interior_only=true)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1SAMRAIVectorReal.html#20855fc232b8820b3294f4ce946be6bb">abs</a> (const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1solv_1_1SAMRAIVectorReal.html">SAMRAIVectorReal</a>&lt; TYPE &gt; &gt; &amp;x, const bool interior_only=true)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">TYPE&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1SAMRAIVectorReal.html#672582d0e6d1a3d6063e33bc5dfd97d9">min</a> (const bool interior_only=true) const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">TYPE&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1SAMRAIVectorReal.html#fe7fe73730c8eb47bddd07f6939ec7a9">max</a> (const bool interior_only=true) const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1SAMRAIVectorReal.html#0fbd684b86ff07667e52fbcc8705ff88">setRandomValues</a> (const TYPE &amp;width, const TYPE &amp;low, const bool interior_only=true)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1SAMRAIVectorReal.html#800b72b8b29d97562248bf67ce3840d8">L1Norm</a> (bool local_only=false) const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1SAMRAIVectorReal.html#202d7dbedb67dca5991b04bdb626e799">L2Norm</a> (bool local_only=false) const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1SAMRAIVectorReal.html#f92a17cca5c61291a14286b4c6961d01">weightedL2Norm</a> (const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1solv_1_1SAMRAIVectorReal.html">SAMRAIVectorReal</a>&lt; TYPE &gt; &gt; &amp;wgt) const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1SAMRAIVectorReal.html#0e926ab1c66e05602ae6fffa60767ad0">RMSNorm</a> () const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1SAMRAIVectorReal.html#146e8dca22a1b79253abc7cdf19c8eae">weightedRMSNorm</a> (const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1solv_1_1SAMRAIVectorReal.html">SAMRAIVectorReal</a>&lt; TYPE &gt; &gt; &amp;wgt) const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1SAMRAIVectorReal.html#2dd1570845d92cd2a5a89b308416a60f">maxNorm</a> (bool local_only=false) const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">TYPE&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1SAMRAIVectorReal.html#478983b5fd4987fc70ef840d0feea2a3">dot</a> (const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1solv_1_1SAMRAIVectorReal.html">SAMRAIVectorReal</a>&lt; TYPE &gt; &gt; &amp;x, bool local_only=false) const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1SAMRAIVectorReal.html#9a20b19da24c1ca5885f4c551e668579">computeConstrProdPos</a> (const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1solv_1_1SAMRAIVectorReal.html">SAMRAIVectorReal</a>&lt; TYPE &gt; &gt; &amp;x) const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1SAMRAIVectorReal.html#cd78842ed9238c70f578b45bfe79a9f4">compareToScalar</a> (const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1solv_1_1SAMRAIVectorReal.html">SAMRAIVectorReal</a>&lt; TYPE &gt; &gt; &amp;x, const TYPE &amp;alpha)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1SAMRAIVectorReal.html#b0cd1b991cc38bb53267d6a6208c2f6d">testReciprocal</a> (const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1solv_1_1SAMRAIVectorReal.html">SAMRAIVectorReal</a>&lt; TYPE &gt; &gt; &amp;x)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">TYPE&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1SAMRAIVectorReal.html#07ee22f7ec8f4aa6af5ba818fb7489b1">maxPointwiseDivide</a> (const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1solv_1_1SAMRAIVectorReal.html">SAMRAIVectorReal</a>&lt; TYPE &gt; &gt; &amp;denom) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute max of "conditional" quotients of two arrays.  <a href="#07ee22f7ec8f4aa6af5ba818fb7489b1"></a><br></td></tr>
</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
<h3>template&lt;class TYPE&gt;<br>
 class SAMRAI::solv::SAMRAIVectorReal&lt; TYPE &gt;</h3>

Class <a class="el" href="classSAMRAI_1_1solv_1_1SAMRAIVectorReal.html">SAMRAIVectorReal</a> allows a collection of patch data types (with double or float data, but not both) defined over a <a class="el" href="namespaceSAMRAI.html">SAMRAI</a> hierarchy to be manipulated as though they are all part of a single vector. Specifically, this class provides a set of common vector operations to manipulate all of the data components as a whole. The most obvious use of this class is in <a class="el" href="namespaceSAMRAI.html">SAMRAI</a> applications that use solver libraries, such as KINSOL, CVODE, or PETSc. Specific vector objects that can be used with these packages are defined elsewhere in <a class="el" href="namespaceSAMRAI.html">SAMRAI</a>. However, all these vactor interfaces are built using this vector class.<p>
This class defines a vector to be any collection of patch data objects (either cell-, edge-, face-, node, or side-centered, or any combination of these) defined over a set of patch levels in an AMR hierarchy. All of the data objects must have the same underlying data type, either double or float. The vector structure is composed by adding individual variable quantities to the vector after it is constructed. When a component is added, a weighting or "control volume" component (having the same type as the vector component) may also be added to the vector. These weights are used to define the contribution of each vector entry to summing operations such as norms and dot products. For example, the weights can be used to mask out coarse level vector data entries in cells that are covered by fine cells when the coarse data are not actually part of the solution vector. The weights can also be used to map the vector operations to grid-based operations that define control volume weights. It is important to note that the centering of each control volume component must match that of the vector component with which it is associated.<p>
Typical usage of this vector class is as follows:<p>
<ul>
<li><b></b>(1) Construct a vector instance by specifying the patch hierarchy and range of levels over which the vector is defined. The levels must exist in the hierarchy before the vector can be used or an assertion will result. However, a vector may be created before the levels exist. The range of levels can be reset (such as after remeshing) by calling the <a class="el" href="classSAMRAI_1_1solv_1_1SAMRAIVectorReal.html#671291b63ea703578b795083ba6bb8fd">resetLevels()</a> function.</li><li><b></b>(2) Register each data component with the vector by providing the variable and its storage location (i.e., patch data index), and the control volume index if needed. See the <a class="el" href="classSAMRAI_1_1solv_1_1SAMRAIVectorReal.html#61dc105aa13f6118d3c7890099329a96">addComponent()</a> functions.</li><li><b></b>(3) Manipulate data using vector operations.</li></ul>
<p>
Before the vector operations can be used, the storage for each of its components must be allocated. Storage allocation is only possible through a vector object after all component variables are added to the vector (using the <a class="el" href="classSAMRAI_1_1solv_1_1SAMRAIVectorReal.html#61dc105aa13f6118d3c7890099329a96">addComponent()</a> function). Then, the <a class="el" href="classSAMRAI_1_1solv_1_1SAMRAIVectorReal.html#40d5da5c80161dd33e699a1ad8fe1666">allocateVectorData()</a> function will allocate storage for all components when called. Alternatively, patch data objects (corresponding to the variables and vector patch data indices) may be explicitly created elsewhere. However, depending on the circumstance, this second alternative may be more confusing and require more bookkeeping on the user's part. See the documentation accompanying the <a class="el" href="classSAMRAI_1_1solv_1_1SAMRAIVectorReal.html#61dc105aa13f6118d3c7890099329a96">addComponent()</a> function for more information.<p>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classSAMRAI_1_1math_1_1HierarchyDataOpsReal.html">math::HierarchyDataOpsReal</a> </dd></dl>

<p>
<hr><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" name="948fab3dbac7d0f0035829c45c7bd1cd"></a><!-- doxytag: member="SAMRAI::solv::SAMRAIVectorReal::SAMRAIVectorReal" ref="948fab3dbac7d0f0035829c45c7bd1cd" args="(const std::string &amp;name, const boost::shared_ptr&lt; hier::PatchHierarchy &gt; &amp;hierarchy, const int coarsest_level, const int finest_level)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSAMRAI_1_1solv_1_1SAMRAIVectorReal.html">SAMRAI::solv::SAMRAIVectorReal</a>&lt; TYPE &gt;::<a class="el" href="classSAMRAI_1_1solv_1_1SAMRAIVectorReal.html">SAMRAIVectorReal</a>           </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchHierarchy.html">hier::PatchHierarchy</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>hierarchy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>coarsest_level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>finest_level</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Constructor for <a class="el" href="classSAMRAI_1_1solv_1_1SAMRAIVectorReal.html">SAMRAIVectorReal</a> class is used to construct each unique vector within an application. That is, each vector that is used to represent a unique set of variable quantities is considered unique. This constructor is used to create a solution vector for an application or solver algorithm. The <a class="el" href="classSAMRAI_1_1solv_1_1SAMRAIVectorReal.html#25a88f92e5088abfd340741c699f71e9">cloneVector()</a> function is provided to generate copies of a given vector. For example, the clone function may be used by a solver to generate copies of the vector as needed; e.g., in a Krylov subspace method like GMRES.<p>
Before the vector may be used, data components must be added to it using the adddComponent(0 function. Also, this constructor does not allocate storage for vector data. This is usually done after all components are added. The <a class="el" href="classSAMRAI_1_1solv_1_1SAMRAIVectorReal.html#40d5da5c80161dd33e699a1ad8fe1666">allocateVectorData()</a> function is used for this purpose. Otherwise, existing patch data quantities can be added as vector components. In any case, storage for all components must be allocated before the vector can be used.<p>
The range levels can be reset at any time (e.g., if the level configuration changes by re-meshing), by calling the <a class="el" href="classSAMRAI_1_1solv_1_1SAMRAIVectorReal.html#671291b63ea703578b795083ba6bb8fd">resetLevels()</a> member function.<p>
Although an empty std::string may be passed as the vector name, it is recommended that a descriptive name be used to facilitate debugging and error reporting.<p>
By default the vector component information and data will be sent to the "plog" output stream when the <a class="el" href="classSAMRAI_1_1solv_1_1SAMRAIVectorReal.html#5d2a65e315281cd26c1017579c5b40f5">print()</a> function is called. This stream can be changed at any time via the <a class="el" href="classSAMRAI_1_1solv_1_1SAMRAIVectorReal.html#8e51ed8352f8e2bc18a893e3e5d464b9">setOutputStream()</a> function.<p>
<dl compact><dt><b>Precondition:</b></dt><dd>hierarchy <p>
(coarsest_level &gt;= 0) &amp;&amp; (finest_level &gt;= coarsest_level) &amp;&amp; (finest_level &lt;= hierarchy-&gt;<a class="el" href="classSAMRAI_1_1solv_1_1SAMRAIVectorReal.html#d07315a091a9c33e692c289649abefe0">getFinestLevelNumber()</a>) </dd></dl>

</div>
</div><p>
<a class="anchor" name="581070ab4220ad5b2fbc3aa75f1e3eb9"></a><!-- doxytag: member="SAMRAI::solv::SAMRAIVectorReal::~SAMRAIVectorReal" ref="581070ab4220ad5b2fbc3aa75f1e3eb9" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSAMRAI_1_1solv_1_1SAMRAIVectorReal.html">SAMRAI::solv::SAMRAIVectorReal</a>&lt; TYPE &gt;::~<a class="el" href="classSAMRAI_1_1solv_1_1SAMRAIVectorReal.html">SAMRAIVectorReal</a>           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Virtual destructor for <a class="el" href="classSAMRAI_1_1solv_1_1SAMRAIVectorReal.html">SAMRAIVectorReal</a> class. The destructor destroys all vector component information. However, the destructor does not deallocate the vector component storage, nor does it return the vector patch data indices to the patch descriptor free list. The <a class="el" href="classSAMRAI_1_1solv_1_1SAMRAIVectorReal.html#b77193fdf529f2e4fd367b562ce171ad">freeVectorComponents()</a> function is provided for this task. The reason for this is that an application may create a vector based on some pre-existing patch data objects that must live beyond the destruction of the vector object. 
</div>
</div><p>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="4be703d182bd7fcc3e0f51a927322722"></a><!-- doxytag: member="SAMRAI::solv::SAMRAIVectorReal::setName" ref="4be703d182bd7fcc3e0f51a927322722" args="(const std::string &amp;name)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSAMRAI_1_1solv_1_1SAMRAIVectorReal.html">SAMRAI::solv::SAMRAIVectorReal</a>&lt; TYPE &gt;::setName           </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>name</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set std::string identifier for this vector object. 
</div>
</div><p>
<a class="anchor" name="8e51ed8352f8e2bc18a893e3e5d464b9"></a><!-- doxytag: member="SAMRAI::solv::SAMRAIVectorReal::setOutputStream" ref="8e51ed8352f8e2bc18a893e3e5d464b9" args="(std::ostream &amp;s)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSAMRAI_1_1solv_1_1SAMRAIVectorReal.html">SAMRAI::solv::SAMRAIVectorReal</a>&lt; TYPE &gt;::setOutputStream           </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&nbsp;</td>
          <td class="paramname"> <em>s</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set output stream for vector object. When the <a class="el" href="classSAMRAI_1_1solv_1_1SAMRAIVectorReal.html#5d2a65e315281cd26c1017579c5b40f5">print()</a> function is called, all vector data will be sent to the given output stream. 
</div>
</div><p>
<a class="anchor" name="9977b38622216d183c9db80ff9822a89"></a><!-- doxytag: member="SAMRAI::solv::SAMRAIVectorReal::getOutputStream" ref="9977b38622216d183c9db80ff9822a89" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; <a class="el" href="classSAMRAI_1_1solv_1_1SAMRAIVectorReal.html">SAMRAI::solv::SAMRAIVectorReal</a>&lt; TYPE &gt;::getOutputStream           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return reference to the output stream used by this vector object. This function is primarily used by classes which define interfaces between this vector class and vector kernels defined by other packages. Specifically, <a class="el" href="namespaceSAMRAI.html">SAMRAI</a> vectors and package-specific wrappers for those vectors may all access the same output stream. 
</div>
</div><p>
<a class="anchor" name="671291b63ea703578b795083ba6bb8fd"></a><!-- doxytag: member="SAMRAI::solv::SAMRAIVectorReal::resetLevels" ref="671291b63ea703578b795083ba6bb8fd" args="(const int coarsest_level, const int finest_level)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSAMRAI_1_1solv_1_1SAMRAIVectorReal.html">SAMRAI::solv::SAMRAIVectorReal</a>&lt; TYPE &gt;::resetLevels           </td>
          <td>(</td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>coarsest_level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>finest_level</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Reset range of patch levels over which vector is defined. This function resets the data operations for all vector components. Note that the levels must exist in the hierarchy when this function is called or a non-recoverable assertion will result. 
</div>
</div><p>
<a class="anchor" name="93680dc20474c0732f63538b7a2b7c14"></a><!-- doxytag: member="SAMRAI::solv::SAMRAIVectorReal::getName" ref="93680dc20474c0732f63538b7a2b7c14" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const std::string &amp; <a class="el" href="classSAMRAI_1_1solv_1_1SAMRAIVectorReal.html">SAMRAI::solv::SAMRAIVectorReal</a>&lt; TYPE &gt;::getName           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return std::string identifier for this vector object. 
</div>
</div><p>
<a class="anchor" name="3f9a08f47ef24d786a32e521452da9ca"></a><!-- doxytag: member="SAMRAI::solv::SAMRAIVectorReal::getPatchHierarchy" ref="3f9a08f47ef24d786a32e521452da9ca" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchHierarchy.html">hier::PatchHierarchy</a> &gt; <a class="el" href="classSAMRAI_1_1solv_1_1SAMRAIVectorReal.html">SAMRAI::solv::SAMRAIVectorReal</a>&lt; TYPE &gt;::getPatchHierarchy           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return pointer to patch hierarchy associated with the vector. 
</div>
</div><p>
<a class="anchor" name="f4b3b73a67a1095bcde945e7f5b77936"></a><!-- doxytag: member="SAMRAI::solv::SAMRAIVectorReal::getCoarsestLevelNumber" ref="f4b3b73a67a1095bcde945e7f5b77936" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classSAMRAI_1_1solv_1_1SAMRAIVectorReal.html">SAMRAI::solv::SAMRAIVectorReal</a>&lt; TYPE &gt;::getCoarsestLevelNumber           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return integer number of coarsest hierarchy level for vector. 
</div>
</div><p>
<a class="anchor" name="d07315a091a9c33e692c289649abefe0"></a><!-- doxytag: member="SAMRAI::solv::SAMRAIVectorReal::getFinestLevelNumber" ref="d07315a091a9c33e692c289649abefe0" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classSAMRAI_1_1solv_1_1SAMRAIVectorReal.html">SAMRAI::solv::SAMRAIVectorReal</a>&lt; TYPE &gt;::getFinestLevelNumber           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return integer number of finest hierarchy level for vector. 
</div>
</div><p>
<a class="anchor" name="a51ff0c70822b11f1986b97558d68b33"></a><!-- doxytag: member="SAMRAI::solv::SAMRAIVectorReal::getNumberOfComponents" ref="a51ff0c70822b11f1986b97558d68b33" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classSAMRAI_1_1solv_1_1SAMRAIVectorReal.html">SAMRAI::solv::SAMRAIVectorReal</a>&lt; TYPE &gt;::getNumberOfComponents           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return integer number of patch data components in vector. 
</div>
</div><p>
<a class="anchor" name="ef9e3db5f110db3ae892aec7250d374b"></a><!-- doxytag: member="SAMRAI::solv::SAMRAIVectorReal::getComponentPatchData" ref="ef9e3db5f110db3ae892aec7250d374b" args="(const int comp_id, const hier::Patch &amp;patch) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchData.html">hier::PatchData</a> &gt; <a class="el" href="classSAMRAI_1_1solv_1_1SAMRAIVectorReal.html">SAMRAI::solv::SAMRAIVectorReal</a>&lt; TYPE &gt;::getComponentPatchData           </td>
          <td>(</td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>comp_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1Patch.html">hier::Patch</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>patch</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return patch data object for given vector component index.<p>
<dl compact><dt><b>Precondition:</b></dt><dd>(comp_id &gt;= 0) &amp;&amp; (comp_id &lt; <a class="el" href="classSAMRAI_1_1solv_1_1SAMRAIVectorReal.html#a51ff0c70822b11f1986b97558d68b33">getNumberOfComponents()</a>) </dd></dl>

</div>
</div><p>
<a class="anchor" name="5537f677c4764c7a2bfc53419398b14f"></a><!-- doxytag: member="SAMRAI::solv::SAMRAIVectorReal::getComponentPatchData" ref="5537f677c4764c7a2bfc53419398b14f" args="(const boost::shared_ptr&lt; hier::Variable &gt; &amp;var, const hier::Patch &amp;patch) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchData.html">hier::PatchData</a> &gt; <a class="el" href="classSAMRAI_1_1solv_1_1SAMRAIVectorReal.html">SAMRAI::solv::SAMRAIVectorReal</a>&lt; TYPE &gt;::getComponentPatchData           </td>
          <td>(</td>
          <td class="paramtype">const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1hier_1_1Variable.html">hier::Variable</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>var</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1Patch.html">hier::Patch</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>patch</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return patch data object associated with given variable.<p>
<dl compact><dt><b>Precondition:</b></dt><dd>var <p>
d_variableid_2_vectorcomponent_map[var-&gt;getInstanceIdentifier()] &gt;= 0 </dd></dl>

</div>
</div><p>
<a class="anchor" name="ba6ad44e1f9ca56b642a72673e4e8090"></a><!-- doxytag: member="SAMRAI::solv::SAMRAIVectorReal::getComponentVariable" ref="ba6ad44e1f9ca56b642a72673e4e8090" args="(const int component) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1hier_1_1Variable.html">hier::Variable</a> &gt; <a class="el" href="classSAMRAI_1_1solv_1_1SAMRAIVectorReal.html">SAMRAI::solv::SAMRAIVectorReal</a>&lt; TYPE &gt;::getComponentVariable           </td>
          <td>(</td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>component</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return pointer to variable for specified vector component.<p>
<dl compact><dt><b>Precondition:</b></dt><dd>(component &gt;= 0) &amp;&amp; (component &lt; <a class="el" href="classSAMRAI_1_1solv_1_1SAMRAIVectorReal.html#a51ff0c70822b11f1986b97558d68b33">getNumberOfComponents()</a>) </dd></dl>

</div>
</div><p>
<a class="anchor" name="edbbedcfba8bcca7ac456f7a6fa38b38"></a><!-- doxytag: member="SAMRAI::solv::SAMRAIVectorReal::getComponentDescriptorIndex" ref="edbbedcfba8bcca7ac456f7a6fa38b38" args="(const int component) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classSAMRAI_1_1solv_1_1SAMRAIVectorReal.html">SAMRAI::solv::SAMRAIVectorReal</a>&lt; TYPE &gt;::getComponentDescriptorIndex           </td>
          <td>(</td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>component</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return patch data index for specified vector component.<p>
<dl compact><dt><b>Precondition:</b></dt><dd>(component &gt;= 0) &amp;&amp; (component &lt; <a class="el" href="classSAMRAI_1_1solv_1_1SAMRAIVectorReal.html#a51ff0c70822b11f1986b97558d68b33">getNumberOfComponents()</a>) </dd></dl>

</div>
</div><p>
<a class="anchor" name="a791818048ee13f7c156c9250340ec58"></a><!-- doxytag: member="SAMRAI::solv::SAMRAIVectorReal::getControlVolumeIndex" ref="a791818048ee13f7c156c9250340ec58" args="(const int component) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classSAMRAI_1_1solv_1_1SAMRAIVectorReal.html">SAMRAI::solv::SAMRAIVectorReal</a>&lt; TYPE &gt;::getControlVolumeIndex           </td>
          <td>(</td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>component</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return patch data index of control volume data for vector component.<p>
<dl compact><dt><b>Precondition:</b></dt><dd>(component &gt;= 0) &amp;&amp; (component &lt; <a class="el" href="classSAMRAI_1_1solv_1_1SAMRAIVectorReal.html#a51ff0c70822b11f1986b97558d68b33">getNumberOfComponents()</a>) </dd></dl>

</div>
</div><p>
<a class="anchor" name="25a88f92e5088abfd340741c699f71e9"></a><!-- doxytag: member="SAMRAI::solv::SAMRAIVectorReal::cloneVector" ref="25a88f92e5088abfd340741c699f71e9" args="(const std::string &amp;name) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1solv_1_1SAMRAIVectorReal.html">SAMRAIVectorReal</a>&lt; TYPE &gt; &gt; <a class="el" href="classSAMRAI_1_1solv_1_1SAMRAIVectorReal.html">SAMRAI::solv::SAMRAIVectorReal</a>&lt; TYPE &gt;::cloneVector           </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>name</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Clone this vector object and return a pointer to the vector copy (i.e., a new vector). Each patch data component in the new vector will match the corresponding component in this vector object. However, the data for the components of the new vector will be assigned to different patch data indices than the original. In short, the cloned vector will have an identical structure to the original, but its data storage will be distinct. Before the new vector object can be used, its data must be allocated explicitly.<p>
Note that this function maps the variables associated with the new vector to the new vector component data indices (i.e., patch data indices) in the variable database. Thus the mapping between variables and patch data for the new vector can be obtained from the variable database if needed.<p>
If an empty std::string is passed in, the name of this vector object is used for the new vector. 
</div>
</div><p>
<a class="anchor" name="b77193fdf529f2e4fd367b562ce171ad"></a><!-- doxytag: member="SAMRAI::solv::SAMRAIVectorReal::freeVectorComponents" ref="b77193fdf529f2e4fd367b562ce171ad" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSAMRAI_1_1solv_1_1SAMRAIVectorReal.html">SAMRAI::solv::SAMRAIVectorReal</a>&lt; TYPE &gt;::freeVectorComponents           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Destroy the storage corresponding to the vector components and free the associated patch data entries from the variable database (which will also clear the indices from the patch descriptor). 
</div>
</div><p>
<a class="anchor" name="61dc105aa13f6118d3c7890099329a96"></a><!-- doxytag: member="SAMRAI::solv::SAMRAIVectorReal::addComponent" ref="61dc105aa13f6118d3c7890099329a96" args="(const boost::shared_ptr&lt; hier::Variable &gt; &amp;var, const int comp_data_id, const int control_vol_id=-1, const boost::shared_ptr&lt; math::HierarchyDataOpsReal&lt; TYPE &gt; &gt; &amp;vop=boost::shared_ptr&lt; math::HierarchyDataOpsReal&lt; TYPE &gt; &gt;())" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSAMRAI_1_1solv_1_1SAMRAIVectorReal.html">SAMRAI::solv::SAMRAIVectorReal</a>&lt; TYPE &gt;::addComponent           </td>
          <td>(</td>
          <td class="paramtype">const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1hier_1_1Variable.html">hier::Variable</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>var</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>comp_data_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>control_vol_id</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1math_1_1HierarchyDataOpsReal.html">math::HierarchyDataOpsReal</a>&lt; TYPE &gt; &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>vop</em> = <code>boost::shared_ptr&lt;&nbsp;<a class="el" href="classSAMRAI_1_1math_1_1HierarchyDataOpsReal.html">math::HierarchyDataOpsReal</a>&lt;&nbsp;TYPE&nbsp;&gt;&nbsp;&gt;()</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Add a new variable and patch data component to this vector. The integer values passed in represent the patch data indices for the vector component data and the component control volume data. If the control volume patch data index is not specified (i.e., control_vol_id &lt; 0), no weighting will be applied in vector operations associated with the component. This routine also accepts a hierarchy data operation object for the component should the user want to provide a special set of such operations. If left unspecified (nearly all cases), the standard operations for the given variable type are used.<p>
Note that this function maps the variable to the component data index (i.e., patch data index) in the variable database. Thus, the mapping between the variable and its patch data for the vector can be obtained from the variable database if needed.<p>
<dl compact><dt><b>Precondition:</b></dt><dd><a class="el" href="classSAMRAI_1_1hier_1_1VariableDatabase.html#9a9b3b6122833db2716a3a600dfa12e3">hier::VariableDatabase::getDatabase()</a>-&gt;checkVariablePatchDataIndexType(var, comp_data_id) <p>
(comp_vol_id &lt; 0) || (<a class="el" href="classSAMRAI_1_1hier_1_1VariableDatabase.html#9a9b3b6122833db2716a3a600dfa12e3">hier::VariableDatabase::getDatabase()</a>-&gt;checkVariablePatchDataIndexType(var, comp_vol_id)) </dd></dl>

</div>
</div><p>
<a class="anchor" name="40d5da5c80161dd33e699a1ad8fe1666"></a><!-- doxytag: member="SAMRAI::solv::SAMRAIVectorReal::allocateVectorData" ref="40d5da5c80161dd33e699a1ad8fe1666" args="(const double timestamp=0.0)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSAMRAI_1_1solv_1_1SAMRAIVectorReal.html">SAMRAI::solv::SAMRAIVectorReal</a>&lt; TYPE &gt;::allocateVectorData           </td>
          <td>(</td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>timestamp</em> = <code>0.0</code>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Allocate data storage for all components of this vector object.<p>
<dl compact><dt><b>Precondition:</b></dt><dd>getPatchHierarchy <p>
(<a class="el" href="classSAMRAI_1_1solv_1_1SAMRAIVectorReal.html#f4b3b73a67a1095bcde945e7f5b77936">getCoarsestLevelNumber()</a> &gt;= 0) &amp;&amp; (<a class="el" href="classSAMRAI_1_1solv_1_1SAMRAIVectorReal.html#d07315a091a9c33e692c289649abefe0">getFinestLevelNumber()</a> &gt;= <a class="el" href="classSAMRAI_1_1solv_1_1SAMRAIVectorReal.html#f4b3b73a67a1095bcde945e7f5b77936">getCoarsestLevelNumber()</a>) &amp;&amp; (getFinestLevelNumber( &lt;= d_hierarchy-&gt;<a class="el" href="classSAMRAI_1_1solv_1_1SAMRAIVectorReal.html#d07315a091a9c33e692c289649abefe0">getFinestLevelNumber()</a>) </dd></dl>

</div>
</div><p>
<a class="anchor" name="b7eb91445678395d0d1cd09d4c234af4"></a><!-- doxytag: member="SAMRAI::solv::SAMRAIVectorReal::deallocateVectorData" ref="b7eb91445678395d0d1cd09d4c234af4" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSAMRAI_1_1solv_1_1SAMRAIVectorReal.html">SAMRAI::solv::SAMRAIVectorReal</a>&lt; TYPE &gt;::deallocateVectorData           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Deallocate data storage for all components of this vector object. Note that this routine will not free the associated data indices in the patch descriptor. See <a class="el" href="classSAMRAI_1_1solv_1_1SAMRAIVectorReal.html#b77193fdf529f2e4fd367b562ce171ad">freeVectorComponents()</a> function.<p>
<dl compact><dt><b>Precondition:</b></dt><dd>getPatchHierarchy <p>
(<a class="el" href="classSAMRAI_1_1solv_1_1SAMRAIVectorReal.html#f4b3b73a67a1095bcde945e7f5b77936">getCoarsestLevelNumber()</a> &gt;= 0) &amp;&amp; (<a class="el" href="classSAMRAI_1_1solv_1_1SAMRAIVectorReal.html#d07315a091a9c33e692c289649abefe0">getFinestLevelNumber()</a> &gt;= <a class="el" href="classSAMRAI_1_1solv_1_1SAMRAIVectorReal.html#f4b3b73a67a1095bcde945e7f5b77936">getCoarsestLevelNumber()</a>) &amp;&amp; (getFinestLevelNumber( &lt;= d_hierarchy-&gt;<a class="el" href="classSAMRAI_1_1solv_1_1SAMRAIVectorReal.html#d07315a091a9c33e692c289649abefe0">getFinestLevelNumber()</a>) </dd></dl>

</div>
</div><p>
<a class="anchor" name="5d2a65e315281cd26c1017579c5b40f5"></a><!-- doxytag: member="SAMRAI::solv::SAMRAIVectorReal::print" ref="5d2a65e315281cd26c1017579c5b40f5" args="(std::ostream &amp;s=tbox::plog, const bool interior_only=true) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSAMRAI_1_1solv_1_1SAMRAIVectorReal.html">SAMRAI::solv::SAMRAIVectorReal</a>&lt; TYPE &gt;::print           </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&nbsp;</td>
          <td class="paramname"> <em>s</em> = <code><a class="el" href="namespaceSAMRAI_1_1tbox.html#b84041705493761fb17a8127e3a2dca2">tbox::plog</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&nbsp;</td>
          <td class="paramname"> <em>interior_only</em> = <code>true</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Print component information and data for this vector object. 
</div>
</div><p>
<a class="anchor" name="6d12617e21f053e6c00cbb302f94a5a5"></a><!-- doxytag: member="SAMRAI::solv::SAMRAIVectorReal::copyVector" ref="6d12617e21f053e6c00cbb302f94a5a5" args="(const boost::shared_ptr&lt; SAMRAIVectorReal&lt; TYPE &gt; &gt; &amp;src_vec, const bool interior_only=true)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSAMRAI_1_1solv_1_1SAMRAIVectorReal.html">SAMRAI::solv::SAMRAIVectorReal</a>&lt; TYPE &gt;::copyVector           </td>
          <td>(</td>
          <td class="paramtype">const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1solv_1_1SAMRAIVectorReal.html">SAMRAIVectorReal</a>&lt; TYPE &gt; &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>src_vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&nbsp;</td>
          <td class="paramname"> <em>interior_only</em> = <code>true</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Copy data from source vector components to components of this vector. 
</div>
</div><p>
<a class="anchor" name="bb8b3d96cad3d31c64c0837175c38800"></a><!-- doxytag: member="SAMRAI::solv::SAMRAIVectorReal::swapVectors" ref="bb8b3d96cad3d31c64c0837175c38800" args="(const boost::shared_ptr&lt; SAMRAIVectorReal&lt; TYPE &gt; &gt; &amp;other)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSAMRAI_1_1solv_1_1SAMRAIVectorReal.html">SAMRAI::solv::SAMRAIVectorReal</a>&lt; TYPE &gt;::swapVectors           </td>
          <td>(</td>
          <td class="paramtype">const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1solv_1_1SAMRAIVectorReal.html">SAMRAIVectorReal</a>&lt; TYPE &gt; &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>other</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Swap data components (i.e. storage) between this vector object and argument vector. 
</div>
</div><p>
<a class="anchor" name="53713e997f15865ad62f59c4eee48ac9"></a><!-- doxytag: member="SAMRAI::solv::SAMRAIVectorReal::setToScalar" ref="53713e997f15865ad62f59c4eee48ac9" args="(const TYPE &amp;alpha, const bool interior_only=true)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSAMRAI_1_1solv_1_1SAMRAIVectorReal.html">SAMRAI::solv::SAMRAIVectorReal</a>&lt; TYPE &gt;::setToScalar           </td>
          <td>(</td>
          <td class="paramtype">const TYPE &amp;&nbsp;</td>
          <td class="paramname"> <em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&nbsp;</td>
          <td class="paramname"> <em>interior_only</em> = <code>true</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set all components of this vector to given scalar value. 
</div>
</div><p>
<a class="anchor" name="dfa527030ec59ff32daf1bb841c5b4eb"></a><!-- doxytag: member="SAMRAI::solv::SAMRAIVectorReal::scale" ref="dfa527030ec59ff32daf1bb841c5b4eb" args="(const TYPE &amp;alpha, const boost::shared_ptr&lt; SAMRAIVectorReal&lt; TYPE &gt; &gt; &amp;x, const bool interior_only=true)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSAMRAI_1_1solv_1_1SAMRAIVectorReal.html">SAMRAI::solv::SAMRAIVectorReal</a>&lt; TYPE &gt;::scale           </td>
          <td>(</td>
          <td class="paramtype">const TYPE &amp;&nbsp;</td>
          <td class="paramname"> <em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1solv_1_1SAMRAIVectorReal.html">SAMRAIVectorReal</a>&lt; TYPE &gt; &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&nbsp;</td>
          <td class="paramname"> <em>interior_only</em> = <code>true</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set this vector to src vector multiplied by given scalar. 
</div>
</div><p>
<a class="anchor" name="3b19117454bb807e952be68b40a2cd34"></a><!-- doxytag: member="SAMRAI::solv::SAMRAIVectorReal::addScalar" ref="3b19117454bb807e952be68b40a2cd34" args="(const boost::shared_ptr&lt; SAMRAIVectorReal&lt; TYPE &gt; &gt; &amp;x, const TYPE &amp;alpha, const bool interior_only=true)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSAMRAI_1_1solv_1_1SAMRAIVectorReal.html">SAMRAI::solv::SAMRAIVectorReal</a>&lt; TYPE &gt;::addScalar           </td>
          <td>(</td>
          <td class="paramtype">const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1solv_1_1SAMRAIVectorReal.html">SAMRAIVectorReal</a>&lt; TYPE &gt; &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TYPE &amp;&nbsp;</td>
          <td class="paramname"> <em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&nbsp;</td>
          <td class="paramname"> <em>interior_only</em> = <code>true</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set this vector to sum of given vector and scalar. 
</div>
</div><p>
<a class="anchor" name="90b4a3fe6ff354ca0a1cedbe54bd7356"></a><!-- doxytag: member="SAMRAI::solv::SAMRAIVectorReal::add" ref="90b4a3fe6ff354ca0a1cedbe54bd7356" args="(const boost::shared_ptr&lt; SAMRAIVectorReal&lt; TYPE &gt; &gt; &amp;x, const boost::shared_ptr&lt; SAMRAIVectorReal&lt; TYPE &gt; &gt; &amp;y, const bool interior_only=true)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSAMRAI_1_1solv_1_1SAMRAIVectorReal.html">SAMRAI::solv::SAMRAIVectorReal</a>&lt; TYPE &gt;::add           </td>
          <td>(</td>
          <td class="paramtype">const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1solv_1_1SAMRAIVectorReal.html">SAMRAIVectorReal</a>&lt; TYPE &gt; &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1solv_1_1SAMRAIVectorReal.html">SAMRAIVectorReal</a>&lt; TYPE &gt; &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&nbsp;</td>
          <td class="paramname"> <em>interior_only</em> = <code>true</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set this vector to sum of two given vectors. 
</div>
</div><p>
<a class="anchor" name="6d25272a3ba500f9c94a5fadaeea2a84"></a><!-- doxytag: member="SAMRAI::solv::SAMRAIVectorReal::subtract" ref="6d25272a3ba500f9c94a5fadaeea2a84" args="(const boost::shared_ptr&lt; SAMRAIVectorReal&lt; TYPE &gt; &gt; &amp;x, const boost::shared_ptr&lt; SAMRAIVectorReal&lt; TYPE &gt; &gt; &amp;y, const bool interior_only=true)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSAMRAI_1_1solv_1_1SAMRAIVectorReal.html">SAMRAI::solv::SAMRAIVectorReal</a>&lt; TYPE &gt;::subtract           </td>
          <td>(</td>
          <td class="paramtype">const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1solv_1_1SAMRAIVectorReal.html">SAMRAIVectorReal</a>&lt; TYPE &gt; &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1solv_1_1SAMRAIVectorReal.html">SAMRAIVectorReal</a>&lt; TYPE &gt; &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&nbsp;</td>
          <td class="paramname"> <em>interior_only</em> = <code>true</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set this vector to difference of two given vectors (i.e., x - y). 
</div>
</div><p>
<a class="anchor" name="edf8d979f8659ca6e1f9197a2603d058"></a><!-- doxytag: member="SAMRAI::solv::SAMRAIVectorReal::multiply" ref="edf8d979f8659ca6e1f9197a2603d058" args="(const boost::shared_ptr&lt; SAMRAIVectorReal&lt; TYPE &gt; &gt; &amp;x, const boost::shared_ptr&lt; SAMRAIVectorReal&lt; TYPE &gt; &gt; &amp;y, const bool interior_only=true)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSAMRAI_1_1solv_1_1SAMRAIVectorReal.html">SAMRAI::solv::SAMRAIVectorReal</a>&lt; TYPE &gt;::multiply           </td>
          <td>(</td>
          <td class="paramtype">const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1solv_1_1SAMRAIVectorReal.html">SAMRAIVectorReal</a>&lt; TYPE &gt; &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1solv_1_1SAMRAIVectorReal.html">SAMRAIVectorReal</a>&lt; TYPE &gt; &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&nbsp;</td>
          <td class="paramname"> <em>interior_only</em> = <code>true</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set each entry in this vector to product of corresponding entries in input vectors. 
</div>
</div><p>
<a class="anchor" name="b0d3493281aeef979354435f893d3fbb"></a><!-- doxytag: member="SAMRAI::solv::SAMRAIVectorReal::divide" ref="b0d3493281aeef979354435f893d3fbb" args="(const boost::shared_ptr&lt; SAMRAIVectorReal&lt; TYPE &gt; &gt; &amp;x, const boost::shared_ptr&lt; SAMRAIVectorReal&lt; TYPE &gt; &gt; &amp;y, const bool interior_only=true)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSAMRAI_1_1solv_1_1SAMRAIVectorReal.html">SAMRAI::solv::SAMRAIVectorReal</a>&lt; TYPE &gt;::divide           </td>
          <td>(</td>
          <td class="paramtype">const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1solv_1_1SAMRAIVectorReal.html">SAMRAIVectorReal</a>&lt; TYPE &gt; &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1solv_1_1SAMRAIVectorReal.html">SAMRAIVectorReal</a>&lt; TYPE &gt; &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&nbsp;</td>
          <td class="paramname"> <em>interior_only</em> = <code>true</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set each entry in this vector to ratio of corresponding entries in input vectors (i.e., x / y). No check for division by zero. 
</div>
</div><p>
<a class="anchor" name="bd912c5f708387d842e8bb08fbaef9cb"></a><!-- doxytag: member="SAMRAI::solv::SAMRAIVectorReal::reciprocal" ref="bd912c5f708387d842e8bb08fbaef9cb" args="(const boost::shared_ptr&lt; SAMRAIVectorReal&lt; TYPE &gt; &gt; &amp;x, const bool interior_only=true)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSAMRAI_1_1solv_1_1SAMRAIVectorReal.html">SAMRAI::solv::SAMRAIVectorReal</a>&lt; TYPE &gt;::reciprocal           </td>
          <td>(</td>
          <td class="paramtype">const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1solv_1_1SAMRAIVectorReal.html">SAMRAIVectorReal</a>&lt; TYPE &gt; &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&nbsp;</td>
          <td class="paramname"> <em>interior_only</em> = <code>true</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set each entry of this vector to reciprocal of corresponding entry in input vector. No check is made for division by zero. 
</div>
</div><p>
<a class="anchor" name="58877a1b777af428f4cedffb04934e68"></a><!-- doxytag: member="SAMRAI::solv::SAMRAIVectorReal::linearSum" ref="58877a1b777af428f4cedffb04934e68" args="(const TYPE &amp;alpha, const boost::shared_ptr&lt; SAMRAIVectorReal&lt; TYPE &gt; &gt; &amp;x, const TYPE &amp;beta, const boost::shared_ptr&lt; SAMRAIVectorReal&lt; TYPE &gt; &gt; &amp;y, const bool interior_only=true)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSAMRAI_1_1solv_1_1SAMRAIVectorReal.html">SAMRAI::solv::SAMRAIVectorReal</a>&lt; TYPE &gt;::linearSum           </td>
          <td>(</td>
          <td class="paramtype">const TYPE &amp;&nbsp;</td>
          <td class="paramname"> <em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1solv_1_1SAMRAIVectorReal.html">SAMRAIVectorReal</a>&lt; TYPE &gt; &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TYPE &amp;&nbsp;</td>
          <td class="paramname"> <em>beta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1solv_1_1SAMRAIVectorReal.html">SAMRAIVectorReal</a>&lt; TYPE &gt; &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&nbsp;</td>
          <td class="paramname"> <em>interior_only</em> = <code>true</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set this vector to the linear sum <img class="formulaInl" alt="$ \alpha x + @beta y $" src="form_83.png"> , where <img class="formulaInl" alt="$ \alpha, @beta $" src="form_84.png"> are scalars and <img class="formulaInl" alt="$ x, y $" src="form_85.png"> are vectors. 
</div>
</div><p>
<a class="anchor" name="0ff8c68bbb80684ed0206794699118ac"></a><!-- doxytag: member="SAMRAI::solv::SAMRAIVectorReal::axpy" ref="0ff8c68bbb80684ed0206794699118ac" args="(const TYPE &amp;alpha, const boost::shared_ptr&lt; SAMRAIVectorReal&lt; TYPE &gt; &gt; &amp;x, const boost::shared_ptr&lt; SAMRAIVectorReal&lt; TYPE &gt; &gt; &amp;y, const bool interior_only=true)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSAMRAI_1_1solv_1_1SAMRAIVectorReal.html">SAMRAI::solv::SAMRAIVectorReal</a>&lt; TYPE &gt;::axpy           </td>
          <td>(</td>
          <td class="paramtype">const TYPE &amp;&nbsp;</td>
          <td class="paramname"> <em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1solv_1_1SAMRAIVectorReal.html">SAMRAIVectorReal</a>&lt; TYPE &gt; &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1solv_1_1SAMRAIVectorReal.html">SAMRAIVectorReal</a>&lt; TYPE &gt; &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&nbsp;</td>
          <td class="paramname"> <em>interior_only</em> = <code>true</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set this vector to the sum <img class="formulaInl" alt="$ \alpha x + y $" src="form_86.png"> , where <img class="formulaInl" alt="$ \alpha $" src="form_51.png"> is a scalar and <img class="formulaInl" alt="$ x, y $" src="form_85.png"> are vectors. 
</div>
</div><p>
<a class="anchor" name="20855fc232b8820b3294f4ce946be6bb"></a><!-- doxytag: member="SAMRAI::solv::SAMRAIVectorReal::abs" ref="20855fc232b8820b3294f4ce946be6bb" args="(const boost::shared_ptr&lt; SAMRAIVectorReal&lt; TYPE &gt; &gt; &amp;x, const bool interior_only=true)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSAMRAI_1_1solv_1_1SAMRAIVectorReal.html">SAMRAI::solv::SAMRAIVectorReal</a>&lt; TYPE &gt;::abs           </td>
          <td>(</td>
          <td class="paramtype">const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1solv_1_1SAMRAIVectorReal.html">SAMRAIVectorReal</a>&lt; TYPE &gt; &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&nbsp;</td>
          <td class="paramname"> <em>interior_only</em> = <code>true</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set each entry of this vector to absolute values of corresponding entry in input vector. 
</div>
</div><p>
<a class="anchor" name="672582d0e6d1a3d6063e33bc5dfd97d9"></a><!-- doxytag: member="SAMRAI::solv::SAMRAIVectorReal::min" ref="672582d0e6d1a3d6063e33bc5dfd97d9" args="(const bool interior_only=true) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">TYPE <a class="el" href="classSAMRAI_1_1solv_1_1SAMRAIVectorReal.html">SAMRAI::solv::SAMRAIVectorReal</a>&lt; TYPE &gt;::min           </td>
          <td>(</td>
          <td class="paramtype">const bool&nbsp;</td>
          <td class="paramname"> <em>interior_only</em> = <code>true</code>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return the minimum data entry in this vector. Note that this routine returns a global min over all vector components and makes no adjustment for coarser level vector data that may be masked out by the existence of underlying fine values. In particular, the control volumes are not used in this operation. This may change based on user needs. 
</div>
</div><p>
<a class="anchor" name="fe7fe73730c8eb47bddd07f6939ec7a9"></a><!-- doxytag: member="SAMRAI::solv::SAMRAIVectorReal::max" ref="fe7fe73730c8eb47bddd07f6939ec7a9" args="(const bool interior_only=true) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">TYPE <a class="el" href="classSAMRAI_1_1solv_1_1SAMRAIVectorReal.html">SAMRAI::solv::SAMRAIVectorReal</a>&lt; TYPE &gt;::max           </td>
          <td>(</td>
          <td class="paramtype">const bool&nbsp;</td>
          <td class="paramname"> <em>interior_only</em> = <code>true</code>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return the maximum entry of this vector. Note that this routine returns a global max over all vector components and makes no adjustment for coarser level vector data that may be masked out by the existence of underlying fine values. In particular, the control volumes are not used in this operation. This may change based on user needs. 
</div>
</div><p>
<a class="anchor" name="0fbd684b86ff07667e52fbcc8705ff88"></a><!-- doxytag: member="SAMRAI::solv::SAMRAIVectorReal::setRandomValues" ref="0fbd684b86ff07667e52fbcc8705ff88" args="(const TYPE &amp;width, const TYPE &amp;low, const bool interior_only=true)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSAMRAI_1_1solv_1_1SAMRAIVectorReal.html">SAMRAI::solv::SAMRAIVectorReal</a>&lt; TYPE &gt;::setRandomValues           </td>
          <td>(</td>
          <td class="paramtype">const TYPE &amp;&nbsp;</td>
          <td class="paramname"> <em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TYPE &amp;&nbsp;</td>
          <td class="paramname"> <em>low</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&nbsp;</td>
          <td class="paramname"> <em>interior_only</em> = <code>true</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set data in this vector to random values. 
</div>
</div><p>
<a class="anchor" name="800b72b8b29d97562248bf67ce3840d8"></a><!-- doxytag: member="SAMRAI::solv::SAMRAIVectorReal::L1Norm" ref="800b72b8b29d97562248bf67ce3840d8" args="(bool local_only=false) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="classSAMRAI_1_1solv_1_1SAMRAIVectorReal.html">SAMRAI::solv::SAMRAIVectorReal</a>&lt; TYPE &gt;::L1Norm           </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>local_only</em> = <code>false</code>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return discrete <img class="formulaInl" alt="$ L_1 $" src="form_69.png"> -norm of this vector using the control volume to weight the contribution of each data entry to the sum. That is, the return value is the sum <img class="formulaInl" alt="$ \sum_i ( \| data_i \| cvol_i ) $" src="form_87.png"> . If the control volume is not defined for a component, the contribution is <img class="formulaInl" alt="$ \sum_i ( \| data_i \| ) $" src="form_88.png"> for that data component. Thus, to have a consistent norm calculation all components must have control volumes, or no control volumes should be used at all. 
</div>
</div><p>
<a class="anchor" name="202d7dbedb67dca5991b04bdb626e799"></a><!-- doxytag: member="SAMRAI::solv::SAMRAIVectorReal::L2Norm" ref="202d7dbedb67dca5991b04bdb626e799" args="(bool local_only=false) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="classSAMRAI_1_1solv_1_1SAMRAIVectorReal.html">SAMRAI::solv::SAMRAIVectorReal</a>&lt; TYPE &gt;::L2Norm           </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>local_only</em> = <code>false</code>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return discrete <img class="formulaInl" alt="$ L_2 $" src="form_70.png"> -norm of this vector using the control volume to weight the contribution of each data entry to the sum. That is, the return value is the sum <img class="formulaInl" alt="$ \sqrt{ \sum_i ( (data_i)^2 cvol_i ) } $" src="form_89.png"> . If the control volume is not defined for a component, the contribution is <img class="formulaInl" alt="$ \sqrt{ \sum_i ( (data_i)^2 ) } $" src="form_90.png"> for that data component. Thus, to have a consistent norm calculation all components must have control volumes, or no control volumes should be used at all. 
</div>
</div><p>
<a class="anchor" name="f92a17cca5c61291a14286b4c6961d01"></a><!-- doxytag: member="SAMRAI::solv::SAMRAIVectorReal::weightedL2Norm" ref="f92a17cca5c61291a14286b4c6961d01" args="(const boost::shared_ptr&lt; SAMRAIVectorReal&lt; TYPE &gt; &gt; &amp;wgt) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="classSAMRAI_1_1solv_1_1SAMRAIVectorReal.html">SAMRAI::solv::SAMRAIVectorReal</a>&lt; TYPE &gt;::weightedL2Norm           </td>
          <td>(</td>
          <td class="paramtype">const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1solv_1_1SAMRAIVectorReal.html">SAMRAIVectorReal</a>&lt; TYPE &gt; &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>wgt</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return discrete weighted <img class="formulaInl" alt="$ L_2 $" src="form_70.png"> -norm of this vector using the control volume to weight the contribution of the data and weight entries to the sum. That is, the return value is the sum <img class="formulaInl" alt="$ \sqrt{ \sum_i ( (data_i * weight_i)^2 cvol_i ) } $" src="form_91.png"> . If the control volume is not defined for a component, the contribution is <img class="formulaInl" alt="$ \sqrt{ \sum_i ( (data_i * weight_i)^2 ) } $" src="form_92.png"> for that data component. Thus, to have a consistent norm calculation all components must have control volumes, or no control volumes should be used at all. 
</div>
</div><p>
<a class="anchor" name="0e926ab1c66e05602ae6fffa60767ad0"></a><!-- doxytag: member="SAMRAI::solv::SAMRAIVectorReal::RMSNorm" ref="0e926ab1c66e05602ae6fffa60767ad0" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="classSAMRAI_1_1solv_1_1SAMRAIVectorReal.html">SAMRAI::solv::SAMRAIVectorReal</a>&lt; TYPE &gt;::RMSNorm           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return discrete root mean squared norm of this vector. If control volumes are defined for all components, the return value is the <img class="formulaInl" alt="$ L_2 $" src="form_70.png"> -norm divided by the square root of the sum of the control volumes. If the control volume is not defined for a component, its contribution to the norm corresponds to its <img class="formulaInl" alt="$ L_2 $" src="form_70.png"> -norm divided by the square root of the number of data entries. Thus, to have a consistent norm calculation all components must have control volumes, or no control volumes should be used at all. 
</div>
</div><p>
<a class="anchor" name="146e8dca22a1b79253abc7cdf19c8eae"></a><!-- doxytag: member="SAMRAI::solv::SAMRAIVectorReal::weightedRMSNorm" ref="146e8dca22a1b79253abc7cdf19c8eae" args="(const boost::shared_ptr&lt; SAMRAIVectorReal&lt; TYPE &gt; &gt; &amp;wgt) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="classSAMRAI_1_1solv_1_1SAMRAIVectorReal.html">SAMRAI::solv::SAMRAIVectorReal</a>&lt; TYPE &gt;::weightedRMSNorm           </td>
          <td>(</td>
          <td class="paramtype">const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1solv_1_1SAMRAIVectorReal.html">SAMRAIVectorReal</a>&lt; TYPE &gt; &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>wgt</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return discrete weighted root mean squared norm of this vector. If control volumes are defined for all components, the return value is the weighted <img class="formulaInl" alt="$ L_2 $" src="form_70.png"> -norm divided by the square root of the sum of the control volumes. If the control volume is not defined for a component, its contribution to the norm corresponds to its weighted <img class="formulaInl" alt="$ L_2 $" src="form_70.png"> -norm divided by the square root of the number of data entries. Thus, to have a consistent norm calculation all components must have control volumes, or no control volumes should be used at all. 
</div>
</div><p>
<a class="anchor" name="2dd1570845d92cd2a5a89b308416a60f"></a><!-- doxytag: member="SAMRAI::solv::SAMRAIVectorReal::maxNorm" ref="2dd1570845d92cd2a5a89b308416a60f" args="(bool local_only=false) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="classSAMRAI_1_1solv_1_1SAMRAIVectorReal.html">SAMRAI::solv::SAMRAIVectorReal</a>&lt; TYPE &gt;::maxNorm           </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>local_only</em> = <code>false</code>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return the <img class="formulaInl" alt="$ \max $" src="form_93.png"> -norm of this vector. If control volumes are defined for all components, the return value is the max norm over all data values where the control volumes are non-zero. If the control volume is not defined for a component, its contribution to the norm will take a max over all of its data values. Thus, to have a consistent norm calculation all components must have control volumes, or no control volumes should be used at all. 
</div>
</div><p>
<a class="anchor" name="478983b5fd4987fc70ef840d0feea2a3"></a><!-- doxytag: member="SAMRAI::solv::SAMRAIVectorReal::dot" ref="478983b5fd4987fc70ef840d0feea2a3" args="(const boost::shared_ptr&lt; SAMRAIVectorReal&lt; TYPE &gt; &gt; &amp;x, bool local_only=false) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">TYPE <a class="el" href="classSAMRAI_1_1solv_1_1SAMRAIVectorReal.html">SAMRAI::solv::SAMRAIVectorReal</a>&lt; TYPE &gt;::dot           </td>
          <td>(</td>
          <td class="paramtype">const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1solv_1_1SAMRAIVectorReal.html">SAMRAIVectorReal</a>&lt; TYPE &gt; &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>local_only</em> = <code>false</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return the dot product of this vector with the argument vector. If control volumes are defined for all components, the return value is a weighted sum involving all data values where the control volumes are non-zero. If the control volume is not defined for a component, its contribution to the sum will involve all of its data values. Thus, to have a consistent dot product calculation all components must have control volumes, or no control volumes should be used at all. 
</div>
</div><p>
<a class="anchor" name="9a20b19da24c1ca5885f4c551e668579"></a><!-- doxytag: member="SAMRAI::solv::SAMRAIVectorReal::computeConstrProdPos" ref="9a20b19da24c1ca5885f4c551e668579" args="(const boost::shared_ptr&lt; SAMRAIVectorReal&lt; TYPE &gt; &gt; &amp;x) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classSAMRAI_1_1solv_1_1SAMRAIVectorReal.html">SAMRAI::solv::SAMRAIVectorReal</a>&lt; TYPE &gt;::computeConstrProdPos           </td>
          <td>(</td>
          <td class="paramtype">const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1solv_1_1SAMRAIVectorReal.html">SAMRAIVectorReal</a>&lt; TYPE &gt; &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return 1 if <img class="formulaInl" alt="$ \|x_i\| > 0 $" src="form_94.png"> and <img class="formulaInl" alt="$ w_i * x_i \leq 0 $" src="form_95.png"> , for any <img class="formulaInl" alt="$ i $" src="form_79.png"> in the set of vector data indices, where <img class="formulaInl" alt="$ cvol_i > 0 $" src="form_96.png"> . Here, <img class="formulaInl" alt="$ w_i $" src="form_78.png"> is a data entry in this vector. Otherwise, return 0. If the control volume is undefined for a component, all data values for the component are considered in the test. Thus, to have a consistent test all components must have control volumes, or no control volumes should be used at all. 
</div>
</div><p>
<a class="anchor" name="cd78842ed9238c70f578b45bfe79a9f4"></a><!-- doxytag: member="SAMRAI::solv::SAMRAIVectorReal::compareToScalar" ref="cd78842ed9238c70f578b45bfe79a9f4" args="(const boost::shared_ptr&lt; SAMRAIVectorReal&lt; TYPE &gt; &gt; &amp;x, const TYPE &amp;alpha)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSAMRAI_1_1solv_1_1SAMRAIVectorReal.html">SAMRAI::solv::SAMRAIVectorReal</a>&lt; TYPE &gt;::compareToScalar           </td>
          <td>(</td>
          <td class="paramtype">const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1solv_1_1SAMRAIVectorReal.html">SAMRAIVectorReal</a>&lt; TYPE &gt; &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TYPE &amp;&nbsp;</td>
          <td class="paramname"> <em>alpha</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Wherever <img class="formulaInl" alt="$ cvol_i > 0 $" src="form_96.png"> in the set of vector data indices, set <img class="formulaInl" alt="$ w_i = 1 $" src="form_97.png"> if <img class="formulaInl" alt="$ \|x_i\| > \alpha $" src="form_98.png"> , and <img class="formulaInl" alt="$ w_i = 0 $" src="form_99.png"> otherwise. Here, <img class="formulaInl" alt="$ w_i $" src="form_78.png"> is a data entry in this vector. If the control volume is undefined for a component, all data values for the component are involved in the comparison. Thus, to have a consistent comparison all components must have control volumes, or no control volumes should be used at all. 
</div>
</div><p>
<a class="anchor" name="b0cd1b991cc38bb53267d6a6208c2f6d"></a><!-- doxytag: member="SAMRAI::solv::SAMRAIVectorReal::testReciprocal" ref="b0cd1b991cc38bb53267d6a6208c2f6d" args="(const boost::shared_ptr&lt; SAMRAIVectorReal&lt; TYPE &gt; &gt; &amp;x)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classSAMRAI_1_1solv_1_1SAMRAIVectorReal.html">SAMRAI::solv::SAMRAIVectorReal</a>&lt; TYPE &gt;::testReciprocal           </td>
          <td>(</td>
          <td class="paramtype">const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1solv_1_1SAMRAIVectorReal.html">SAMRAIVectorReal</a>&lt; TYPE &gt; &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Wherever <img class="formulaInl" alt="$ cvol_i > 0 $" src="form_96.png"> in the set of vector data indices, set <img class="formulaInl" alt="$ w_i = 1/x_i $" src="form_100.png"> if <img class="formulaInl" alt="$ x_i \neq 0 $" src="form_101.png"> , and <img class="formulaInl" alt="$ w_i = 0 $" src="form_99.png"> otherwise. Here, <img class="formulaInl" alt="$ w_i $" src="form_78.png"> is a data entry in this vector. If the control volume is undefined for a component, all data values for the component are involved in the operation. Thus, to have a consistent operation all components must have control volumes, or no control volumes should be used at all. 
</div>
</div><p>
<a class="anchor" name="07ee22f7ec8f4aa6af5ba818fb7489b1"></a><!-- doxytag: member="SAMRAI::solv::SAMRAIVectorReal::maxPointwiseDivide" ref="07ee22f7ec8f4aa6af5ba818fb7489b1" args="(const boost::shared_ptr&lt; SAMRAIVectorReal&lt; TYPE &gt; &gt; &amp;denom) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">TYPE <a class="el" href="classSAMRAI_1_1solv_1_1SAMRAIVectorReal.html">SAMRAI::solv::SAMRAIVectorReal</a>&lt; TYPE &gt;::maxPointwiseDivide           </td>
          <td>(</td>
          <td class="paramtype">const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1solv_1_1SAMRAIVectorReal.html">SAMRAIVectorReal</a>&lt; TYPE &gt; &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>denom</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Compute max of "conditional" quotients of two arrays. 
<p>
Return the maximum of pointwise "conditional" quotients of the numerator and denominator.<p>
The "conditional" quotient is defined as |numerator/denominator| if the denominator is nonzero. Otherwise, it is defined as |numerator|.<p>
<b>Note:</b> This method is currently intended to support the PETSc-2.1.6 vector wrapper only. Please do not use it! 
</div>
</div><p>
<hr>The documentation for this class was generated from the following files:<ul>
<li>source/SAMRAI/solv/<a class="el" href="SAMRAIVectorReal_8h.html">SAMRAIVectorReal.h</a><li>source/SAMRAI/solv/<a class="el" href="SAMRAIVectorReal_8C.html">SAMRAIVectorReal.C</a></ul>
<hr size="1"><address style="align: right;"><small>Generated on 5 Jul 2013 for SAMRAI by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.7 </small></address>
</body>
</html>
