<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>SAMRAI: SAMRAI::pdat::OuteredgeData&lt; TYPE &gt; Class Template Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.7 -->
<div class="tabs">
  <ul>
    <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="namespaces.html"><span>Namespaces</span></a></li>
    <li id="current"><a href="annotated.html"><span>Classes</span></a></li>
    <li><a href="files.html"><span>Files</span></a></li>
    <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
  </ul></div>
<div class="tabs">
  <ul>
    <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
    <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
    <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
  </ul></div>
<div class="nav">
<a class="el" href="namespaceSAMRAI.html">SAMRAI</a>::<a class="el" href="namespaceSAMRAI_1_1pdat.html">pdat</a>::<a class="el" href="classSAMRAI_1_1pdat_1_1OuteredgeData.html">OuteredgeData</a></div>
<h1>SAMRAI::pdat::OuteredgeData&lt; TYPE &gt; Class Template Reference</h1><!-- doxytag: class="SAMRAI::pdat::OuteredgeData" --><!-- doxytag: inherits="SAMRAI::hier::PatchData" -->Class OuteredgeData&lt;TYPE&gt; provides an implementation for data defined at cell edges on the boundaries of AMR patches. It is derived from the <a class="el" href="classSAMRAI_1_1hier_1_1PatchData.html">hier::PatchData</a> interface common to all <a class="el" href="namespaceSAMRAI.html">SAMRAI</a> patch data types. Given a CELL-centered AMR index space box, an outeredge data object represents data of some template TYPE and depth on the cell edges on the boundary of the box. Here, depth indicates the number of data values at each edge index location. The OuteredgedgeGeometry class provides the translation between the standard <a class="el" href="namespaceSAMRAI.html">SAMRAI</a> cell-centered AMR index space and outeredge-centered data.  
<a href="#_details">More...</a>
<p>
<code>#include &lt;source/SAMRAI/pdat/OuteredgeData.h&gt;</code>
<p>
<p>Inheritance diagram for SAMRAI::pdat::OuteredgeData&lt; TYPE &gt;:
<p><center><img src="classSAMRAI_1_1pdat_1_1OuteredgeData.png" usemap="#SAMRAI::pdat::OuteredgeData< TYPE >_map" border="0" alt=""></center>
<map name="SAMRAI::pdat::OuteredgeData< TYPE >_map">
<area href="classSAMRAI_1_1hier_1_1PatchData.html" alt="SAMRAI::hier::PatchData" shape="rect" coords="0,0,238,24">
</map>
<a href="classSAMRAI_1_1pdat_1_1OuteredgeData-members.html">List of all members.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1pdat_1_1OuteredgeData.html#e93a939a339960ebd8fe23619c3443f2">OuteredgeData</a> (const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">hier::Box</a> &amp;box, int depth)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Constructor for an outeredge data object.  <a href="#e93a939a339960ebd8fe23619c3443f2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1pdat_1_1OuteredgeData.html#b56f6467748e4007a15d1a598196fbb6">~OuteredgeData</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Virtual destructor for a outeredge data object.  <a href="#b56f6467748e4007a15d1a598196fbb6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1pdat_1_1OuteredgeData.html#2db481c0309f63b1ece6d08f901e8d05">getDepth</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the depth (i.e., the number of data values for each spatial location) of the array.  <a href="#2db481c0309f63b1ece6d08f901e8d05"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1pdat_1_1OuteredgeData.html#b04993f56aa09953f85577313f7f6875">dataExists</a> (int axis, int face_normal) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns true if outeredge data exists for the given axis and face normal direction; false otherwise.  <a href="#b04993f56aa09953f85577313f7f6875"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classSAMRAI_1_1hier_1_1Box.html">hier::Box</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1pdat_1_1OuteredgeData.html#22bbf4cf4c3dde390cda398d531dd630">getDataBox</a> (int axis, int face_normal, int side)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the box of valid edge indices for outeredge data. Note: the returned box will reside in the <em>edge</em> index space.  <a href="#22bbf4cf4c3dde390cda398d531dd630"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">TYPE *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1pdat_1_1OuteredgeData.html#6fb5d3242802fe803acf4a2b1e856d04">getPointer</a> (int axis, int face_normal, int side, int depth=0)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get a pointer to the beginning of a particular axis, face normal, side, and depth component of the outeredge centered array.  <a href="#6fb5d3242802fe803acf4a2b1e856d04"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">const TYPE *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1pdat_1_1OuteredgeData.html#719d1ce135d91cf272d2330752262a56">getPointer</a> (int axis, int face_normal, int side, int depth=0) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get a const pointer to the beginning of a particular axis, face normal, side, and depth component of the outeredge centered array.  <a href="#719d1ce135d91cf272d2330752262a56"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">TYPE &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1pdat_1_1OuteredgeData.html#c6ba60b1b735e37dec764f28f2d4c8b1">operator()</a> (const <a class="el" href="classSAMRAI_1_1pdat_1_1EdgeIndex.html">EdgeIndex</a> &amp;i, int depth=0)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return a reference to data entry corresponding to a given edge index and depth.  <a href="#c6ba60b1b735e37dec764f28f2d4c8b1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">const TYPE &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1pdat_1_1OuteredgeData.html#c0399edb3082f867eae38364a17512ca">operator()</a> (const <a class="el" href="classSAMRAI_1_1pdat_1_1EdgeIndex.html">EdgeIndex</a> &amp;i, int depth=0) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return a const reference to data entry corresponding to a given edge index and depth.  <a href="#c0399edb3082f867eae38364a17512ca"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html">ArrayData</a>&lt; TYPE &gt; &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1pdat_1_1OuteredgeData.html#9cc40a571cf5d2f952e021778d8ed74e">getArrayData</a> (int axis, int face_normal, int side)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return a reference to the array data object for given axis, face normal, and side index of the outeredge centered array.  <a href="#9cc40a571cf5d2f952e021778d8ed74e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">const <a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html">ArrayData</a>&lt; TYPE &gt; &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1pdat_1_1OuteredgeData.html#16e76dc60dda8d5be4351ee9bcb9dfd4">getArrayData</a> (int axis, int face_normal, int side) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return a const reference to the array data object for given axis, face normal, and side index of the outeredge centered array.  <a href="#16e76dc60dda8d5be4351ee9bcb9dfd4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1pdat_1_1OuteredgeData.html#ac5d8c13ca05c50b5f88c80c3f78ea92">copy</a> (const <a class="el" href="classSAMRAI_1_1hier_1_1PatchData.html">hier::PatchData</a> &amp;src)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A fast copy from source to destination (i.e., this) patch data object.  <a href="#ac5d8c13ca05c50b5f88c80c3f78ea92"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1pdat_1_1OuteredgeData.html#3592bba5724b619b798d09502d044e1c">copy2</a> (<a class="el" href="classSAMRAI_1_1hier_1_1PatchData.html">hier::PatchData</a> &amp;dst) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A fast copy from source (i.e., this) to destination patch data object.  <a href="#3592bba5724b619b798d09502d044e1c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1pdat_1_1OuteredgeData.html#4acd765a71de212834ea6a7b9160f259">copy</a> (const <a class="el" href="classSAMRAI_1_1hier_1_1PatchData.html">hier::PatchData</a> &amp;src, const <a class="el" href="classSAMRAI_1_1hier_1_1BoxOverlap.html">hier::BoxOverlap</a> &amp;overlap)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copy data from source to destination (i.e., this) patch data object on the given overlap.  <a href="#4acd765a71de212834ea6a7b9160f259"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1pdat_1_1OuteredgeData.html#f3547603fe16d66e57dc2eb095c4348d">copy2</a> (<a class="el" href="classSAMRAI_1_1hier_1_1PatchData.html">hier::PatchData</a> &amp;dst, const <a class="el" href="classSAMRAI_1_1hier_1_1BoxOverlap.html">hier::BoxOverlap</a> &amp;overlap) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copy data from source (i.e., this) to destination patch data object on the given overlap.  <a href="#f3547603fe16d66e57dc2eb095c4348d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1pdat_1_1OuteredgeData.html#800ee1a498d93679f9c72f764a1d890b">copyDepth</a> (int dst_depth, const <a class="el" href="classSAMRAI_1_1pdat_1_1EdgeData.html">EdgeData</a>&lt; TYPE &gt; &amp;src, int src_depth)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Fast copy (i.e., assumes edge and outeredge data objects are defined over the same box) from the given edge source data object to this destination outeredge data object at the specified depths.  <a href="#800ee1a498d93679f9c72f764a1d890b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1pdat_1_1OuteredgeData.html#0ae546bb2d9d0a3b5ff37e2562f8d636">copyDepth2</a> (int dst_depth, <a class="el" href="classSAMRAI_1_1pdat_1_1EdgeData.html">EdgeData</a>&lt; TYPE &gt; &amp;dst, int src_depth) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Fast copy (i.e., assumes edge and outeredge data objects are defined over the same box) to the given edge destination data object from this source outeredge data object at the specified depths.  <a href="#0ae546bb2d9d0a3b5ff37e2562f8d636"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1pdat_1_1OuteredgeData.html#21ec1414a34922c6b244d6553a69a6d1">sum</a> (const <a class="el" href="classSAMRAI_1_1hier_1_1PatchData.html">hier::PatchData</a> &amp;src, const <a class="el" href="classSAMRAI_1_1hier_1_1BoxOverlap.html">hier::BoxOverlap</a> &amp;overlap)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Add data from source to destination (i.e., this) patch data object on the given overlap.  <a href="#21ec1414a34922c6b244d6553a69a6d1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1pdat_1_1OuteredgeData.html#86ae3f8f198b35afb21cecbf8e97276d">canEstimateStreamSizeFromBox</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return true if the patch data object can estimate the stream size required to fit its data using only index space information (i.e., a box).  <a href="#86ae3f8f198b35afb21cecbf8e97276d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1pdat_1_1OuteredgeData.html#ebda3831bfc284beeba7e7dc0dd3648c">getDataStreamSize</a> (const <a class="el" href="classSAMRAI_1_1hier_1_1BoxOverlap.html">hier::BoxOverlap</a> &amp;overlap) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the number of bytes needed to stream the data in this patch data object lying in the specified box overlap region.  <a href="#ebda3831bfc284beeba7e7dc0dd3648c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1pdat_1_1OuteredgeData.html#87d96f37d474c3416044d92d82b223b2">packStream</a> (<a class="el" href="classSAMRAI_1_1tbox_1_1MessageStream.html">tbox::MessageStream</a> &amp;stream, const <a class="el" href="classSAMRAI_1_1hier_1_1BoxOverlap.html">hier::BoxOverlap</a> &amp;overlap) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Pack data in this patch data object lying in the specified box overlap region into the stream. The overlap must be an <a class="el" href="classSAMRAI_1_1pdat_1_1EdgeOverlap.html">EdgeOverlap</a> of the same DIM.  <a href="#87d96f37d474c3416044d92d82b223b2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1pdat_1_1OuteredgeData.html#af6c8aee86d802d52a2b59f425376a6b">unpackStream</a> (<a class="el" href="classSAMRAI_1_1tbox_1_1MessageStream.html">tbox::MessageStream</a> &amp;stream, const <a class="el" href="classSAMRAI_1_1hier_1_1BoxOverlap.html">hier::BoxOverlap</a> &amp;overlap)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Unpack data from stream into this patch data object over the specified box overlap region. The overlap must be an <a class="el" href="classSAMRAI_1_1pdat_1_1EdgeOverlap.html">EdgeOverlap</a> of the same DIM.  <a href="#af6c8aee86d802d52a2b59f425376a6b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1pdat_1_1OuteredgeData.html#698fd4eaa01be7d9c40319f0363bd1e8">unpackStreamAndSum</a> (<a class="el" href="classSAMRAI_1_1tbox_1_1MessageStream.html">tbox::MessageStream</a> &amp;stream, const <a class="el" href="classSAMRAI_1_1hier_1_1BoxOverlap.html">hier::BoxOverlap</a> &amp;overlap)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Unpack data from stream and add into this patch data object over the specified box overlap region.  <a href="#698fd4eaa01be7d9c40319f0363bd1e8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1pdat_1_1OuteredgeData.html#6ae6fad0878aa0e67d3ad9e11ef6bae5">fill</a> (const TYPE &amp;t, int d=0)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Fill all values at depth d with the value t.  <a href="#6ae6fad0878aa0e67d3ad9e11ef6bae5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1pdat_1_1OuteredgeData.html#0778a3518e0a599f769e36a28543e1f2">fill</a> (const TYPE &amp;t, const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">hier::Box</a> &amp;box, int d=0)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Fill all values at depth d within the box with the value t.  <a href="#0778a3518e0a599f769e36a28543e1f2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1pdat_1_1OuteredgeData.html#54e12b1be7dadf84cd13cdaf9b71d1d2">fillAll</a> (const TYPE &amp;t)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Fill all depth components with value t.  <a href="#54e12b1be7dadf84cd13cdaf9b71d1d2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1pdat_1_1OuteredgeData.html#a3689a92a5a6d18bffb81b757929c68a">fillAll</a> (const TYPE &amp;t, const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">hier::Box</a> &amp;box)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Fill all depth components within the box with value t.  <a href="#a3689a92a5a6d18bffb81b757929c68a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1pdat_1_1OuteredgeData.html#f7478b2c947ebbd05f0023880ca88e10">print</a> (const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">hier::Box</a> &amp;box, std::ostream &amp;os=<a class="el" href="namespaceSAMRAI_1_1tbox.html#b84041705493761fb17a8127e3a2dca2">tbox::plog</a>, int prec=12) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Print all outeredge data values residing in the specified box. If the depth of the array is greater than one, all depths are printed.  <a href="#f7478b2c947ebbd05f0023880ca88e10"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1pdat_1_1OuteredgeData.html#3bf36ab3bc9936b3b673370261edfa4a">print</a> (const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">hier::Box</a> &amp;box, int depth, std::ostream &amp;os=<a class="el" href="namespaceSAMRAI_1_1tbox.html#b84041705493761fb17a8127e3a2dca2">tbox::plog</a>, int prec=12) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Print all outeredge data values at the given array depth in the specified box.  <a href="#3bf36ab3bc9936b3b673370261edfa4a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1pdat_1_1OuteredgeData.html#09eecf7259892c6a45a71933986214cf">printAxisSide</a> (int axis, int face_normal, int side, const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">hier::Box</a> &amp;box, std::ostream &amp;os=<a class="el" href="namespaceSAMRAI_1_1tbox.html#b84041705493761fb17a8127e3a2dca2">tbox::plog</a>, int prec=12) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Print all outeredge centered data values for specified axis, face_normal, and side residing in the specified box. If the depth of the data is greater than one, all depths are printed.  <a href="#09eecf7259892c6a45a71933986214cf"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1pdat_1_1OuteredgeData.html#bbd6412b2c6479cd3d850b52f382bb75">printAxisSide</a> (int axis, int face_normal, int side, const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">hier::Box</a> &amp;box, int depth, std::ostream &amp;os=<a class="el" href="namespaceSAMRAI_1_1tbox.html#b84041705493761fb17a8127e3a2dca2">tbox::plog</a>, int prec=12) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Print all outeredge centered data values for specified axis, face_normal, side, and depth residing in the specified box.  <a href="#bbd6412b2c6479cd3d850b52f382bb75"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1pdat_1_1OuteredgeData.html#236cff06aa49cc75f264a35272041c89">getFromRestart</a> (const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Database.html">tbox::Database</a> &gt; &amp;restart_db)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Check that class version and restart file version are equal. If so, read data members from the restart database.  <a href="#236cff06aa49cc75f264a35272041c89"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1pdat_1_1OuteredgeData.html#b16de422a71c1083869efaa33001d2b8">putToRestart</a> (const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Database.html">tbox::Database</a> &gt; &amp;restart_db) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Write out the class version number and other data members to the restart database.  <a href="#b16de422a71c1083869efaa33001d2b8"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Static Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1pdat_1_1OuteredgeData.html#63aff3cf6a833dfe90eaef9b0749ff40">getSizeOfData</a> (const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">hier::Box</a> &amp;box, int depth)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Calculate the amount of memory needed to represent outeredge- centered data over a CELL-centered AMR index space box.  <a href="#63aff3cf6a833dfe90eaef9b0749ff40"></a><br></td></tr>
</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
<h3>template&lt;class TYPE&gt;<br>
 class SAMRAI::pdat::OuteredgeData&lt; TYPE &gt;</h3>

Class OuteredgeData&lt;TYPE&gt; provides an implementation for data defined at cell edges on the boundaries of AMR patches. It is derived from the <a class="el" href="classSAMRAI_1_1hier_1_1PatchData.html">hier::PatchData</a> interface common to all <a class="el" href="namespaceSAMRAI.html">SAMRAI</a> patch data types. Given a CELL-centered AMR index space box, an outeredge data object represents data of some template TYPE and depth on the cell edges on the boundary of the box. Here, depth indicates the number of data values at each edge index location. The OuteredgedgeGeometry class provides the translation between the standard <a class="el" href="namespaceSAMRAI.html">SAMRAI</a> cell-centered AMR index space and outeredge-centered data. 
<p>
Outeredge data is stored in 2*DIM*(DIM-2) arrays, each of which contains data associated with edge indices in a coordinate axis direction, an outward pointing face normal direction, and an upper or lower box face in the face normal direction. The data layout in the outernode data arrays matches the corresponding array sections provided by the node data implementation. Note that outeredge data is NOT defined when the axis and face normal are equal. This is consistent with the edge data representation. Where an edge index falls on more than one box face (patch boundary edges and corners), the outeredge data value belongs to only one data array so that there are no redundant data values. Specifically, when DIM &gt; 2, outeredge data boxes are "trimmed" for each axis edge direction so that each edge index that lives on more than one face on the box boundary will be associated with the largest face normal direction and only that face. Within each array, data is stored in (i,...,k,d) order, where i,...,k indicates a spatial index and the d indicates the component depth at that location. Memory allocation is in column-major ordering (e.g., Fortran style) so that the leftmost index runs fastest in memory.<p>
To illustrate the outeredge data layout, in particular the "box trimming" that prevents redundant data values, we describe the data for a three-dimensional outeredge data object instantiated over a box [l0:u0,l1:u1,l2:u2] in the standard <a class="el" href="namespaceSAMRAI.html">SAMRAI</a> cell-centered AMR index space. Note: no boxes are trimmed when DIM &lt; 3.<p>
<div class="fragment"><pre class="fragment"> *
 *    a = edge axis (corresponds to the standard EdgeData axis)
 *    f = face normal dir
 *    s = lower/upper face
 *    d = data depth (i.e., number of values at each edge index point).
 *
 *    Here axis and face normal values 0, 1, and 2 can be thought of as X, Y, Z
 *    respectively.
 *
 *        (a,f,s)
 *    axis 0:
 *        (0,0,[0,1])  DATA IS NOT DEFINED when a == f
 *        (0,1,0)      [l0:u0, l1:l1,     l2+1:u2,   d]
 *        (0,1,1)      [l0:u0, u1+1:u1+1, l2+1:u2,   d]
 *        (0,2,0)      [l0:u0, l1:u1+1,   l2:l2,     d]
 *        (0,2,1)      [l0:u0, l1:u1+1,   u2+1:u2+1, d]
 *        Note: Edge indices are duplicated at the intersection of faces normal
 *              to directions 1 and 2.
 *              So boxes for face normal direction 1 are trimmed in direction 2
 *              so that edge indices shared with faces in direction 2 only
 *              appear in face normal direction 2 boxes.
 *
 *    axis 1:
 *        (1,0,0)      [l0:l0,     l1:u1, l2+1:u2,   d]
 *        (1,0,1)      [u0+1:u0+1, l1:u1, l2+1:u2,   d]
 *        (1,1,[0,1])  DATA IS NOT DEFINED when a == f
 *        (1,2,0)      [l0:u0+1,   l1:u1, l2:l2,     d]
 *        (1,2,1)      [l0:u0+1,   l1:u1, u2+1:u2+1, d]
 *        Note: Edge indices are duplicated at the intersection of faces normal
 *              to directions 0 and 2.
 *              So boxes for face normal direction 0 are trimmed in direction 2
 *              so that edge indices shared with faces in direction 2 only
 *              appear in face normal direction 2 boxes.
 *
 *    axis 2:
 *        (2,0,0)      [l0:l0,     l1+1:u1,   l2:u2, d]
 *        (2,0,1)      [u0+1:u0+1, l1+1:u1,   l2:u2, d]
 *        (2,1,0)      [l0:u0+1,   l1:l1,     l2:u2, d]
 *        (2,1,1)      [l0:u0+1,   u1+1:u1+1, l2:u2, d]
 *        (2,2,[0,1])  DATA IS NOT DEFINED when a == f
 *        Note: Edge indices are duplicated at the intersection of faces normal
 *              to directions 0 and 1.
 *              So boxes for face normal direction 0 are trimmed in direction 1
 *              so that edge indices shared with faces in direction 1 only
 *              appear in face normal direction 1 boxes.
 *
 * </pre></div> Other spatial dimensions are represented similarly.<p>
The data type TYPE must define a default constructor (that takes no arguments) and also the assignment operator.<p>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html">pdat::ArrayData</a> <p>
<a class="el" href="classSAMRAI_1_1hier_1_1PatchData.html">hier::PatchData</a> <p>
<a class="el" href="classSAMRAI_1_1pdat_1_1OuteredgeDataFactory.html">pdat::OuteredgeDataFactory</a> <p>
<a class="el" href="classSAMRAI_1_1pdat_1_1OuteredgeGeometry.html">pdat::OuteredgeGeometry</a> <p>
<a class="el" href="classSAMRAI_1_1pdat_1_1EdgeIterator.html">pdat::EdgeIterator</a> <p>
<a class="el" href="classSAMRAI_1_1pdat_1_1EdgeIndex.html">pdat::EdgeIndex</a> </dd></dl>

<p>
<hr><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" name="e93a939a339960ebd8fe23619c3443f2"></a><!-- doxytag: member="SAMRAI::pdat::OuteredgeData::OuteredgeData" ref="e93a939a339960ebd8fe23619c3443f2" args="(const hier::Box &amp;box, int depth)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSAMRAI_1_1pdat_1_1OuteredgeData.html">SAMRAI::pdat::OuteredgeData</a>&lt; TYPE &gt;::<a class="el" href="classSAMRAI_1_1pdat_1_1OuteredgeData.html">OuteredgeData</a>           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">hier::Box</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>box</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>depth</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Constructor for an outeredge data object. 
<p>
Note: Outeredge data always has ghost cell width of zero.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>box</em>&nbsp;</td><td>const Box reference describing the interior of the standard CELL-centered index box over which the outeredge data object will be created. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>depth</em>&nbsp;</td><td>gives the number of data values for each spatial location in the array.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Precondition:</b></dt><dd>depth &gt; 0 </dd></dl>

</div>
</div><p>
<a class="anchor" name="b56f6467748e4007a15d1a598196fbb6"></a><!-- doxytag: member="SAMRAI::pdat::OuteredgeData::~OuteredgeData" ref="b56f6467748e4007a15d1a598196fbb6" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSAMRAI_1_1pdat_1_1OuteredgeData.html">SAMRAI::pdat::OuteredgeData</a>&lt; TYPE &gt;::~<a class="el" href="classSAMRAI_1_1pdat_1_1OuteredgeData.html">OuteredgeData</a>           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Virtual destructor for a outeredge data object. 
<p>

</div>
</div><p>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="63aff3cf6a833dfe90eaef9b0749ff40"></a><!-- doxytag: member="SAMRAI::pdat::OuteredgeData::getSizeOfData" ref="63aff3cf6a833dfe90eaef9b0749ff40" args="(const hier::Box &amp;box, int depth)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classSAMRAI_1_1pdat_1_1OuteredgeData.html">SAMRAI::pdat::OuteredgeData</a>&lt; TYPE &gt;::getSizeOfData           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">hier::Box</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>box</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>depth</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Calculate the amount of memory needed to represent outeredge- centered data over a CELL-centered AMR index space box. 
<p>
This function assumes that the amount of memory needed for TYPE is sizeof(TYPE). If this is not the case, then a specialized function must be defined.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>box</em>&nbsp;</td><td>const Box reference describing the interior of the standard CELL-centered index box over which the outeredge data object will be created. Note: the ghost cell width is assumed to be zero. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>depth</em>&nbsp;</td><td>gives the number of data values for each spatial location in the array.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Precondition:</b></dt><dd>depth &gt; 0 </dd></dl>

</div>
</div><p>
<a class="anchor" name="2db481c0309f63b1ece6d08f901e8d05"></a><!-- doxytag: member="SAMRAI::pdat::OuteredgeData::getDepth" ref="2db481c0309f63b1ece6d08f901e8d05" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classSAMRAI_1_1pdat_1_1OuteredgeData.html">SAMRAI::pdat::OuteredgeData</a>&lt; TYPE &gt;::getDepth           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return the depth (i.e., the number of data values for each spatial location) of the array. 
<p>

</div>
</div><p>
<a class="anchor" name="b04993f56aa09953f85577313f7f6875"></a><!-- doxytag: member="SAMRAI::pdat::OuteredgeData::dataExists" ref="b04993f56aa09953f85577313f7f6875" args="(int axis, int face_normal) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classSAMRAI_1_1pdat_1_1OuteredgeData.html">SAMRAI::pdat::OuteredgeData</a>&lt; TYPE &gt;::dataExists           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>axis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>face_normal</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns true if outeredge data exists for the given axis and face normal direction; false otherwise. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>axis</em>&nbsp;</td><td>integer edge data coordinate axis, must satisfy 0 &lt;= axis &lt; DIM </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>face_normal</em>&nbsp;</td><td>integer face normal direction for data, must satisfy 0 &lt;= face_normal &lt; DIM</td></tr>
  </table>
</dl>
<dl compact><dt><b>Precondition:</b></dt><dd>(axis &gt;= 0) &amp;&amp; (axis &lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchData.html#4b2528593ae5bf177579d4d11afac2e3">getDim()</a>.getValue()) <p>
(face_normal &gt;= 0) &amp;&amp; (face_normal &lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchData.html#4b2528593ae5bf177579d4d11afac2e3">getDim()</a>.getValue()) </dd></dl>

</div>
</div><p>
<a class="anchor" name="22bbf4cf4c3dde390cda398d531dd630"></a><!-- doxytag: member="SAMRAI::pdat::OuteredgeData::getDataBox" ref="22bbf4cf4c3dde390cda398d531dd630" args="(int axis, int face_normal, int side)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSAMRAI_1_1hier_1_1Box.html">hier::Box</a> <a class="el" href="classSAMRAI_1_1pdat_1_1OuteredgeData.html">SAMRAI::pdat::OuteredgeData</a>&lt; TYPE &gt;::getDataBox           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>axis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>face_normal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>side</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return the box of valid edge indices for outeredge data. Note: the returned box will reside in the <em>edge</em> index space. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>axis</em>&nbsp;</td><td>integer edge data coordinate axis, must satisfy 0 &lt;= axis &lt; DIM </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>face_normal</em>&nbsp;</td><td>integer face normal direction for data, must satisfy 0 &lt;= face_normal &lt; DIM </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>side</em>&nbsp;</td><td>integer lower (0) or upper (1) side of outeredge data array </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="6fb5d3242802fe803acf4a2b1e856d04"></a><!-- doxytag: member="SAMRAI::pdat::OuteredgeData::getPointer" ref="6fb5d3242802fe803acf4a2b1e856d04" args="(int axis, int face_normal, int side, int depth=0)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">TYPE * <a class="el" href="classSAMRAI_1_1pdat_1_1OuteredgeData.html">SAMRAI::pdat::OuteredgeData</a>&lt; TYPE &gt;::getPointer           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>axis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>face_normal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>side</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>depth</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get a pointer to the beginning of a particular axis, face normal, side, and depth component of the outeredge centered array. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>axis</em>&nbsp;</td><td>integer edge data coordinate axis, must satisfy 0 &lt;= axis &lt; DIM </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>face_normal</em>&nbsp;</td><td>integer face normal direction for data, must satisfy 0 &lt;= face_normal &lt; DIM </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>side</em>&nbsp;</td><td>integer lower (0) or upper (1) side of outeredge data array </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>depth</em>&nbsp;</td><td>integer depth component, must satisfy 0 &lt;= depth &lt; actual depth of data array</td></tr>
  </table>
</dl>
<dl compact><dt><b>Precondition:</b></dt><dd>(axis &gt;= 0) &amp;&amp; (axis &lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchData.html#4b2528593ae5bf177579d4d11afac2e3">getDim()</a>.getValue()) <p>
(face_normal &gt;= 0) &amp;&amp; (face_normal &lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchData.html#4b2528593ae5bf177579d4d11afac2e3">getDim()</a>.getValue()) <p>
(side == 0) || (side == 1) <p>
(depth &gt;= 0) &amp;&amp; (depth &lt; <a class="el" href="classSAMRAI_1_1pdat_1_1OuteredgeData.html#2db481c0309f63b1ece6d08f901e8d05">getDepth()</a>) </dd></dl>

</div>
</div><p>
<a class="anchor" name="719d1ce135d91cf272d2330752262a56"></a><!-- doxytag: member="SAMRAI::pdat::OuteredgeData::getPointer" ref="719d1ce135d91cf272d2330752262a56" args="(int axis, int face_normal, int side, int depth=0) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const TYPE * <a class="el" href="classSAMRAI_1_1pdat_1_1OuteredgeData.html">SAMRAI::pdat::OuteredgeData</a>&lt; TYPE &gt;::getPointer           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>axis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>face_normal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>side</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>depth</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get a const pointer to the beginning of a particular axis, face normal, side, and depth component of the outeredge centered array. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>axis</em>&nbsp;</td><td>integer edge data coordinate axis, must satisfy 0 &lt;= axis &lt; DIM </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>face_normal</em>&nbsp;</td><td>integer face normal direction for data, must satisfy 0 &lt;= face_normal &lt; DIM </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>side</em>&nbsp;</td><td>integer lower (0) or upper (1) side of outeredge data array </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>depth</em>&nbsp;</td><td>integer depth component, must satisfy 0 &lt;= depth &lt; actual depth of data array</td></tr>
  </table>
</dl>
<dl compact><dt><b>Precondition:</b></dt><dd>(axis &gt;= 0) &amp;&amp; (axis &lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchData.html#4b2528593ae5bf177579d4d11afac2e3">getDim()</a>.getValue()) <p>
(face_normal &gt;= 0) &amp;&amp; (face_normal &lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchData.html#4b2528593ae5bf177579d4d11afac2e3">getDim()</a>.getValue()) <p>
(side == 0) || (side == 1) <p>
(depth &gt;= 0) &amp;&amp; (depth &lt; <a class="el" href="classSAMRAI_1_1pdat_1_1OuteredgeData.html#2db481c0309f63b1ece6d08f901e8d05">getDepth()</a>) </dd></dl>

</div>
</div><p>
<a class="anchor" name="c6ba60b1b735e37dec764f28f2d4c8b1"></a><!-- doxytag: member="SAMRAI::pdat::OuteredgeData::operator()" ref="c6ba60b1b735e37dec764f28f2d4c8b1" args="(const EdgeIndex &amp;i, int depth=0)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">TYPE &amp; <a class="el" href="classSAMRAI_1_1pdat_1_1OuteredgeData.html">SAMRAI::pdat::OuteredgeData</a>&lt; TYPE &gt;::operator()           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1pdat_1_1EdgeIndex.html">EdgeIndex</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>depth</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return a reference to data entry corresponding to a given edge index and depth. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>i</em>&nbsp;</td><td>const reference to <a class="el" href="classSAMRAI_1_1pdat_1_1EdgeIndex.html">EdgeIndex</a>, <em>MUST</em> be an index on the outeredge of the box. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>depth</em>&nbsp;</td><td>integer depth component, must satisfy 0 &lt;= depth &lt; actual depth of data array</td></tr>
  </table>
</dl>
<dl compact><dt><b>Precondition:</b></dt><dd><a class="el" href="classSAMRAI_1_1hier_1_1PatchData.html#4b2528593ae5bf177579d4d11afac2e3">getDim()</a> == i.getDim() <p>
(i.getAxis() &gt;= 0) &amp;&amp; (i.getAxis() &lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchData.html#4b2528593ae5bf177579d4d11afac2e3">getDim()</a>.getValue()) <p>
(depth &gt;= 0) &amp;&amp; (depth &lt; <a class="el" href="classSAMRAI_1_1pdat_1_1OuteredgeData.html#2db481c0309f63b1ece6d08f901e8d05">getDepth()</a>) </dd></dl>

</div>
</div><p>
<a class="anchor" name="c0399edb3082f867eae38364a17512ca"></a><!-- doxytag: member="SAMRAI::pdat::OuteredgeData::operator()" ref="c0399edb3082f867eae38364a17512ca" args="(const EdgeIndex &amp;i, int depth=0) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const TYPE &amp; <a class="el" href="classSAMRAI_1_1pdat_1_1OuteredgeData.html">SAMRAI::pdat::OuteredgeData</a>&lt; TYPE &gt;::operator()           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1pdat_1_1EdgeIndex.html">EdgeIndex</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>depth</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return a const reference to data entry corresponding to a given edge index and depth. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>i</em>&nbsp;</td><td>const reference to <a class="el" href="classSAMRAI_1_1pdat_1_1EdgeIndex.html">EdgeIndex</a>, <em>MUST</em> be an index on the outeredge of the box. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>depth</em>&nbsp;</td><td>integer depth component, must satisfy 0 &lt;= depth &lt; actual depth of data array</td></tr>
  </table>
</dl>
<dl compact><dt><b>Precondition:</b></dt><dd><a class="el" href="classSAMRAI_1_1hier_1_1PatchData.html#4b2528593ae5bf177579d4d11afac2e3">getDim()</a> == i.getDim() <p>
(i.getAxis() &gt;= 0) &amp;&amp; (i.getAxis() &lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchData.html#4b2528593ae5bf177579d4d11afac2e3">getDim()</a>.getValue()) <p>
(depth &gt;= 0) &amp;&amp; (depth &lt; <a class="el" href="classSAMRAI_1_1pdat_1_1OuteredgeData.html#2db481c0309f63b1ece6d08f901e8d05">getDepth()</a>) </dd></dl>

</div>
</div><p>
<a class="anchor" name="9cc40a571cf5d2f952e021778d8ed74e"></a><!-- doxytag: member="SAMRAI::pdat::OuteredgeData::getArrayData" ref="9cc40a571cf5d2f952e021778d8ed74e" args="(int axis, int face_normal, int side)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html">ArrayData</a>&lt; TYPE &gt; &amp; <a class="el" href="classSAMRAI_1_1pdat_1_1OuteredgeData.html">SAMRAI::pdat::OuteredgeData</a>&lt; TYPE &gt;::getArrayData           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>axis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>face_normal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>side</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return a reference to the array data object for given axis, face normal, and side index of the outeredge centered array. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>axis</em>&nbsp;</td><td>integer edge data coordinate axis, must satisfy 0 &lt;= axis &lt; DIM </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>face_normal</em>&nbsp;</td><td>integer face normal direction for data, must satisfy 0 &lt;= face_normal &lt; DIM </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>side</em>&nbsp;</td><td>integer lower (0) or upper (1) side of outeredge data array</td></tr>
  </table>
</dl>
<dl compact><dt><b>Precondition:</b></dt><dd>(axis &gt;= 0) &amp;&amp; (axis &lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchData.html#4b2528593ae5bf177579d4d11afac2e3">getDim()</a>.getValue()) <p>
(face_normal &gt;= 0) &amp;&amp; (face_normal &lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchData.html#4b2528593ae5bf177579d4d11afac2e3">getDim()</a>.getValue()) <p>
(side == 0) || (side == 1) </dd></dl>

</div>
</div><p>
<a class="anchor" name="16e76dc60dda8d5be4351ee9bcb9dfd4"></a><!-- doxytag: member="SAMRAI::pdat::OuteredgeData::getArrayData" ref="16e76dc60dda8d5be4351ee9bcb9dfd4" args="(int axis, int face_normal, int side) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html">ArrayData</a>&lt; TYPE &gt; &amp; <a class="el" href="classSAMRAI_1_1pdat_1_1OuteredgeData.html">SAMRAI::pdat::OuteredgeData</a>&lt; TYPE &gt;::getArrayData           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>axis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>face_normal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>side</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return a const reference to the array data object for given axis, face normal, and side index of the outeredge centered array. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>axis</em>&nbsp;</td><td>integer edge data coordinate axis, must satisfy 0 &lt;= axis &lt; DIM </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>face_normal</em>&nbsp;</td><td>integer face normal direction for data, must satisfy 0 &lt;= face_normal &lt; DIM </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>side</em>&nbsp;</td><td>integer lower (0) or upper (1) side of outeredge data array</td></tr>
  </table>
</dl>
<dl compact><dt><b>Precondition:</b></dt><dd>(axis &gt;= 0) &amp;&amp; (axis &lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchData.html#4b2528593ae5bf177579d4d11afac2e3">getDim()</a>.getValue()) <p>
(face_normal &gt;= 0) &amp;&amp; (face_normal &lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchData.html#4b2528593ae5bf177579d4d11afac2e3">getDim()</a>.getValue()) <p>
(side == 0) || (side == 1) </dd></dl>

</div>
</div><p>
<a class="anchor" name="ac5d8c13ca05c50b5f88c80c3f78ea92"></a><!-- doxytag: member="SAMRAI::pdat::OuteredgeData::copy" ref="ac5d8c13ca05c50b5f88c80c3f78ea92" args="(const hier::PatchData &amp;src)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSAMRAI_1_1pdat_1_1OuteredgeData.html">SAMRAI::pdat::OuteredgeData</a>&lt; TYPE &gt;::copy           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1PatchData.html">hier::PatchData</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>src</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
A fast copy from source to destination (i.e., this) patch data object. 
<p>
Data is copied where there is overlap in the underlying index space. The copy is performed on the interior plus the ghost cell width (for both the source and destination). Currently, source data must be either <a class="el" href="classSAMRAI_1_1pdat_1_1EdgeData.html">EdgeData</a> or <a class="el" href="classSAMRAI_1_1pdat_1_1OuteredgeData.html">OuteredgeData</a> of the same DIM and TYPE. If not, then an unrecoverable error results.<p>
<dl compact><dt><b>Precondition:</b></dt><dd><a class="el" href="classSAMRAI_1_1hier_1_1PatchData.html#4b2528593ae5bf177579d4d11afac2e3">getDim()</a> == src.getDim() <p>
dynamic_cast&lt;const EdgeData&lt;TYPE&gt; *&gt;(&amp;src) != 0 || dynamic_cast&lt;const OuteredgeData&lt;TYPE&gt; *&gt;(&amp;src) != 0 </dd></dl>

<p>
Implements <a class="el" href="classSAMRAI_1_1hier_1_1PatchData.html#e11daa48e2aedf80b7c44bb838cdf9f2">SAMRAI::hier::PatchData</a>.
</div>
</div><p>
<a class="anchor" name="3592bba5724b619b798d09502d044e1c"></a><!-- doxytag: member="SAMRAI::pdat::OuteredgeData::copy2" ref="3592bba5724b619b798d09502d044e1c" args="(hier::PatchData &amp;dst) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSAMRAI_1_1pdat_1_1OuteredgeData.html">SAMRAI::pdat::OuteredgeData</a>&lt; TYPE &gt;::copy2           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1hier_1_1PatchData.html">hier::PatchData</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>dst</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
A fast copy from source (i.e., this) to destination patch data object. 
<p>
Data is copied where there is overlap in the underlying index space. The copy is performed on the interior plus the ghost cell width (for both the source and destination). Currently, destination data must be either <a class="el" href="classSAMRAI_1_1pdat_1_1EdgeData.html">EdgeData</a> or <a class="el" href="classSAMRAI_1_1pdat_1_1OuteredgeData.html">OuteredgeData</a> of the same DIM and TYPE. If not, then an unrecoverable error results.<p>
<dl compact><dt><b>Precondition:</b></dt><dd><a class="el" href="classSAMRAI_1_1hier_1_1PatchData.html#4b2528593ae5bf177579d4d11afac2e3">getDim()</a> == dst.getDim() <p>
dynamic_cast&lt;EdgeData&lt;TYPE&gt; *&gt;(&amp;dst) != 0 || dynamic_cast&lt;OuteredgeData&lt;TYPE&gt; *&gt;(&amp;dst) != 0 </dd></dl>

<p>
Implements <a class="el" href="classSAMRAI_1_1hier_1_1PatchData.html#34a0b358ae9349e2bef0a8e3bf6b4278">SAMRAI::hier::PatchData</a>.
</div>
</div><p>
<a class="anchor" name="4acd765a71de212834ea6a7b9160f259"></a><!-- doxytag: member="SAMRAI::pdat::OuteredgeData::copy" ref="4acd765a71de212834ea6a7b9160f259" args="(const hier::PatchData &amp;src, const hier::BoxOverlap &amp;overlap)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSAMRAI_1_1pdat_1_1OuteredgeData.html">SAMRAI::pdat::OuteredgeData</a>&lt; TYPE &gt;::copy           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1PatchData.html">hier::PatchData</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1BoxOverlap.html">hier::BoxOverlap</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>overlap</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Copy data from source to destination (i.e., this) patch data object on the given overlap. 
<p>
Currently, source data must be either <a class="el" href="classSAMRAI_1_1pdat_1_1EdgeData.html">EdgeData</a> or <a class="el" href="classSAMRAI_1_1pdat_1_1OuteredgeData.html">OuteredgeData</a> of the same DIM and TYPE and the overlap must be an <a class="el" href="classSAMRAI_1_1pdat_1_1EdgeOverlap.html">EdgeOverlap</a> of the same DIM. If not, then an unrecoverable error results.<p>
<dl compact><dt><b>Precondition:</b></dt><dd><a class="el" href="classSAMRAI_1_1hier_1_1PatchData.html#4b2528593ae5bf177579d4d11afac2e3">getDim()</a> == src.getDim() <p>
dynamic_cast&lt;const EdgeOverlap *&gt;(&amp;overlap) != 0 <p>
dynamic_cast&lt;const EdgeData&lt;TYPE&gt; *&gt;(&amp;src) != 0 || dynamic_cast&lt;const OuteredgeData&lt;TYPE&gt; *&gt;(&amp;src) != 0 </dd></dl>

<p>
Implements <a class="el" href="classSAMRAI_1_1hier_1_1PatchData.html#9db2a42da4a464f29d9e69c271bb7cd2">SAMRAI::hier::PatchData</a>.
</div>
</div><p>
<a class="anchor" name="f3547603fe16d66e57dc2eb095c4348d"></a><!-- doxytag: member="SAMRAI::pdat::OuteredgeData::copy2" ref="f3547603fe16d66e57dc2eb095c4348d" args="(hier::PatchData &amp;dst, const hier::BoxOverlap &amp;overlap) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSAMRAI_1_1pdat_1_1OuteredgeData.html">SAMRAI::pdat::OuteredgeData</a>&lt; TYPE &gt;::copy2           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1hier_1_1PatchData.html">hier::PatchData</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1BoxOverlap.html">hier::BoxOverlap</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>overlap</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Copy data from source (i.e., this) to destination patch data object on the given overlap. 
<p>
Currently, destination data must be either <a class="el" href="classSAMRAI_1_1pdat_1_1EdgeData.html">EdgeData</a> or <a class="el" href="classSAMRAI_1_1pdat_1_1OuteredgeData.html">OuteredgeData</a> of the same DIM and TYPE and the overlap must be an <a class="el" href="classSAMRAI_1_1pdat_1_1EdgeOverlap.html">EdgeOverlap</a> of the same DIM. If not, then an unrecoverable error results.<p>
<dl compact><dt><b>Precondition:</b></dt><dd><a class="el" href="classSAMRAI_1_1hier_1_1PatchData.html#4b2528593ae5bf177579d4d11afac2e3">getDim()</a> == dst.getDim() <p>
dynamic_cast&lt;const EdgeOverlap *&gt;(&amp;overlap) != 0 <p>
dynamic_cast&lt;EdgeData&lt;TYPE&gt; *&gt;(&amp;dst) != 0 || dynamic_cast&lt;OuteredgeData&lt;TYPE&gt; *&gt;(&amp;dst) != 0 </dd></dl>

<p>
Implements <a class="el" href="classSAMRAI_1_1hier_1_1PatchData.html#828b790d3f3c553535b4502452ba2eba">SAMRAI::hier::PatchData</a>.
</div>
</div><p>
<a class="anchor" name="800ee1a498d93679f9c72f764a1d890b"></a><!-- doxytag: member="SAMRAI::pdat::OuteredgeData::copyDepth" ref="800ee1a498d93679f9c72f764a1d890b" args="(int dst_depth, const EdgeData&lt; TYPE &gt; &amp;src, int src_depth)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSAMRAI_1_1pdat_1_1OuteredgeData.html">SAMRAI::pdat::OuteredgeData</a>&lt; TYPE &gt;::copyDepth           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>dst_depth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1pdat_1_1EdgeData.html">EdgeData</a>&lt; TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>src_depth</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Fast copy (i.e., assumes edge and outeredge data objects are defined over the same box) from the given edge source data object to this destination outeredge data object at the specified depths. 
<p>
<dl compact><dt><b>Precondition:</b></dt><dd><a class="el" href="classSAMRAI_1_1hier_1_1PatchData.html#4b2528593ae5bf177579d4d11afac2e3">getDim()</a> == src.getDim() </dd></dl>

</div>
</div><p>
<a class="anchor" name="0ae546bb2d9d0a3b5ff37e2562f8d636"></a><!-- doxytag: member="SAMRAI::pdat::OuteredgeData::copyDepth2" ref="0ae546bb2d9d0a3b5ff37e2562f8d636" args="(int dst_depth, EdgeData&lt; TYPE &gt; &amp;dst, int src_depth) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSAMRAI_1_1pdat_1_1OuteredgeData.html">SAMRAI::pdat::OuteredgeData</a>&lt; TYPE &gt;::copyDepth2           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>dst_depth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1pdat_1_1EdgeData.html">EdgeData</a>&lt; TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>src_depth</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Fast copy (i.e., assumes edge and outeredge data objects are defined over the same box) to the given edge destination data object from this source outeredge data object at the specified depths. 
<p>
<dl compact><dt><b>Precondition:</b></dt><dd><a class="el" href="classSAMRAI_1_1hier_1_1PatchData.html#4b2528593ae5bf177579d4d11afac2e3">getDim()</a> == dst.getDim() </dd></dl>

</div>
</div><p>
<a class="anchor" name="21ec1414a34922c6b244d6553a69a6d1"></a><!-- doxytag: member="SAMRAI::pdat::OuteredgeData::sum" ref="21ec1414a34922c6b244d6553a69a6d1" args="(const hier::PatchData &amp;src, const hier::BoxOverlap &amp;overlap)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSAMRAI_1_1pdat_1_1OuteredgeData.html">SAMRAI::pdat::OuteredgeData</a>&lt; TYPE &gt;::sum           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1PatchData.html">hier::PatchData</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1BoxOverlap.html">hier::BoxOverlap</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>overlap</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Add data from source to destination (i.e., this) patch data object on the given overlap. 
<p>
Currently, source data must be <a class="el" href="classSAMRAI_1_1pdat_1_1OuteredgeData.html">OuteredgeData</a> of the same DIM and TYPE and the overlap must be an <a class="el" href="classSAMRAI_1_1pdat_1_1EdgeOverlap.html">EdgeOverlap</a> of the same DIM. If not, then an unrecoverable error results.<p>
<dl compact><dt><b>Precondition:</b></dt><dd><a class="el" href="classSAMRAI_1_1hier_1_1PatchData.html#4b2528593ae5bf177579d4d11afac2e3">getDim()</a> == src.getDim() <p>
dynamic_cast&lt;const EdgeOverlap *&gt;(&amp;overlap) != 0 <p>
dynamic_cast&lt;const OuteredgeData&lt;TYPE&gt; *&gt;(&amp;src) != 0 </dd></dl>

</div>
</div><p>
<a class="anchor" name="86ae3f8f198b35afb21cecbf8e97276d"></a><!-- doxytag: member="SAMRAI::pdat::OuteredgeData::canEstimateStreamSizeFromBox" ref="86ae3f8f198b35afb21cecbf8e97276d" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classSAMRAI_1_1pdat_1_1OuteredgeData.html">SAMRAI::pdat::OuteredgeData</a>&lt; TYPE &gt;::canEstimateStreamSizeFromBox           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return true if the patch data object can estimate the stream size required to fit its data using only index space information (i.e., a box). 
<p>
This routine is defined for the standard types (bool, char, double, float, int, and dcomplex). 
<p>
Implements <a class="el" href="classSAMRAI_1_1hier_1_1PatchData.html#6a8a6bea3564c490bac76fa7989e1d6a">SAMRAI::hier::PatchData</a>.
</div>
</div><p>
<a class="anchor" name="ebda3831bfc284beeba7e7dc0dd3648c"></a><!-- doxytag: member="SAMRAI::pdat::OuteredgeData::getDataStreamSize" ref="ebda3831bfc284beeba7e7dc0dd3648c" args="(const hier::BoxOverlap &amp;overlap) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classSAMRAI_1_1pdat_1_1OuteredgeData.html">SAMRAI::pdat::OuteredgeData</a>&lt; TYPE &gt;::getDataStreamSize           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1BoxOverlap.html">hier::BoxOverlap</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>overlap</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return the number of bytes needed to stream the data in this patch data object lying in the specified box overlap region. 
<p>
This routine is defined for the standard types (bool, char, double, float, int, and dcomplex).<p>
<dl compact><dt><b>Precondition:</b></dt><dd>dynamic_cast&lt;const EdgeOverlap *&gt;(&amp;overlap) != 0 </dd></dl>

<p>
Implements <a class="el" href="classSAMRAI_1_1hier_1_1PatchData.html#79afb3717c2858e760eb43d1c92e8aed">SAMRAI::hier::PatchData</a>.
</div>
</div><p>
<a class="anchor" name="87d96f37d474c3416044d92d82b223b2"></a><!-- doxytag: member="SAMRAI::pdat::OuteredgeData::packStream" ref="87d96f37d474c3416044d92d82b223b2" args="(tbox::MessageStream &amp;stream, const hier::BoxOverlap &amp;overlap) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSAMRAI_1_1pdat_1_1OuteredgeData.html">SAMRAI::pdat::OuteredgeData</a>&lt; TYPE &gt;::packStream           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1tbox_1_1MessageStream.html">tbox::MessageStream</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1BoxOverlap.html">hier::BoxOverlap</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>overlap</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Pack data in this patch data object lying in the specified box overlap region into the stream. The overlap must be an <a class="el" href="classSAMRAI_1_1pdat_1_1EdgeOverlap.html">EdgeOverlap</a> of the same DIM. 
<p>
<dl compact><dt><b>Precondition:</b></dt><dd>dynamic_cast&lt;const EdgeOverlap *&gt;(&amp;overlap) != 0 </dd></dl>

<p>
Implements <a class="el" href="classSAMRAI_1_1hier_1_1PatchData.html#9b73721b1f1f580e99626de07f91d950">SAMRAI::hier::PatchData</a>.
</div>
</div><p>
<a class="anchor" name="af6c8aee86d802d52a2b59f425376a6b"></a><!-- doxytag: member="SAMRAI::pdat::OuteredgeData::unpackStream" ref="af6c8aee86d802d52a2b59f425376a6b" args="(tbox::MessageStream &amp;stream, const hier::BoxOverlap &amp;overlap)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSAMRAI_1_1pdat_1_1OuteredgeData.html">SAMRAI::pdat::OuteredgeData</a>&lt; TYPE &gt;::unpackStream           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1tbox_1_1MessageStream.html">tbox::MessageStream</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1BoxOverlap.html">hier::BoxOverlap</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>overlap</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Unpack data from stream into this patch data object over the specified box overlap region. The overlap must be an <a class="el" href="classSAMRAI_1_1pdat_1_1EdgeOverlap.html">EdgeOverlap</a> of the same DIM. 
<p>
<dl compact><dt><b>Precondition:</b></dt><dd>dynamic_cast&lt;const EdgeOverlap *&gt;(&amp;overlap) != 0 </dd></dl>

<p>
Implements <a class="el" href="classSAMRAI_1_1hier_1_1PatchData.html#da56faab0c403e0c8b2e95ad28515a00">SAMRAI::hier::PatchData</a>.
</div>
</div><p>
<a class="anchor" name="698fd4eaa01be7d9c40319f0363bd1e8"></a><!-- doxytag: member="SAMRAI::pdat::OuteredgeData::unpackStreamAndSum" ref="698fd4eaa01be7d9c40319f0363bd1e8" args="(tbox::MessageStream &amp;stream, const hier::BoxOverlap &amp;overlap)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSAMRAI_1_1pdat_1_1OuteredgeData.html">SAMRAI::pdat::OuteredgeData</a>&lt; TYPE &gt;::unpackStreamAndSum           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1tbox_1_1MessageStream.html">tbox::MessageStream</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1BoxOverlap.html">hier::BoxOverlap</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>overlap</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Unpack data from stream and add into this patch data object over the specified box overlap region. 
<p>
<dl compact><dt><b>Precondition:</b></dt><dd>dynamic_cast&lt;const EdgeOverlap *&gt;(&amp;overlap) != 0 </dd></dl>

</div>
</div><p>
<a class="anchor" name="6ae6fad0878aa0e67d3ad9e11ef6bae5"></a><!-- doxytag: member="SAMRAI::pdat::OuteredgeData::fill" ref="6ae6fad0878aa0e67d3ad9e11ef6bae5" args="(const TYPE &amp;t, int d=0)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSAMRAI_1_1pdat_1_1OuteredgeData.html">SAMRAI::pdat::OuteredgeData</a>&lt; TYPE &gt;::fill           </td>
          <td>(</td>
          <td class="paramtype">const TYPE &amp;&nbsp;</td>
          <td class="paramname"> <em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>d</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Fill all values at depth d with the value t. 
<p>
<dl compact><dt><b>Precondition:</b></dt><dd>(d &gt;= 0) &amp;&amp; (d &lt; <a class="el" href="classSAMRAI_1_1pdat_1_1OuteredgeData.html#2db481c0309f63b1ece6d08f901e8d05">getDepth()</a>) </dd></dl>

</div>
</div><p>
<a class="anchor" name="0778a3518e0a599f769e36a28543e1f2"></a><!-- doxytag: member="SAMRAI::pdat::OuteredgeData::fill" ref="0778a3518e0a599f769e36a28543e1f2" args="(const TYPE &amp;t, const hier::Box &amp;box, int d=0)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSAMRAI_1_1pdat_1_1OuteredgeData.html">SAMRAI::pdat::OuteredgeData</a>&lt; TYPE &gt;::fill           </td>
          <td>(</td>
          <td class="paramtype">const TYPE &amp;&nbsp;</td>
          <td class="paramname"> <em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">hier::Box</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>box</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>d</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Fill all values at depth d within the box with the value t. 
<p>
<dl compact><dt><b>Precondition:</b></dt><dd><a class="el" href="classSAMRAI_1_1hier_1_1PatchData.html#4b2528593ae5bf177579d4d11afac2e3">getDim()</a> == box.getDim() <p>
(d &gt;= 0) &amp;&amp; (d &lt; <a class="el" href="classSAMRAI_1_1pdat_1_1OuteredgeData.html#2db481c0309f63b1ece6d08f901e8d05">getDepth()</a>) </dd></dl>

</div>
</div><p>
<a class="anchor" name="54e12b1be7dadf84cd13cdaf9b71d1d2"></a><!-- doxytag: member="SAMRAI::pdat::OuteredgeData::fillAll" ref="54e12b1be7dadf84cd13cdaf9b71d1d2" args="(const TYPE &amp;t)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSAMRAI_1_1pdat_1_1OuteredgeData.html">SAMRAI::pdat::OuteredgeData</a>&lt; TYPE &gt;::fillAll           </td>
          <td>(</td>
          <td class="paramtype">const TYPE &amp;&nbsp;</td>
          <td class="paramname"> <em>t</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Fill all depth components with value t. 
<p>

</div>
</div><p>
<a class="anchor" name="a3689a92a5a6d18bffb81b757929c68a"></a><!-- doxytag: member="SAMRAI::pdat::OuteredgeData::fillAll" ref="a3689a92a5a6d18bffb81b757929c68a" args="(const TYPE &amp;t, const hier::Box &amp;box)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSAMRAI_1_1pdat_1_1OuteredgeData.html">SAMRAI::pdat::OuteredgeData</a>&lt; TYPE &gt;::fillAll           </td>
          <td>(</td>
          <td class="paramtype">const TYPE &amp;&nbsp;</td>
          <td class="paramname"> <em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">hier::Box</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>box</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Fill all depth components within the box with value t. 
<p>
<dl compact><dt><b>Precondition:</b></dt><dd><a class="el" href="classSAMRAI_1_1hier_1_1PatchData.html#4b2528593ae5bf177579d4d11afac2e3">getDim()</a> == box.getDim() </dd></dl>

</div>
</div><p>
<a class="anchor" name="f7478b2c947ebbd05f0023880ca88e10"></a><!-- doxytag: member="SAMRAI::pdat::OuteredgeData::print" ref="f7478b2c947ebbd05f0023880ca88e10" args="(const hier::Box &amp;box, std::ostream &amp;os=tbox::plog, int prec=12) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSAMRAI_1_1pdat_1_1OuteredgeData.html">SAMRAI::pdat::OuteredgeData</a>&lt; TYPE &gt;::print           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">hier::Box</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>box</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;&nbsp;</td>
          <td class="paramname"> <em>os</em> = <code><a class="el" href="namespaceSAMRAI_1_1tbox.html#b84041705493761fb17a8127e3a2dca2">tbox::plog</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>prec</em> = <code>12</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Print all outeredge data values residing in the specified box. If the depth of the array is greater than one, all depths are printed. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>box</em>&nbsp;</td><td>const reference to box over whioch to print data. Note box is assumed to reside in standard cell-centered index space and will be converted to edge index space. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>os</em>&nbsp;</td><td>reference to output stream. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>prec</em>&nbsp;</td><td>integer precision for printing floating point numbers (i.e., TYPE = float, double, or dcomplex). The default is 12 decimal places for double and complex floating point numbers, and the default is 6 decimal places floats. For other types, this value is ignored.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Precondition:</b></dt><dd><a class="el" href="classSAMRAI_1_1hier_1_1PatchData.html#4b2528593ae5bf177579d4d11afac2e3">getDim()</a> == box.getDim() </dd></dl>

</div>
</div><p>
<a class="anchor" name="3bf36ab3bc9936b3b673370261edfa4a"></a><!-- doxytag: member="SAMRAI::pdat::OuteredgeData::print" ref="3bf36ab3bc9936b3b673370261edfa4a" args="(const hier::Box &amp;box, int depth, std::ostream &amp;os=tbox::plog, int prec=12) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSAMRAI_1_1pdat_1_1OuteredgeData.html">SAMRAI::pdat::OuteredgeData</a>&lt; TYPE &gt;::print           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">hier::Box</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>box</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>depth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;&nbsp;</td>
          <td class="paramname"> <em>os</em> = <code><a class="el" href="namespaceSAMRAI_1_1tbox.html#b84041705493761fb17a8127e3a2dca2">tbox::plog</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>prec</em> = <code>12</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Print all outeredge data values at the given array depth in the specified box. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>box</em>&nbsp;</td><td>const reference to box over whioch to print data. Note box is assumed to reside in standard cell-centered index space and will be converted to edge index space. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>depth</em>&nbsp;</td><td>integer depth component, must satisfy 0 &lt;= depth &lt; actual depth of data array </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>os</em>&nbsp;</td><td>reference to output stream. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>prec</em>&nbsp;</td><td>integer precision for printing floating point numbers (i.e., TYPE = float, double, or dcomplex). The default is 12 decimal places for double and complex floating point numbers, and the default is 6 decimal places floats. For other types, this value is ignored.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Precondition:</b></dt><dd><a class="el" href="classSAMRAI_1_1hier_1_1PatchData.html#4b2528593ae5bf177579d4d11afac2e3">getDim()</a> == box.getDim() <p>
(depth &gt;= 0) &amp;&amp; (depth &lt; <a class="el" href="classSAMRAI_1_1pdat_1_1OuteredgeData.html#2db481c0309f63b1ece6d08f901e8d05">getDepth()</a>) </dd></dl>

</div>
</div><p>
<a class="anchor" name="09eecf7259892c6a45a71933986214cf"></a><!-- doxytag: member="SAMRAI::pdat::OuteredgeData::printAxisSide" ref="09eecf7259892c6a45a71933986214cf" args="(int axis, int face_normal, int side, const hier::Box &amp;box, std::ostream &amp;os=tbox::plog, int prec=12) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSAMRAI_1_1pdat_1_1OuteredgeData.html">SAMRAI::pdat::OuteredgeData</a>&lt; TYPE &gt;::printAxisSide           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>axis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>face_normal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>side</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">hier::Box</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>box</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;&nbsp;</td>
          <td class="paramname"> <em>os</em> = <code><a class="el" href="namespaceSAMRAI_1_1tbox.html#b84041705493761fb17a8127e3a2dca2">tbox::plog</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>prec</em> = <code>12</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Print all outeredge centered data values for specified axis, face_normal, and side residing in the specified box. If the depth of the data is greater than one, all depths are printed. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>axis</em>&nbsp;</td><td>integer edge data coordinate axis, must satisfy 0 &lt;= axis &lt; DIM </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>face_normal</em>&nbsp;</td><td>integer face normal direction for data, must satisfy 0 &lt;= face_normal &lt; DIM </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>side</em>&nbsp;</td><td>integer lower (0) or upper (1) side of outeredge data array </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>box</em>&nbsp;</td><td>const reference to box over whioch to print data. Note box is assumed to reside in standard cell-centered index space and will be converted to edge index space. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>os</em>&nbsp;</td><td>reference to output stream. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>prec</em>&nbsp;</td><td>integer precision for printing floating point numbers (i.e., TYPE = float, double, or dcomplex). The default is 12 decimal places for double and complex floating point numbers, and the default is 6 decimal places floats. For other types, this value is ignored.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Precondition:</b></dt><dd><a class="el" href="classSAMRAI_1_1hier_1_1PatchData.html#4b2528593ae5bf177579d4d11afac2e3">getDim()</a> == box.getDim() <p>
(axis &gt;= 0) &amp;&amp; (axis &lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchData.html#4b2528593ae5bf177579d4d11afac2e3">getDim()</a>.getValue()) <p>
(face_normal &gt;= 0) &amp;&amp; (face_normal &lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchData.html#4b2528593ae5bf177579d4d11afac2e3">getDim()</a>.getValue()) <p>
(side == 0) || (side == 1) </dd></dl>

</div>
</div><p>
<a class="anchor" name="bbd6412b2c6479cd3d850b52f382bb75"></a><!-- doxytag: member="SAMRAI::pdat::OuteredgeData::printAxisSide" ref="bbd6412b2c6479cd3d850b52f382bb75" args="(int axis, int face_normal, int side, const hier::Box &amp;box, int depth, std::ostream &amp;os=tbox::plog, int prec=12) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSAMRAI_1_1pdat_1_1OuteredgeData.html">SAMRAI::pdat::OuteredgeData</a>&lt; TYPE &gt;::printAxisSide           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>axis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>face_normal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>side</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">hier::Box</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>box</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>depth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;&nbsp;</td>
          <td class="paramname"> <em>os</em> = <code><a class="el" href="namespaceSAMRAI_1_1tbox.html#b84041705493761fb17a8127e3a2dca2">tbox::plog</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>prec</em> = <code>12</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Print all outeredge centered data values for specified axis, face_normal, side, and depth residing in the specified box. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>axis</em>&nbsp;</td><td>integer edge data coordinate axis, must satisfy 0 &lt;= axis &lt; DIM </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>face_normal</em>&nbsp;</td><td>integer face normal direction for data, must satisfy 0 &lt;= face_normal &lt; DIM </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>side</em>&nbsp;</td><td>integer lower (0) or upper (1) side of outeredge data array </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>box</em>&nbsp;</td><td>const reference to box over whioch to print data. Note box is assumed to reside in standard cell-centered index space and will be converted to edge index space. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>depth</em>&nbsp;</td><td>integer depth component, must satisfy 0 &lt;= depth &lt; actual depth of data array </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>os</em>&nbsp;</td><td>reference to output stream. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>prec</em>&nbsp;</td><td>integer precision for printing floating point numbers (i.e., TYPE = float, double, or dcomplex). The default is 12 decimal places for double and complex floating point numbers, and the default is 6 decimal places floats. For other types, this value is ignored.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Precondition:</b></dt><dd><a class="el" href="classSAMRAI_1_1hier_1_1PatchData.html#4b2528593ae5bf177579d4d11afac2e3">getDim()</a> == box.getDim() <p>
(depth &gt;= 0) &amp;&amp; (depth &lt; <a class="el" href="classSAMRAI_1_1pdat_1_1OuteredgeData.html#2db481c0309f63b1ece6d08f901e8d05">getDepth()</a>) <p>
(axis &gt;= 0) &amp;&amp; (axis &lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchData.html#4b2528593ae5bf177579d4d11afac2e3">getDim()</a>.getValue()) <p>
(face_normal &gt;= 0) &amp;&amp; (face_normal &lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchData.html#4b2528593ae5bf177579d4d11afac2e3">getDim()</a>.getValue()) <p>
(side == 0) || (side == 1) </dd></dl>

</div>
</div><p>
<a class="anchor" name="236cff06aa49cc75f264a35272041c89"></a><!-- doxytag: member="SAMRAI::pdat::OuteredgeData::getFromRestart" ref="236cff06aa49cc75f264a35272041c89" args="(const boost::shared_ptr&lt; tbox::Database &gt; &amp;restart_db)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSAMRAI_1_1pdat_1_1OuteredgeData.html">SAMRAI::pdat::OuteredgeData</a>&lt; TYPE &gt;::getFromRestart           </td>
          <td>(</td>
          <td class="paramtype">const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Database.html">tbox::Database</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>restart_db</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Check that class version and restart file version are equal. If so, read data members from the restart database. 
<p>
<dl compact><dt><b>Precondition:</b></dt><dd>restart_db </dd></dl>

<p>
Reimplemented from <a class="el" href="classSAMRAI_1_1hier_1_1PatchData.html#78b67dc5c322c4def87ae730b4092696">SAMRAI::hier::PatchData</a>.
</div>
</div><p>
<a class="anchor" name="b16de422a71c1083869efaa33001d2b8"></a><!-- doxytag: member="SAMRAI::pdat::OuteredgeData::putToRestart" ref="b16de422a71c1083869efaa33001d2b8" args="(const boost::shared_ptr&lt; tbox::Database &gt; &amp;restart_db) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSAMRAI_1_1pdat_1_1OuteredgeData.html">SAMRAI::pdat::OuteredgeData</a>&lt; TYPE &gt;::putToRestart           </td>
          <td>(</td>
          <td class="paramtype">const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Database.html">tbox::Database</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>restart_db</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Write out the class version number and other data members to the restart database. 
<p>
<dl compact><dt><b>Precondition:</b></dt><dd>restart_db </dd></dl>

<p>
Reimplemented from <a class="el" href="classSAMRAI_1_1hier_1_1PatchData.html#46f69705aaa6831bf10978dd2973f375">SAMRAI::hier::PatchData</a>.
</div>
</div><p>
<hr>The documentation for this class was generated from the following files:<ul>
<li>source/SAMRAI/pdat/<a class="el" href="OuteredgeData_8h.html">OuteredgeData.h</a><li>source/SAMRAI/pdat/<a class="el" href="OuteredgeData_8C.html">OuteredgeData.C</a></ul>
<hr size="1"><address style="align: right;"><small>Generated on 5 Jul 2013 for SAMRAI by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.7 </small></address>
</body>
</html>
