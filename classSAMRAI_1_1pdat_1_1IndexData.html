<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>SAMRAI: SAMRAI::pdat::IndexData&lt; TYPE, BOX_GEOMETRY &gt; Class Template Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.7 -->
<div class="tabs">
  <ul>
    <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="namespaces.html"><span>Namespaces</span></a></li>
    <li id="current"><a href="annotated.html"><span>Classes</span></a></li>
    <li><a href="files.html"><span>Files</span></a></li>
    <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
  </ul></div>
<div class="tabs">
  <ul>
    <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
    <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
    <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
  </ul></div>
<div class="nav">
<a class="el" href="namespaceSAMRAI.html">SAMRAI</a>::<a class="el" href="namespaceSAMRAI_1_1pdat.html">pdat</a>::<a class="el" href="classSAMRAI_1_1pdat_1_1IndexData.html">IndexData</a></div>
<h1>SAMRAI::pdat::IndexData&lt; TYPE, BOX_GEOMETRY &gt; Class Template Reference</h1><!-- doxytag: class="SAMRAI::pdat::IndexData" --><!-- doxytag: inherits="SAMRAI::hier::PatchData" --><code>#include &lt;source/SAMRAI/pdat/IndexData.h&gt;</code>
<p>
<p>Inheritance diagram for SAMRAI::pdat::IndexData&lt; TYPE, BOX_GEOMETRY &gt;:
<p><center><img src="classSAMRAI_1_1pdat_1_1IndexData.png" usemap="#SAMRAI::pdat::IndexData< TYPE, BOX_GEOMETRY >_map" border="0" alt=""></center>
<map name="SAMRAI::pdat::IndexData< TYPE, BOX_GEOMETRY >_map">
<area href="classSAMRAI_1_1hier_1_1PatchData.html" alt="SAMRAI::hier::PatchData" shape="rect" coords="0,0,321,24">
</map>
<a href="classSAMRAI_1_1pdat_1_1IndexData-members.html">List of all members.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Types</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef <a class="el" href="classSAMRAI_1_1pdat_1_1IndexIterator.html">IndexIterator</a>&lt; TYPE,<br>
 BOX_GEOMETRY &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1pdat_1_1IndexData.html#8c304e3a278c7664762471826e0e96e2">Iterator</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef ConstIndexIterator&lt;<br>
 TYPE, BOX_GEOMETRY &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1pdat_1_1IndexData.html#dca6eb4b647bf4e89c72fca267ef7fbe">ConstIterator</a></td></tr>

<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1pdat_1_1IndexData.html#acb21d1fd4d0bc937f5cc15d11580102">IndexData</a> (const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">hier::Box</a> &amp;box, const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a> &amp;ghosts)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1pdat_1_1IndexData.html#208e3b633060640ea8d4d50a9c4b74c2">~IndexData</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1pdat_1_1IndexData.html#99bcd952ccfd0ca0090969b14eb838d5">copy</a> (const <a class="el" href="classSAMRAI_1_1hier_1_1PatchData.html">hier::PatchData</a> &amp;src)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1pdat_1_1IndexData.html#5869ffbcb7539ea1f1083959e8649523">copy2</a> (<a class="el" href="classSAMRAI_1_1hier_1_1PatchData.html">hier::PatchData</a> &amp;dst) const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1pdat_1_1IndexData.html#06595cf2b31d4289e0164397806a680d">copy</a> (const <a class="el" href="classSAMRAI_1_1hier_1_1PatchData.html">hier::PatchData</a> &amp;src, const <a class="el" href="classSAMRAI_1_1hier_1_1BoxOverlap.html">hier::BoxOverlap</a> &amp;overlap)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1pdat_1_1IndexData.html#1fbebce9aa5d01a566e40af4b16edbdf">copy2</a> (<a class="el" href="classSAMRAI_1_1hier_1_1PatchData.html">hier::PatchData</a> &amp;dst, const <a class="el" href="classSAMRAI_1_1hier_1_1BoxOverlap.html">hier::BoxOverlap</a> &amp;overlap) const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1pdat_1_1IndexData.html#9db35f6e8f49e211462c7bcb8a9029a6">canEstimateStreamSizeFromBox</a> () const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1pdat_1_1IndexData.html#a2b0401e571b5f725770daf5f270592e">getDataStreamSize</a> (const <a class="el" href="classSAMRAI_1_1hier_1_1BoxOverlap.html">hier::BoxOverlap</a> &amp;overlap) const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1pdat_1_1IndexData.html#e87360378a9a608892c9ec494addca92">packStream</a> (<a class="el" href="classSAMRAI_1_1tbox_1_1MessageStream.html">tbox::MessageStream</a> &amp;stream, const <a class="el" href="classSAMRAI_1_1hier_1_1BoxOverlap.html">hier::BoxOverlap</a> &amp;overlap) const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1pdat_1_1IndexData.html#ec8d27fe1d365b73f75f83ad85d4c758">unpackStream</a> (<a class="el" href="classSAMRAI_1_1tbox_1_1MessageStream.html">tbox::MessageStream</a> &amp;stream, const <a class="el" href="classSAMRAI_1_1hier_1_1BoxOverlap.html">hier::BoxOverlap</a> &amp;overlap)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1pdat_1_1IndexData.html#931afc282915e77d8381b9e27264cb8c">appendItem</a> (const <a class="el" href="classSAMRAI_1_1hier_1_1Index.html">hier::Index</a> &amp;index, const TYPE &amp;item)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1pdat_1_1IndexData.html#3b239be6b1e7e15895d6a9a79b9256fd">appendItemPointer</a> (const <a class="el" href="classSAMRAI_1_1hier_1_1Index.html">hier::Index</a> &amp;index, TYPE *item)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1pdat_1_1IndexData.html#33e3cf4ac9c7c04a1d40cc763f9d84a3">addItem</a> (const <a class="el" href="classSAMRAI_1_1hier_1_1Index.html">hier::Index</a> &amp;index, const TYPE &amp;item)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1pdat_1_1IndexData.html#2ea0e89c4f0e22fe4c84d1ac1064ea40">addItemPointer</a> (const <a class="el" href="classSAMRAI_1_1hier_1_1Index.html">hier::Index</a> &amp;index, TYPE *item)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1pdat_1_1IndexData.html#b8b836411a0798641d43ad0e239cd64d">replaceAddItem</a> (const <a class="el" href="classSAMRAI_1_1hier_1_1Index.html">hier::Index</a> &amp;index, const TYPE &amp;item)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1pdat_1_1IndexData.html#23cfa0b7b0e7e9bf61ba2045c68c883d">replaceAddItemPointer</a> (const <a class="el" href="classSAMRAI_1_1hier_1_1Index.html">hier::Index</a> &amp;index, TYPE *item)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1pdat_1_1IndexData.html#b0af51ce534ba20e235d2bee12b4fbc4">replaceAppendItem</a> (const <a class="el" href="classSAMRAI_1_1hier_1_1Index.html">hier::Index</a> &amp;index, const TYPE &amp;item)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1pdat_1_1IndexData.html#9ae6cb58d56ae1509558b45ee8af899f">replaceAppendItemPointer</a> (const <a class="el" href="classSAMRAI_1_1hier_1_1Index.html">hier::Index</a> &amp;index, TYPE *item)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1pdat_1_1IndexData.html#7b6ad43bcbc9b176ae27b49d6df573c5">removeItem</a> (const <a class="el" href="classSAMRAI_1_1hier_1_1Index.html">hier::Index</a> &amp;index)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1pdat_1_1IndexData.html#44cc5e05050e897d62cc5ea3ec6e4b9d">getNumberOfItems</a> () const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1pdat_1_1IndexData.html#3762df0f2468fefcb2f4132a3ed0cbd3">removeInsideBox</a> (const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">hier::Box</a> &amp;box)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1pdat_1_1IndexData.html#4011bb1e9bbf5936ec6cd0eb9b36e9e6">removeOutsideBox</a> (const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">hier::Box</a> &amp;box)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1pdat_1_1IndexData.html#ec92b69d9f1702cc37c72521473ad2ea">removeGhostItems</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1pdat_1_1IndexData.html#6685c217512ff21b10f9d861e9295b6f">removeAllItems</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1pdat_1_1IndexData.html#74ea56f86c3bbbbbc3e86a695bfe436b">isElement</a> (const <a class="el" href="classSAMRAI_1_1hier_1_1Index.html">hier::Index</a> &amp;index) const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">TYPE *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1pdat_1_1IndexData.html#41ce4e137f2e60525668faf4b6af9382">getItem</a> (const <a class="el" href="classSAMRAI_1_1hier_1_1Index.html">hier::Index</a> &amp;index) const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1pdat_1_1IndexData.html#4e6bb1f79c39d3a9281ea64bf43e72e4">getSpecializedFromDatabase</a> (<a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Database.html">tbox::Database</a> &gt; database)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1pdat_1_1IndexData.html#8e3a66737856e996a86cb95a1afcbd07">putSpecializedToDatabase</a> (<a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Database.html">tbox::Database</a> &gt; database)</td></tr>

<tr><td colspan="2"><br><h2>Friends</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1pdat_1_1IndexData.html#29bf18abb486c1b3ee1fb5a3b425af36">IndexIterator&lt; TYPE, BOX_GEOMETRY &gt;</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1pdat_1_1IndexData.html#7a8cb872a5fba9172bdab35a5a5c86f9">ConstIndexIterator&lt; TYPE, BOX_GEOMETRY &gt;</a></td></tr>

</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
<h3>template&lt;class TYPE, class BOX_GEOMETRY&gt;<br>
 class SAMRAI::pdat::IndexData&lt; TYPE, BOX_GEOMETRY &gt;</h3>

<a class="el" href="classSAMRAI_1_1pdat_1_1IndexData.html">IndexData</a> is used for storing sparse data. The iteration over the data preserves insertion order similar to a linked list, hence data may be inserted at the front (AddItem) or tail (AppendItem).<p>
For example, this class is used to represent embedded * boundary features as a regular patch data type using the BoundaryCell class as the template type. The iteration ordering property is used to visit the boundary cells in a well defined way.<p>
Additional insertion methods are provided for optimization in specific use cases. An extra constructor call can be avoided if the "Pointer" versions of Add/AppendItem are used. These methods assume that the items are being "given" to <a class="el" href="classSAMRAI_1_1pdat_1_1IndexData.html">IndexData</a> thus <a class="el" href="classSAMRAI_1_1pdat_1_1IndexData.html">IndexData</a> will delete them when needed. The items must be dynamically allocated for this to work correctly, E.G.<p>
index_data.addItemPointer(someIndex, new ItemToInsert());<p>
The "replace" versions of the insert routines may be used when one wishes to preserve the existing iteration ordering. If an item already exists the replace insert will delete the old item and put the item provided in it's place (inserting it into that location in the linked list).<p>
If one does not care about the iteration order and is frequently updating the items stored, the "replace" versions are significantly faster.<p>
The template parameter TYPE * defines the storage at each index location. IndexDaga is derived from * <a class="el" href="classSAMRAI_1_1hier_1_1PatchData.html">hier::PatchData</a>.<p>
The data type TYPE must define the following five methods which are require by this class:<p>
<ul>
<li><b>-</b> Default constructor (taking no arguments).</li><li><b>-</b> Assignment operator; i.e., TYPE&amp; operator=(const TYPE&amp; rhs)</li><li><b>-</b> Copy; copySourceItem(const <a class="el" href="classSAMRAI_1_1hier_1_1Index.html">hier::Index</a>&amp; index, const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a>&amp; src_offset, const TYPE&amp; src_item)</li><li><b>-</b> Return size of data; size_t <a class="el" href="classSAMRAI_1_1pdat_1_1IndexData.html#a2b0401e571b5f725770daf5f270592e">getDataStreamSize()</a></li><li><b>-</b> Pack data into message stream; i.e., packStream(MessageStream&amp; stream,</li><li><b>-</b> Unpack data from message stream; i.e., unpackStream(MessageStream&amp; stream, const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a>&amp; offset)</li><li><b>-</b> Write to restart; putToDatabase(tbox::Pointer&lt;tbox::Database&gt;&amp; database)</li><li><b>-</b> Retrieve from restart; getFromDatabase(tbox::Pointer&lt;tbox::Database&gt;&amp; database)</li></ul>
<p>
The BOX_GEOMETRY template parameter defines the geometry. BOX_GEOMETRY must have a nested class name Overlap that implements he following methods:<p>
<ul>
<li><b>-</b> getSourceOffset</li><li><b>-</b> getDestinationBoxList</li></ul>
<p>
More information about the templated TYPE is provided in the <a class="el" href="classSAMRAI_1_1pdat_1_1IndexData.html">IndexData</a> README file.<p>
IndexData&lt;DIM&gt; objects are created by the IndexDataFactory&lt;DIM&gt; factory object just as all other patch data types.<p>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classSAMRAI_1_1pdat_1_1IndexData.html">pdat::IndexData</a> <p>
<a class="el" href="classSAMRAI_1_1hier_1_1PatchData.html">hier::PatchData</a> <p>
<a class="el" href="classSAMRAI_1_1pdat_1_1IndexDataFactory.html">pdat::IndexDataFactory</a> </dd></dl>

<p>
<hr><h2>Member Typedef Documentation</h2>
<a class="anchor" name="8c304e3a278c7664762471826e0e96e2"></a><!-- doxytag: member="SAMRAI::pdat::IndexData::Iterator" ref="8c304e3a278c7664762471826e0e96e2" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE, class BOX_GEOMETRY&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classSAMRAI_1_1pdat_1_1IndexIterator.html">IndexIterator</a>&lt;TYPE, BOX_GEOMETRY&gt; <a class="el" href="classSAMRAI_1_1pdat_1_1IndexData.html">SAMRAI::pdat::IndexData</a>&lt; TYPE, BOX_GEOMETRY &gt;::<a class="el" href="classSAMRAI_1_1pdat_1_1IndexIterator.html">Iterator</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Define the iterator. 
</div>
</div><p>
<a class="anchor" name="dca6eb4b647bf4e89c72fca267ef7fbe"></a><!-- doxytag: member="SAMRAI::pdat::IndexData::ConstIterator" ref="dca6eb4b647bf4e89c72fca267ef7fbe" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE, class BOX_GEOMETRY&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef ConstIndexIterator&lt;TYPE, BOX_GEOMETRY&gt; <a class="el" href="classSAMRAI_1_1pdat_1_1IndexData.html">SAMRAI::pdat::IndexData</a>&lt; TYPE, BOX_GEOMETRY &gt;::<a class="el" href="classSAMRAI_1_1pdat_1_1IndexData.html#dca6eb4b647bf4e89c72fca267ef7fbe">ConstIterator</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<hr><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" name="acb21d1fd4d0bc937f5cc15d11580102"></a><!-- doxytag: member="SAMRAI::pdat::IndexData::IndexData" ref="acb21d1fd4d0bc937f5cc15d11580102" args="(const hier::Box &amp;box, const hier::IntVector &amp;ghosts)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE, class BOX_GEOMETRY&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSAMRAI_1_1pdat_1_1IndexData.html">SAMRAI::pdat::IndexData</a>&lt; TYPE, BOX_GEOMETRY &gt;::<a class="el" href="classSAMRAI_1_1pdat_1_1IndexData.html">IndexData</a>           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">hier::Box</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>box</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>ghosts</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The constructor for an <a class="el" href="classSAMRAI_1_1pdat_1_1IndexData.html">IndexData</a> object. The box describes the interior of the index space and the ghosts vector describes the ghost nodes in each coordinate direction. 
</div>
</div><p>
<a class="anchor" name="208e3b633060640ea8d4d50a9c4b74c2"></a><!-- doxytag: member="SAMRAI::pdat::IndexData::~IndexData" ref="208e3b633060640ea8d4d50a9c4b74c2" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE, class BOX_GEOMETRY&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSAMRAI_1_1pdat_1_1IndexData.html">SAMRAI::pdat::IndexData</a>&lt; TYPE, BOX_GEOMETRY &gt;::~<a class="el" href="classSAMRAI_1_1pdat_1_1IndexData.html">IndexData</a>           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The virtual destructor for an <a class="el" href="classSAMRAI_1_1pdat_1_1IndexData.html">IndexData</a> object. 
</div>
</div><p>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="99bcd952ccfd0ca0090969b14eb838d5"></a><!-- doxytag: member="SAMRAI::pdat::IndexData::copy" ref="99bcd952ccfd0ca0090969b14eb838d5" args="(const hier::PatchData &amp;src)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE, class BOX_GEOMETRY&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSAMRAI_1_1pdat_1_1IndexData.html">SAMRAI::pdat::IndexData</a>&lt; TYPE, BOX_GEOMETRY &gt;::copy           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1PatchData.html">hier::PatchData</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>src</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
A fast copy between the source and destination. All data is copied from the source into the destination where there is overlap in the index space. 
<p>
Implements <a class="el" href="classSAMRAI_1_1hier_1_1PatchData.html#1eceef85e707249a51fd6e8719b8b888">SAMRAI::hier::PatchData</a>.
</div>
</div><p>
<a class="anchor" name="5869ffbcb7539ea1f1083959e8649523"></a><!-- doxytag: member="SAMRAI::pdat::IndexData::copy2" ref="5869ffbcb7539ea1f1083959e8649523" args="(hier::PatchData &amp;dst) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE, class BOX_GEOMETRY&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSAMRAI_1_1pdat_1_1IndexData.html">SAMRAI::pdat::IndexData</a>&lt; TYPE, BOX_GEOMETRY &gt;::copy2           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1hier_1_1PatchData.html">hier::PatchData</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>dst</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
A fast copy between the source and destination. Data is copied from the source into the destination where there is overlap in the underlying index space. The copy is performed on the interior plus the ghost cell width (for both the source and destination). If this copy does not understand how to copy data from the destination, then it may throw an assertion (aka dump core in a failed assertion). 
<p>
Implements <a class="el" href="classSAMRAI_1_1hier_1_1PatchData.html#09c4b4a8c05efa18ad83662db4ba5351">SAMRAI::hier::PatchData</a>.
</div>
</div><p>
<a class="anchor" name="06595cf2b31d4289e0164397806a680d"></a><!-- doxytag: member="SAMRAI::pdat::IndexData::copy" ref="06595cf2b31d4289e0164397806a680d" args="(const hier::PatchData &amp;src, const hier::BoxOverlap &amp;overlap)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE, class BOX_GEOMETRY&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSAMRAI_1_1pdat_1_1IndexData.html">SAMRAI::pdat::IndexData</a>&lt; TYPE, BOX_GEOMETRY &gt;::copy           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1PatchData.html">hier::PatchData</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1BoxOverlap.html">hier::BoxOverlap</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>overlap</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Copy data from the source into the destination using the designated overlap descriptor. The overlap description should have been computed previously from computeIntersection(). 
<p>
Implements <a class="el" href="classSAMRAI_1_1hier_1_1PatchData.html#60dd0fcc44ae5ef062a4249dad8a4f47">SAMRAI::hier::PatchData</a>.
</div>
</div><p>
<a class="anchor" name="1fbebce9aa5d01a566e40af4b16edbdf"></a><!-- doxytag: member="SAMRAI::pdat::IndexData::copy2" ref="1fbebce9aa5d01a566e40af4b16edbdf" args="(hier::PatchData &amp;dst, const hier::BoxOverlap &amp;overlap) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE, class BOX_GEOMETRY&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSAMRAI_1_1pdat_1_1IndexData.html">SAMRAI::pdat::IndexData</a>&lt; TYPE, BOX_GEOMETRY &gt;::copy2           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1hier_1_1PatchData.html">hier::PatchData</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1BoxOverlap.html">hier::BoxOverlap</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>overlap</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Copy data from the source into the destination using the designated overlap descriptor. The overlap description will have been computed using the appropriate box geometry objects If this member function cannot complete the copy from the destination, then it may throw an assertion (aka dump core in a failed assertion). 
<p>
Implements <a class="el" href="classSAMRAI_1_1hier_1_1PatchData.html#bd068fc4e5d159b2f927d59ea2ffda40">SAMRAI::hier::PatchData</a>.
</div>
</div><p>
<a class="anchor" name="9db35f6e8f49e211462c7bcb8a9029a6"></a><!-- doxytag: member="SAMRAI::pdat::IndexData::canEstimateStreamSizeFromBox" ref="9db35f6e8f49e211462c7bcb8a9029a6" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE, class BOX_GEOMETRY&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classSAMRAI_1_1pdat_1_1IndexData.html">SAMRAI::pdat::IndexData</a>&lt; TYPE, BOX_GEOMETRY &gt;::canEstimateStreamSizeFromBox           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Determines whether the <a class="el" href="classSAMRAI_1_1hier_1_1PatchData.html">hier::PatchData</a> subclass can estinate the necessary stream size using only index space information. 
<p>
Implements <a class="el" href="classSAMRAI_1_1hier_1_1PatchData.html#e9cfe3b5f5cb132e6968467154f46521">SAMRAI::hier::PatchData</a>.
</div>
</div><p>
<a class="anchor" name="a2b0401e571b5f725770daf5f270592e"></a><!-- doxytag: member="SAMRAI::pdat::IndexData::getDataStreamSize" ref="a2b0401e571b5f725770daf5f270592e" args="(const hier::BoxOverlap &amp;overlap) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE, class BOX_GEOMETRY&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classSAMRAI_1_1pdat_1_1IndexData.html">SAMRAI::pdat::IndexData</a>&lt; TYPE, BOX_GEOMETRY &gt;::getDataStreamSize           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1BoxOverlap.html">hier::BoxOverlap</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>overlap</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Calculate the number of bytes needed to stream the data lying in the specified box domain. 
<p>
Implements <a class="el" href="classSAMRAI_1_1hier_1_1PatchData.html#c70a44451c3a87e5744328e09b33efa8">SAMRAI::hier::PatchData</a>.
</div>
</div><p>
<a class="anchor" name="e87360378a9a608892c9ec494addca92"></a><!-- doxytag: member="SAMRAI::pdat::IndexData::packStream" ref="e87360378a9a608892c9ec494addca92" args="(tbox::MessageStream &amp;stream, const hier::BoxOverlap &amp;overlap) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE, class BOX_GEOMETRY&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSAMRAI_1_1pdat_1_1IndexData.html">SAMRAI::pdat::IndexData</a>&lt; TYPE, BOX_GEOMETRY &gt;::packStream           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1tbox_1_1MessageStream.html">tbox::MessageStream</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1BoxOverlap.html">hier::BoxOverlap</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>overlap</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Pack data lying on the specified index set into the output stream. 
<p>
Implements <a class="el" href="classSAMRAI_1_1hier_1_1PatchData.html#5f351ded8a02c75ecf9eb124cec0b509">SAMRAI::hier::PatchData</a>.
</div>
</div><p>
<a class="anchor" name="ec8d27fe1d365b73f75f83ad85d4c758"></a><!-- doxytag: member="SAMRAI::pdat::IndexData::unpackStream" ref="ec8d27fe1d365b73f75f83ad85d4c758" args="(tbox::MessageStream &amp;stream, const hier::BoxOverlap &amp;overlap)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE, class BOX_GEOMETRY&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSAMRAI_1_1pdat_1_1IndexData.html">SAMRAI::pdat::IndexData</a>&lt; TYPE, BOX_GEOMETRY &gt;::unpackStream           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1tbox_1_1MessageStream.html">tbox::MessageStream</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1BoxOverlap.html">hier::BoxOverlap</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>overlap</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Unpack data from the message stream into the specified index set. 
<p>
Implements <a class="el" href="classSAMRAI_1_1hier_1_1PatchData.html#64f047f667adb684706c6a546176f460">SAMRAI::hier::PatchData</a>.
</div>
</div><p>
<a class="anchor" name="931afc282915e77d8381b9e27264cb8c"></a><!-- doxytag: member="SAMRAI::pdat::IndexData::appendItem" ref="931afc282915e77d8381b9e27264cb8c" args="(const hier::Index &amp;index, const TYPE &amp;item)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE, class BOX_GEOMETRY&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSAMRAI_1_1pdat_1_1IndexData.html">SAMRAI::pdat::IndexData</a>&lt; TYPE, BOX_GEOMETRY &gt;::appendItem           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1Index.html">hier::Index</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TYPE &amp;&nbsp;</td>
          <td class="paramname"> <em>item</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Add a new item to the tail of the irregular index set. 
</div>
</div><p>
<a class="anchor" name="3b239be6b1e7e15895d6a9a79b9256fd"></a><!-- doxytag: member="SAMRAI::pdat::IndexData::appendItemPointer" ref="3b239be6b1e7e15895d6a9a79b9256fd" args="(const hier::Index &amp;index, TYPE *item)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE, class BOX_GEOMETRY&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSAMRAI_1_1pdat_1_1IndexData.html">SAMRAI::pdat::IndexData</a>&lt; TYPE, BOX_GEOMETRY &gt;::appendItemPointer           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1Index.html">hier::Index</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TYPE *&nbsp;</td>
          <td class="paramname"> <em>item</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Add a pointer to a new item to the tail of the irregular index set. <a class="el" href="classSAMRAI_1_1pdat_1_1IndexData.html">IndexData</a> will delete the item when it is no longer needed by <a class="el" href="classSAMRAI_1_1pdat_1_1IndexData.html">IndexData</a>. Due to this behavior item must be dynamically created (e.g. new) so that it may be deleted.<p>
NOTE: This is an optimization to avoid an extra constructor call. It should be used with caution, the caller MUST NOT delete the referenced item. Think of this as giving up control of the item to <a class="el" href="classSAMRAI_1_1pdat_1_1IndexData.html">IndexData</a>. 
</div>
</div><p>
<a class="anchor" name="33e3cf4ac9c7c04a1d40cc763f9d84a3"></a><!-- doxytag: member="SAMRAI::pdat::IndexData::addItem" ref="33e3cf4ac9c7c04a1d40cc763f9d84a3" args="(const hier::Index &amp;index, const TYPE &amp;item)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE, class BOX_GEOMETRY&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSAMRAI_1_1pdat_1_1IndexData.html">SAMRAI::pdat::IndexData</a>&lt; TYPE, BOX_GEOMETRY &gt;::addItem           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1Index.html">hier::Index</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TYPE &amp;&nbsp;</td>
          <td class="paramname"> <em>item</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Add a new item to the head of the irregular index set 
</div>
</div><p>
<a class="anchor" name="2ea0e89c4f0e22fe4c84d1ac1064ea40"></a><!-- doxytag: member="SAMRAI::pdat::IndexData::addItemPointer" ref="2ea0e89c4f0e22fe4c84d1ac1064ea40" args="(const hier::Index &amp;index, TYPE *item)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE, class BOX_GEOMETRY&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSAMRAI_1_1pdat_1_1IndexData.html">SAMRAI::pdat::IndexData</a>&lt; TYPE, BOX_GEOMETRY &gt;::addItemPointer           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1Index.html">hier::Index</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TYPE *&nbsp;</td>
          <td class="paramname"> <em>item</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Add a pointer to a new item to the head of the irregular index set. <a class="el" href="classSAMRAI_1_1pdat_1_1IndexData.html">IndexData</a> will delete the item when it is no longer needed by <a class="el" href="classSAMRAI_1_1pdat_1_1IndexData.html">IndexData</a>. Due to this behavior item must be dynamically created (e.g. new) so that it may be deleted.<p>
NOTE: This is an optimization to avoid an extra constructor call. It should be used with caution, the caller MUST NOT delete the referenced item. Think of this as giving up control of the item to <a class="el" href="classSAMRAI_1_1pdat_1_1IndexData.html">IndexData</a>. 
</div>
</div><p>
<a class="anchor" name="b8b836411a0798641d43ad0e239cd64d"></a><!-- doxytag: member="SAMRAI::pdat::IndexData::replaceAddItem" ref="b8b836411a0798641d43ad0e239cd64d" args="(const hier::Index &amp;index, const TYPE &amp;item)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE, class BOX_GEOMETRY&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSAMRAI_1_1pdat_1_1IndexData.html">SAMRAI::pdat::IndexData</a>&lt; TYPE, BOX_GEOMETRY &gt;::replaceAddItem           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1Index.html">hier::Index</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TYPE &amp;&nbsp;</td>
          <td class="paramname"> <em>item</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Remove (deallocate) the item in the irregular index set located at the specified <a class="el" href="classSAMRAI_1_1hier_1_1Index.html">hier::Index</a> and replace it with a new item.<p>
This preserves the iteration order of the orginal insertions.<p>
If an item does not already exist at index this is equivelent to addItem. 
</div>
</div><p>
<a class="anchor" name="23cfa0b7b0e7e9bf61ba2045c68c883d"></a><!-- doxytag: member="SAMRAI::pdat::IndexData::replaceAddItemPointer" ref="23cfa0b7b0e7e9bf61ba2045c68c883d" args="(const hier::Index &amp;index, TYPE *item)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE, class BOX_GEOMETRY&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSAMRAI_1_1pdat_1_1IndexData.html">SAMRAI::pdat::IndexData</a>&lt; TYPE, BOX_GEOMETRY &gt;::replaceAddItemPointer           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1Index.html">hier::Index</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TYPE *&nbsp;</td>
          <td class="paramname"> <em>item</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Remove (deallocate) the item in the irregular index set located at the specified <a class="el" href="classSAMRAI_1_1hier_1_1Index.html">hier::Index</a> and replace it with a new item.<p>
This preserves the iteration order of the original insertions.<p>
If an item does not already exist at index this is equivelent to addItemPointer.<p>
See addItemPointer for additional comments on pointer semantics. 
</div>
</div><p>
<a class="anchor" name="b0af51ce534ba20e235d2bee12b4fbc4"></a><!-- doxytag: member="SAMRAI::pdat::IndexData::replaceAppendItem" ref="b0af51ce534ba20e235d2bee12b4fbc4" args="(const hier::Index &amp;index, const TYPE &amp;item)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE, class BOX_GEOMETRY&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSAMRAI_1_1pdat_1_1IndexData.html">SAMRAI::pdat::IndexData</a>&lt; TYPE, BOX_GEOMETRY &gt;::replaceAppendItem           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1Index.html">hier::Index</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TYPE &amp;&nbsp;</td>
          <td class="paramname"> <em>item</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Remove (deallocate) the item in the irregular index set located at the specified <a class="el" href="classSAMRAI_1_1hier_1_1Index.html">hier::Index</a> and replace it with a new item.<p>
This preserves the iteration order of the orginal insertions.<p>
If an item does not already exist at index this is equivelent to appendItem. 
</div>
</div><p>
<a class="anchor" name="9ae6cb58d56ae1509558b45ee8af899f"></a><!-- doxytag: member="SAMRAI::pdat::IndexData::replaceAppendItemPointer" ref="9ae6cb58d56ae1509558b45ee8af899f" args="(const hier::Index &amp;index, TYPE *item)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE, class BOX_GEOMETRY&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSAMRAI_1_1pdat_1_1IndexData.html">SAMRAI::pdat::IndexData</a>&lt; TYPE, BOX_GEOMETRY &gt;::replaceAppendItemPointer           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1Index.html">hier::Index</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TYPE *&nbsp;</td>
          <td class="paramname"> <em>item</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Remove (deallocate) the item in the irregular index set located at the specified <a class="el" href="classSAMRAI_1_1hier_1_1Index.html">hier::Index</a> and replace it with a new item.<p>
This preserves the iteration order of the original insertions.<p>
If an item does not already exist at index this is equivelent to appendItemPointer.<p>
See addItemPointer for additional comments on pointer semantics. 
</div>
</div><p>
<a class="anchor" name="7b6ad43bcbc9b176ae27b49d6df573c5"></a><!-- doxytag: member="SAMRAI::pdat::IndexData::removeItem" ref="7b6ad43bcbc9b176ae27b49d6df573c5" args="(const hier::Index &amp;index)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE, class BOX_GEOMETRY&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSAMRAI_1_1pdat_1_1IndexData.html">SAMRAI::pdat::IndexData</a>&lt; TYPE, BOX_GEOMETRY &gt;::removeItem           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1Index.html">hier::Index</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>index</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Remove (deallocate) the item in the irregular index set located at the specified <a class="el" href="classSAMRAI_1_1hier_1_1Index.html">hier::Index</a>. 
</div>
</div><p>
<a class="anchor" name="44cc5e05050e897d62cc5ea3ec6e4b9d"></a><!-- doxytag: member="SAMRAI::pdat::IndexData::getNumberOfItems" ref="44cc5e05050e897d62cc5ea3ec6e4b9d" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE, class BOX_GEOMETRY&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classSAMRAI_1_1pdat_1_1IndexData.html">SAMRAI::pdat::IndexData</a>&lt; TYPE, BOX_GEOMETRY &gt;::getNumberOfItems           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return the number of data items (i.e. the number of indices) in the index data list. 
</div>
</div><p>
<a class="anchor" name="3762df0f2468fefcb2f4132a3ed0cbd3"></a><!-- doxytag: member="SAMRAI::pdat::IndexData::removeInsideBox" ref="3762df0f2468fefcb2f4132a3ed0cbd3" args="(const hier::Box &amp;box)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE, class BOX_GEOMETRY&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSAMRAI_1_1pdat_1_1IndexData.html">SAMRAI::pdat::IndexData</a>&lt; TYPE, BOX_GEOMETRY &gt;::removeInsideBox           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">hier::Box</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>box</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Remove (deallocate) any items in the irregular index set located in the index space of the <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">hier::Box</a>. 
</div>
</div><p>
<a class="anchor" name="4011bb1e9bbf5936ec6cd0eb9b36e9e6"></a><!-- doxytag: member="SAMRAI::pdat::IndexData::removeOutsideBox" ref="4011bb1e9bbf5936ec6cd0eb9b36e9e6" args="(const hier::Box &amp;box)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE, class BOX_GEOMETRY&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSAMRAI_1_1pdat_1_1IndexData.html">SAMRAI::pdat::IndexData</a>&lt; TYPE, BOX_GEOMETRY &gt;::removeOutsideBox           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">hier::Box</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>box</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Remove (deallocate) any items in the irregular index set located outside of the index space of the <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">hier::Box</a>. 
</div>
</div><p>
<a class="anchor" name="ec92b69d9f1702cc37c72521473ad2ea"></a><!-- doxytag: member="SAMRAI::pdat::IndexData::removeGhostItems" ref="ec92b69d9f1702cc37c72521473ad2ea" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE, class BOX_GEOMETRY&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSAMRAI_1_1pdat_1_1IndexData.html">SAMRAI::pdat::IndexData</a>&lt; TYPE, BOX_GEOMETRY &gt;::removeGhostItems           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Remove (deallocate) the items in the irregular index set located in the ghost region of the patch. 
</div>
</div><p>
<a class="anchor" name="6685c217512ff21b10f9d861e9295b6f"></a><!-- doxytag: member="SAMRAI::pdat::IndexData::removeAllItems" ref="6685c217512ff21b10f9d861e9295b6f" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE, class BOX_GEOMETRY&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSAMRAI_1_1pdat_1_1IndexData.html">SAMRAI::pdat::IndexData</a>&lt; TYPE, BOX_GEOMETRY &gt;::removeAllItems           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Remove (deallocate) all items in the irregular index set. 
</div>
</div><p>
<a class="anchor" name="74ea56f86c3bbbbbc3e86a695bfe436b"></a><!-- doxytag: member="SAMRAI::pdat::IndexData::isElement" ref="74ea56f86c3bbbbbc3e86a695bfe436b" args="(const hier::Index &amp;index) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE, class BOX_GEOMETRY&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classSAMRAI_1_1pdat_1_1IndexData.html">SAMRAI::pdat::IndexData</a>&lt; TYPE, BOX_GEOMETRY &gt;::isElement           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1Index.html">hier::Index</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>index</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns true if there is an element of the irregular index set at the specified <a class="el" href="classSAMRAI_1_1hier_1_1Index.html">hier::Index</a>. 
</div>
</div><p>
<a class="anchor" name="41ce4e137f2e60525668faf4b6af9382"></a><!-- doxytag: member="SAMRAI::pdat::IndexData::getItem" ref="41ce4e137f2e60525668faf4b6af9382" args="(const hier::Index &amp;index) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE, class BOX_GEOMETRY&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">TYPE * <a class="el" href="classSAMRAI_1_1pdat_1_1IndexData.html">SAMRAI::pdat::IndexData</a>&lt; TYPE, BOX_GEOMETRY &gt;::getItem           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1Index.html">hier::Index</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>index</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Given an index, return a pointer to the item located at that index. If there is no item at the index, null is returned. 
</div>
</div><p>
<a class="anchor" name="4e6bb1f79c39d3a9281ea64bf43e72e4"></a><!-- doxytag: member="SAMRAI::pdat::IndexData::getSpecializedFromDatabase" ref="4e6bb1f79c39d3a9281ea64bf43e72e4" args="(tbox::Pointer&lt; tbox::Database &gt; database)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE, class BOX_GEOMETRY&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSAMRAI_1_1pdat_1_1IndexData.html">SAMRAI::pdat::IndexData</a>&lt; TYPE, BOX_GEOMETRY &gt;::getSpecializedFromDatabase           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Database.html">tbox::Database</a> &gt;&nbsp;</td>
          <td class="paramname"> <em>database</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Check to make sure that the class version number is the same as the restart file version number.<p>
Assertions: database must be a non-null pointer. 
<p>
Implements <a class="el" href="classSAMRAI_1_1hier_1_1PatchData.html#5fb8db1f58940d0fd1f130ea857037a4">SAMRAI::hier::PatchData</a>.
</div>
</div><p>
<a class="anchor" name="8e3a66737856e996a86cb95a1afcbd07"></a><!-- doxytag: member="SAMRAI::pdat::IndexData::putSpecializedToDatabase" ref="8e3a66737856e996a86cb95a1afcbd07" args="(tbox::Pointer&lt; tbox::Database &gt; database)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE, class BOX_GEOMETRY&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSAMRAI_1_1pdat_1_1IndexData.html">SAMRAI::pdat::IndexData</a>&lt; TYPE, BOX_GEOMETRY &gt;::putSpecializedToDatabase           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Database.html">tbox::Database</a> &gt;&nbsp;</td>
          <td class="paramname"> <em>database</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Write out the class version number to the database.<p>
Assertions: database must be a non-null pointer. 
<p>
Implements <a class="el" href="classSAMRAI_1_1hier_1_1PatchData.html#aa793038dcc04fee9bf96943b35951ee">SAMRAI::hier::PatchData</a>.
</div>
</div><p>
<hr><h2>Friends And Related Function Documentation</h2>
<a class="anchor" name="29bf18abb486c1b3ee1fb5a3b425af36"></a><!-- doxytag: member="SAMRAI::pdat::IndexData::IndexIterator&lt; TYPE, BOX_GEOMETRY &gt;" ref="29bf18abb486c1b3ee1fb5a3b425af36" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE, class BOX_GEOMETRY&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="classSAMRAI_1_1pdat_1_1IndexIterator.html">IndexIterator</a>&lt; TYPE, BOX_GEOMETRY &gt;<code> [friend]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="7a8cb872a5fba9172bdab35a5a5c86f9"></a><!-- doxytag: member="SAMRAI::pdat::IndexData::ConstIndexIterator&lt; TYPE, BOX_GEOMETRY &gt;" ref="7a8cb872a5fba9172bdab35a5a5c86f9" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE, class BOX_GEOMETRY&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">friend class ConstIndexIterator&lt; TYPE, BOX_GEOMETRY &gt;<code> [friend]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<hr>The documentation for this class was generated from the following files:<ul>
<li>source/SAMRAI/pdat/<a class="el" href="IndexData_8h.html">IndexData.h</a><li>source/SAMRAI/pdat/<a class="el" href="IndexData_8C.html">IndexData.C</a></ul>
<hr size="1"><address style="align: right;"><small>Generated on Fri Mar 16 14:34:20 2012 for SAMRAI by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.7 </small></address>
</body>
</html>
