<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>SAMRAI: SAMRAI::hier::BoxLevelConnectorUtils Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath"><a class="el" href="namespaceSAMRAI.html">SAMRAI</a>::<a class="el" href="namespaceSAMRAI_1_1hier.html">hier</a>::<a class="el" href="classSAMRAI_1_1hier_1_1BoxLevelConnectorUtils.html">BoxLevelConnectorUtils</a>
  </div>
</div>
<div class="contents">
<h1>SAMRAI::hier::BoxLevelConnectorUtils Class Reference</h1><!-- doxytag: class="SAMRAI::hier::BoxLevelConnectorUtils" -->
<p>Utilities for common operating on BoxLevels.  
<a href="#_details">More...</a></p>

<p><code>#include &lt;source/SAMRAI/hier/BoxLevelConnectorUtils.h&gt;</code></p>

<p><a href="classSAMRAI_1_1hier_1_1BoxLevelConnectorUtils-members.html">List of all members.</a></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevelConnectorUtils.html#a7bcaa32bb4e11b2c1fee3080a64a2545">BoxLevelConnectorUtils</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Default constructor.  <a href="#a7bcaa32bb4e11b2c1fee3080a64a2545"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevelConnectorUtils.html#a2ee1f5fd62409eb09e099ce82a1aa5cf">~BoxLevelConnectorUtils</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Destructor.  <a href="#a2ee1f5fd62409eb09e099ce82a1aa5cf"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevelConnectorUtils.html#ae7c029d73668a17cbcd4decbb1bf0866">setSanityCheckMethodPreconditions</a> (bool do_check)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set whether to run expensive sanity checks on input parameters.  <a href="#ae7c029d73668a17cbcd4decbb1bf0866"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevelConnectorUtils.html#ad487b8fea1290525313ec0e667aa08a9">setSanityCheckMethodPostconditions</a> (bool do_check)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set whether to run expensive sanity checks on output parameters.  <a href="#ad487b8fea1290525313ec0e667aa08a9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevelConnectorUtils.html#a2a2e2c35b5c00f2dfd9f6d39566d8554">computeBoxesAroundBoundary</a> (<a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a> &amp;boundary, const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;refinement_ratio, const boost::shared_ptr&lt; const <a class="el" href="classSAMRAI_1_1hier_1_1BaseGridGeometry.html">BaseGridGeometry</a> &gt; &amp;grid_geometry, const bool simplify_boundary_boxes=true) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Given a set of Boxes, compute its boundary as a set of boxes located just outside it.  <a href="#a2a2e2c35b5c00f2dfd9f6d39566d8554"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevelConnectorUtils.html#a7d59815e4dfdfaacd8a72c6f2bda8abd">setTimerPrefix</a> (const std::string &amp;timer_prefix)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Setup names of timers.  <a href="#a7d59815e4dfdfaacd8a72c6f2bda8abd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const std::string&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevelConnectorUtils.html#a84f4e540d816b2fd5660ea38428456f0">getObjectName</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the name of this object.  <a href="#a84f4e540d816b2fd5660ea38428456f0"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Comparing boxes of two BoxLevels</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrp738741ca19b0bebdf5538456cd0d6261"></a> </p>
<br/><br/></div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevelConnectorUtils.html#a42f1f7020d108fbad46a7853910d0b18">baseNestsInHead</a> (bool *locally_nests, const <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">Connector</a> &amp;connector, const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;base_swell, const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;head_swell, const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;head_nesting_margin, const <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a> *domain=0) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Given an overlap <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html" title="A container which holds relationship connections between two BoxLevels.">Connector</a>, determine the extent to which the Connector's base nests in its head.  <a href="#a42f1f7020d108fbad46a7853910d0b18"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevelConnectorUtils.html#ad603f2ccd20562a8020dca52e5f233bd">baseNestsInHead</a> (bool *locally_nests, const <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a> &amp;base, const <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a> &amp;head, const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;base_swell, const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;head_swell, const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;head_margin, const <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a> *domain=0) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Given base and head BoxLevels, determine the extent to which the base nests in the head.  <a href="#ad603f2ccd20562a8020dca52e5f233bd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevelConnectorUtils.html#a82485b05ecc10f9ca99dd38e727ef9e7">computeExternalParts</a> (boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a> &gt; &amp;external, boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1hier_1_1MappingConnector.html">MappingConnector</a> &gt; &amp;input_to_external, const <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">Connector</a> &amp;input_to_reference, const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;nesting_width, const <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a> &amp;domain=<a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a>()) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute the parts of one <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html" title="A distributed set of Box objects which reside in the same index space.">BoxLevel</a> that are external to another <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html" title="A distributed set of Box objects which reside in the same index space.">BoxLevel</a>.  <a href="#a82485b05ecc10f9ca99dd38e727ef9e7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevelConnectorUtils.html#a936a0a54222605b44e39ee306d8ba9a7">computeInternalParts</a> (boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a> &gt; &amp;internal, boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1hier_1_1MappingConnector.html">MappingConnector</a> &gt; &amp;input_to_internal, const <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">Connector</a> &amp;input_to_reference, const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;nesting_width, const <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a> &amp;domain=<a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a>()) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute the parts of one <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html" title="A distributed set of Box objects which reside in the same index space.">BoxLevel</a> that are internal to another <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html" title="A distributed set of Box objects which reside in the same index space.">BoxLevel</a>.  <a href="#a936a0a54222605b44e39ee306d8ba9a7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevelConnectorUtils.html#ab742fc9b6c8104a713d1716a9fe3b096">computeNonIntersectingParts</a> (boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a> &gt; &amp;remainder, boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">Connector</a> &gt; &amp;input_to_remainder, const <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">Connector</a> &amp;input_to_takeaway) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute parts of a level that do not intersect with another level.  <a href="#ab742fc9b6c8104a713d1716a9fe3b096"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Setting up common MappingConnectors</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrpb7f06706cbb0e61dc5f4dacf3835599f"></a> </p>
<br/><br/></div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevelConnectorUtils.html#a307c40943177d19883e736a4ac7c6430">makeSortingMap</a> (boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a> &gt; &amp;sorted_box_level, boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1hier_1_1MappingConnector.html">MappingConnector</a> &gt; &amp;output_map, const <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a> &amp;unsorted_box_level, bool sort_boxes_by_corner=true, bool sequentialize_global_indices=true, <a class="el" href="classSAMRAI_1_1hier_1_1LocalId.html">LocalId</a> initial_sequential_index=LocalId::getZero()) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevelConnectorUtils.html#ac089ec2d0ac153bd3e494ab46ee0a257">makeRemainderMap</a> (boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a> &gt; &amp;remainder, boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1hier_1_1MappingConnector.html">MappingConnector</a> &gt; &amp;orig_to_remainder, const <a class="el" href="classSAMRAI_1_1hier_1_1MappingConnector.html">MappingConnector</a> &amp;orig_to_rejections) const </td></tr>
<tr><td colspan="2"><div class="groupHeader">Adding periodic images</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrp874cc33e1f28e1900e77bbae93158367"></a> </p>
<br/><br/></div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevelConnectorUtils.html#a7cb54d1f23e65ddd4c74ae78d1d75b40">addPeriodicImages</a> (<a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a> &amp;box_level, const <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a> &amp;domain_search_tree, const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;threshold_distance) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Add periodic images to a <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html" title="A distributed set of Box objects which reside in the same index space.">BoxLevel</a>.  <a href="#a7cb54d1f23e65ddd4c74ae78d1d75b40"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevelConnectorUtils.html#ac49fedc69a4c201ea8ac36631d8b93c8">addPeriodicImagesAndRelationships</a> (<a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a> &amp;box_level, <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">Connector</a> &amp;box_level_to_anchor, const <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a> &amp;domain_search_tree, const <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">Connector</a> &amp;anchor_to_anchor) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Add periodic images to a <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html" title="A distributed set of Box objects which reside in the same index space.">BoxLevel</a> and add new relationships to the periodic images.  <a href="#ac49fedc69a4c201ea8ac36631d8b93c8"></a><br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>Utilities for common operating on BoxLevels. </p>
<p>Objects of this class can be set to perform certain sanity checks on the pre and post conditions of the methods. See <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevelConnectorUtils.html#ae7c029d73668a17cbcd4decbb1bf0866" title="Set whether to run expensive sanity checks on input parameters.">setSanityCheckMethodPreconditions()</a> and <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevelConnectorUtils.html#ad487b8fea1290525313ec0e667aa08a9" title="Set whether to run expensive sanity checks on output parameters.">setSanityCheckMethodPostconditions()</a>. </p>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a7bcaa32bb4e11b2c1fee3080a64a2545"></a><!-- doxytag: member="SAMRAI::hier::BoxLevelConnectorUtils::BoxLevelConnectorUtils" ref="a7bcaa32bb4e11b2c1fee3080a64a2545" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SAMRAI::hier::BoxLevelConnectorUtils::BoxLevelConnectorUtils </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Default constructor. </p>
<p>By default, sanity checks are disabled. To enable them, see <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevelConnectorUtils.html#ae7c029d73668a17cbcd4decbb1bf0866" title="Set whether to run expensive sanity checks on input parameters.">setSanityCheckMethodPreconditions()</a> and <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevelConnectorUtils.html#ad487b8fea1290525313ec0e667aa08a9" title="Set whether to run expensive sanity checks on output parameters.">setSanityCheckMethodPostconditions()</a>. </p>

<p>References <a class="el" href="BoxLevelConnectorUtils_8C_source.html#l01546">setTimerPrefix()</a>.</p>

</div>
</div>
<a class="anchor" id="a2ee1f5fd62409eb09e099ce82a1aa5cf"></a><!-- doxytag: member="SAMRAI::hier::BoxLevelConnectorUtils::~BoxLevelConnectorUtils" ref="a2ee1f5fd62409eb09e099ce82a1aa5cf" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SAMRAI::hier::BoxLevelConnectorUtils::~BoxLevelConnectorUtils </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Destructor. </p>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="ae7c029d73668a17cbcd4decbb1bf0866"></a><!-- doxytag: member="SAMRAI::hier::BoxLevelConnectorUtils::setSanityCheckMethodPreconditions" ref="ae7c029d73668a17cbcd4decbb1bf0866" args="(bool do_check)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::hier::BoxLevelConnectorUtils::setSanityCheckMethodPreconditions </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>do_check</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set whether to run expensive sanity checks on input parameters. </p>
<p>Mainly for debugging.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>do_check</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad487b8fea1290525313ec0e667aa08a9"></a><!-- doxytag: member="SAMRAI::hier::BoxLevelConnectorUtils::setSanityCheckMethodPostconditions" ref="ad487b8fea1290525313ec0e667aa08a9" args="(bool do_check)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::hier::BoxLevelConnectorUtils::setSanityCheckMethodPostconditions </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>do_check</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set whether to run expensive sanity checks on output parameters. </p>
<p>Mainly for debugging.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>do_check</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a42f1f7020d108fbad46a7853910d0b18"></a><!-- doxytag: member="SAMRAI::hier::BoxLevelConnectorUtils::baseNestsInHead" ref="a42f1f7020d108fbad46a7853910d0b18" args="(bool *locally_nests, const Connector &amp;connector, const IntVector &amp;base_swell, const IntVector &amp;head_swell, const IntVector &amp;head_nesting_margin, const BoxContainer *domain=0) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SAMRAI::hier::BoxLevelConnectorUtils::baseNestsInHead </td>
          <td>(</td>
          <td class="paramtype">bool *&nbsp;</td>
          <td class="paramname"> <em>locally_nests</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">Connector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>connector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>base_swell</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>head_swell</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>head_nesting_margin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a> *&nbsp;</td>
          <td class="paramname"> <em>domain</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Given an overlap <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html" title="A container which holds relationship connections between two BoxLevels.">Connector</a>, determine the extent to which the Connector's base nests in its head. </p>
<p>This method returns true if the base, grown by <code>base_swell</code>, nests inside the head, grown by <code>head_swell</code>, by a margin of <code>head_nesting_margin</code>. <code>base_swell</code> and <code>head_swell</code> should be non-negative and specified in the base and head index spaces, respectively. <code>head_nesting_margin</code> should be in the head index space.</p>
<p>The <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html" title="A container which holds relationship connections between two BoxLevels.">Connector</a> width must be at least the sum of the <code>base_swell</code> and the (appropriately converted) <code>head_swell</code> and <code>head_nesting_margin</code>. We require and assume without verifying that the <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html" title="A container which holds relationship connections between two BoxLevels.">Connector</a> is complete.</p>
<p>If the domain is given, non-nesting parts outside of the domain are disregarded.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>locally_nests</em>&nbsp;</td><td>Whether the local parts of the base nests in the head. This output may vary among the processes.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>connector</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>base_swell</em>&nbsp;</td><td>the amount that the base is grown by, given in the base index space and non-negative</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>head_swell</em>&nbsp;</td><td>the amount that the head is grown by, given in the head index space and non-negative</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>head_nesting_margin</em>&nbsp;</td><td>given in the head index space.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>domain</em>&nbsp;</td><td>Domain description, in reference index space, in search tree format.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>True if the given base <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html" title="A distributed set of Box objects which reside in the same index space.">BoxLevel</a> nests in the head, otherwise False. </dd></dl>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>(connector.getBase().getDim() == base_swell.getDim()) &amp;&amp; (connector.getBase().getDim() == head_nesting_margin.getDim()) </dd>
<dd>
connector.isFinalized() </dd>
<dd>
base_swell &gt;= <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html#a178dc4477a52ff09e80a2c3e86944e7f" title="Return an IntVector of zeros of the specified dimension.">IntVector::getZero</a>(connector.getBase().getDim()) </dd>
<dd>
head_nesting_margin &gt;= <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html#a178dc4477a52ff09e80a2c3e86944e7f" title="Return an IntVector of zeros of the specified dimension.">IntVector::getZero</a>(connector.getBase().getDim()) </dd></dl>

<p>References <a class="el" href="Connector_8C_source.html#l02156">SAMRAI::hier::Connector::assertOverlapCorrectness()</a>, <a class="el" href="BoxContainer_8h_source.html#l00706">SAMRAI::hier::BoxContainer::begin()</a>, <a class="el" href="IntVector_8h_source.html#l00653">SAMRAI::hier::IntVector::ceilingDivide()</a>, <a class="el" href="BoxLevelConnectorUtils_8h_source.html#l00231">computeExternalParts()</a>, <a class="el" href="BoxLevelConnectorUtils_8h_source.html#l00294">computeInternalParts()</a>, <a class="el" href="BoxContainer_8h_source.html#l00717">SAMRAI::hier::BoxContainer::end()</a>, <a class="el" href="OverlapConnectorAlgorithm_8C_source.html#l00384">SAMRAI::hier::OverlapConnectorAlgorithm::findOverlaps()</a>, <a class="el" href="Connector_8h_source.html#l00753">SAMRAI::hier::Connector::getBase()</a>, <a class="el" href="BoxLevel_8h_source.html#l00521">SAMRAI::hier::BoxLevel::getBoxes()</a>, <a class="el" href="Connector_8h_source.html#l00981">SAMRAI::hier::Connector::getConnectorWidth()</a>, <a class="el" href="BoxLevel_8h_source.html#l00848">SAMRAI::hier::BoxLevel::getDim()</a>, <a class="el" href="BoxLevel_8h_source.html#l00859">SAMRAI::hier::BoxLevel::getGridGeometry()</a>, <a class="el" href="Connector_8h_source.html#l00780">SAMRAI::hier::Connector::getHead()</a>, <a class="el" href="Connector_8h_source.html#l00825">SAMRAI::hier::Connector::getHeadCoarserFlag()</a>, <a class="el" href="Connector_8h_source.html#l00948">SAMRAI::hier::Connector::getMPI()</a>, <a class="el" href="BoxLevel_8h_source.html#l00398">SAMRAI::hier::BoxLevel::getMPI()</a>, <a class="el" href="IntVector_8h_source.html#l01143">SAMRAI::hier::IntVector::getOne()</a>, <a class="el" href="Connector_8h_source.html#l00797">SAMRAI::hier::Connector::getRatio()</a>, <a class="el" href="BoxLevel_8h_source.html#l00583">SAMRAI::hier::BoxLevel::getRefinementRatio()</a>, <a class="el" href="IntVector_8h_source.html#l01130">SAMRAI::hier::IntVector::getZero()</a>, <a class="el" href="BoxLevel_8h_source.html#l00104">SAMRAI::hier::BoxLevel::GLOBALIZED</a>, <a class="el" href="Box_8h_source.html#l00915">SAMRAI::hier::Box::grow()</a>, <a class="el" href="Connector_8h_source.html#l00707">SAMRAI::hier::Connector::growLocalNeighbors()</a>, <a class="el" href="Connector_8h_source.html#l00199">SAMRAI::hier::Connector::isFinalized()</a>, <a class="el" href="MappingConnectorAlgorithm_8C_source.html#l00140">SAMRAI::hier::MappingConnectorAlgorithm::modify()</a>, <a class="el" href="Connector_8C_source.html#l00996">SAMRAI::hier::Connector::setBase()</a>, <a class="el" href="Connector_8C_source.html#l01018">SAMRAI::hier::Connector::setHead()</a>, <a class="el" href="Connector_8C_source.html#l01039">SAMRAI::hier::Connector::setWidth()</a>, <a class="el" href="Utilities_8h_source.html#l00110">TBOX_ASSERT</a>, <a class="el" href="Utilities_8h_source.html#l00187">TBOX_ASSERT_OBJDIM_EQUALITY3</a>, and <a class="el" href="Utilities_8h_source.html#l00060">TBOX_ERROR</a>.</p>

<p>Referenced by <a class="el" href="BoxLevelConnectorUtils_8C_source.html#l00095">baseNestsInHead()</a>, and <a class="el" href="GriddingAlgorithm_8C_source.html#l00685">SAMRAI::mesh::GriddingAlgorithm::makeFinerLevel()</a>.</p>

</div>
</div>
<a class="anchor" id="ad603f2ccd20562a8020dca52e5f233bd"></a><!-- doxytag: member="SAMRAI::hier::BoxLevelConnectorUtils::baseNestsInHead" ref="ad603f2ccd20562a8020dca52e5f233bd" args="(bool *locally_nests, const BoxLevel &amp;base, const BoxLevel &amp;head, const IntVector &amp;base_swell, const IntVector &amp;head_swell, const IntVector &amp;head_margin, const BoxContainer *domain=0) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SAMRAI::hier::BoxLevelConnectorUtils::baseNestsInHead </td>
          <td>(</td>
          <td class="paramtype">bool *&nbsp;</td>
          <td class="paramname"> <em>locally_nests</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>head</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>base_swell</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>head_swell</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>head_margin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a> *&nbsp;</td>
          <td class="paramname"> <em>domain</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Given base and head BoxLevels, determine the extent to which the base nests in the head. </p>
<p>This method is similar to the version taking a <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html" title="A container which holds relationship connections between two BoxLevels.">Connector</a> instead of the base and head BoxLevels, except that it will use the base BoxLevel's <a class="el" href="classSAMRAI_1_1hier_1_1PersistentOverlapConnectors.html" title="A managager of overlap Connectors incident from a BoxLevel, used to store and, if...">PersistentOverlapConnectors</a> object to get the base---&gt;head <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html" title="A container which holds relationship connections between two BoxLevels.">Connector</a>. If such a <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html" title="A container which holds relationship connections between two BoxLevels.">Connector</a> does not exist, the <a class="el" href="classSAMRAI_1_1hier_1_1PersistentOverlapConnectors.html" title="A managager of overlap Connectors incident from a BoxLevel, used to store and, if...">PersistentOverlapConnectors</a> object will create it, an unscalable operation possibly requiring collective communication.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>domain</em>&nbsp;</td><td>Domain description, in reference index space, in search tree format.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Whether the given base <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html" title="A distributed set of Box objects which reside in the same index space.">BoxLevel</a> nests in the head.</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>locally_nests</em>&nbsp;</td><td>Whether the local parts of the base nests in the head. This output may vary among the processes.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>base</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>head</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>base_swell</em>&nbsp;</td><td>the amount that the base is grown by, given in the base index space and non-negative</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>head_swell</em>&nbsp;</td><td>the amount that the head is grown by, given in the head index space and non-negative</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>head_margin</em>&nbsp;</td><td>given in the head index space.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>domain</em>&nbsp;</td><td>Domain description, in reference index space, in search tree format.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Whether the given base <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html" title="A distributed set of Box objects which reside in the same index space.">BoxLevel</a> nests in the head.</dd></dl>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>head_nesting_margin.getDim() == base_swell.getDim() </dd>
<dd>
head.getMPI() == base.getMPI() </dd>
<dd>
base_swell &gt;= <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html#a178dc4477a52ff09e80a2c3e86944e7f" title="Return an IntVector of zeros of the specified dimension.">IntVector::getZero</a>(head.getDim()) </dd>
<dd>
head_swell &gt;= <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html#a178dc4477a52ff09e80a2c3e86944e7f" title="Return an IntVector of zeros of the specified dimension.">IntVector::getZero</a>(head.getDim()) </dd>
<dd>
head_nesting_margin &gt;= <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html#a178dc4477a52ff09e80a2c3e86944e7f" title="Return an IntVector of zeros of the specified dimension.">IntVector::getZero</a>(head.getDim()) </dd>
<dd>
(head.getRefinementRatio() &lt;= base.getRefinementRatio()) || (head.getRefinementRatio() &gt;= base.getRefinementRatio()) || </dd></dl>

<p>References <a class="el" href="BoxLevelConnectorUtils_8C_source.html#l00171">baseNestsInHead()</a>, <a class="el" href="IntVector_8h_source.html#l00653">SAMRAI::hier::IntVector::ceilingDivide()</a>, <a class="el" href="OverlapConnectorAlgorithm_8C_source.html#l00384">SAMRAI::hier::OverlapConnectorAlgorithm::findOverlaps()</a>, <a class="el" href="BoxLevel_8h_source.html#l00848">SAMRAI::hier::BoxLevel::getDim()</a>, <a class="el" href="BoxLevel_8h_source.html#l00398">SAMRAI::hier::BoxLevel::getMPI()</a>, <a class="el" href="BoxLevel_8h_source.html#l00583">SAMRAI::hier::BoxLevel::getRefinementRatio()</a>, <a class="el" href="IntVector_8h_source.html#l01130">SAMRAI::hier::IntVector::getZero()</a>, <a class="el" href="Utilities_8h_source.html#l00110">TBOX_ASSERT</a>, <a class="el" href="Utilities_8h_source.html#l00182">TBOX_ASSERT_OBJDIM_EQUALITY2</a>, and <a class="el" href="Utilities_8h_source.html#l00060">TBOX_ERROR</a>.</p>

</div>
</div>
<a class="anchor" id="a82485b05ecc10f9ca99dd38e727ef9e7"></a><!-- doxytag: member="SAMRAI::hier::BoxLevelConnectorUtils::computeExternalParts" ref="a82485b05ecc10f9ca99dd38e727ef9e7" args="(boost::shared_ptr&lt; BoxLevel &gt; &amp;external, boost::shared_ptr&lt; MappingConnector &gt; &amp;input_to_external, const Connector &amp;input_to_reference, const IntVector &amp;nesting_width, const BoxContainer &amp;domain=BoxContainer()) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::hier::BoxLevelConnectorUtils::computeExternalParts </td>
          <td>(</td>
          <td class="paramtype">boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>external</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1hier_1_1MappingConnector.html">MappingConnector</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>input_to_external</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">Connector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>input_to_reference</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>nesting_width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>domain</em> = <code><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a>()</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compute the parts of one <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html" title="A distributed set of Box objects which reside in the same index space.">BoxLevel</a> that are external to another <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html" title="A distributed set of Box objects which reside in the same index space.">BoxLevel</a>. </p>
<p>Compare an input <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html" title="A distributed set of Box objects which reside in the same index space.">BoxLevel</a> to a "reference" <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html" title="A distributed set of Box objects which reside in the same index space.">BoxLevel</a>. Compute the parts of the input that are external to the reference. Build the "external" <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html" title="A distributed set of Box objects which reside in the same index space.">BoxLevel</a> representing the external parts. Build a <a class="el" href="classSAMRAI_1_1hier_1_1MappingConnector.html" title="A container which holds overlap relationship connections between two BoxLevels.">MappingConnector</a> with the input as its base and the external as its head.</p>
<p>A partially external input cell (possible when input is coarser than reference) is considered to be external.</p>
<p>For the purpose of defining what is external, the reference level can be grown by nesting_width before comparing. This feature can be used to determing which parts of the input does not nest in the reference comparison. A negative growth indicates shrinking of the reference level.</p>
<p>This method does not require any communication.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>external</em>&nbsp;</td><td>The existing state will be discarded.</td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>input_to_external</em>&nbsp;</td><td>The existing state will be discarded.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>input_to_reference</em>&nbsp;</td><td>Overlap <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html" title="A container which holds relationship connections between two BoxLevels.">Connector</a> from input to reference <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html" title="A distributed set of Box objects which reside in the same index space.">BoxLevel</a>. The width of input_to_reference must be at least one and at least the absolute value of nesting_width.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>nesting_width</em>&nbsp;</td><td>Growth of the reference <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html" title="A distributed set of Box objects which reside in the same index space.">BoxLevel</a> for the purpose of comparing to input. Must be in resolution of input <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html" title="A distributed set of Box objects which reside in the same index space.">BoxLevel</a>. Must be either non-negative or non-positive but not mixed. If any width is negative, then input_to_reference must have a <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html" title="A container which holds relationship connections between two BoxLevels.">Connector</a> width of at least 1. Otherwise, an error is thrown (because correct results cannot be guaranteed).</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>domain</em>&nbsp;</td><td>The domain representation, without periodic images, in search tree form. These boxes should be in the reference index space. If domain is given, do not shrink the reference <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html" title="A distributed set of Box objects which reside in the same index space.">BoxLevel</a> where it touches the domain boundary.</td></tr>
  </table>
  </dd>
</dl>
<dl class="post"><dt><b>Postcondition:</b></dt><dd>input_to_external.isLocal() </dd></dl>

<p>Referenced by <a class="el" href="BoxLevelConnectorUtils_8C_source.html#l00171">baseNestsInHead()</a>, <a class="el" href="BoxLevelConnectorUtils_8C_source.html#l01486">computeNonIntersectingParts()</a>, <a class="el" href="MappingConnector_8C_source.html#l00165">SAMRAI::hier::MappingConnector::findMappingErrors()</a>, and <a class="el" href="GriddingAlgorithm_8C_source.html#l00685">SAMRAI::mesh::GriddingAlgorithm::makeFinerLevel()</a>.</p>

</div>
</div>
<a class="anchor" id="a936a0a54222605b44e39ee306d8ba9a7"></a><!-- doxytag: member="SAMRAI::hier::BoxLevelConnectorUtils::computeInternalParts" ref="a936a0a54222605b44e39ee306d8ba9a7" args="(boost::shared_ptr&lt; BoxLevel &gt; &amp;internal, boost::shared_ptr&lt; MappingConnector &gt; &amp;input_to_internal, const Connector &amp;input_to_reference, const IntVector &amp;nesting_width, const BoxContainer &amp;domain=BoxContainer()) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::hier::BoxLevelConnectorUtils::computeInternalParts </td>
          <td>(</td>
          <td class="paramtype">boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>internal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1hier_1_1MappingConnector.html">MappingConnector</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>input_to_internal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">Connector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>input_to_reference</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>nesting_width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>domain</em> = <code><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a>()</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compute the parts of one <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html" title="A distributed set of Box objects which reside in the same index space.">BoxLevel</a> that are internal to another <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html" title="A distributed set of Box objects which reside in the same index space.">BoxLevel</a>. </p>
<p>Compare an input <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html" title="A distributed set of Box objects which reside in the same index space.">BoxLevel</a> to a "reference" box_level. Identify parts of the input that are internal to the reference <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html" title="A distributed set of Box objects which reside in the same index space.">BoxLevel</a>, and store the internal parts in a <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html" title="A distributed set of Box objects which reside in the same index space.">BoxLevel</a>. Set up a <a class="el" href="classSAMRAI_1_1hier_1_1MappingConnector.html" title="A container which holds overlap relationship connections between two BoxLevels.">MappingConnector</a> between the input and its internal parts.</p>
<p>A partially internal input cell (possible when input is coarser than reference) is considered to be internal.</p>
<p>For the purpose of defining what is external, the reference level can be grown by nesting_width before comparing. This feature can be used to determing which parts of the input does not nest in the reference comparison. A negative growth indicates shrinking of the reference level.</p>
<p>This method does not require any communication.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>internal</em>&nbsp;</td><td>The existing state will be discarded.</td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>input_to_internal</em>&nbsp;</td><td>The existing state will be discarded.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>input_to_reference</em>&nbsp;</td><td>Overlap <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html" title="A container which holds relationship connections between two BoxLevels.">Connector</a> from input to reference <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html" title="A distributed set of Box objects which reside in the same index space.">BoxLevel</a>. The width of input_to_reference must be at least one and at least the absolute value of nesting_width.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>nesting_width</em>&nbsp;</td><td>Growth of the reference <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html" title="A distributed set of Box objects which reside in the same index space.">BoxLevel</a> for the purpose of comparing to input. Must be in resolution of input <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html" title="A distributed set of Box objects which reside in the same index space.">BoxLevel</a>. Must be either non-negative or non-positive but not mixed. If any width is negative, then input_to_reference must have a <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html" title="A container which holds relationship connections between two BoxLevels.">Connector</a> width of at least 1. Otherwise, an error is thrown (because correct results cannot be guaranteed).</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>domain</em>&nbsp;</td><td>The domain representation, without periodic images, in search tree form. These boxes should be in the reference index space. If domain is given, do not shrink the reference <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html" title="A distributed set of Box objects which reside in the same index space.">BoxLevel</a> where it touches the domain boundary.</td></tr>
  </table>
  </dd>
</dl>
<dl class="post"><dt><b>Postcondition:</b></dt><dd>input_to_internal.isLocal() </dd></dl>

<p>Referenced by <a class="el" href="BoxLevelConnectorUtils_8C_source.html#l00171">baseNestsInHead()</a>.</p>

</div>
</div>
<a class="anchor" id="ab742fc9b6c8104a713d1716a9fe3b096"></a><!-- doxytag: member="SAMRAI::hier::BoxLevelConnectorUtils::computeNonIntersectingParts" ref="ab742fc9b6c8104a713d1716a9fe3b096" args="(boost::shared_ptr&lt; BoxLevel &gt; &amp;remainder, boost::shared_ptr&lt; Connector &gt; &amp;input_to_remainder, const Connector &amp;input_to_takeaway) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::hier::BoxLevelConnectorUtils::computeNonIntersectingParts </td>
          <td>(</td>
          <td class="paramtype">boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>remainder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">Connector</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>input_to_remainder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">Connector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>input_to_takeaway</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compute parts of a level that do not intersect with another level. </p>
<p>Given the <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html" title="A container which holds relationship connections between two BoxLevels.">Connector</a> input_to_takeaway, this method computes the parts of the base level 'input' that do not intersect the head level 'takeaway'. The results are stored in the <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html" title="A distributed set of Box objects which reside in the same index space.">BoxLevel</a> 'remainder', with the input_to_remainder <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html" title="A container which holds relationship connections between two BoxLevels.">Connector</a> storing the overlap relationships between 'input' and 'remainder'.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>remainder</em>&nbsp;</td><td>The non-intersecting parts of input level </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>input_to_remainder</em>&nbsp;</td><td>Overlap connector with width zero </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>input_to_takeaway</em>&nbsp;</td><td>Overlap connector, may have any width</td></tr>
  </table>
  </dd>
</dl>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>input_to_takeaway is a complete overlap connector </dd></dl>
<dl class="post"><dt><b>Postcondition:</b></dt><dd>input_to_remainder.isLocal() </dd></dl>

<p>References <a class="el" href="Connector_8C_source.html#l02156">SAMRAI::hier::Connector::assertOverlapCorrectness()</a>, <a class="el" href="BoxLevelConnectorUtils_8h_source.html#l00231">computeExternalParts()</a>, <a class="el" href="BoxContainer_8h_source.html#l00695">SAMRAI::hier::BoxContainer::empty()</a>, <a class="el" href="BoxContainer_8h_source.html#l00717">SAMRAI::hier::BoxContainer::end()</a>, <a class="el" href="BoxContainer_8h_source.html#l01583">SAMRAI::hier::BoxContainer::find()</a>, <a class="el" href="Connector_8h_source.html#l00753">SAMRAI::hier::Connector::getBase()</a>, <a class="el" href="BoxLevel_8h_source.html#l00521">SAMRAI::hier::BoxLevel::getBoxes()</a>, <a class="el" href="Connector_8h_source.html#l00981">SAMRAI::hier::Connector::getConnectorWidth()</a>, <a class="el" href="IntVector_8h_source.html#l01118">SAMRAI::hier::IntVector::getDim()</a>, <a class="el" href="IntVector_8h_source.html#l01130">SAMRAI::hier::IntVector::getZero()</a>, and <a class="el" href="Utilities_8h_source.html#l00110">TBOX_ASSERT</a>.</p>

</div>
</div>
<a class="anchor" id="a2a2e2c35b5c00f2dfd9f6d39566d8554"></a><!-- doxytag: member="SAMRAI::hier::BoxLevelConnectorUtils::computeBoxesAroundBoundary" ref="a2a2e2c35b5c00f2dfd9f6d39566d8554" args="(BoxContainer &amp;boundary, const IntVector &amp;refinement_ratio, const boost::shared_ptr&lt; const BaseGridGeometry &gt; &amp;grid_geometry, const bool simplify_boundary_boxes=true) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::hier::BoxLevelConnectorUtils::computeBoxesAroundBoundary </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>boundary</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>refinement_ratio</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const boost::shared_ptr&lt; const <a class="el" href="classSAMRAI_1_1hier_1_1BaseGridGeometry.html">BaseGridGeometry</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>grid_geometry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&nbsp;</td>
          <td class="paramname"> <em>simplify_boundary_boxes</em> = <code>true</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Given a set of Boxes, compute its boundary as a set of boxes located just outside it. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>boundary</em>&nbsp;</td><td>Boundary boxes, sorted into BoxContainers according to the <a class="el" href="classSAMRAI_1_1hier_1_1BlockId.html" title="Generic identifier for identifying the block id.">BlockId</a>.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>refinement_ratio</em>&nbsp;</td><td>Refinement ratio of boxes.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>grid_geometry</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>simplify_boundary_boxes</em>&nbsp;</td><td>Whether to simplify the boundary boxes after computing them. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="BoxContainer_8h_source.html#l00706">SAMRAI::hier::BoxContainer::begin()</a>, <a class="el" href="BoxContainer_8h_source.html#l00865">SAMRAI::hier::BoxContainer::clear()</a>, <a class="el" href="BoxContainer_8h_source.html#l00717">SAMRAI::hier::BoxContainer::end()</a>, <a class="el" href="BaseGridGeometry_8h_source.html#l00810">SAMRAI::hier::BaseGridGeometry::Neighbor::getBlockId()</a>, <a class="el" href="IntVector_8h_source.html#l01143">SAMRAI::hier::IntVector::getOne()</a>, <a class="el" href="BaseGridGeometry_8h_source.html#l00820">SAMRAI::hier::BaseGridGeometry::Neighbor::getTransformedDomain()</a>, <a class="el" href="BoxContainer_8C_source.html#l01560">SAMRAI::hier::BoxContainer::grow()</a>, <a class="el" href="BoxContainer_8C_source.html#l01621">SAMRAI::hier::BoxContainer::hasBoxInBlock()</a>, <a class="el" href="BaseGridGeometry_8h_source.html#l00878">SAMRAI::hier::BaseGridGeometry::Neighbor::isSingularity()</a>, <a class="el" href="BoxContainer_8C_source.html#l01609">SAMRAI::hier::BoxContainer::makeTree()</a>, <a class="el" href="BoxContainer_8C_source.html#l00781">SAMRAI::hier::BoxContainer::removeIntersections()</a>, <a class="el" href="BoxContainer_8h_source.html#l01223">SAMRAI::hier::BoxContainer::spliceBack()</a>, and <a class="el" href="BoxContainer_8C_source.html#l01437">SAMRAI::hier::BoxContainer::unorder()</a>.</p>

</div>
</div>
<a class="anchor" id="a307c40943177d19883e736a4ac7c6430"></a><!-- doxytag: member="SAMRAI::hier::BoxLevelConnectorUtils::makeSortingMap" ref="a307c40943177d19883e736a4ac7c6430" args="(boost::shared_ptr&lt; BoxLevel &gt; &amp;sorted_box_level, boost::shared_ptr&lt; MappingConnector &gt; &amp;output_map, const BoxLevel &amp;unsorted_box_level, bool sort_boxes_by_corner=true, bool sequentialize_global_indices=true, LocalId initial_sequential_index=LocalId::getZero()) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::hier::BoxLevelConnectorUtils::makeSortingMap </td>
          <td>(</td>
          <td class="paramtype">boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>sorted_box_level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1hier_1_1MappingConnector.html">MappingConnector</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>output_map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>unsorted_box_level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>sort_boxes_by_corner</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>sequentialize_global_indices</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1hier_1_1LocalId.html">LocalId</a>&nbsp;</td>
          <td class="paramname"> <em>initial_sequential_index</em> = <code>LocalId::getZero()</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>References <a class="el" href="BoxContainer_8h_source.html#l00695">SAMRAI::hier::BoxContainer::empty()</a>, <a class="el" href="BoxContainer_8h_source.html#l00717">SAMRAI::hier::BoxContainer::end()</a>, <a class="el" href="BoxContainer_8h_source.html#l01583">SAMRAI::hier::BoxContainer::find()</a>, <a class="el" href="Box_8h_source.html#l00330">SAMRAI::hier::Box::getBlockId()</a>, <a class="el" href="BoxLevel_8h_source.html#l00521">SAMRAI::hier::BoxLevel::getBoxes()</a>, <a class="el" href="Box_8h_source.html#l00315">SAMRAI::hier::Box::getBoxId()</a>, <a class="el" href="BoxLevel_8h_source.html#l00848">SAMRAI::hier::BoxLevel::getDim()</a>, <a class="el" href="Box_8h_source.html#l00351">SAMRAI::hier::Box::getGlobalId()</a>, <a class="el" href="BoxLevel_8h_source.html#l00859">SAMRAI::hier::BoxLevel::getGridGeometry()</a>, <a class="el" href="Box_8h_source.html#l00344">SAMRAI::hier::Box::getLocalId()</a>, <a class="el" href="BoxLevel_8h_source.html#l00596">SAMRAI::hier::BoxLevel::getLocalNumberOfBoxes()</a>, <a class="el" href="BoxLevel_8h_source.html#l00398">SAMRAI::hier::BoxLevel::getMPI()</a>, <a class="el" href="Box_8h_source.html#l00358">SAMRAI::hier::Box::getOwnerRank()</a>, <a class="el" href="Box_8h_source.html#l00369">SAMRAI::hier::Box::getPeriodicId()</a>, <a class="el" href="BoxLevel_8h_source.html#l00583">SAMRAI::hier::BoxLevel::getRefinementRatio()</a>, <a class="el" href="IntVector_8h_source.html#l01130">SAMRAI::hier::IntVector::getZero()</a>, <a class="el" href="SAMRAI__MPI_8h_source.html#l00052">MPI_INT</a>, <a class="el" href="SAMRAI__MPI_8h_source.html#l00063">MPI_SUM</a>, <a class="el" href="SAMRAI__MPI_8C_source.html#l01223">SAMRAI::tbox::SAMRAI_MPI::Scan()</a>, <a class="el" href="BoxContainer_8C_source.html#l00606">SAMRAI::hier::BoxContainer::separatePeriodicImages()</a>, <a class="el" href="Utilities_8h_source.html#l00110">TBOX_ASSERT</a>, and <a class="el" href="SAMRAI__MPI_8h_source.html#l00838">SAMRAI::tbox::SAMRAI_MPI::usingMPI()</a>.</p>

</div>
</div>
<a class="anchor" id="ac089ec2d0ac153bd3e494ab46ee0a257"></a><!-- doxytag: member="SAMRAI::hier::BoxLevelConnectorUtils::makeRemainderMap" ref="ac089ec2d0ac153bd3e494ab46ee0a257" args="(boost::shared_ptr&lt; BoxLevel &gt; &amp;remainder, boost::shared_ptr&lt; MappingConnector &gt; &amp;orig_to_remainder, const MappingConnector &amp;orig_to_rejections) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::hier::BoxLevelConnectorUtils::makeRemainderMap </td>
          <td>(</td>
          <td class="paramtype">boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>remainder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1hier_1_1MappingConnector.html">MappingConnector</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>orig_to_remainder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1MappingConnector.html">MappingConnector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>orig_to_rejections</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>References <a class="el" href="Connector_8h_source.html#l00208">SAMRAI::hier::Connector::begin()</a>, <a class="el" href="BoxContainer_8h_source.html#l00706">SAMRAI::hier::BoxContainer::begin()</a>, <a class="el" href="BoxContainer_8C_source.html#l00528">SAMRAI::hier::BoxContainer::coalesce()</a>, <a class="el" href="Connector_8h_source.html#l00226">SAMRAI::hier::Connector::end()</a>, <a class="el" href="BoxContainer_8h_source.html#l00717">SAMRAI::hier::BoxContainer::end()</a>, <a class="el" href="Connector_8h_source.html#l00299">SAMRAI::hier::Connector::findLocal()</a>, <a class="el" href="Connector_8h_source.html#l00753">SAMRAI::hier::Connector::getBase()</a>, <a class="el" href="Box_8h_source.html#l00330">SAMRAI::hier::Box::getBlockId()</a>, <a class="el" href="BoxLevel_8h_source.html#l00521">SAMRAI::hier::BoxLevel::getBoxes()</a>, <a class="el" href="Box_8h_source.html#l00315">SAMRAI::hier::Box::getBoxId()</a>, <a class="el" href="BoxLevel_8h_source.html#l00848">SAMRAI::hier::BoxLevel::getDim()</a>, <a class="el" href="IntVector_8h_source.html#l01130">SAMRAI::hier::IntVector::getZero()</a>, <a class="el" href="Connector_8h_source.html#l00382">SAMRAI::hier::Connector::hasNeighborSet()</a>, <a class="el" href="Connector_8h_source.html#l00840">SAMRAI::hier::Connector::isLocal()</a>, <a class="el" href="Connector_8h_source.html#l00463">SAMRAI::hier::Connector::numLocalNeighbors()</a>, <a class="el" href="BoxContainer_8C_source.html#l00781">SAMRAI::hier::BoxContainer::removeIntersections()</a>, <a class="el" href="BoxContainer_8h_source.html#l00663">SAMRAI::hier::BoxContainer::size()</a>, and <a class="el" href="Utilities_8h_source.html#l00110">TBOX_ASSERT</a>.</p>

</div>
</div>
<a class="anchor" id="a7cb54d1f23e65ddd4c74ae78d1d75b40"></a><!-- doxytag: member="SAMRAI::hier::BoxLevelConnectorUtils::addPeriodicImages" ref="a7cb54d1f23e65ddd4c74ae78d1d75b40" args="(BoxLevel &amp;box_level, const BoxContainer &amp;domain_search_tree, const IntVector &amp;threshold_distance) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::hier::BoxLevelConnectorUtils::addPeriodicImages </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>box_level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>domain_search_tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>threshold_distance</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Add periodic images to a <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html" title="A distributed set of Box objects which reside in the same index space.">BoxLevel</a>. </p>
<p>This method is a no-op in the case of non-periodic domains.</p>
<p>Any periodic image within a certain distance of the domain is added, Those farther out are not added. The threshold distance is <code>threshold_distance</code>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>box_level</em>&nbsp;</td><td><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html" title="A distributed set of Box objects which reside in the same index space.">BoxLevel</a> subject to the addition of periodic Boxes.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>domain_search_tree</em>&nbsp;</td><td>Domain description in the reference index space. This tree must NOT include periodic images.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>threshold_distance</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="BoxLevel_8C_source.html#l01109">SAMRAI::hier::BoxLevel::addPeriodicBox()</a>, <a class="el" href="BoxLevel_8C_source.html#l00307">SAMRAI::hier::BoxLevel::finalize()</a>, <a class="el" href="BoxLevel_8h_source.html#l00521">SAMRAI::hier::BoxLevel::getBoxes()</a>, <a class="el" href="BoxLevel_8h_source.html#l00859">SAMRAI::hier::BoxLevel::getGridGeometry()</a>, <a class="el" href="PeriodicShiftCatalog_8h_source.html#l00141">SAMRAI::hier::PeriodicShiftCatalog::getNumberOfShifts()</a>, <a class="el" href="BoxLevel_8h_source.html#l00583">SAMRAI::hier::BoxLevel::getRefinementRatio()</a>, <a class="el" href="Box_8h_source.html#l00915">SAMRAI::hier::Box::grow()</a>, <a class="el" href="BoxContainer_8C_source.html#l01878">SAMRAI::hier::BoxContainer::hasOverlap()</a>, <a class="el" href="PeriodicShiftCatalog_8h_source.html#l00132">SAMRAI::hier::PeriodicShiftCatalog::isPeriodic()</a>, <a class="el" href="Box_8h_source.html#l01084">SAMRAI::hier::Box::shift()</a>, and <a class="el" href="PeriodicShiftCatalog_8h_source.html#l00068">SAMRAI::hier::PeriodicShiftCatalog::shiftNumberToShiftDistance()</a>.</p>

<p>Referenced by <a class="el" href="GriddingAlgorithm_8C_source.html#l00336">SAMRAI::mesh::GriddingAlgorithm::makeCoarsestLevel()</a>.</p>

</div>
</div>
<a class="anchor" id="ac49fedc69a4c201ea8ac36631d8b93c8"></a><!-- doxytag: member="SAMRAI::hier::BoxLevelConnectorUtils::addPeriodicImagesAndRelationships" ref="ac49fedc69a4c201ea8ac36631d8b93c8" args="(BoxLevel &amp;box_level, Connector &amp;box_level_to_anchor, const BoxContainer &amp;domain_search_tree, const Connector &amp;anchor_to_anchor) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::hier::BoxLevelConnectorUtils::addPeriodicImagesAndRelationships </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>box_level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">Connector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>box_level_to_anchor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>domain_search_tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">Connector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>anchor_to_anchor</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Add periodic images to a <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html" title="A distributed set of Box objects which reside in the same index space.">BoxLevel</a> and add new relationships to the periodic images. </p>
<p>This method is a no-op in the case of non-periodic domains.</p>
<p>Any periodic images within a certain distance of the domain is added, but the rest are not added. The threshold distance is the width of the <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html" title="A container which holds relationship connections between two BoxLevels.">Connector</a> <code>box_level_to_anchor</code>.</p>
<p>This method updates the overlap Connectors between the <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html" title="A distributed set of Box objects which reside in the same index space.">BoxLevel</a> getting new periodic Boxes and an "anchor" <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html" title="A distributed set of Box objects which reside in the same index space.">BoxLevel</a>. New periodic overlap relationships generated are added to the overlap <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html" title="A container which holds relationship connections between two BoxLevels.">Connector</a> <code>box_level_to_anchor</code>. If you don't need to have a <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html" title="A container which holds relationship connections between two BoxLevels.">Connector</a> updated, use <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevelConnectorUtils.html#a7cb54d1f23e65ddd4c74ae78d1d75b40" title="Add periodic images to a BoxLevel.">addPeriodicImages()</a> instead of this method.</p>
<p>Preconditions: box_level&lt;==&gt;anchor must be transpose overlap Connectors (or communications may hang). anchor---&gt;anchor must be a complete overlap <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html" title="A container which holds relationship connections between two BoxLevels.">Connector</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>box_level</em>&nbsp;</td><td><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html" title="A distributed set of Box objects which reside in the same index space.">BoxLevel</a> subject to the addition of periodic Boxes.</td></tr>
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>box_level_to_anchor</em>&nbsp;</td><td>Overlap <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html" title="A container which holds relationship connections between two BoxLevels.">Connector</a> to be updated with new relationships.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>domain_search_tree</em>&nbsp;</td><td>Domain description in the reference index space. This tree must NOT include periodic images.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>anchor_to_anchor</em>&nbsp;</td><td>Self overlap <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html" title="A container which holds relationship connections between two BoxLevels.">Connector</a> for anchor <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html" title="A distributed set of Box objects which reside in the same index space.">BoxLevel</a>. Must be a complete overlap <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html" title="A container which holds relationship connections between two BoxLevels.">Connector</a> with periodic relationships. To guarantee complete periodic relationships, the anchor, grown by the width of this <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html" title="A container which holds relationship connections between two BoxLevels.">Connector</a>, must nest box_level grown by the width of box_level_to_anchor. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="BoxLevel_8C_source.html#l01109">SAMRAI::hier::BoxLevel::addPeriodicBox()</a>, <a class="el" href="Connector_8C_source.html#l01604">SAMRAI::hier::Connector::assertTransposeCorrectness()</a>, <a class="el" href="OverlapConnectorAlgorithm_8C_source.html#l00740">SAMRAI::hier::OverlapConnectorAlgorithm::bridge()</a>, <a class="el" href="Connector_8C_source.html#l01877">SAMRAI::hier::Connector::checkConsistencyWithBase()</a>, <a class="el" href="Connector_8C_source.html#l01999">SAMRAI::hier::Connector::checkConsistencyWithHead()</a>, <a class="el" href="Connector_8C_source.html#l02205">SAMRAI::hier::Connector::checkOverlapCorrectness()</a>, <a class="el" href="BoxLevel_8h_source.html#l00284">SAMRAI::hier::BoxLevel::clearForBoxChanges()</a>, <a class="el" href="Connector_8h_source.html#l00659">SAMRAI::hier::Connector::eraseEmptyNeighborSets()</a>, <a class="el" href="Connector_8h_source.html#l01487">SAMRAI::hier::Connector::format()</a>, <a class="el" href="BoxLevel_8C_source.html#l01642">SAMRAI::hier::BoxLevel::format()</a>, <a class="el" href="BoxLevel_8h_source.html#l00521">SAMRAI::hier::BoxLevel::getBoxes()</a>, <a class="el" href="Box_8h_source.html#l00315">SAMRAI::hier::Box::getBoxId()</a>, <a class="el" href="Connector_8h_source.html#l00981">SAMRAI::hier::Connector::getConnectorWidth()</a>, <a class="el" href="BoxLevel_8h_source.html#l00859">SAMRAI::hier::BoxLevel::getGridGeometry()</a>, <a class="el" href="PeriodicShiftCatalog_8h_source.html#l00141">SAMRAI::hier::PeriodicShiftCatalog::getNumberOfShifts()</a>, <a class="el" href="BoxLevel_8h_source.html#l00583">SAMRAI::hier::BoxLevel::getRefinementRatio()</a>, <a class="el" href="Connector_8h_source.html#l01147">SAMRAI::hier::Connector::getTranspose()</a>, <a class="el" href="Box_8h_source.html#l00915">SAMRAI::hier::Box::grow()</a>, <a class="el" href="Connector_8h_source.html#l00382">SAMRAI::hier::Connector::hasNeighborSet()</a>, <a class="el" href="BoxContainer_8C_source.html#l01878">SAMRAI::hier::BoxContainer::hasOverlap()</a>, <a class="el" href="Connector_8h_source.html#l01136">SAMRAI::hier::Connector::hasTranspose()</a>, <a class="el" href="Connector_8h_source.html#l00671">SAMRAI::hier::Connector::isEmptyNeighborhood()</a>, <a class="el" href="PeriodicShiftCatalog_8h_source.html#l00132">SAMRAI::hier::PeriodicShiftCatalog::isPeriodic()</a>, <a class="el" href="Connector_8C_source.html#l01314">SAMRAI::hier::Connector::isTransposeOf()</a>, <a class="el" href="BoxContainer_8C_source.html#l01609">SAMRAI::hier::BoxContainer::makeTree()</a>, <a class="el" href="namespaceSAMRAI_1_1tbox.html#ad72fd66574b63c87061563d2c66b5475">SAMRAI::tbox::perr</a>, <a class="el" href="namespaceSAMRAI_1_1tbox.html#ab84041705493761fb17a8127e3a2dca2">SAMRAI::tbox::plog</a>, <a class="el" href="BoxContainer_8C_source.html#l01585">SAMRAI::hier::BoxContainer::refine()</a>, <a class="el" href="OverlapConnectorAlgorithm_8h_source.html#l00444">SAMRAI::hier::OverlapConnectorAlgorithm::setSanityCheckMethodPreconditions()</a>, <a class="el" href="Box_8h_source.html#l01084">SAMRAI::hier::Box::shift()</a>, <a class="el" href="PeriodicShiftCatalog_8h_source.html#l00068">SAMRAI::hier::PeriodicShiftCatalog::shiftNumberToShiftDistance()</a>, <a class="el" href="Utilities_8h_source.html#l00110">TBOX_ASSERT</a>, <a class="el" href="Utilities_8h_source.html#l00060">TBOX_ERROR</a>, and <a class="el" href="Utilities_8h_source.html#l00070">TBOX_WARNING</a>.</p>

</div>
</div>
<a class="anchor" id="a7d59815e4dfdfaacd8a72c6f2bda8abd"></a><!-- doxytag: member="SAMRAI::hier::BoxLevelConnectorUtils::setTimerPrefix" ref="a7d59815e4dfdfaacd8a72c6f2bda8abd" args="(const std::string &amp;timer_prefix)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::hier::BoxLevelConnectorUtils::setTimerPrefix </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>timer_prefix</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Setup names of timers. </p>
<p>By default, timers are named "hier::BoxLevelConnectorUtils::*", where the third field is the specific steps performed by the <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevelConnectorUtils.html" title="Utilities for common operating on BoxLevels.">BoxLevelConnectorUtils</a>. You can override the first two fields with this method. Conforming to the timer naming convention, timer_prefix should have the form "*::*". </p>

<p>Referenced by <a class="el" href="BoxLevelConnectorUtils_8C_source.html#l00045">BoxLevelConnectorUtils()</a>, and <a class="el" href="GriddingAlgorithm_8C_source.html#l00054">SAMRAI::mesh::GriddingAlgorithm::GriddingAlgorithm()</a>.</p>

</div>
</div>
<a class="anchor" id="a84f4e540d816b2fd5660ea38428456f0"></a><!-- doxytag: member="SAMRAI::hier::BoxLevelConnectorUtils::getObjectName" ref="a84f4e540d816b2fd5660ea38428456f0" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::string SAMRAI::hier::BoxLevelConnectorUtils::getObjectName </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the name of this object. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>source/SAMRAI/hier/<a class="el" href="BoxLevelConnectorUtils_8h.html">BoxLevelConnectorUtils.h</a></li>
<li>source/SAMRAI/hier/<a class="el" href="BoxLevelConnectorUtils_8C.html">BoxLevelConnectorUtils.C</a></li>
</ul>
</div>
<hr size="1"/><address style="text-align: right;"><small>Generated on 5 Jun 2015 for SAMRAI by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.1 </small></address>
</body>
</html>
