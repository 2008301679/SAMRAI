<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>SAMRAI: SAMRAI::hier::BoxLevelConnectorUtils Class Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.7 -->
<div class="tabs">
  <ul>
    <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="namespaces.html"><span>Namespaces</span></a></li>
    <li id="current"><a href="annotated.html"><span>Classes</span></a></li>
    <li><a href="files.html"><span>Files</span></a></li>
    <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
  </ul></div>
<div class="tabs">
  <ul>
    <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
    <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
    <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
  </ul></div>
<div class="nav">
<a class="el" href="namespaceSAMRAI.html">SAMRAI</a>::<a class="el" href="namespaceSAMRAI_1_1hier.html">hier</a>::<a class="el" href="classSAMRAI_1_1hier_1_1BoxLevelConnectorUtils.html">BoxLevelConnectorUtils</a></div>
<h1>SAMRAI::hier::BoxLevelConnectorUtils Class Reference</h1><!-- doxytag: class="SAMRAI::hier::BoxLevelConnectorUtils" -->Utilities for common operating on BoxLevels.  
<a href="#_details">More...</a>
<p>
<code>#include &lt;source/SAMRAI/hier/BoxLevelConnectorUtils.h&gt;</code>
<p>
<a href="classSAMRAI_1_1hier_1_1BoxLevelConnectorUtils-members.html">List of all members.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevelConnectorUtils.html#4d5cb7988f2a2a0e20faae4dc9694bed">BoxLevelConnectorUtils</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Default constructor.  <a href="#4d5cb7988f2a2a0e20faae4dc9694bed"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevelConnectorUtils.html#97074be16f5026eea98984df78e1fdbc">setSanityCheckMethodPreconditions</a> (bool do_check)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set whether to run expensive sanity checks on input parameters.  <a href="#97074be16f5026eea98984df78e1fdbc"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevelConnectorUtils.html#5c1f03a9ba4faae88a8c2b00dda74abd">setSanityCheckMethodPostconditions</a> (bool do_check)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set whether to run expensive sanity checks on output parameters.  <a href="#5c1f03a9ba4faae88a8c2b00dda74abd"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevelConnectorUtils.html#277fc240566f5f3ee8a7364d0f1e0d04">computeBoxesAroundBoundary</a> (<a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a> &amp;boundary, const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;refinement_ratio, const boost::shared_ptr&lt; const <a class="el" href="classSAMRAI_1_1hier_1_1BaseGridGeometry.html">BaseGridGeometry</a> &gt; &amp;grid_geometry, const bool simplify_boundary_boxes=true) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Given a set of Boxes, compute its boundary as a set of boxes located just outside it.  <a href="#277fc240566f5f3ee8a7364d0f1e0d04"></a><br></td></tr>
<tr><td colspan="2"><div class="groupHeader">Comparing boxes of two BoxLevels</div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevelConnectorUtils.html#31c793b97f9c3fad37a0f072ac1d06c6">baseNestsInHead</a> (bool *locally_nests, const <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">Connector</a> &amp;connector, const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;base_swell, const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;head_swell, const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;head_nesting_margin, const <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a> *domain=0) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Given an overlap <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">Connector</a>, determine the extent to which the Connector's base nests in its head.  <a href="#31c793b97f9c3fad37a0f072ac1d06c6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevelConnectorUtils.html#7dba510f014ca5cda9e8c7c5d81064bc">baseNestsInHead</a> (bool *locally_nests, const <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a> &amp;base, const <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a> &amp;head, const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;base_swell, const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;head_swell, const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;head_margin, const <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a> *domain=0) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Given base and head BoxLevels, determine the extent to which the base nests in the head.  <a href="#7dba510f014ca5cda9e8c7c5d81064bc"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevelConnectorUtils.html#6256405899aecdc768c3823f12db1022">computeExternalParts</a> (<a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a> &amp;external, <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">Connector</a> &amp;input_to_external, const <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">Connector</a> &amp;input_to_reference, const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;nesting_width, const <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a> &amp;domain=<a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a>()) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute the parts of one <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a> that are external to another <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a>.  <a href="#6256405899aecdc768c3823f12db1022"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevelConnectorUtils.html#38492be307b8a386f668dae4abcb7932">computeInternalParts</a> (<a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a> &amp;internal, <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">Connector</a> &amp;input_to_internal, const <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">Connector</a> &amp;input_to_reference, const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;nesting_width, const <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a> &amp;domain=<a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a>()) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute the parts of one <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a> that are internal to another <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a>.  <a href="#38492be307b8a386f668dae4abcb7932"></a><br></td></tr>
<tr><td colspan="2"><div class="groupHeader">Setting up common mapping Connectors</div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevelConnectorUtils.html#ba36ba1dc36d7a50a76d424e28513b34">makeSortingMap</a> (<a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a> &amp;sorted_box_level, <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">Connector</a> &amp;output_map, const <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a> &amp;unsorted_box_level, bool sort_boxes_by_corner=true, bool sequentialize_global_indices=true, <a class="el" href="classSAMRAI_1_1hier_1_1LocalId.html">LocalId</a> initial_sequential_index=LocalId::getZero()) const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevelConnectorUtils.html#53f3d12fae576eab2826b8c5b5fe5b0a">makeRemainderMap</a> (<a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a> &amp;remainder, <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">Connector</a> &amp;orig_to_remainder, const <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">Connector</a> &amp;orig_to_rejections) const </td></tr>

<tr><td colspan="2"><div class="groupHeader">Adding periodic images</div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevelConnectorUtils.html#a9a22ab6174ad056237839189ac39a8d">addPeriodicImages</a> (<a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a> &amp;box_level, const <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a> &amp;domain_search_tree, const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;threshold_distance) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Add periodic images to a <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a>.  <a href="#a9a22ab6174ad056237839189ac39a8d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevelConnectorUtils.html#cc1571fcc10d9be2831c04e7195b0822">addPeriodicImagesAndRelationships</a> (<a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a> &amp;box_level, <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">Connector</a> &amp;box_level_to_anchor, <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">Connector</a> &amp;anchor_to_box_level, const <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a> &amp;domain_search_tree, const <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">Connector</a> &amp;anchor_to_anchor) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Add periodic images to a <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a> and add new relationships to the periodic images.  <a href="#cc1571fcc10d9be2831c04e7195b0822"></a><br></td></tr>
</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
Utilities for common operating on BoxLevels. 
<p>
Objects of this class can be set to perform certain sanity checks on the pre and post conditions of the methods. See <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevelConnectorUtils.html#97074be16f5026eea98984df78e1fdbc">setSanityCheckMethodPreconditions()</a> and <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevelConnectorUtils.html#5c1f03a9ba4faae88a8c2b00dda74abd">setSanityCheckMethodPostconditions()</a>. 
<p>
<hr><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" name="4d5cb7988f2a2a0e20faae4dc9694bed"></a><!-- doxytag: member="SAMRAI::hier::BoxLevelConnectorUtils::BoxLevelConnectorUtils" ref="4d5cb7988f2a2a0e20faae4dc9694bed" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SAMRAI::hier::BoxLevelConnectorUtils::BoxLevelConnectorUtils           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Default constructor. 
<p>
By default, sanity checks are disabled. To enable them, see <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevelConnectorUtils.html#97074be16f5026eea98984df78e1fdbc">setSanityCheckMethodPreconditions()</a> and <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevelConnectorUtils.html#5c1f03a9ba4faae88a8c2b00dda74abd">setSanityCheckMethodPostconditions()</a>. 
</div>
</div><p>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="97074be16f5026eea98984df78e1fdbc"></a><!-- doxytag: member="SAMRAI::hier::BoxLevelConnectorUtils::setSanityCheckMethodPreconditions" ref="97074be16f5026eea98984df78e1fdbc" args="(bool do_check)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::hier::BoxLevelConnectorUtils::setSanityCheckMethodPreconditions           </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>do_check</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set whether to run expensive sanity checks on input parameters. 
<p>
Mainly for debugging.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>do_check</em>&nbsp;</td><td></td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="5c1f03a9ba4faae88a8c2b00dda74abd"></a><!-- doxytag: member="SAMRAI::hier::BoxLevelConnectorUtils::setSanityCheckMethodPostconditions" ref="5c1f03a9ba4faae88a8c2b00dda74abd" args="(bool do_check)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::hier::BoxLevelConnectorUtils::setSanityCheckMethodPostconditions           </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>do_check</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set whether to run expensive sanity checks on output parameters. 
<p>
Mainly for debugging.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>do_check</em>&nbsp;</td><td></td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="31c793b97f9c3fad37a0f072ac1d06c6"></a><!-- doxytag: member="SAMRAI::hier::BoxLevelConnectorUtils::baseNestsInHead" ref="31c793b97f9c3fad37a0f072ac1d06c6" args="(bool *locally_nests, const Connector &amp;connector, const IntVector &amp;base_swell, const IntVector &amp;head_swell, const IntVector &amp;head_nesting_margin, const BoxContainer *domain=0) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SAMRAI::hier::BoxLevelConnectorUtils::baseNestsInHead           </td>
          <td>(</td>
          <td class="paramtype">bool *&nbsp;</td>
          <td class="paramname"> <em>locally_nests</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">Connector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>connector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>base_swell</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>head_swell</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>head_nesting_margin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a> *&nbsp;</td>
          <td class="paramname"> <em>domain</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Given an overlap <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">Connector</a>, determine the extent to which the Connector's base nests in its head. 
<p>
This method returns true if the base, grown by <code>base_swell</code>, nests inside the head, grown by <code>head_swell</code>, by a margin of <code>head_nesting_margin</code>. <code>base_swell</code> and <code>head_swell</code> should be non-negative and specified in the base and head index spaces, respectively. <code>head_nesting_margin</code> should be in the head index space.<p>
The <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">Connector</a> width must be at least the sum of the <code>base_swell</code> and the (appropriately converted) <code>head_swell</code> and <code>head_nesting_margin</code>. We require and assume without verifying that the <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">Connector</a> is complete.<p>
If the domain is given, non-nesting parts outside of the domain are disregarded.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>locally_nests</em>&nbsp;</td><td>Whether the local parts of the base nests in the head. This output may vary among the processes.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>connector</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>base_swell</em>&nbsp;</td><td>the amount that the base is grown by, given in the base index space and non-negative</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>head_swell</em>&nbsp;</td><td>the amount that the head is grown by, given in the head index space and non-negative</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>head_nesting_margin</em>&nbsp;</td><td>given in the head index space.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>domain</em>&nbsp;</td><td>Domain description, in reference index space, in search tree format.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>True if the given base <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a> nests in the head, otherwise False. </dd></dl>
<dl compact><dt><b>Precondition:</b></dt><dd>(connector.getBase().getDim() == base_swell.getDim()) &amp;&amp; (connector.getBase().getDim() == head_nesting_margin.getDim()) <p>
connector.isFinalized() <p>
base_swell &gt;= <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html#75075186e3ca2b549792b84f3f5dcb9b">IntVector::getZero</a>(connector.getBase().getDim()) <p>
head_nesting_margin &gt;= <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html#75075186e3ca2b549792b84f3f5dcb9b">IntVector::getZero</a>(connector.getBase().getDim()) </dd></dl>

</div>
</div><p>
<a class="anchor" name="7dba510f014ca5cda9e8c7c5d81064bc"></a><!-- doxytag: member="SAMRAI::hier::BoxLevelConnectorUtils::baseNestsInHead" ref="7dba510f014ca5cda9e8c7c5d81064bc" args="(bool *locally_nests, const BoxLevel &amp;base, const BoxLevel &amp;head, const IntVector &amp;base_swell, const IntVector &amp;head_swell, const IntVector &amp;head_margin, const BoxContainer *domain=0) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SAMRAI::hier::BoxLevelConnectorUtils::baseNestsInHead           </td>
          <td>(</td>
          <td class="paramtype">bool *&nbsp;</td>
          <td class="paramname"> <em>locally_nests</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>head</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>base_swell</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>head_swell</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>head_margin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a> *&nbsp;</td>
          <td class="paramname"> <em>domain</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Given base and head BoxLevels, determine the extent to which the base nests in the head. 
<p>
This method is similar to the version taking a <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">Connector</a> instead of the base and head BoxLevels, except that it will use the base BoxLevel's <a class="el" href="classSAMRAI_1_1hier_1_1PersistentOverlapConnectors.html">PersistentOverlapConnectors</a> object to get the base---&gt;head <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">Connector</a>. If such a <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">Connector</a> does not exist, the <a class="el" href="classSAMRAI_1_1hier_1_1PersistentOverlapConnectors.html">PersistentOverlapConnectors</a> object will create it, an unscalable operation possibly requiring collective communication.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>domain</em>&nbsp;</td><td>Domain description, in reference index space, in search tree format.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Whether the given base <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a> nests in the head.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>locally_nests</em>&nbsp;</td><td>Whether the local parts of the base nests in the head. This output may vary among the processes.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>base</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>head</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>base_swell</em>&nbsp;</td><td>the amount that the base is grown by, given in the base index space and non-negative</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>head_swell</em>&nbsp;</td><td>the amount that the head is grown by, given in the head index space and non-negative</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>head_margin</em>&nbsp;</td><td>given in the head index space.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>domain</em>&nbsp;</td><td>Domain description, in reference index space, in search tree format.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Whether the given base <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a> nests in the head.</dd></dl>
<dl compact><dt><b>Precondition:</b></dt><dd>head_nesting_margin.getDim() == base_swell.getDim() <p>
head.getMPI() == base.getMPI() <p>
base_swell &gt;= <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html#75075186e3ca2b549792b84f3f5dcb9b">IntVector::getZero</a>(head.getDim()) <p>
head_swell &gt;= <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html#75075186e3ca2b549792b84f3f5dcb9b">IntVector::getZero</a>(head.getDim()) <p>
head_nesting_margin &gt;= <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html#75075186e3ca2b549792b84f3f5dcb9b">IntVector::getZero</a>(head.getDim()) <p>
(head.getRefinementRatio() &lt;= base.getRefinementRatio()) || (head.getRefinementRatio() &gt;= base.getRefinementRatio()) || </dd></dl>

</div>
</div><p>
<a class="anchor" name="6256405899aecdc768c3823f12db1022"></a><!-- doxytag: member="SAMRAI::hier::BoxLevelConnectorUtils::computeExternalParts" ref="6256405899aecdc768c3823f12db1022" args="(BoxLevel &amp;external, Connector &amp;input_to_external, const Connector &amp;input_to_reference, const IntVector &amp;nesting_width, const BoxContainer &amp;domain=BoxContainer()) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::hier::BoxLevelConnectorUtils::computeExternalParts           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>external</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">Connector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>input_to_external</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">Connector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>input_to_reference</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>nesting_width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>domain</em> = <code><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a>()</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Compute the parts of one <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a> that are external to another <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a>. 
<p>
Compare an input <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a> to a "reference" <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a>. Compute the parts of the input that are external to the reference. Build the "external" <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a> representing the external parts. Build a mapping <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">Connector</a> with the input as its base and the external as its head.<p>
A partially external input cell (possible when input is coarser than reference) is considered to be external.<p>
For the purpose of defining what is external, the reference level can be grown by nesting_width before comparing. This feature can be used to determing which parts of the input does not nest in the reference comparison. A negative growth indicates shrinking of the reference level.<p>
This method does not require any communication.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>external</em>&nbsp;</td><td>The existing state will be discarded.</td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>input_to_external</em>&nbsp;</td><td>The existing state will be discarded.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>input_to_reference</em>&nbsp;</td><td>Overlap <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">Connector</a> from input to reference <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a>. The width of input_to_reference must be at least one and at least the absolute value of nesting_width.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>nesting_width</em>&nbsp;</td><td>Growth of the reference <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a> for the purpose of comparing to input. Must be in resolution of input <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a>. Must be either non-negative or non-positive but not mixed. If any width is negative, then input_to_reference must have a <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">Connector</a> width of at least 1. Otherwise, an error is thrown (because correct results cannot be guaranteed).</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>domain</em>&nbsp;</td><td>The domain representation, without periodic images, in search tree form. These boxes should be in the reference index space. If domain is given, do not shrink the reference <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a> where it touches the domain boundary.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Postcondition:</b></dt><dd>input_to_external.isLocal() </dd></dl>

</div>
</div><p>
<a class="anchor" name="38492be307b8a386f668dae4abcb7932"></a><!-- doxytag: member="SAMRAI::hier::BoxLevelConnectorUtils::computeInternalParts" ref="38492be307b8a386f668dae4abcb7932" args="(BoxLevel &amp;internal, Connector &amp;input_to_internal, const Connector &amp;input_to_reference, const IntVector &amp;nesting_width, const BoxContainer &amp;domain=BoxContainer()) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::hier::BoxLevelConnectorUtils::computeInternalParts           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>internal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">Connector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>input_to_internal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">Connector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>input_to_reference</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>nesting_width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>domain</em> = <code><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a>()</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Compute the parts of one <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a> that are internal to another <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a>. 
<p>
Compare an input <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a> to a "reference" box_level. Identify parts of the input that are internal to the reference <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a>, and store the internal parts in a <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a>. Set up a mapping <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">Connector</a> between the input and its internal parts.<p>
A partially internal input cell (possible when input is coarser than reference) is considered to be internal.<p>
For the purpose of defining what is external, the reference level can be grown by nesting_width before comparing. This feature can be used to determing which parts of the input does not nest in the reference comparison. A negative growth indicates shrinking of the reference level.<p>
This method does not require any communication.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>internal</em>&nbsp;</td><td>The existing state will be discarded.</td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>input_to_internal</em>&nbsp;</td><td>The existing state will be discarded.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>input_to_reference</em>&nbsp;</td><td>Overlap <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">Connector</a> from input to reference <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a>. The width of input_to_reference must be at least one and at least the absolute value of nesting_width.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>nesting_width</em>&nbsp;</td><td>Growth of the reference <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a> for the purpose of comparing to input. Must be in resolution of input <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a>. Must be either non-negative or non-positive but not mixed. If any width is negative, then input_to_reference must have a <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">Connector</a> width of at least 1. Otherwise, an error is thrown (because correct results cannot be guaranteed).</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>domain</em>&nbsp;</td><td>The domain representation, without periodic images, in search tree form. These boxes should be in the reference index space. If domain is given, do not shrink the reference <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a> where it touches the domain boundary.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Postcondition:</b></dt><dd>input_to_internal.isLocal() </dd></dl>

</div>
</div><p>
<a class="anchor" name="277fc240566f5f3ee8a7364d0f1e0d04"></a><!-- doxytag: member="SAMRAI::hier::BoxLevelConnectorUtils::computeBoxesAroundBoundary" ref="277fc240566f5f3ee8a7364d0f1e0d04" args="(BoxContainer &amp;boundary, const IntVector &amp;refinement_ratio, const boost::shared_ptr&lt; const BaseGridGeometry &gt; &amp;grid_geometry, const bool simplify_boundary_boxes=true) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::hier::BoxLevelConnectorUtils::computeBoxesAroundBoundary           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>boundary</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>refinement_ratio</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const boost::shared_ptr&lt; const <a class="el" href="classSAMRAI_1_1hier_1_1BaseGridGeometry.html">BaseGridGeometry</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>grid_geometry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&nbsp;</td>
          <td class="paramname"> <em>simplify_boundary_boxes</em> = <code>true</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Given a set of Boxes, compute its boundary as a set of boxes located just outside it. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>boundary</em>&nbsp;</td><td>Boundary boxes, sorted into BoxContainers according to the <a class="el" href="classSAMRAI_1_1hier_1_1BlockId.html">BlockId</a>.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>refinement_ratio</em>&nbsp;</td><td>Refinement ratio of boxes.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>grid_geometry</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>simplify_boundary_boxes</em>&nbsp;</td><td>Whether to simplify the boundary boxes after computing them. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="ba36ba1dc36d7a50a76d424e28513b34"></a><!-- doxytag: member="SAMRAI::hier::BoxLevelConnectorUtils::makeSortingMap" ref="ba36ba1dc36d7a50a76d424e28513b34" args="(BoxLevel &amp;sorted_box_level, Connector &amp;output_map, const BoxLevel &amp;unsorted_box_level, bool sort_boxes_by_corner=true, bool sequentialize_global_indices=true, LocalId initial_sequential_index=LocalId::getZero()) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::hier::BoxLevelConnectorUtils::makeSortingMap           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>sorted_box_level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">Connector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>output_map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>unsorted_box_level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>sort_boxes_by_corner</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>sequentialize_global_indices</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1hier_1_1LocalId.html">LocalId</a>&nbsp;</td>
          <td class="paramname"> <em>initial_sequential_index</em> = <code>LocalId::getZero()</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="53f3d12fae576eab2826b8c5b5fe5b0a"></a><!-- doxytag: member="SAMRAI::hier::BoxLevelConnectorUtils::makeRemainderMap" ref="53f3d12fae576eab2826b8c5b5fe5b0a" args="(BoxLevel &amp;remainder, Connector &amp;orig_to_remainder, const Connector &amp;orig_to_rejections) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::hier::BoxLevelConnectorUtils::makeRemainderMap           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>remainder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">Connector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>orig_to_remainder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">Connector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>orig_to_rejections</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="a9a22ab6174ad056237839189ac39a8d"></a><!-- doxytag: member="SAMRAI::hier::BoxLevelConnectorUtils::addPeriodicImages" ref="a9a22ab6174ad056237839189ac39a8d" args="(BoxLevel &amp;box_level, const BoxContainer &amp;domain_search_tree, const IntVector &amp;threshold_distance) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::hier::BoxLevelConnectorUtils::addPeriodicImages           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>box_level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>domain_search_tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>threshold_distance</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Add periodic images to a <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a>. 
<p>
This method is a no-op in the case of non-periodic domains.<p>
Any periodic image within a certain distance of the domain is added, Those farther out are not added. The threshold distance is <code>threshold_distance</code>.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>box_level</em>&nbsp;</td><td><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a> subject to the addition of periodic Boxes.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>domain_search_tree</em>&nbsp;</td><td>Domain description in the reference index space. This tree must NOT include periodic images.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>threshold_distance</em>&nbsp;</td><td></td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="cc1571fcc10d9be2831c04e7195b0822"></a><!-- doxytag: member="SAMRAI::hier::BoxLevelConnectorUtils::addPeriodicImagesAndRelationships" ref="cc1571fcc10d9be2831c04e7195b0822" args="(BoxLevel &amp;box_level, Connector &amp;box_level_to_anchor, Connector &amp;anchor_to_box_level, const BoxContainer &amp;domain_search_tree, const Connector &amp;anchor_to_anchor) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::hier::BoxLevelConnectorUtils::addPeriodicImagesAndRelationships           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>box_level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">Connector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>box_level_to_anchor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">Connector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>anchor_to_box_level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>domain_search_tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">Connector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>anchor_to_anchor</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Add periodic images to a <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a> and add new relationships to the periodic images. 
<p>
This method is a no-op in the case of non-periodic domains.<p>
Any periodic images within a certain distance of the domain is added, but the rest are not added. The threshold distance is the width of the <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">Connector</a> <code>box_level_to_anchor</code>.<p>
This method updates the overlap Connectors between the <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a> getting new periodic Boxes and an "anchor" <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a>. New periodic overlap relationships generated are added to the overlap <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">Connector</a> <code>box_level_to_anchor</code>. If you don't need to have a <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">Connector</a> updated, use <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevelConnectorUtils.html#a9a22ab6174ad056237839189ac39a8d">addPeriodicImages()</a> instead of this method.<p>
Preconditions: box_level&lt;==&gt;anchor must be transpose overlap Connectors (or communications may hang). anchor---&gt;anchor must be a complete overlap <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">Connector</a>.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>box_level</em>&nbsp;</td><td><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a> subject to the addition of periodic Boxes.</td></tr>
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>box_level_to_anchor</em>&nbsp;</td><td>Overlap <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">Connector</a> to be updated with new relationships.</td></tr>
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>anchor_to_box_level</em>&nbsp;</td><td>Overlap <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">Connector</a> to be updated with new relationships.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>domain_search_tree</em>&nbsp;</td><td>Domain description in the reference index space. This tree must NOT include periodic images.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>anchor_to_anchor</em>&nbsp;</td><td>Self overlap <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">Connector</a> for anchor <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a>. Must be a complete overlap <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">Connector</a> with periodic relationships. </td></tr>
  </table>
</dl>

</div>
</div><p>
<hr>The documentation for this class was generated from the following files:<ul>
<li>source/SAMRAI/hier/<a class="el" href="BoxLevelConnectorUtils_8h.html">BoxLevelConnectorUtils.h</a><li>source/SAMRAI/hier/<a class="el" href="BoxLevelConnectorUtils_8C.html">BoxLevelConnectorUtils.C</a></ul>
<hr size="1"><address style="align: right;"><small>Generated on Mon Oct 15 15:43:54 2012 for SAMRAI by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.7 </small></address>
</body>
</html>
