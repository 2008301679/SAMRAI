<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>SAMRAI: SAMRAI::hier::BoxLevel Class Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.7 -->
<div class="tabs">
  <ul>
    <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="namespaces.html"><span>Namespaces</span></a></li>
    <li id="current"><a href="annotated.html"><span>Classes</span></a></li>
    <li><a href="files.html"><span>Files</span></a></li>
    <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
  </ul></div>
<div class="tabs">
  <ul>
    <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
    <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
    <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
  </ul></div>
<div class="nav">
<a class="el" href="namespaceSAMRAI.html">SAMRAI</a>::<a class="el" href="namespaceSAMRAI_1_1hier.html">hier</a>::<a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a></div>
<h1>SAMRAI::hier::BoxLevel Class Reference</h1><!-- doxytag: class="SAMRAI::hier::BoxLevel" -->A distributed set of <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> objects which reside in the same index space.  
<a href="#_details">More...</a>
<p>
<code>#include &lt;source/SAMRAI/hier/BoxLevel.h&gt;</code>
<p>
<a href="classSAMRAI_1_1hier_1_1BoxLevel-members.html">List of all members.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Types</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#02c34699888ab34b06f59a210247bcb450fcdd33dde8ec1597aa318dcb384578">DISTRIBUTED</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#02c34699888ab34b06f59a210247bcb42dbf00b87512ae236e2dbde25acb952f">GLOBALIZED</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#02c34699888ab34b06f59a210247bcb4">ParallelState</a> { <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#02c34699888ab34b06f59a210247bcb450fcdd33dde8ec1597aa318dcb384578">DISTRIBUTED</a>, 
<a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#02c34699888ab34b06f59a210247bcb42dbf00b87512ae236e2dbde25acb952f">GLOBALIZED</a>
 }</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Names of parallel states.  <a href="classSAMRAI_1_1hier_1_1BoxLevel.html#02c34699888ab34b06f59a210247bcb4">More...</a><br></td></tr>
<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#35b7fce14d4b31de23aa5d5bdf1a472e">BoxLevel</a> (const <a class="el" href="classSAMRAI_1_1tbox_1_1Dimension.html">tbox::Dimension</a> &amp;dim, <a class="el" href="classSAMRAI_1_1tbox_1_1Database.html">tbox::Database</a> &amp;restart_db, const boost::shared_ptr&lt; const <a class="el" href="classSAMRAI_1_1hier_1_1BaseGridGeometry.html">BaseGridGeometry</a> &gt; &amp;grid_geom)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Construct a <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a> which will be initialized from the supplied restart database.  <a href="#35b7fce14d4b31de23aa5d5bdf1a472e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#b8771dd90200a99a9e60cb6b356fcecf">BoxLevel</a> (const <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a> &amp;rhs)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copy constructor.  <a href="#b8771dd90200a99a9e60cb6b356fcecf"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#f19ca6a464561b4f23133b91d77d4470">BoxLevel</a> (const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;ratio, const boost::shared_ptr&lt; const <a class="el" href="classSAMRAI_1_1hier_1_1BaseGridGeometry.html">BaseGridGeometry</a> &gt; &amp;grid_geom, const <a class="el" href="classSAMRAI_1_1tbox_1_1SAMRAI__MPI.html">tbox::SAMRAI_MPI</a> &amp;mpi=tbox::SAMRAI_MPI::getSAMRAIWorld(), const <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#02c34699888ab34b06f59a210247bcb4">ParallelState</a> parallel_state=DISTRIBUTED)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Constructs an empty, initialized object.  <a href="#f19ca6a464561b4f23133b91d77d4470"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#4fc90e22dd04d5408a1f52ecb1ac8d60">BoxLevel</a> (const <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a> &amp;boxes, const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;ratio, const boost::shared_ptr&lt; const <a class="el" href="classSAMRAI_1_1hier_1_1BaseGridGeometry.html">BaseGridGeometry</a> &gt; &amp;grid_geom, const <a class="el" href="classSAMRAI_1_1tbox_1_1SAMRAI__MPI.html">tbox::SAMRAI_MPI</a> &amp;mpi=tbox::SAMRAI_MPI::getSAMRAIWorld(), const <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#02c34699888ab34b06f59a210247bcb4">ParallelState</a> parallel_state=DISTRIBUTED)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Constructs a populated object.  <a href="#4fc90e22dd04d5408a1f52ecb1ac8d60"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#962662fdff601ac5bc5fe60440c67d83">~BoxLevel</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Destructor.  <a href="#962662fdff601ac5bc5fe60440c67d83"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#13c61b0dbe112df0eca5960e378f35c5">operator=</a> (const <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a> &amp;rhs)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Assignment operator duplicates all internal data, including parallel mode.  <a href="#13c61b0dbe112df0eca5960e378f35c5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#ab19edd439fc4c1124ca533ad1146381">operator==</a> (const <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a> &amp;rhs) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Equality comparison.  <a href="#ab19edd439fc4c1124ca533ad1146381"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#c944ca2251fa1c7ac06c5570919ae734">operator!=</a> (const <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a> &amp;rhs) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Inequality comparison.  <a href="#c944ca2251fa1c7ac06c5570919ae734"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#f26bd3d728ba0f8094ee6b9acb593040">invalidateGlobalData</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets d_global_data_up_to_date to false. Must be called after calls to addBox or eraseBox.  <a href="#f26bd3d728ba0f8094ee6b9acb593040"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#8ce8fadb18fcfcdd48f1b373a1b979a8">clearPersistentOverlapConnectors</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Deallocate persistent overlap Connectors, if there are any.  <a href="#8ce8fadb18fcfcdd48f1b373a1b979a8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">const <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">Connector</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#d4ef30985671aaeac06be82bf7a238cb">findConnector</a> (const <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a> &amp;head, const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;min_connector_width, <a class="el" href="namespaceSAMRAI_1_1hier.html#256cef944748f7494c84017f5829101a">ConnectorNotFoundAction</a> not_found_action, bool exact_width_only=false) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Find an overlap <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">Connector</a> with the given head and minimum <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">Connector</a> width. If the specified <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">Connector</a> is not found, take the specified action.  <a href="#d4ef30985671aaeac06be82bf7a238cb"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">const <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">Connector</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#9ef122b8e4b1c02fa4850a6a81976110">findConnectorWithTranspose</a> (const <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a> &amp;head, const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;min_connector_width, const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;transpose_min_connector_width, <a class="el" href="namespaceSAMRAI_1_1hier.html#256cef944748f7494c84017f5829101a">ConnectorNotFoundAction</a> not_found_action, bool exact_width_only=false) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Find an overlap <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">Connector</a> with its transpose with the given head and minimum <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">Connector</a> widths. If the specified <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">Connector</a> is not found, take the specified action.  <a href="#9ef122b8e4b1c02fa4850a6a81976110"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">const <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">Connector</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#02aa235c3d2e5b9700a81e6853294fb7">createConnector</a> (const <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a> &amp;head, const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;connector_width) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create an overlap <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">Connector</a>, computing relationships by globalizing data.  <a href="#02aa235c3d2e5b9700a81e6853294fb7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">const <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">Connector</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#85bf92f1e262d7e182442aa09316640d">createConnectorWithTranspose</a> (const <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a> &amp;head, const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;connector_width, const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;transpose_connector_width) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create an overlap <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">Connector</a> with its transpose, computing relationships by globalizing data.  <a href="#85bf92f1e262d7e182442aa09316640d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#6caf4ac1f3c3b137a4bc890e3680c710">cacheConnector</a> (boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">Connector</a> &gt; &amp;connector) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Cache the supplied overlap <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">Connector</a> and its transpose if it exists.  <a href="#6caf4ac1f3c3b137a4bc890e3680c710"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#5843797f8b24c016bb92eb4b963f65ac">hasConnector</a> (const <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a> &amp;head, const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;min_connector_width, bool exact_width_only=false) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns whether the object has overlap Connectors with the given head and minimum <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">Connector</a> width.  <a href="#5843797f8b24c016bb92eb4b963f65ac"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevelHandle.html">BoxLevelHandle</a> &gt; &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#d28ae9914fffcd6712061af51e0fbfef">getBoxLevelHandle</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the handle with which Connectors reference the <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a> instead of referencing the <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a> itself. Not for general use.  <a href="#d28ae9914fffcd6712061af51e0fbfef"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#dd9723ad7a88b27b00f7a691d6eb2e0c">lock</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Effectively makes a non-const <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a> const. Prevents any non-const method from executing.  <a href="#dd9723ad7a88b27b00f7a691d6eb2e0c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#8f53858f6a358760477cbf8f42615b1c">locked</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns true if the <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a> is locked.  <a href="#8f53858f6a358760477cbf8f42615b1c"></a><br></td></tr>
<tr><td colspan="2"><div class="groupHeader">Initialization and clearing methods</div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#f3867518e8cca269d54e4b04d9622781">initialize</a> (const <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a> &amp;boxes, const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;ratio, const boost::shared_ptr&lt; const <a class="el" href="classSAMRAI_1_1hier_1_1BaseGridGeometry.html">BaseGridGeometry</a> &gt; &amp;grid_geom, const <a class="el" href="classSAMRAI_1_1tbox_1_1SAMRAI__MPI.html">tbox::SAMRAI_MPI</a> &amp;mpi=tbox::SAMRAI_MPI::getSAMRAIWorld(), const <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#02c34699888ab34b06f59a210247bcb4">ParallelState</a> parallel_state=DISTRIBUTED)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Initialize the <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a>.  <a href="#f3867518e8cca269d54e4b04d9622781"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#b1fd7baf5161fcdbbb830480f3f77293">swapInitialize</a> (<a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a> &amp;boxes, const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;ratio, const boost::shared_ptr&lt; const <a class="el" href="classSAMRAI_1_1hier_1_1BaseGridGeometry.html">BaseGridGeometry</a> &gt; &amp;grid_geom, const <a class="el" href="classSAMRAI_1_1tbox_1_1SAMRAI__MPI.html">tbox::SAMRAI_MPI</a> &amp;mpi=tbox::SAMRAI_MPI::getSAMRAIWorld(), const <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#02c34699888ab34b06f59a210247bcb4">ParallelState</a> parallel_state=DISTRIBUTED)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Initialize the <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a>.  <a href="#b1fd7baf5161fcdbbb830480f3f77293"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#d1993c509749c5b3e92c0c534a51e9fd">finalize</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Removes non-local boxes; computes bounding box, local number of boxes, local number of cells, max/min box size. To be called after all Boxes in a <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a> have been added to indicate that the <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a> is fully defined and ready to be used.  <a href="#d1993c509749c5b3e92c0c534a51e9fd"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#b5f4c8b090dbff0226e778e316b21920">isInitialized</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns True if the object has been initialized.  <a href="#b5f4c8b090dbff0226e778e316b21920"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#2b2aeafd75c199736c5e2ed21dc015b3">removePeriodicImageBoxes</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Remove all the periodic image boxes in the <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a>.  <a href="#2b2aeafd75c199736c5e2ed21dc015b3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#d1e2b6cbb81383c7661222048edd103c">clear</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Clear the internal state of the <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a>.  <a href="#d1e2b6cbb81383c7661222048edd103c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#a94cf056421d4661cb39f485dd236ba3">clearForBoxChanges</a> (bool isInvalid=true)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Clear the globalized version and the persistent overlap connectors for data consistency.  <a href="#a94cf056421d4661cb39f485dd236ba3"></a><br></td></tr>
<tr><td colspan="2"><div class="groupHeader">Parallelism</div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#68a7c6544286b59ab1508695cadc0c99">setParallelState</a> (const <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#02c34699888ab34b06f59a210247bcb4">ParallelState</a> parallel_state)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the parallel state.  <a href="#68a7c6544286b59ab1508695cadc0c99"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#02c34699888ab34b06f59a210247bcb4">ParallelState</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#e0f03563c8ba07e61c0262ebac27b6c2">getParallelState</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the ParallelState of the object.  <a href="#e0f03563c8ba07e61c0262ebac27b6c2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#88d752dca7dd51b8c1b0b0aa27c3d64e">cacheGlobalReducedData</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">If global reduced data (global <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> count, global cell count and global bounding box) have not been updated, compute and cache them (communication required).  <a href="#88d752dca7dd51b8c1b0b0aa27c3d64e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">const <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#257e30e9541d393912b74e66e3f1393d">getGlobalizedVersion</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the globalized version of the <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a>, creating it if needed.  <a href="#257e30e9541d393912b74e66e3f1393d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#0394ad7edaca17db2b72deefec2ecf3d">deallocateGlobalizedVersion</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Deallocate the internal globalized version of the <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a>, if there is any.  <a href="#0394ad7edaca17db2b72deefec2ecf3d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">const <a class="el" href="classSAMRAI_1_1tbox_1_1SAMRAI__MPI.html">tbox::SAMRAI_MPI</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#a56ee65e5e67d58f580b4a6a700c431f">getMPI</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the SAMRAI_MPI communicator over which the Boxes are distributed.  <a href="#a56ee65e5e67d58f580b4a6a700c431f"></a><br></td></tr>
<tr><td colspan="2"><div class="groupHeader">Accessors</div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">const <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#1e75df2ef751e7ed7f42c9e9a0991fa3">getBoxes</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the container of local Boxes.  <a href="#1e75df2ef751e7ed7f42c9e9a0991fa3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">const <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#fe03004a023ac5e76e01aef59fd6a612">getGlobalBoxes</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the container of global Boxes.  <a href="#fe03004a023ac5e76e01aef59fd6a612"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#621aa4df7351bf32b53dcc2258890415">getGlobalBoxes</a> (<a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a> &amp;global_boxes) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Fill the container with the global Boxes.  <a href="#621aa4df7351bf32b53dcc2258890415"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classSAMRAI_1_1hier_1_1LocalId.html">LocalId</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#153e6634835c71dcb5643609112995e6">getFirstLocalId</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the first <a class="el" href="classSAMRAI_1_1hier_1_1LocalId.html">LocalId</a>, or one with a value of -1 if no local <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> exists.  <a href="#153e6634835c71dcb5643609112995e6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classSAMRAI_1_1hier_1_1LocalId.html">LocalId</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#ba0e4564fd0ccd65a4e91c0326b38789">getLastLocalId</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the last <a class="el" href="classSAMRAI_1_1hier_1_1LocalId.html">LocalId</a>, or one with a value of -1 if no local <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> exists.  <a href="#ba0e4564fd0ccd65a4e91c0326b38789"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#769ce9dbc1523384d0092a33aa0e5dbf">getRefinementRatio</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get const access to BoxLevel's refinement ratio (with respect to a reference level).  <a href="#769ce9dbc1523384d0092a33aa0e5dbf"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#75baa526ecb8ca03a4f9520172ae8904">getLocalNumberOfBoxes</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return local number of boxes.  <a href="#75baa526ecb8ca03a4f9520172ae8904"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#e17e88ee3daf8c90f63eb69d75fd9e5a">getLocalNumberOfBoxes</a> (int rank) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return number of boxes local to the given rank.  <a href="#e17e88ee3daf8c90f63eb69d75fd9e5a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#d4838ed2fd92a444d15c5b01e069a898">getGlobalNumberOfBoxes</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return global number of Boxes.  <a href="#d4838ed2fd92a444d15c5b01e069a898"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#799ad52b977646d3c095c25463d4d15b">getMaxNumberOfBoxes</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return maximum number of Boxes over all processes.  <a href="#799ad52b977646d3c095c25463d4d15b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#922bbd77b18facc9efe362166f9f0a1c">getMinNumberOfBoxes</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return maximum number of Boxes over all processes.  <a href="#922bbd77b18facc9efe362166f9f0a1c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#c5422e0dc4aa9d6d58106895ff02bac4">getLocalNumberOfCells</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return local number of cells.  <a href="#c5422e0dc4aa9d6d58106895ff02bac4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#9393d4518cb5fab157e054d070a9676b">getMaxNumberOfCells</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return maximum number of cells over all processes.  <a href="#9393d4518cb5fab157e054d070a9676b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#c5c5540240eaaca51f895c58c04c68a5">getMinNumberOfCells</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return maximum number of cells over all processes.  <a href="#c5c5540240eaaca51f895c58c04c68a5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#c163b80b716511ad09233ffb5576c87e">getLocalNumberOfCells</a> (int rank) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return number of cells local to the given rank.  <a href="#c163b80b716511ad09233ffb5576c87e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#4cbe06570b6e5bef932cf7f4a463f53d">getGlobalNumberOfCells</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return global number of cells.  <a href="#4cbe06570b6e5bef932cf7f4a463f53d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#a0e3992e8720b4df0bdbbca45546fc1f">getLocalBoundingBox</a> (int block_number) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return bounding box for local Boxes in a block.  <a href="#a0e3992e8720b4df0bdbbca45546fc1f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#9deaa634cf3fe5ab246fe7aca0d70a43">getGlobalBoundingBox</a> (int block_number) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return bounding box for global Boxes in a block.  <a href="#9deaa634cf3fe5ab246fe7aca0d70a43"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#38cd4acb77caa36d41515252db0e1102">getLocalMaxBoxSize</a> (int block_number) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return size of the largest local <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> in a block.  <a href="#38cd4acb77caa36d41515252db0e1102"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#c1e3b956ec5dd8504d7375960545755c">getLocalMinBoxSize</a> (int block_number) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return size of the smallest local <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> in a block.  <a href="#c1e3b956ec5dd8504d7375960545755c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#27a9f68acbf0a41fae9538cfa249406a">getGlobalMaxBoxSize</a> (int block_number) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return size of the largest <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> globally in a block.  <a href="#27a9f68acbf0a41fae9538cfa249406a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#38e7e581ec5d2ceb7f0130eca279a84f">getGlobalMinBoxSize</a> (int block_number) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return size of the smallest <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> globally in a block.  <a href="#38e7e581ec5d2ceb7f0130eca279a84f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">const <a class="el" href="classSAMRAI_1_1tbox_1_1Dimension.html">tbox::Dimension</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#9a051730fadf4671bf844259fe45fd39">getDim</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the dimension of this object.  <a href="#9a051730fadf4671bf844259fe45fd39"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">const boost::shared_ptr&lt; const <br>
<a class="el" href="classSAMRAI_1_1hier_1_1BaseGridGeometry.html">BaseGridGeometry</a> &gt; &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#ec78d23ef813cea9c1f08b30d6cec25f">getGridGeometry</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the grid geometry associated with this object.  <a href="#ec78d23ef813cea9c1f08b30d6cec25f"></a><br></td></tr>
<tr><td colspan="2"><div class="groupHeader">Methods to modify all Boxes.</div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#f9d572999cb352e26876d5641c89f28c">refineBoxes</a> (<a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a> &amp;finer, const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;ratio, const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;final_ratio) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Refine all Boxes of this <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a> by ratio placing result into finer making finer's ratio final_ratio.  <a href="#f9d572999cb352e26876d5641c89f28c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#6d08a9ac95f9c25ffb319bbc0e79f7b1">coarsenBoxes</a> (<a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a> &amp;coarser, const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;ratio, const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;final_ratio) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Coarsen all Boxes of this <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a> by ratio placing result into coarser making coarser's ratio final_ratio.  <a href="#6d08a9ac95f9c25ffb319bbc0e79f7b1"></a><br></td></tr>
<tr><td colspan="2"><div class="groupHeader">Individual Box methods.</div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer_1_1BoxContainerConstIterator.html">BoxContainer::const_iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#7f03d7672157b32ea927b73751663872">addBox</a> (const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> &amp;box, const <a class="el" href="classSAMRAI_1_1hier_1_1BlockId.html">BlockId</a> &amp;block_id)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create new local <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> from given <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> and add it to this level.  <a href="#7f03d7672157b32ea927b73751663872"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#7a80e5adb2b547f075125db37be16ff7">addBox</a> (const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> &amp;box)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Add a <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> to this level.  <a href="#7a80e5adb2b547f075125db37be16ff7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#7192f8a642329533e870d08ac4affb08">addBoxWithoutUpdate</a> (const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> &amp;box)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Add a <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> to this level without updating summary data such as local number of boxes/cells, bounding box, max/min box size. Meant to be used during the construction of a <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a> as Boxes belonging to the level are found. <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#d1993c509749c5b3e92c0c534a51e9fd">finalize()</a> should be called at the end of construction making use of addBoxWithoutUpdate.  <a href="#7192f8a642329533e870d08ac4affb08"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#1efaddb0a58895344bfdc03003e1aa9d">addPeriodicBox</a> (const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> &amp;existing_box, const <a class="el" href="classSAMRAI_1_1hier_1_1PeriodicId.html">PeriodicId</a> &amp;shift_number)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Insert given periodic image of an existing <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a>.  <a href="#1efaddb0a58895344bfdc03003e1aa9d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#960befb3bc83403345c75c7ed6a177e8">eraseBox</a> (<a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer_1_1BoxContainerIterator.html">BoxContainer::iterator</a> &amp;ibox)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Erase the existing <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> specified by its iterator.  <a href="#960befb3bc83403345c75c7ed6a177e8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#ac786eaec7c2fa5256f41a685c945257">eraseBox</a> (const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> &amp;box)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Erase the <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> matching the one given.  <a href="#ac786eaec7c2fa5256f41a685c945257"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#0ee46cb63c7d8409c8688f3700605a98">eraseBoxWithoutUpdate</a> (const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> &amp;box)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Erases the <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> matching the supplied <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> from this level without updating summary data such as local number of boxes/cells, bounding box, max/min box size. Meant to be used during the construction of a <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a> as Boxes not belonging to the level are found. <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#d1993c509749c5b3e92c0c534a51e9fd">finalize()</a> should be called at the end of construction making use of eraseBoxWithoutUpdate.  <a href="#0ee46cb63c7d8409c8688f3700605a98"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer_1_1BoxContainerConstIterator.html">BoxContainer::const_iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#ae14445c8c9e8c06bc7d3132ee490555">getBox</a> (const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> &amp;box) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Find the <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> matching the one given.  <a href="#ae14445c8c9e8c06bc7d3132ee490555"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer_1_1BoxContainerConstIterator.html">BoxContainer::const_iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#2fc9a3140f7ad64850ad6556d53223ec">getBox</a> (const <a class="el" href="classSAMRAI_1_1hier_1_1BoxId.html">BoxId</a> &amp;box_id) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Find the <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> specified by the given <a class="el" href="classSAMRAI_1_1hier_1_1BoxId.html">BoxId</a> and periodic shift.  <a href="#2fc9a3140f7ad64850ad6556d53223ec"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer_1_1BoxContainerConstIterator.html">BoxContainer::const_iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#eb1f97fa84af6ba5c273c64c0ea0c80c">getBoxStrict</a> (const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> &amp;box) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Find the <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> matching the one given.  <a href="#eb1f97fa84af6ba5c273c64c0ea0c80c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer_1_1BoxContainerConstIterator.html">BoxContainer::const_iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#5d59700b00e6da268bf003a842f626ee">getBoxStrict</a> (const <a class="el" href="classSAMRAI_1_1hier_1_1BoxId.html">BoxId</a> &amp;box_id) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Find the <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> specified by the given <a class="el" href="classSAMRAI_1_1hier_1_1BoxId.html">BoxId</a>.  <a href="#5d59700b00e6da268bf003a842f626ee"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#c33526f84722654e4eec9ef11093aaac">getSpatiallyEqualBox</a> (const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> &amp;box_to_match, const <a class="el" href="classSAMRAI_1_1hier_1_1BlockId.html">BlockId</a> &amp;block_id, <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> &amp;matching_box) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Find the <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> with the given <a class="el" href="classSAMRAI_1_1hier_1_1BlockId.html">BlockId</a> which is spatially equal to the supplied <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a>.  <a href="#c33526f84722654e4eec9ef11093aaac"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#a36386f372e60084d09119c9e8c36718">hasBox</a> (const <a class="el" href="classSAMRAI_1_1hier_1_1BoxId.html">BoxId</a> &amp;box_id) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns true when the object has a <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> specified by the <a class="el" href="classSAMRAI_1_1hier_1_1BoxId.html">BoxId</a>.  <a href="#a36386f372e60084d09119c9e8c36718"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#1d8a2324f2425898efad09a23f1f61f6">hasBox</a> (const <a class="el" href="classSAMRAI_1_1hier_1_1GlobalId.html">GlobalId</a> &amp;global_id, const <a class="el" href="classSAMRAI_1_1hier_1_1PeriodicId.html">PeriodicId</a> &amp;periodic_id) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns true when the object has a <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> consistent with all of the arguments.  <a href="#1d8a2324f2425898efad09a23f1f61f6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#3b57ea9786676c090d5619abde08bd63">hasBox</a> (const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> &amp;box) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns true when this <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a> has a <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> matching the <a class="el" href="classSAMRAI_1_1hier_1_1BoxId.html">BoxId</a> of the given box.  <a href="#3b57ea9786676c090d5619abde08bd63"></a><br></td></tr>
<tr><td colspan="2"><div class="groupHeader">IO support.</div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#8ec0ee23695893a76962ad8a8922f2a1">putToRestart</a> (const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Database.html">tbox::Database</a> &gt; &amp;restart_db) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Write the <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a> to a restart database.  <a href="#8ec0ee23695893a76962ad8a8922f2a1"></a><br></td></tr>
<tr><td colspan="2"><div class="groupHeader">Methods for outputs, error checking and debugging.</div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#00c11404f06b3a72323cb3fc5d650309">recursivePrint</a> (std::ostream &amp;os, const std::string &amp;border, int detail_depth=2) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Print <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> info from this level.  <a href="#00c11404f06b3a72323cb3fc5d650309"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel_1_1Outputter.html">Outputter</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#ef7ffb368ef636b78732ba7b64c51277">format</a> (const std::string &amp;border=std::string(), int detail_depth=2) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return a object that can format the <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a> for inserting into output streams.  <a href="#ef7ffb368ef636b78732ba7b64c51277"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel_1_1Outputter.html">Outputter</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#0358ed57086330055c464956136feac8">formatStatistics</a> (const std::string &amp;border=std::string()) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return a object that can format the <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a> for inserting its global statistics into output streams.  <a href="#0358ed57086330055c464956136feac8"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Static Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#9eebd53c534a0b42c59cf9cb08f2777e">swap</a> (<a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a> &amp;level_a, <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a> &amp;level_b)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Swap the contents of two <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a> objects.  <a href="#9eebd53c534a0b42c59cf9cb08f2777e"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Friends</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#e17fc1942f6de54c13321a9481366cd1">PersistentOverlapConnectors</a></td></tr>

<tr><td colspan="2"><br><h2>Classes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel_1_1Outputter.html">Outputter</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A class for outputting <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a>.  <a href="classSAMRAI_1_1hier_1_1BoxLevel_1_1Outputter.html#_details">More...</a><br></td></tr>
</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
A distributed set of <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> objects which reside in the same index space. 
<p>
TODO: Are we eliminating DLBG terminology?<p>
This class is a part of the distributed layered box graph (DLBG) for managing SAMR meshes in parallel. A <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a> is a set of boxes in the same index space. Relationships (e.g., neighbor adjacency) among boxes is contained in a <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">Connector</a> object. Also, each <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a> has an refinement ratio vector describing the relationship of the index space to that of a reference level in a patch hierarchy (typically the coarsest level or level zero).<p>
Like a <a class="el" href="classSAMRAI_1_1hier_1_1PatchLevel.html">PatchLevel</a>, a <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a> is a parallel object. The Boxes of a <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a> may be distributed across all the processors in an MPI communicator and can be in one of two parallel states:<p>
<ul>
<li><b>DISTRIBUTED:</b> Each MPI process knows only the Boxes in the set that are "owned" by that process. This is analogous to a <a class="el" href="classSAMRAI_1_1hier_1_1PatchLevel.html">PatchLevel</a> which owns only the Patches that reside on a process.</li></ul>
<p>
<ul>
<li><b>GLOBALIZED:</b> All processes know all Boxes in the set. This is analogous to <a class="el" href="classSAMRAI_1_1hier_1_1PatchLevel.html">PatchLevel</a> <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a> state when it is globalized (<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classSAMRAI_1_1hier_1_1PatchLevel.html#d425bff9332a3eb2bbfb7509ccf13dc9">PatchLevel::getBoxes()</a>).</dd></dl>
<dl compact><dt><b>Performance notes</b></dt><dd><ul>
<li>
The parallel state is changed by calling <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#68a7c6544286b59ab1508695cadc0c99">setParallelState()</a>. Going from DISTRIBUTED to GLOBALIZED state is an expensive operation requiring all-to-all communication. Using this state can incur a significant performance penalty.<p>
</li>
<li>
The GLOBALIZED state requires more memory.<p>
</li>
<li>
Transitioning from GLOBALIZED state to DISTRIBUTED state is cheap. </li>
</ul>
</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>The general attributes of a <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a> are <ul>
<li>
the set of <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> objects with unique BoxIds, </li>
<li>
the refinement ratio defining their index space, and </li>
<li>
the parallel state. </li>
</ul>
</dd></dl>
<a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> object uniqueness is based on the <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> equality operator, which compares owner MPI ranks and local indices. Therefore, a valid <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a> does not contain two Boxes with the same owner and index. </li></ul>

<p>
<hr><h2>Member Enumeration Documentation</h2>
<a class="anchor" name="02c34699888ab34b06f59a210247bcb4"></a><!-- doxytag: member="SAMRAI::hier::BoxLevel::ParallelState" ref="02c34699888ab34b06f59a210247bcb4" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#02c34699888ab34b06f59a210247bcb4">SAMRAI::hier::BoxLevel::ParallelState</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Names of parallel states. 
<p>
<dl compact><dt><b>Enumerator: </b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" name="02c34699888ab34b06f59a210247bcb450fcdd33dde8ec1597aa318dcb384578"></a><!-- doxytag: member="DISTRIBUTED" ref="02c34699888ab34b06f59a210247bcb450fcdd33dde8ec1597aa318dcb384578" args="" -->DISTRIBUTED</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" name="02c34699888ab34b06f59a210247bcb42dbf00b87512ae236e2dbde25acb952f"></a><!-- doxytag: member="GLOBALIZED" ref="02c34699888ab34b06f59a210247bcb42dbf00b87512ae236e2dbde25acb952f" args="" -->GLOBALIZED</em>&nbsp;</td><td>
</td></tr>
</table>
</dl>

</div>
</div><p>
<hr><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" name="35b7fce14d4b31de23aa5d5bdf1a472e"></a><!-- doxytag: member="SAMRAI::hier::BoxLevel::BoxLevel" ref="35b7fce14d4b31de23aa5d5bdf1a472e" args="(const tbox::Dimension &amp;dim, tbox::Database &amp;restart_db, const boost::shared_ptr&lt; const BaseGridGeometry &gt; &amp;grid_geom)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SAMRAI::hier::BoxLevel::BoxLevel           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1tbox_1_1Dimension.html">tbox::Dimension</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>dim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1tbox_1_1Database.html">tbox::Database</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>restart_db</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const boost::shared_ptr&lt; const <a class="el" href="classSAMRAI_1_1hier_1_1BaseGridGeometry.html">BaseGridGeometry</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>grid_geom</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Construct a <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a> which will be initialized from the supplied restart database. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>dim</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>restart_db</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>grid_geom</em>&nbsp;</td><td></td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="b8771dd90200a99a9e60cb6b356fcecf"></a><!-- doxytag: member="SAMRAI::hier::BoxLevel::BoxLevel" ref="b8771dd90200a99a9e60cb6b356fcecf" args="(const BoxLevel &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SAMRAI::hier::BoxLevel::BoxLevel           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Copy constructor. 
<p>
New object has the same parallel state as original.<p>
Persistent Connectors are not duplicated. This decision was based on expected usage, which is that copies are either for short term usage or meant to be changed in some way and will invalidate Connectors.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>rhs</em>&nbsp;</td><td></td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="f19ca6a464561b4f23133b91d77d4470"></a><!-- doxytag: member="SAMRAI::hier::BoxLevel::BoxLevel" ref="f19ca6a464561b4f23133b91d77d4470" args="(const IntVector &amp;ratio, const boost::shared_ptr&lt; const BaseGridGeometry &gt; &amp;grid_geom, const tbox::SAMRAI_MPI &amp;mpi=tbox::SAMRAI_MPI::getSAMRAIWorld(), const ParallelState parallel_state=DISTRIBUTED)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SAMRAI::hier::BoxLevel::BoxLevel           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>ratio</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const boost::shared_ptr&lt; const <a class="el" href="classSAMRAI_1_1hier_1_1BaseGridGeometry.html">BaseGridGeometry</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>grid_geom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1tbox_1_1SAMRAI__MPI.html">tbox::SAMRAI_MPI</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>mpi</em> = <code>tbox::SAMRAI_MPI::getSAMRAIWorld()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#02c34699888ab34b06f59a210247bcb4">ParallelState</a>&nbsp;</td>
          <td class="paramname"> <em>parallel_state</em> = <code>DISTRIBUTED</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Constructs an empty, initialized object. 
<p>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#7f03d7672157b32ea927b73751663872">addBox()</a> <p>
<a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#f3867518e8cca269d54e4b04d9622781">initialize()</a></dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>ratio</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>grid_geom</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>mpi</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>parallel_state</em>&nbsp;</td><td></td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="4fc90e22dd04d5408a1f52ecb1ac8d60"></a><!-- doxytag: member="SAMRAI::hier::BoxLevel::BoxLevel" ref="4fc90e22dd04d5408a1f52ecb1ac8d60" args="(const BoxContainer &amp;boxes, const IntVector &amp;ratio, const boost::shared_ptr&lt; const BaseGridGeometry &gt; &amp;grid_geom, const tbox::SAMRAI_MPI &amp;mpi=tbox::SAMRAI_MPI::getSAMRAIWorld(), const ParallelState parallel_state=DISTRIBUTED)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SAMRAI::hier::BoxLevel::BoxLevel           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>boxes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>ratio</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const boost::shared_ptr&lt; const <a class="el" href="classSAMRAI_1_1hier_1_1BaseGridGeometry.html">BaseGridGeometry</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>grid_geom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1tbox_1_1SAMRAI__MPI.html">tbox::SAMRAI_MPI</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>mpi</em> = <code>tbox::SAMRAI_MPI::getSAMRAIWorld()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#02c34699888ab34b06f59a210247bcb4">ParallelState</a>&nbsp;</td>
          <td class="paramname"> <em>parallel_state</em> = <code>DISTRIBUTED</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Constructs a populated object. 
<p>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#7f03d7672157b32ea927b73751663872">addBox()</a> <p>
<a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#f3867518e8cca269d54e4b04d9622781">initialize()</a></dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>boxes</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>ratio</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>grid_geom</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>mpi</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>parallel_state</em>&nbsp;</td><td></td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="962662fdff601ac5bc5fe60440c67d83"></a><!-- doxytag: member="SAMRAI::hier::BoxLevel::~BoxLevel" ref="962662fdff601ac5bc5fe60440c67d83" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SAMRAI::hier::BoxLevel::~BoxLevel           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Destructor. 
<p>
Deallocate internal data. 
</div>
</div><p>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="f3867518e8cca269d54e4b04d9622781"></a><!-- doxytag: member="SAMRAI::hier::BoxLevel::initialize" ref="f3867518e8cca269d54e4b04d9622781" args="(const BoxContainer &amp;boxes, const IntVector &amp;ratio, const boost::shared_ptr&lt; const BaseGridGeometry &gt; &amp;grid_geom, const tbox::SAMRAI_MPI &amp;mpi=tbox::SAMRAI_MPI::getSAMRAIWorld(), const ParallelState parallel_state=DISTRIBUTED)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::hier::BoxLevel::initialize           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>boxes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>ratio</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const boost::shared_ptr&lt; const <a class="el" href="classSAMRAI_1_1hier_1_1BaseGridGeometry.html">BaseGridGeometry</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>grid_geom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1tbox_1_1SAMRAI__MPI.html">tbox::SAMRAI_MPI</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>mpi</em> = <code>tbox::SAMRAI_MPI::getSAMRAIWorld()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#02c34699888ab34b06f59a210247bcb4">ParallelState</a>&nbsp;</td>
          <td class="paramname"> <em>parallel_state</em> = <code>DISTRIBUTED</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Initialize the <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a>. 
<p>
The content and state of the object before calling this function is discarded.<p>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#7f03d7672157b32ea927b73751663872">addBox()</a> <p>
initialize(const BoxContainer&amp;, const IntVector&amp;, const tbox::SAMRAI_MPI&amp;, const ParallelState)</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>boxes</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>ratio</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>grid_geom</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>mpi</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>parallel_state</em>&nbsp;</td><td></td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="b1fd7baf5161fcdbbb830480f3f77293"></a><!-- doxytag: member="SAMRAI::hier::BoxLevel::swapInitialize" ref="b1fd7baf5161fcdbbb830480f3f77293" args="(BoxContainer &amp;boxes, const IntVector &amp;ratio, const boost::shared_ptr&lt; const BaseGridGeometry &gt; &amp;grid_geom, const tbox::SAMRAI_MPI &amp;mpi=tbox::SAMRAI_MPI::getSAMRAIWorld(), const ParallelState parallel_state=DISTRIBUTED)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::hier::BoxLevel::swapInitialize           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>boxes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>ratio</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const boost::shared_ptr&lt; const <a class="el" href="classSAMRAI_1_1hier_1_1BaseGridGeometry.html">BaseGridGeometry</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>grid_geom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1tbox_1_1SAMRAI__MPI.html">tbox::SAMRAI_MPI</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>mpi</em> = <code>tbox::SAMRAI_MPI::getSAMRAIWorld()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#02c34699888ab34b06f59a210247bcb4">ParallelState</a>&nbsp;</td>
          <td class="paramname"> <em>parallel_state</em> = <code>DISTRIBUTED</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Initialize the <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a>. 
<p>
Similar to initialize(const BoxContainer&amp;, const IntVector&amp;, const tbox::SAMRAI_MPI&amp;, const ParallelState), except that the <code>boxes</code> are mutable.<p>
The state of the object before calling this function is discarded. The <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> content before calling this function is returned via the <code>boxes</code> argument.<p>
<dl compact><dt><b>See also:</b></dt><dd>initializePrivate()</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>boxes</em>&nbsp;</td><td>On input, this should contain the Boxes to place in the <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a>. On output, it contains the Boxes that were in the <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a> before the call.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>boxes</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>ratio</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>grid_geom</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>mpi</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>parallel_state</em>&nbsp;</td><td></td></tr>
  </table>
</dl>
<dl compact><dt><b>Precondition:</b></dt><dd>&amp;boxes != &amp;<a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#1e75df2ef751e7ed7f42c9e9a0991fa3">getBoxes()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="d1993c509749c5b3e92c0c534a51e9fd"></a><!-- doxytag: member="SAMRAI::hier::BoxLevel::finalize" ref="d1993c509749c5b3e92c0c534a51e9fd" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::hier::BoxLevel::finalize           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Removes non-local boxes; computes bounding box, local number of boxes, local number of cells, max/min box size. To be called after all Boxes in a <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a> have been added to indicate that the <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a> is fully defined and ready to be used. 
<p>

</div>
</div><p>
<a class="anchor" name="b5f4c8b090dbff0226e778e316b21920"></a><!-- doxytag: member="SAMRAI::hier::BoxLevel::isInitialized" ref="b5f4c8b090dbff0226e778e316b21920" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SAMRAI::hier::BoxLevel::isInitialized           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns True if the object has been initialized. 
<p>

</div>
</div><p>
<a class="anchor" name="2b2aeafd75c199736c5e2ed21dc015b3"></a><!-- doxytag: member="SAMRAI::hier::BoxLevel::removePeriodicImageBoxes" ref="2b2aeafd75c199736c5e2ed21dc015b3" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::hier::BoxLevel::removePeriodicImageBoxes           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Remove all the periodic image boxes in the <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a>. 
<p>

</div>
</div><p>
<a class="anchor" name="d1e2b6cbb81383c7661222048edd103c"></a><!-- doxytag: member="SAMRAI::hier::BoxLevel::clear" ref="d1e2b6cbb81383c7661222048edd103c" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::hier::BoxLevel::clear           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Clear the internal state of the <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a>. 
<p>
The <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a> will be in an uninitialized state after a call to this method. 
</div>
</div><p>
<a class="anchor" name="a94cf056421d4661cb39f485dd236ba3"></a><!-- doxytag: member="SAMRAI::hier::BoxLevel::clearForBoxChanges" ref="a94cf056421d4661cb39f485dd236ba3" args="(bool isInvalid=true)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::hier::BoxLevel::clearForBoxChanges           </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>isInvalid</em> = <code>true</code>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Clear the globalized version and the persistent overlap connectors for data consistency. 
<p>
Most of the time, this method is automatically called by methods that know when some data is stale and needs to be cleared. For example, adding a box makes the global number of boxes stale. However, sometimes it is necessary to call this method manually. For example, when only some processes add boxes while others do not, resulting in some processes not knowing that the global number of boxes is inconsistent.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>isInvalid</em>&nbsp;</td><td>A flag indicating that boxes have been (or will be) removed, thus invalidating the handle. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="68a7c6544286b59ab1508695cadc0c99"></a><!-- doxytag: member="SAMRAI::hier::BoxLevel::setParallelState" ref="68a7c6544286b59ab1508695cadc0c99" args="(const ParallelState parallel_state)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::hier::BoxLevel::setParallelState           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#02c34699888ab34b06f59a210247bcb4">ParallelState</a>&nbsp;</td>
          <td class="paramname"> <em>parallel_state</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set the parallel state. 
<p>
This method is potentially expensive. Acquiring remote <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> information (when going to GLOBALIZED mode) triggers all-gather communication. More memory is required to store additional Boxes.<p>
Data not used by the new state gets deallocated.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>parallel_state</em>&nbsp;</td><td></td></tr>
  </table>
</dl>
<dl compact><dt><b>Precondition:</b></dt><dd><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#b5f4c8b090dbff0226e778e316b21920">isInitialized()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="e0f03563c8ba07e61c0262ebac27b6c2"></a><!-- doxytag: member="SAMRAI::hier::BoxLevel::getParallelState" ref="e0f03563c8ba07e61c0262ebac27b6c2" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#02c34699888ab34b06f59a210247bcb4">ParallelState</a> SAMRAI::hier::BoxLevel::getParallelState           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the ParallelState of the object. 
<p>

</div>
</div><p>
<a class="anchor" name="88d752dca7dd51b8c1b0b0aa27c3d64e"></a><!-- doxytag: member="SAMRAI::hier::BoxLevel::cacheGlobalReducedData" ref="88d752dca7dd51b8c1b0b0aa27c3d64e" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::hier::BoxLevel::cacheGlobalReducedData           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
If global reduced data (global <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> count, global cell count and global bounding box) have not been updated, compute and cache them (communication required). 
<p>
After this method is called, data requiring global reduction can be accessed without further communications, until the object changes.<p>
Sets d_global_data_up_to_date to true;<p>
<dl compact><dt><b>Precondition:</b></dt><dd><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#b5f4c8b090dbff0226e778e316b21920">isInitialized()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="257e30e9541d393912b74e66e3f1393d"></a><!-- doxytag: member="SAMRAI::hier::BoxLevel::getGlobalizedVersion" ref="257e30e9541d393912b74e66e3f1393d" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a> &amp; SAMRAI::hier::BoxLevel::getGlobalizedVersion           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return the globalized version of the <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a>, creating it if needed. 
<p>
If the <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a> is in globalized state, return <code>*this</code>. If not, create and cache a globalized version (if necessary) and return that.<p>
The cached version remains until it is removed by <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#0394ad7edaca17db2b72deefec2ecf3d">deallocateGlobalizedVersion()</a> or a method that can potentially change the Boxes is called. Note that globalizing and globalized data is not scalable. Use only when necessary.<p>
Obviously, when the globalized version must be created (when the <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a> is in DISTRIBUTED state and there is no cached version yet), all processes must make this call at the same point.<p>
<dl compact><dt><b>Precondition:</b></dt><dd><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#b5f4c8b090dbff0226e778e316b21920">isInitialized()</a></dd></dl>
<dl compact><dt><b>Postcondition:</b></dt><dd>d_globalized_version-&gt;<a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#e0f03563c8ba07e61c0262ebac27b6c2">getParallelState()</a> == GLOBALIZED </dd></dl>

</div>
</div><p>
<a class="anchor" name="0394ad7edaca17db2b72deefec2ecf3d"></a><!-- doxytag: member="SAMRAI::hier::BoxLevel::deallocateGlobalizedVersion" ref="0394ad7edaca17db2b72deefec2ecf3d" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::hier::BoxLevel::deallocateGlobalizedVersion           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Deallocate the internal globalized version of the <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a>, if there is any. 
<p>
<dl compact><dt><b>Precondition:</b></dt><dd>(d_globalized_version == 0) || (d_globalized_version-&gt;<a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#e0f03563c8ba07e61c0262ebac27b6c2">getParallelState()</a> == GLOBALIZED) </dd></dl>

</div>
</div><p>
<a class="anchor" name="a56ee65e5e67d58f580b4a6a700c431f"></a><!-- doxytag: member="SAMRAI::hier::BoxLevel::getMPI" ref="a56ee65e5e67d58f580b4a6a700c431f" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classSAMRAI_1_1tbox_1_1SAMRAI__MPI.html">tbox::SAMRAI_MPI</a>&amp; SAMRAI::hier::BoxLevel::getMPI           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the SAMRAI_MPI communicator over which the Boxes are distributed. 
<p>

</div>
</div><p>
<a class="anchor" name="13c61b0dbe112df0eca5960e378f35c5"></a><!-- doxytag: member="SAMRAI::hier::BoxLevel::operator=" ref="13c61b0dbe112df0eca5960e378f35c5" args="(const BoxLevel &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a> &amp; SAMRAI::hier::BoxLevel::operator=           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Assignment operator duplicates all internal data, including parallel mode. 
<p>
Assignment is a modifying operation, causing the <a class="el" href="classSAMRAI_1_1hier_1_1PersistentOverlapConnectors.html">PersistentOverlapConnectors</a> to be cleared.<p>
Persistent Connectors are not duplicated. This decision was based on expected usage, which is that copies are either for short term usage or meant to be changed in some way (thus invalidating current Connectors anyway).<p>
<dl compact><dt><b>See also:</b></dt><dd>getPersistentOverlapConnectors()</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>rhs</em>&nbsp;</td><td></td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="9eebd53c534a0b42c59cf9cb08f2777e"></a><!-- doxytag: member="SAMRAI::hier::BoxLevel::swap" ref="9eebd53c534a0b42c59cf9cb08f2777e" args="(BoxLevel &amp;level_a, BoxLevel &amp;level_b)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::hier::BoxLevel::swap           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>level_a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>level_b</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Swap the contents of two <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a> objects. 
<p>
Swapping is a modifying operation, so the <a class="el" href="classSAMRAI_1_1hier_1_1PersistentOverlapConnectors.html">PersistentOverlapConnectors</a> of the operands are cleared.<p>
Persistent Connectors are not swapped. This decision was based on expected usage, which is that copies are either for short term usage or meant to be changed in some way (thus invalidating current Connectors anyway).<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>level_a</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>level_b</em>&nbsp;</td><td></td></tr>
  </table>
</dl>
<dl compact><dt><b>Precondition:</b></dt><dd>(&amp;level_a == &amp;level_b) || !level_a.<a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#b5f4c8b090dbff0226e778e316b21920">isInitialized()</a> || !level_b.<a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#b5f4c8b090dbff0226e778e316b21920">isInitialized()</a> || (level_a.getDim() == level_b.getDim()) </dd></dl>

</div>
</div><p>
<a class="anchor" name="ab19edd439fc4c1124ca533ad1146381"></a><!-- doxytag: member="SAMRAI::hier::BoxLevel::operator==" ref="ab19edd439fc4c1124ca533ad1146381" args="(const BoxLevel &amp;rhs) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SAMRAI::hier::BoxLevel::operator==           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Equality comparison. 
<p>
All data required to initialize the object is compared, except for the parallel state. Thus equality here means just the local parts are equal. <b>BEWARE!</b> This means that one processor may see the equality differently from another.<p>
The cost for the comparison is on the order of the local <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> count. An object may be compared to itself, an efficient operation that always returns true.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>rhs</em>&nbsp;</td><td></td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="c944ca2251fa1c7ac06c5570919ae734"></a><!-- doxytag: member="SAMRAI::hier::BoxLevel::operator!=" ref="c944ca2251fa1c7ac06c5570919ae734" args="(const BoxLevel &amp;rhs) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SAMRAI::hier::BoxLevel::operator!=           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Inequality comparison. 
<p>
All data required to initialize the object is compared, except for the parallel state. Thus equality here means just the local parts are equal. <b>BEWARE!</b> This means that one processor may see the inequality differently from another.<p>
The cost for the comparison is on the order of the local <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> count. However, an object may be compared to itself, an efficient operation that always returns false.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>rhs</em>&nbsp;</td><td></td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="1e75df2ef751e7ed7f42c9e9a0991fa3"></a><!-- doxytag: member="SAMRAI::hier::BoxLevel::getBoxes" ref="1e75df2ef751e7ed7f42c9e9a0991fa3" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a>&amp; SAMRAI::hier::BoxLevel::getBoxes           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the container of local Boxes. 
<p>
<dl compact><dt><b>Important</b></dt><dd>The <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a> returned contains periodic image Boxes (if any). To iterate through real Boxes only, see <a class="el" href="classSAMRAI_1_1hier_1_1RealBoxConstIterator.html">RealBoxConstIterator</a>.</dd></dl>
You cannot directly modify the <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a> because it may invalidate other internal data. Use other methods for modifying the <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a>.<p>
<dl compact><dt><b>Note:</b></dt><dd>It is possible that one may wish to perform repeated searches on the Boxes in the <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a> returned by this method. As noted in BoxContainer's documentation, it may be advantageous to call the makeTree method on the <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a> in this case. If you do, remember that the GridGeometry passed to makeTree must be the GridGeometry held by this <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a>. Thus the proper use of makeTree with the result of a call to this method will look like: <div class="fragment"><pre class="fragment">    *    box_level.getBoxes().makeTree(box_level.getGridGeometry());
    * </pre></div></dd></dl>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#d4838ed2fd92a444d15c5b01e069a898">getGlobalNumberOfBoxes()</a> <p>
<a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#75baa526ecb8ca03a4f9520172ae8904">getLocalNumberOfBoxes()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="fe03004a023ac5e76e01aef59fd6a612"></a><!-- doxytag: member="SAMRAI::hier::BoxLevel::getGlobalBoxes" ref="fe03004a023ac5e76e01aef59fd6a612" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a>&amp; SAMRAI::hier::BoxLevel::getGlobalBoxes           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the container of global Boxes. 
<p>
<dl compact><dt><b>Note:</b></dt><dd>It is possible that one may wish to perform repeated searches on the Boxes in the <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a> returned by this method. As noted in BoxContainer's documentation, it may be advantageous to call the makeTree method on the <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a> in this case. If you do, remember that the GridGeometry passed to makeTree must be the GridGeometry held by this <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a>. Thus the proper use of makeTree with the result of a call to this method will look like: <div class="fragment"><pre class="fragment">    *    box_level.getBoxes().makeTree(box_level.getGridGeometry());
    * </pre></div> </dd></dl>

</div>
</div><p>
<a class="anchor" name="621aa4df7351bf32b53dcc2258890415"></a><!-- doxytag: member="SAMRAI::hier::BoxLevel::getGlobalBoxes" ref="621aa4df7351bf32b53dcc2258890415" args="(BoxContainer &amp;global_boxes) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::hier::BoxLevel::getGlobalBoxes           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>global_boxes</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Fill the container with the global Boxes. 
<p>

</div>
</div><p>
<a class="anchor" name="153e6634835c71dcb5643609112995e6"></a><!-- doxytag: member="SAMRAI::hier::BoxLevel::getFirstLocalId" ref="153e6634835c71dcb5643609112995e6" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSAMRAI_1_1hier_1_1LocalId.html">LocalId</a> SAMRAI::hier::BoxLevel::getFirstLocalId           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the first <a class="el" href="classSAMRAI_1_1hier_1_1LocalId.html">LocalId</a>, or one with a value of -1 if no local <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> exists. 
<p>
<dl compact><dt><b>Precondition:</b></dt><dd><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#b5f4c8b090dbff0226e778e316b21920">isInitialized()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="ba0e4564fd0ccd65a4e91c0326b38789"></a><!-- doxytag: member="SAMRAI::hier::BoxLevel::getLastLocalId" ref="ba0e4564fd0ccd65a4e91c0326b38789" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSAMRAI_1_1hier_1_1LocalId.html">LocalId</a> SAMRAI::hier::BoxLevel::getLastLocalId           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the last <a class="el" href="classSAMRAI_1_1hier_1_1LocalId.html">LocalId</a>, or one with a value of -1 if no local <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> exists. 
<p>
<dl compact><dt><b>Precondition:</b></dt><dd><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#b5f4c8b090dbff0226e778e316b21920">isInitialized()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="769ce9dbc1523384d0092a33aa0e5dbf"></a><!-- doxytag: member="SAMRAI::hier::BoxLevel::getRefinementRatio" ref="769ce9dbc1523384d0092a33aa0e5dbf" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a>&amp; SAMRAI::hier::BoxLevel::getRefinementRatio           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get const access to BoxLevel's refinement ratio (with respect to a reference level). 
<p>

</div>
</div><p>
<a class="anchor" name="75baa526ecb8ca03a4f9520172ae8904"></a><!-- doxytag: member="SAMRAI::hier::BoxLevel::getLocalNumberOfBoxes" ref="75baa526ecb8ca03a4f9520172ae8904" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int SAMRAI::hier::BoxLevel::getLocalNumberOfBoxes           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return local number of boxes. 
<p>
Periodic image Boxes are excluded.<p>
<dl compact><dt><b>Precondition:</b></dt><dd><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#b5f4c8b090dbff0226e778e316b21920">isInitialized()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="e17e88ee3daf8c90f63eb69d75fd9e5a"></a><!-- doxytag: member="SAMRAI::hier::BoxLevel::getLocalNumberOfBoxes" ref="e17e88ee3daf8c90f63eb69d75fd9e5a" args="(int rank) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int SAMRAI::hier::BoxLevel::getLocalNumberOfBoxes           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>rank</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return number of boxes local to the given rank. 
<p>
Periodic image Boxes are excluded.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>rank</em>&nbsp;</td><td></td></tr>
  </table>
</dl>
<dl compact><dt><b>Precondition:</b></dt><dd><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#b5f4c8b090dbff0226e778e316b21920">isInitialized()</a> <p>
(<a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#e0f03563c8ba07e61c0262ebac27b6c2">getParallelState()</a> == GLOBALIZED) || (rank == <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#a56ee65e5e67d58f580b4a6a700c431f">getMPI()</a>.getRank()) <p>
(rank &gt;= 0) &amp;&amp; (rank &lt; <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#a56ee65e5e67d58f580b4a6a700c431f">getMPI()</a>.getSize()) </dd></dl>

</div>
</div><p>
<a class="anchor" name="d4838ed2fd92a444d15c5b01e069a898"></a><!-- doxytag: member="SAMRAI::hier::BoxLevel::getGlobalNumberOfBoxes" ref="d4838ed2fd92a444d15c5b01e069a898" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int SAMRAI::hier::BoxLevel::getGlobalNumberOfBoxes           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return global number of Boxes. 
<p>
This requires a global reduction, if the global-reduced data has not been computed and cached. When communication is required, all processors must call this method. To ensure that no communication is needed, call <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#88d752dca7dd51b8c1b0b0aa27c3d64e">cacheGlobalReducedData()</a> first.<p>
Periodic image Boxes are excluded.<p>
<dl compact><dt><b>Precondition:</b></dt><dd><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#b5f4c8b090dbff0226e778e316b21920">isInitialized()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="799ad52b977646d3c095c25463d4d15b"></a><!-- doxytag: member="SAMRAI::hier::BoxLevel::getMaxNumberOfBoxes" ref="799ad52b977646d3c095c25463d4d15b" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int SAMRAI::hier::BoxLevel::getMaxNumberOfBoxes           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return maximum number of Boxes over all processes. 
<p>
This requires a global reduction, if the global-reduced data has not been computed and cached. When communication is required, all processors must call this method. To ensure that no communication is needed, call <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#88d752dca7dd51b8c1b0b0aa27c3d64e">cacheGlobalReducedData()</a> first.<p>
Periodic image Boxes are excluded.<p>
<dl compact><dt><b>Precondition:</b></dt><dd><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#b5f4c8b090dbff0226e778e316b21920">isInitialized()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="922bbd77b18facc9efe362166f9f0a1c"></a><!-- doxytag: member="SAMRAI::hier::BoxLevel::getMinNumberOfBoxes" ref="922bbd77b18facc9efe362166f9f0a1c" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int SAMRAI::hier::BoxLevel::getMinNumberOfBoxes           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return maximum number of Boxes over all processes. 
<p>
This requires a global reduction, if the global-reduced data has not been computed and cached. When communication is required, all processors must call this method. To ensure that no communication is needed, call <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#88d752dca7dd51b8c1b0b0aa27c3d64e">cacheGlobalReducedData()</a> first.<p>
Periodic image Boxes are excluded.<p>
<dl compact><dt><b>Precondition:</b></dt><dd><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#b5f4c8b090dbff0226e778e316b21920">isInitialized()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="c5422e0dc4aa9d6d58106895ff02bac4"></a><!-- doxytag: member="SAMRAI::hier::BoxLevel::getLocalNumberOfCells" ref="c5422e0dc4aa9d6d58106895ff02bac4" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t SAMRAI::hier::BoxLevel::getLocalNumberOfCells           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return local number of cells. 
<p>
Cells in periodic image Boxes are excluded.<p>
<dl compact><dt><b>Precondition:</b></dt><dd><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#b5f4c8b090dbff0226e778e316b21920">isInitialized()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="9393d4518cb5fab157e054d070a9676b"></a><!-- doxytag: member="SAMRAI::hier::BoxLevel::getMaxNumberOfCells" ref="9393d4518cb5fab157e054d070a9676b" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t SAMRAI::hier::BoxLevel::getMaxNumberOfCells           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return maximum number of cells over all processes. 
<p>
This requires a global reduction, if the global-reduced data has not been computed and cached. When communication is required, all processors must call this method. To ensure that no communication is needed, call <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#88d752dca7dd51b8c1b0b0aa27c3d64e">cacheGlobalReducedData()</a> first.<p>
Periodic image Boxes are excluded.<p>
<dl compact><dt><b>Precondition:</b></dt><dd><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#b5f4c8b090dbff0226e778e316b21920">isInitialized()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="c5c5540240eaaca51f895c58c04c68a5"></a><!-- doxytag: member="SAMRAI::hier::BoxLevel::getMinNumberOfCells" ref="c5c5540240eaaca51f895c58c04c68a5" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t SAMRAI::hier::BoxLevel::getMinNumberOfCells           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return maximum number of cells over all processes. 
<p>
This requires a global reduction, if the global-reduced data has not been computed and cached. When communication is required, all processors must call this method. To ensure that no communication is needed, call <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#88d752dca7dd51b8c1b0b0aa27c3d64e">cacheGlobalReducedData()</a> first.<p>
Periodic image Boxes are excluded.<p>
<dl compact><dt><b>Precondition:</b></dt><dd><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#b5f4c8b090dbff0226e778e316b21920">isInitialized()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="c163b80b716511ad09233ffb5576c87e"></a><!-- doxytag: member="SAMRAI::hier::BoxLevel::getLocalNumberOfCells" ref="c163b80b716511ad09233ffb5576c87e" args="(int rank) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t SAMRAI::hier::BoxLevel::getLocalNumberOfCells           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>rank</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return number of cells local to the given rank. 
<p>
Cells in periodic image Boxes are excluded.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>rank</em>&nbsp;</td><td></td></tr>
  </table>
</dl>
<dl compact><dt><b>Precondition:</b></dt><dd><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#b5f4c8b090dbff0226e778e316b21920">isInitialized()</a> <p>
(<a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#e0f03563c8ba07e61c0262ebac27b6c2">getParallelState()</a> == GLOBALIZED) || (rank == <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#a56ee65e5e67d58f580b4a6a700c431f">getMPI()</a>.getRank()) <p>
(rank &gt;= 0) &amp;&amp; (rank &lt; <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#a56ee65e5e67d58f580b4a6a700c431f">getMPI()</a>.getSize()) </dd></dl>

</div>
</div><p>
<a class="anchor" name="4cbe06570b6e5bef932cf7f4a463f53d"></a><!-- doxytag: member="SAMRAI::hier::BoxLevel::getGlobalNumberOfCells" ref="4cbe06570b6e5bef932cf7f4a463f53d" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t SAMRAI::hier::BoxLevel::getGlobalNumberOfCells           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return global number of cells. 
<p>
This requires a global reduction if the global-reduced data has not been computed and cached. When communication is required, all processors must call this method. To ensure that no communication is needed, call <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#88d752dca7dd51b8c1b0b0aa27c3d64e">cacheGlobalReducedData()</a> first.<p>
Cells in periodic image Boxes are excluded.<p>
<dl compact><dt><b>Precondition:</b></dt><dd><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#b5f4c8b090dbff0226e778e316b21920">isInitialized()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="a0e3992e8720b4df0bdbbca45546fc1f"></a><!-- doxytag: member="SAMRAI::hier::BoxLevel::getLocalBoundingBox" ref="a0e3992e8720b4df0bdbbca45546fc1f" args="(int block_number) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a>&amp; SAMRAI::hier::BoxLevel::getLocalBoundingBox           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>block_number</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return bounding box for local Boxes in a block. 
<p>

</div>
</div><p>
<a class="anchor" name="9deaa634cf3fe5ab246fe7aca0d70a43"></a><!-- doxytag: member="SAMRAI::hier::BoxLevel::getGlobalBoundingBox" ref="9deaa634cf3fe5ab246fe7aca0d70a43" args="(int block_number) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a>&amp; SAMRAI::hier::BoxLevel::getGlobalBoundingBox           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>block_number</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return bounding box for global Boxes in a block. 
<p>
This requires a global reduction if the global bounding box has not been computed and cached. When communication is required, all processors must call this method. To ensure that no communication is needed, call <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#88d752dca7dd51b8c1b0b0aa27c3d64e">cacheGlobalReducedData()</a> first. 
</div>
</div><p>
<a class="anchor" name="38cd4acb77caa36d41515252db0e1102"></a><!-- doxytag: member="SAMRAI::hier::BoxLevel::getLocalMaxBoxSize" ref="38cd4acb77caa36d41515252db0e1102" args="(int block_number) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a>&amp; SAMRAI::hier::BoxLevel::getLocalMaxBoxSize           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>block_number</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return size of the largest local <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> in a block. 
<p>

</div>
</div><p>
<a class="anchor" name="c1e3b956ec5dd8504d7375960545755c"></a><!-- doxytag: member="SAMRAI::hier::BoxLevel::getLocalMinBoxSize" ref="c1e3b956ec5dd8504d7375960545755c" args="(int block_number) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a>&amp; SAMRAI::hier::BoxLevel::getLocalMinBoxSize           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>block_number</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return size of the smallest local <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> in a block. 
<p>

</div>
</div><p>
<a class="anchor" name="27a9f68acbf0a41fae9538cfa249406a"></a><!-- doxytag: member="SAMRAI::hier::BoxLevel::getGlobalMaxBoxSize" ref="27a9f68acbf0a41fae9538cfa249406a" args="(int block_number) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a>&amp; SAMRAI::hier::BoxLevel::getGlobalMaxBoxSize           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>block_number</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return size of the largest <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> globally in a block. 
<p>
This requires a global reduction if the global bounding box has not been computed and cached. When communication is required, all processors must call this method. To ensure that no communication is needed, call <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#88d752dca7dd51b8c1b0b0aa27c3d64e">cacheGlobalReducedData()</a> first. 
</div>
</div><p>
<a class="anchor" name="38e7e581ec5d2ceb7f0130eca279a84f"></a><!-- doxytag: member="SAMRAI::hier::BoxLevel::getGlobalMinBoxSize" ref="38e7e581ec5d2ceb7f0130eca279a84f" args="(int block_number) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a>&amp; SAMRAI::hier::BoxLevel::getGlobalMinBoxSize           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>block_number</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return size of the smallest <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> globally in a block. 
<p>
This requires a global reduction if the global bounding box has not been computed and cached. When communication is required, all processors must call this method. To ensure that no communication is needed, call <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#88d752dca7dd51b8c1b0b0aa27c3d64e">cacheGlobalReducedData()</a> first. 
</div>
</div><p>
<a class="anchor" name="9a051730fadf4671bf844259fe45fd39"></a><!-- doxytag: member="SAMRAI::hier::BoxLevel::getDim" ref="9a051730fadf4671bf844259fe45fd39" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classSAMRAI_1_1tbox_1_1Dimension.html">tbox::Dimension</a>&amp; SAMRAI::hier::BoxLevel::getDim           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return the dimension of this object. 
<p>

</div>
</div><p>
<a class="anchor" name="ec78d23ef813cea9c1f08b30d6cec25f"></a><!-- doxytag: member="SAMRAI::hier::BoxLevel::getGridGeometry" ref="ec78d23ef813cea9c1f08b30d6cec25f" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const boost::shared_ptr&lt;const <a class="el" href="classSAMRAI_1_1hier_1_1BaseGridGeometry.html">BaseGridGeometry</a>&gt;&amp; SAMRAI::hier::BoxLevel::getGridGeometry           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return the grid geometry associated with this object. 
<p>
If object has never been initialized, return NULL pointer. 
</div>
</div><p>
<a class="anchor" name="f9d572999cb352e26876d5641c89f28c"></a><!-- doxytag: member="SAMRAI::hier::BoxLevel::refineBoxes" ref="f9d572999cb352e26876d5641c89f28c" args="(BoxLevel &amp;finer, const IntVector &amp;ratio, const IntVector &amp;final_ratio) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::hier::BoxLevel::refineBoxes           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>finer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>ratio</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>final_ratio</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Refine all Boxes of this <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a> by ratio placing result into finer making finer's ratio final_ratio. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>finer</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>ratio</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>final_ratio</em>&nbsp;</td><td></td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="6d08a9ac95f9c25ffb319bbc0e79f7b1"></a><!-- doxytag: member="SAMRAI::hier::BoxLevel::coarsenBoxes" ref="6d08a9ac95f9c25ffb319bbc0e79f7b1" args="(BoxLevel &amp;coarser, const IntVector &amp;ratio, const IntVector &amp;final_ratio) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::hier::BoxLevel::coarsenBoxes           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>coarser</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>ratio</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>final_ratio</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Coarsen all Boxes of this <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a> by ratio placing result into coarser making coarser's ratio final_ratio. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>coarser</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>ratio</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>final_ratio</em>&nbsp;</td><td></td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="7f03d7672157b32ea927b73751663872"></a><!-- doxytag: member="SAMRAI::hier::BoxLevel::addBox" ref="7f03d7672157b32ea927b73751663872" args="(const Box &amp;box, const BlockId &amp;block_id)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer_1_1BoxContainerConstIterator.html">BoxContainer::const_iterator</a> SAMRAI::hier::BoxLevel::addBox           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>box</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1BlockId.html">BlockId</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>block_id</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Create new local <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> from given <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> and add it to this level. 
<p>
The new <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> will be assigned an unused local index, so the input box need not have a valid one. To be efficient, no communication will be used. Therefore, the state must be distributed.<p>
The new <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> will have a periodic shift number corresponding to zero-shift.<p>
<dl compact><dt><b>Note:</b></dt><dd>It is imperative that applications which call addBox also call invalidateGlobalData. It is possible for some processes to add Boxes and for others to not. Since the addBox method sets d_global_data_up_to_date to false, some processes in this situation will have this flag set to true and others will not. This will result in a hang in cacheGlobalReducedData when global data is accessed. We could have performed and allReduce of this flag to the top of cacheGlobalReducedData but this would have added a costly call for every access of global data.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>box</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>block_id</em>&nbsp;</td><td></td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>iterator to the new <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a></dd></dl>
<dl compact><dt><b>Precondition:</b></dt><dd><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#e0f03563c8ba07e61c0262ebac27b6c2">getParallelState()</a> == DISTRIBUTED <p>
(box.getBlockId() == <a class="el" href="classSAMRAI_1_1hier_1_1BlockId.html#f5ec2c3b87256cd021571cd78a897d92">BlockId::invalidId()</a>) || (box.getBlockId() == block_id) </dd></dl>

</div>
</div><p>
<a class="anchor" name="7a80e5adb2b547f075125db37be16ff7"></a><!-- doxytag: member="SAMRAI::hier::BoxLevel::addBox" ref="7a80e5adb2b547f075125db37be16ff7" args="(const Box &amp;box)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::hier::BoxLevel::addBox           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>box</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Add a <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> to this level. 
<p>
<dl compact><dt><b>CAUTION</b></dt><dd>To be efficient, no checks are made to make sure the <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a> representation is consistent across all processors. Setting inconsistent data leads potentially elusive bugs.</dd></dl>
<dl compact><dt><b>Errors</b></dt><dd>It is an error to add a periodic image of a <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> that is not a part of the <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a>.</dd></dl>
It is an error to add any <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> that already exists.<p>
<dl compact><dt><b>Note:</b></dt><dd>It is imperative that applications which call addBox also call invalidateGlobalData. It is possible for some processes to add Boxes and for others to not. Since the addBox method sets d_global_data_up_to_date to false, some processes in this situation will have this flag set to true and others will not. This will result in a hang in cacheGlobalReducedData when global data is accessed. We could have performed and allReduce of this flag to the top of cacheGlobalReducedData but this would have added a costly call for every access of global data.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>box</em>&nbsp;</td><td></td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="7192f8a642329533e870d08ac4affb08"></a><!-- doxytag: member="SAMRAI::hier::BoxLevel::addBoxWithoutUpdate" ref="7192f8a642329533e870d08ac4affb08" args="(const Box &amp;box)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::hier::BoxLevel::addBoxWithoutUpdate           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>box</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Add a <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> to this level without updating summary data such as local number of boxes/cells, bounding box, max/min box size. Meant to be used during the construction of a <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a> as Boxes belonging to the level are found. <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#d1993c509749c5b3e92c0c534a51e9fd">finalize()</a> should be called at the end of construction making use of addBoxWithoutUpdate. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>box</em>&nbsp;</td><td></td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="1efaddb0a58895344bfdc03003e1aa9d"></a><!-- doxytag: member="SAMRAI::hier::BoxLevel::addPeriodicBox" ref="1efaddb0a58895344bfdc03003e1aa9d" args="(const Box &amp;existing_box, const PeriodicId &amp;shift_number)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::hier::BoxLevel::addPeriodicBox           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>existing_box</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1PeriodicId.html">PeriodicId</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>shift_number</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Insert given periodic image of an existing <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a>. 
<p>
Unlike adding a regular <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a>, it is OK to add a periodic image <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> that already exists. However, that is a no-op.<p>
<dl compact><dt><b>CAUTION</b></dt><dd>To be efficient, no checks are made to make sure the <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a> representation is consistent across all processors. Setting inconsistent data leads to potentially elusive bugs.</dd></dl>
<dl compact><dt><b>Errors</b></dt><dd>It is an error to add a periodic image of a <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> that does not exist.</dd></dl>
TODO: Should we prevent this operation if persistent overlap Connectors are attached to this object?<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>existing_box</em>&nbsp;</td><td>An existing <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> for reference. This <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> must be in the <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a>. The <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> added is an image of the reference <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> but shifted to another position. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>shift_number</em>&nbsp;</td><td>The valid shift number for the <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> being added. The shift amount is taken from the <a class="el" href="classSAMRAI_1_1hier_1_1PeriodicShiftCatalog.html">PeriodicShiftCatalog</a>.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Precondition:</b></dt><dd>shift_number != <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#ec78d23ef813cea9c1f08b30d6cec25f">getGridGeometry()</a>-&gt;getPeriodicShiftCatalog().getZeroShiftNumber() </dd></dl>

</div>
</div><p>
<a class="anchor" name="960befb3bc83403345c75c7ed6a177e8"></a><!-- doxytag: member="SAMRAI::hier::BoxLevel::eraseBox" ref="960befb3bc83403345c75c7ed6a177e8" args="(BoxContainer::iterator &amp;ibox)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::hier::BoxLevel::eraseBox           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer_1_1BoxContainerIterator.html">BoxContainer::iterator</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>ibox</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Erase the existing <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> specified by its iterator. 
<p>
The given iterator <em>MUST</em> be a valid iterator pointing to a <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> currently in this object. After erasing, the iterator is advanced to the next valid <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> (or the end of its <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a>).<p>
Erasing a <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> also erases all of its periodic images.<p>
TODO: Should we prevent this operation if the object has persistent overlap Connectors?<p>
<dl compact><dt><b>Note:</b></dt><dd>It is imperative that applications which call eraseBox also call invalidateGlobalData. It is possible for some processes to erase Boxes and for others to not. Since the eraseBox method sets d_global_data_up_to_date to false, some processes in this situation will have this flag set to true and others will not. This will result in a hang in cacheGlobalReducedData when global data is accessed. We could have performed and allReduce of this flag to the top of cacheGlobalReducedData but this would have erased a costly call for every access of global data.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>ibox</em>&nbsp;</td><td>The iterator of the <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> to erase.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Precondition:</b></dt><dd><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#e0f03563c8ba07e61c0262ebac27b6c2">getParallelState()</a> == DISTRIBUTED <p>
ibox == <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#1e75df2ef751e7ed7f42c9e9a0991fa3">getBoxes()</a>.find(*ibox) </dd></dl>

</div>
</div><p>
<a class="anchor" name="ac786eaec7c2fa5256f41a685c945257"></a><!-- doxytag: member="SAMRAI::hier::BoxLevel::eraseBox" ref="ac786eaec7c2fa5256f41a685c945257" args="(const Box &amp;box)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::hier::BoxLevel::eraseBox           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>box</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Erase the <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> matching the one given. 
<p>
The given <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> <em>MUST</em> match a <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> currently in this object. Matching means that the BoxId's match (disregarding the spatial coordinates).<p>
Erasing a <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> also erases all of its periodic images.<p>
TODO: Should we prevent this operation if the object has persistent overlap Connectors?<p>
<dl compact><dt><b>Note:</b></dt><dd>It is imperative that applications which call eraseBox also call invalidateGlobalData. It is possible for some processes to erase Boxes and for others to not. Since the eraseBox method sets d_global_data_up_to_date to false, some processes in this situation will have this flag set to true and others will not. This will result in a hang in cacheGlobalReducedData when global data is accessed. We could have performed and allReduce of this flag to the top of cacheGlobalReducedData but this would have erased a costly call for every access of global data.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>box</em>&nbsp;</td><td></td></tr>
  </table>
</dl>
<dl compact><dt><b>Precondition:</b></dt><dd><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#e0f03563c8ba07e61c0262ebac27b6c2">getParallelState()</a> == DISTRIBUTED <p>
<a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#1e75df2ef751e7ed7f42c9e9a0991fa3">getBoxes()</a>.find(box) != <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#1e75df2ef751e7ed7f42c9e9a0991fa3">getBoxes()</a>.end() </dd></dl>

</div>
</div><p>
<a class="anchor" name="0ee46cb63c7d8409c8688f3700605a98"></a><!-- doxytag: member="SAMRAI::hier::BoxLevel::eraseBoxWithoutUpdate" ref="0ee46cb63c7d8409c8688f3700605a98" args="(const Box &amp;box)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::hier::BoxLevel::eraseBoxWithoutUpdate           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>box</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Erases the <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> matching the supplied <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> from this level without updating summary data such as local number of boxes/cells, bounding box, max/min box size. Meant to be used during the construction of a <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a> as Boxes not belonging to the level are found. <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#d1993c509749c5b3e92c0c534a51e9fd">finalize()</a> should be called at the end of construction making use of eraseBoxWithoutUpdate. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>box</em>&nbsp;</td><td></td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="ae14445c8c9e8c06bc7d3132ee490555"></a><!-- doxytag: member="SAMRAI::hier::BoxLevel::getBox" ref="ae14445c8c9e8c06bc7d3132ee490555" args="(const Box &amp;box) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer_1_1BoxContainerConstIterator.html">BoxContainer::const_iterator</a> SAMRAI::hier::BoxLevel::getBox           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>box</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Find the <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> matching the one given. 
<p>
Only the <a class="el" href="classSAMRAI_1_1hier_1_1BoxId.html">BoxId</a> matters in matching, so the actual <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> can be anything.<p>
If <code>box</code> is not a local <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a>, the state must be GLOBALIZED.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>box</em>&nbsp;</td><td></td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Iterator to the box, or <code>getBoxes(owner)</code>.end() if box does not exist in set.</dd></dl>
<dl compact><dt><b>Precondition:</b></dt><dd>(box.getOwnerRank() == <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#a56ee65e5e67d58f580b4a6a700c431f">getMPI()</a>.getRank()) || (<a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#e0f03563c8ba07e61c0262ebac27b6c2">getParallelState()</a> == GLOBALIZED) </dd></dl>

</div>
</div><p>
<a class="anchor" name="2fc9a3140f7ad64850ad6556d53223ec"></a><!-- doxytag: member="SAMRAI::hier::BoxLevel::getBox" ref="2fc9a3140f7ad64850ad6556d53223ec" args="(const BoxId &amp;box_id) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer_1_1BoxContainerConstIterator.html">BoxContainer::const_iterator</a> SAMRAI::hier::BoxLevel::getBox           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1BoxId.html">BoxId</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>box_id</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Find the <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> specified by the given <a class="el" href="classSAMRAI_1_1hier_1_1BoxId.html">BoxId</a> and periodic shift. 
<p>
If <code>box</code> is not a local <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a>, the state must be GLOBALIZED. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>box_id</em>&nbsp;</td><td></td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Iterator to the box, or <code>getBoxes(owner)</code>.end() if box does not exist in set. </dd></dl>

</div>
</div><p>
<a class="anchor" name="eb1f97fa84af6ba5c273c64c0ea0c80c"></a><!-- doxytag: member="SAMRAI::hier::BoxLevel::getBoxStrict" ref="eb1f97fa84af6ba5c273c64c0ea0c80c" args="(const Box &amp;box) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer_1_1BoxContainerConstIterator.html">BoxContainer::const_iterator</a> SAMRAI::hier::BoxLevel::getBoxStrict           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>box</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Find the <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> matching the one given. 
<p>
Only the <a class="el" href="classSAMRAI_1_1hier_1_1BoxId.html">BoxId</a> matters in matching, so the actual <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> can be anything.<p>
If <code>box</code> is not owned by the local process, the state must be GLOBALIZED.<p>
You cannot directly modify the <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a> because it may invalidate other internal data. Use other methods for modifying the <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a>.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>box</em>&nbsp;</td><td></td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Iterator to the box.</dd></dl>
<dl compact><dt><b>Precondition:</b></dt><dd>((box.getOwnerRank() == <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#a56ee65e5e67d58f580b4a6a700c431f">getMPI()</a>.getRank()) &amp;&amp; (<a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#1e75df2ef751e7ed7f42c9e9a0991fa3">getBoxes()</a>.find(box) != <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#1e75df2ef751e7ed7f42c9e9a0991fa3">getBoxes()</a>.end())) || ((box.getOwnerRank() != <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#a56ee65e5e67d58f580b4a6a700c431f">getMPI()</a>.getRank()) &amp;&amp; (<a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#e0f03563c8ba07e61c0262ebac27b6c2">getParallelState()</a> == GLOBALIZED) &amp;&amp; (<a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#fe03004a023ac5e76e01aef59fd6a612">getGlobalBoxes()</a>.find(box) != <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#fe03004a023ac5e76e01aef59fd6a612">getGlobalBoxes()</a>.end())) </dd></dl>

</div>
</div><p>
<a class="anchor" name="5d59700b00e6da268bf003a842f626ee"></a><!-- doxytag: member="SAMRAI::hier::BoxLevel::getBoxStrict" ref="5d59700b00e6da268bf003a842f626ee" args="(const BoxId &amp;box_id) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer_1_1BoxContainerConstIterator.html">BoxContainer::const_iterator</a> SAMRAI::hier::BoxLevel::getBoxStrict           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1BoxId.html">BoxId</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>box_id</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Find the <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> specified by the given <a class="el" href="classSAMRAI_1_1hier_1_1BoxId.html">BoxId</a>. 
<p>
You cannot directly modify the <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a> because it may invalidate other internal data. Use other methods for modifying the <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a>.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>box_id</em>&nbsp;</td><td></td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Iterator to the box.</dd></dl>
<dl compact><dt><b>Precondition:</b></dt><dd>(box_id.getOwnerRank() == <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#a56ee65e5e67d58f580b4a6a700c431f">getMPI()</a>.getRank()) || (<a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#e0f03563c8ba07e61c0262ebac27b6c2">getParallelState()</a> == GLOBALIZED) <p>
box with supplied <a class="el" href="classSAMRAI_1_1hier_1_1BoxId.html">BoxId</a> exists in the <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="c33526f84722654e4eec9ef11093aaac"></a><!-- doxytag: member="SAMRAI::hier::BoxLevel::getSpatiallyEqualBox" ref="c33526f84722654e4eec9ef11093aaac" args="(const Box &amp;box_to_match, const BlockId &amp;block_id, Box &amp;matching_box) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SAMRAI::hier::BoxLevel::getSpatiallyEqualBox           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>box_to_match</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1BlockId.html">BlockId</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>block_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>matching_box</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Find the <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> with the given <a class="el" href="classSAMRAI_1_1hier_1_1BlockId.html">BlockId</a> which is spatially equal to the supplied <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a>. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>box_to_match</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>block_id</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>matching_box</em>&nbsp;</td><td>If there is a box with the supplied <a class="el" href="classSAMRAI_1_1hier_1_1BlockId.html">BlockId</a> spatially equal to box_to_match then this is set to that <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a>.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>true if a match is found. </dd></dl>

</div>
</div><p>
<a class="anchor" name="a36386f372e60084d09119c9e8c36718"></a><!-- doxytag: member="SAMRAI::hier::BoxLevel::hasBox" ref="a36386f372e60084d09119c9e8c36718" args="(const BoxId &amp;box_id) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SAMRAI::hier::BoxLevel::hasBox           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1BoxId.html">BoxId</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>box_id</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns true when the object has a <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> specified by the <a class="el" href="classSAMRAI_1_1hier_1_1BoxId.html">BoxId</a>. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>box_id</em>&nbsp;</td><td></td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="1d8a2324f2425898efad09a23f1f61f6"></a><!-- doxytag: member="SAMRAI::hier::BoxLevel::hasBox" ref="1d8a2324f2425898efad09a23f1f61f6" args="(const GlobalId &amp;global_id, const PeriodicId &amp;periodic_id) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SAMRAI::hier::BoxLevel::hasBox           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1GlobalId.html">GlobalId</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>global_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1PeriodicId.html">PeriodicId</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>periodic_id</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns true when the object has a <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> consistent with all of the arguments. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>global_id</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>periodic_id</em>&nbsp;</td><td></td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="3b57ea9786676c090d5619abde08bd63"></a><!-- doxytag: member="SAMRAI::hier::BoxLevel::hasBox" ref="3b57ea9786676c090d5619abde08bd63" args="(const Box &amp;box) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SAMRAI::hier::BoxLevel::hasBox           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>box</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns true when this <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a> has a <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> matching the <a class="el" href="classSAMRAI_1_1hier_1_1BoxId.html">BoxId</a> of the given box. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>box</em>&nbsp;</td><td></td></tr>
  </table>
</dl>
<dl compact><dt><b>Precondition:</b></dt><dd>(box.getOwnerRank() == <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#a56ee65e5e67d58f580b4a6a700c431f">getMPI()</a>.getRank()) || (<a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#e0f03563c8ba07e61c0262ebac27b6c2">getParallelState()</a> == GLOBALIZED) </dd></dl>

</div>
</div><p>
<a class="anchor" name="8ec0ee23695893a76962ad8a8922f2a1"></a><!-- doxytag: member="SAMRAI::hier::BoxLevel::putToRestart" ref="8ec0ee23695893a76962ad8a8922f2a1" args="(const boost::shared_ptr&lt; tbox::Database &gt; &amp;restart_db) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::hier::BoxLevel::putToRestart           </td>
          <td>(</td>
          <td class="paramtype">const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Database.html">tbox::Database</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>restart_db</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Write the <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a> to a restart database. 
<p>
Write only local parts regardless of parallel state (to avoid writing tons of repetitive data).<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>restart_db</em>&nbsp;</td><td></td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="f26bd3d728ba0f8094ee6b9acb593040"></a><!-- doxytag: member="SAMRAI::hier::BoxLevel::invalidateGlobalData" ref="f26bd3d728ba0f8094ee6b9acb593040" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::hier::BoxLevel::invalidateGlobalData           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets d_global_data_up_to_date to false. Must be called after calls to addBox or eraseBox. 
<p>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#7f03d7672157b32ea927b73751663872">addBox()</a> <p>
<a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#960befb3bc83403345c75c7ed6a177e8">eraseBox()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="8ce8fadb18fcfcdd48f1b373a1b979a8"></a><!-- doxytag: member="SAMRAI::hier::BoxLevel::clearPersistentOverlapConnectors" ref="8ce8fadb18fcfcdd48f1b373a1b979a8" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::hier::BoxLevel::clearPersistentOverlapConnectors           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Deallocate persistent overlap Connectors, if there are any. 
<p>

</div>
</div><p>
<a class="anchor" name="d4ef30985671aaeac06be82bf7a238cb"></a><!-- doxytag: member="SAMRAI::hier::BoxLevel::findConnector" ref="d4ef30985671aaeac06be82bf7a238cb" args="(const BoxLevel &amp;head, const IntVector &amp;min_connector_width, ConnectorNotFoundAction not_found_action, bool exact_width_only=false) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">Connector</a>&amp; SAMRAI::hier::BoxLevel::findConnector           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>head</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>min_connector_width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceSAMRAI_1_1hier.html#256cef944748f7494c84017f5829101a">ConnectorNotFoundAction</a>&nbsp;</td>
          <td class="paramname"> <em>not_found_action</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>exact_width_only</em> = <code>false</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Find an overlap <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">Connector</a> with the given head and minimum <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">Connector</a> width. If the specified <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">Connector</a> is not found, take the specified action. 
<p>
If multiple Connectors fit the criteria, the one with the smallest ghost cell width (based on the algebraic sum of the components) is selected.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>head</em>&nbsp;</td><td>Find the overlap <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">Connector</a> with this specified head. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>min_connector_width</em>&nbsp;</td><td>Find the overlap <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">Connector</a> satisfying this minimum <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">Connector</a> width. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>not_found_action</em>&nbsp;</td><td>Action to take if <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">Connector</a> is not found. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>exact_width_only</em>&nbsp;</td><td>If true, reject Connectors that do not match the requested width exactly.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">Connector</a> which matches the search criterion.</dd></dl>
<dl compact><dt><b>Precondition:</b></dt><dd><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#b5f4c8b090dbff0226e778e316b21920">isInitialized()</a> <p>
head.isInitialized() </dd></dl>

</div>
</div><p>
<a class="anchor" name="9ef122b8e4b1c02fa4850a6a81976110"></a><!-- doxytag: member="SAMRAI::hier::BoxLevel::findConnectorWithTranspose" ref="9ef122b8e4b1c02fa4850a6a81976110" args="(const BoxLevel &amp;head, const IntVector &amp;min_connector_width, const IntVector &amp;transpose_min_connector_width, ConnectorNotFoundAction not_found_action, bool exact_width_only=false) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">Connector</a>&amp; SAMRAI::hier::BoxLevel::findConnectorWithTranspose           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>head</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>min_connector_width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>transpose_min_connector_width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceSAMRAI_1_1hier.html#256cef944748f7494c84017f5829101a">ConnectorNotFoundAction</a>&nbsp;</td>
          <td class="paramname"> <em>not_found_action</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>exact_width_only</em> = <code>false</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Find an overlap <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">Connector</a> with its transpose with the given head and minimum <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">Connector</a> widths. If the specified <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">Connector</a> is not found, take the specified action. 
<p>
If multiple Connectors fit the criteria, the one with the smallest ghost cell width (based on the algebraic sum of the components) is selected.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>head</em>&nbsp;</td><td>Find the overlap <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">Connector</a> with this specified head. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>min_connector_width</em>&nbsp;</td><td>Find the overlap <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">Connector</a> satisfying this minimum <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">Connector</a> width. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>transpose_min_connector_width</em>&nbsp;</td><td>Find the transpose overlap <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">Connector</a> satisfying this minimum <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">Connector</a> width. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>not_found_action</em>&nbsp;</td><td>Action to take if <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">Connector</a> is not found. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>exact_width_only</em>&nbsp;</td><td>If true, reject Connectors that do not match the requested width exactly.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">Connector</a> which matches the search criterion.</dd></dl>
<dl compact><dt><b>Precondition:</b></dt><dd><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#b5f4c8b090dbff0226e778e316b21920">isInitialized()</a> <p>
head.isInitialized() </dd></dl>

</div>
</div><p>
<a class="anchor" name="02aa235c3d2e5b9700a81e6853294fb7"></a><!-- doxytag: member="SAMRAI::hier::BoxLevel::createConnector" ref="02aa235c3d2e5b9700a81e6853294fb7" args="(const BoxLevel &amp;head, const IntVector &amp;connector_width) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">Connector</a>&amp; SAMRAI::hier::BoxLevel::createConnector           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>head</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>connector_width</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Create an overlap <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">Connector</a>, computing relationships by globalizing data. 
<p>
The base will be this <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a>. Find <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">Connector</a> relationships using a (non-scalable) global search.<p>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">hier::Connector</a> <p>
hier::Connector::initialize()</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>head</em>&nbsp;</td><td>This <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a> will be the head. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>connector_width</em>&nbsp;</td><td></td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>A const reference to the newly created overlap <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">Connector</a>.</dd></dl>
<dl compact><dt><b>Precondition:</b></dt><dd><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#b5f4c8b090dbff0226e778e316b21920">isInitialized()</a> <p>
head.isInitialized() </dd></dl>

</div>
</div><p>
<a class="anchor" name="85bf92f1e262d7e182442aa09316640d"></a><!-- doxytag: member="SAMRAI::hier::BoxLevel::createConnectorWithTranspose" ref="85bf92f1e262d7e182442aa09316640d" args="(const BoxLevel &amp;head, const IntVector &amp;connector_width, const IntVector &amp;transpose_connector_width) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">Connector</a>&amp; SAMRAI::hier::BoxLevel::createConnectorWithTranspose           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>head</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>connector_width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>transpose_connector_width</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Create an overlap <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">Connector</a> with its transpose, computing relationships by globalizing data. 
<p>
The base will be this <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a>. Find <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">Connector</a> relationships using a (non-scalable) global search.<p>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">hier::Connector</a> <p>
hier::Connector::initialize()</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>head</em>&nbsp;</td><td>This <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a> will be the head. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>connector_width</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>transpose_connector_width</em>&nbsp;</td><td></td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>A const reference to the newly created overlap <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">Connector</a>.</dd></dl>
<dl compact><dt><b>Precondition:</b></dt><dd><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#b5f4c8b090dbff0226e778e316b21920">isInitialized()</a> <p>
head.isInitialized() </dd></dl>

</div>
</div><p>
<a class="anchor" name="6caf4ac1f3c3b137a4bc890e3680c710"></a><!-- doxytag: member="SAMRAI::hier::BoxLevel::cacheConnector" ref="6caf4ac1f3c3b137a4bc890e3680c710" args="(boost::shared_ptr&lt; Connector &gt; &amp;connector) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::hier::BoxLevel::cacheConnector           </td>
          <td>(</td>
          <td class="paramtype">boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">Connector</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>connector</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Cache the supplied overlap <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">Connector</a> and its transpose if it exists. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>connector</em>&nbsp;</td><td></td></tr>
  </table>
</dl>
<dl compact><dt><b>Precondition:</b></dt><dd><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#b5f4c8b090dbff0226e778e316b21920">isInitialized()</a> <p>
connector </dd></dl>

</div>
</div><p>
<a class="anchor" name="5843797f8b24c016bb92eb4b963f65ac"></a><!-- doxytag: member="SAMRAI::hier::BoxLevel::hasConnector" ref="5843797f8b24c016bb92eb4b963f65ac" args="(const BoxLevel &amp;head, const IntVector &amp;min_connector_width, bool exact_width_only=false) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SAMRAI::hier::BoxLevel::hasConnector           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>head</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>min_connector_width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>exact_width_only</em> = <code>false</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns whether the object has overlap Connectors with the given head and minimum <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">Connector</a> width. 
<p>
TODO: does the following comment mean that this must be called before the call to findConnector?<p>
If this returns true, the <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">Connector</a> fitting the specification exists and <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#d4ef30985671aaeac06be82bf7a238cb">findConnector()</a> will not throw an assertion.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>head</em>&nbsp;</td><td>Find the overlap <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">Connector</a> with this specified head. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>min_connector_width</em>&nbsp;</td><td>Find the overlap <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">Connector</a> satisfying this minimum ghost cell width. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>exact_width_only</em>&nbsp;</td><td>If true, reject Connectors that do not match the requested width exactly.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>True if a <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">Connector</a> is found, otherwise false. </dd></dl>

</div>
</div><p>
<a class="anchor" name="d28ae9914fffcd6712061af51e0fbfef"></a><!-- doxytag: member="SAMRAI::hier::BoxLevel::getBoxLevelHandle" ref="d28ae9914fffcd6712061af51e0fbfef" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const boost::shared_ptr&lt;<a class="el" href="classSAMRAI_1_1hier_1_1BoxLevelHandle.html">BoxLevelHandle</a>&gt;&amp; SAMRAI::hier::BoxLevel::getBoxLevelHandle           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the handle with which Connectors reference the <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a> instead of referencing the <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a> itself. Not for general use. 
<p>
Connectors referencing their base and head BoxLevels should reference their handles instead of the BoxLevels themselves. As long as the <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a> does not change in a way that can invalidate <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">Connector</a> data, you can access the <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a> from the <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevelHandle.html">BoxLevelHandle</a>.<p>
If the <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a> go out of scope before the <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">Connector</a> disconnects, this boost::shared_ptr object will stay around until all Connectors have disconnected.<p>
Operations that can invalidate <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">Connector</a> data are those that remove information from the <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a>. These are:<p>
<ul>
<li><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#f3867518e8cca269d54e4b04d9622781">initialize()</a> </li>
<li><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#b1fd7baf5161fcdbbb830480f3f77293">swapInitialize()</a> </li>
<li><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#9eebd53c534a0b42c59cf9cb08f2777e">swap()</a> </li>
<li><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#d1e2b6cbb81383c7661222048edd103c">clear()</a> </li>
<li><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#13c61b0dbe112df0eca5960e378f35c5">operator=()</a> (assignment) (Exception: assigning to self is a no-op, which does not invalidate <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">Connector</a> data. </li>
<li><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#960befb3bc83403345c75c7ed6a177e8">eraseBox()</a> (Note that adding a <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> does not invalidate <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">Connector</a> data.) </li>
<li>going out of scope</li>
</ul>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevelHandle.html">BoxLevelHandle</a>.</dd></dl>
<dl compact><dt><b>Returns:</b></dt><dd>A boost::shared_ptr to the <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevelHandle.html">BoxLevelHandle</a></dd></dl>
<dl compact><dt><b>Precondition:</b></dt><dd>!d_handle || (d_handle-&gt;d_box_level == this) </dd></dl>

</div>
</div><p>
<a class="anchor" name="dd9723ad7a88b27b00f7a691d6eb2e0c"></a><!-- doxytag: member="SAMRAI::hier::BoxLevel::lock" ref="dd9723ad7a88b27b00f7a691d6eb2e0c" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::hier::BoxLevel::lock           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Effectively makes a non-const <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a> const. Prevents any non-const method from executing. 
<p>

</div>
</div><p>
<a class="anchor" name="8f53858f6a358760477cbf8f42615b1c"></a><!-- doxytag: member="SAMRAI::hier::BoxLevel::locked" ref="8f53858f6a358760477cbf8f42615b1c" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SAMRAI::hier::BoxLevel::locked           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns true if the <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a> is locked. 
<p>

</div>
</div><p>
<a class="anchor" name="00c11404f06b3a72323cb3fc5d650309"></a><!-- doxytag: member="SAMRAI::hier::BoxLevel::recursivePrint" ref="00c11404f06b3a72323cb3fc5d650309" args="(std::ostream &amp;os, const std::string &amp;border, int detail_depth=2) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::hier::BoxLevel::recursivePrint           </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&nbsp;</td>
          <td class="paramname"> <em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>border</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>detail_depth</em> = <code>2</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Print <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> info from this level. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>os</em>&nbsp;</td><td>The output stream </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>border</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>detail_depth</em>&nbsp;</td><td></td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="ef7ffb368ef636b78732ba7b64c51277"></a><!-- doxytag: member="SAMRAI::hier::BoxLevel::format" ref="ef7ffb368ef636b78732ba7b64c51277" args="(const std::string &amp;border=std::string(), int detail_depth=2) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel_1_1Outputter.html">BoxLevel::Outputter</a> SAMRAI::hier::BoxLevel::format           </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>border</em> = <code>std::string()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>detail_depth</em> = <code>2</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return a object that can format the <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a> for inserting into output streams. 
<p>
Usage example: <div class="fragment"><pre class="fragment">    <a class="code" href="namespaceSAMRAI_1_1tbox.html#b84041705493761fb17a8127e3a2dca2">tbox::plog</a> &lt;&lt; <span class="stringliteral">"my box_level:\n"</span> &lt;&lt; box_level.format() &lt;&lt; endl;
</pre></div><p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>border</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>detail_depth</em>&nbsp;</td><td></td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="0358ed57086330055c464956136feac8"></a><!-- doxytag: member="SAMRAI::hier::BoxLevel::formatStatistics" ref="0358ed57086330055c464956136feac8" args="(const std::string &amp;border=std::string()) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel_1_1Outputter.html">BoxLevel::Outputter</a> SAMRAI::hier::BoxLevel::formatStatistics           </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>border</em> = <code>std::string()</code>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return a object that can format the <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a> for inserting its global statistics into output streams. 
<p>
Usage example: <div class="fragment"><pre class="fragment">    std::cout &lt;&lt; <span class="stringliteral">"my box_level statistics:\n"</span>
              &lt;&lt; box_level.formatStatistics(<span class="stringliteral">"  "</span>) &lt;&lt; std::endl;
</pre></div><p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>border</em>&nbsp;</td><td></td></tr>
  </table>
</dl>

</div>
</div><p>
<hr><h2>Friends And Related Function Documentation</h2>
<a class="anchor" name="e17fc1942f6de54c13321a9481366cd1"></a><!-- doxytag: member="SAMRAI::hier::BoxLevel::PersistentOverlapConnectors" ref="e17fc1942f6de54c13321a9481366cd1" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="classSAMRAI_1_1hier_1_1PersistentOverlapConnectors.html">PersistentOverlapConnectors</a><code> [friend]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<hr>The documentation for this class was generated from the following files:<ul>
<li>source/SAMRAI/hier/<a class="el" href="BoxLevel_8h.html">BoxLevel.h</a><li>source/SAMRAI/hier/<a class="el" href="BoxLevel_8C.html">BoxLevel.C</a></ul>
<hr size="1"><address style="align: right;"><small>Generated on 3 Mar 2015 for SAMRAI by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.7 </small></address>
</body>
</html>
