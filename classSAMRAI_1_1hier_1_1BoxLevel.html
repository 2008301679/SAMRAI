<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>SAMRAI: SAMRAI::hier::BoxLevel Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath"><a class="el" href="namespaceSAMRAI.html">SAMRAI</a>::<a class="el" href="namespaceSAMRAI_1_1hier.html">hier</a>::<a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a>
  </div>
</div>
<div class="contents">
<h1>SAMRAI::hier::BoxLevel Class Reference</h1><!-- doxytag: class="SAMRAI::hier::BoxLevel" -->
<p>A distributed set of <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> objects which reside in the same index space.  
<a href="#_details">More...</a></p>

<p><code>#include &lt;source/SAMRAI/hier/BoxLevel.h&gt;</code></p>

<p><a href="classSAMRAI_1_1hier_1_1BoxLevel-members.html">List of all members.</a></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Classes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel_1_1Outputter.html">Outputter</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A class for outputting <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html" title="A distributed set of Box objects which reside in the same index space.">BoxLevel</a>.  <a href="classSAMRAI_1_1hier_1_1BoxLevel_1_1Outputter.html#_details">More...</a><br/></td></tr>
<tr><td colspan="2"><h2>Public Types</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#a02c34699888ab34b06f59a210247bcb4">ParallelState</a> { <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#a02c34699888ab34b06f59a210247bcb4a50fcdd33dde8ec1597aa318dcb384578">DISTRIBUTED</a>, 
<a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#a02c34699888ab34b06f59a210247bcb4a2dbf00b87512ae236e2dbde25acb952f">GLOBALIZED</a>
 }</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>Names of parallel states. </p>
 <a href="classSAMRAI_1_1hier_1_1BoxLevel.html#a02c34699888ab34b06f59a210247bcb4">More...</a><br/></td></tr>
<tr><td colspan="2"><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#a35b7fce14d4b31de23aa5d5bdf1a472e">BoxLevel</a> (const <a class="el" href="classSAMRAI_1_1tbox_1_1Dimension.html">tbox::Dimension</a> &amp;dim, <a class="el" href="classSAMRAI_1_1tbox_1_1Database.html">tbox::Database</a> &amp;restart_db, const boost::shared_ptr&lt; const <a class="el" href="classSAMRAI_1_1hier_1_1BaseGridGeometry.html">BaseGridGeometry</a> &gt; &amp;grid_geom)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Construct a <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html" title="A distributed set of Box objects which reside in the same index space.">BoxLevel</a> which will be initialized from the supplied restart database.  <a href="#a35b7fce14d4b31de23aa5d5bdf1a472e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#ab8771dd90200a99a9e60cb6b356fcecf">BoxLevel</a> (const <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a> &amp;rhs)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copy constructor.  <a href="#ab8771dd90200a99a9e60cb6b356fcecf"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#af19ca6a464561b4f23133b91d77d4470">BoxLevel</a> (const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;ratio, const boost::shared_ptr&lt; const <a class="el" href="classSAMRAI_1_1hier_1_1BaseGridGeometry.html">BaseGridGeometry</a> &gt; &amp;grid_geom, const <a class="el" href="classSAMRAI_1_1tbox_1_1SAMRAI__MPI.html">tbox::SAMRAI_MPI</a> &amp;mpi=tbox::SAMRAI_MPI::getSAMRAIWorld(), const <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#a02c34699888ab34b06f59a210247bcb4">ParallelState</a> parallel_state=DISTRIBUTED)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Constructs an empty, initialized object.  <a href="#af19ca6a464561b4f23133b91d77d4470"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#a962662fdff601ac5bc5fe60440c67d83">~BoxLevel</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Destructor.  <a href="#a962662fdff601ac5bc5fe60440c67d83"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#a13c61b0dbe112df0eca5960e378f35c5">operator=</a> (const <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a> &amp;rhs)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Assignment operator duplicates all internal data, including parallel mode.  <a href="#a13c61b0dbe112df0eca5960e378f35c5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#aab19edd439fc4c1124ca533ad1146381">operator==</a> (const <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a> &amp;rhs) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Equality comparison.  <a href="#aab19edd439fc4c1124ca533ad1146381"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#ac944ca2251fa1c7ac06c5570919ae734">operator!=</a> (const <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a> &amp;rhs) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Inequality comparison.  <a href="#ac944ca2251fa1c7ac06c5570919ae734"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#af26bd3d728ba0f8094ee6b9acb593040">invalidateGlobalData</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets d_global_data_up_to_date to false. Must be called after calls to addBox or eraseBox.  <a href="#af26bd3d728ba0f8094ee6b9acb593040"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#a8ce8fadb18fcfcdd48f1b373a1b979a8">clearPersistentOverlapConnectors</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Deallocate persistent overlap Connectors, if there are any.  <a href="#a8ce8fadb18fcfcdd48f1b373a1b979a8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">Connector</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#ad4ef30985671aaeac06be82bf7a238cb">findConnector</a> (const <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a> &amp;head, const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;min_connector_width, <a class="el" href="namespaceSAMRAI_1_1hier.html#a256cef944748f7494c84017f5829101a">ConnectorNotFoundAction</a> not_found_action, bool exact_width_only=false) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Find an overlap <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html" title="A container which holds relationship connections between two BoxLevels.">Connector</a> with the given head and minimum <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html" title="A container which holds relationship connections between two BoxLevels.">Connector</a> width. If the specified <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html" title="A container which holds relationship connections between two BoxLevels.">Connector</a> is not found, take the specified action.  <a href="#ad4ef30985671aaeac06be82bf7a238cb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">Connector</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#a9ef122b8e4b1c02fa4850a6a81976110">findConnectorWithTranspose</a> (const <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a> &amp;head, const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;min_connector_width, const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;transpose_min_connector_width, <a class="el" href="namespaceSAMRAI_1_1hier.html#a256cef944748f7494c84017f5829101a">ConnectorNotFoundAction</a> not_found_action, bool exact_width_only=false) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Find an overlap <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html" title="A container which holds relationship connections between two BoxLevels.">Connector</a> with its transpose with the given head and minimum <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html" title="A container which holds relationship connections between two BoxLevels.">Connector</a> widths. If the specified <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html" title="A container which holds relationship connections between two BoxLevels.">Connector</a> is not found, take the specified action.  <a href="#a9ef122b8e4b1c02fa4850a6a81976110"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">Connector</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#a02aa235c3d2e5b9700a81e6853294fb7">createConnector</a> (const <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a> &amp;head, const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;connector_width) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create an overlap <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html" title="A container which holds relationship connections between two BoxLevels.">Connector</a>, computing relationships by globalizing data.  <a href="#a02aa235c3d2e5b9700a81e6853294fb7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">Connector</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#a85bf92f1e262d7e182442aa09316640d">createConnectorWithTranspose</a> (const <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a> &amp;head, const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;connector_width, const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;transpose_connector_width) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create an overlap <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html" title="A container which holds relationship connections between two BoxLevels.">Connector</a> with its transpose, computing relationships by globalizing data.  <a href="#a85bf92f1e262d7e182442aa09316640d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#a6caf4ac1f3c3b137a4bc890e3680c710">cacheConnector</a> (boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">Connector</a> &gt; &amp;connector) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Cache the supplied overlap <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html" title="A container which holds relationship connections between two BoxLevels.">Connector</a> and its transpose if it exists.  <a href="#a6caf4ac1f3c3b137a4bc890e3680c710"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#a5843797f8b24c016bb92eb4b963f65ac">hasConnector</a> (const <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a> &amp;head, const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;min_connector_width, bool exact_width_only=false) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns whether the object has overlap Connectors with the given head and minimum <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html" title="A container which holds relationship connections between two BoxLevels.">Connector</a> width.  <a href="#a5843797f8b24c016bb92eb4b963f65ac"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const boost::shared_ptr<br class="typebreak"/>
&lt; <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevelHandle.html">BoxLevelHandle</a> &gt; &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#ad28ae9914fffcd6712061af51e0fbfef">getBoxLevelHandle</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the handle with which Connectors reference the <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html" title="A distributed set of Box objects which reside in the same index space.">BoxLevel</a> instead of referencing the <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html" title="A distributed set of Box objects which reside in the same index space.">BoxLevel</a> itself. Not for general use.  <a href="#ad28ae9914fffcd6712061af51e0fbfef"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#add9723ad7a88b27b00f7a691d6eb2e0c">lock</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Effectively makes a non-const <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html" title="A distributed set of Box objects which reside in the same index space.">BoxLevel</a> const. Prevents any non-const method from executing.  <a href="#add9723ad7a88b27b00f7a691d6eb2e0c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#a8f53858f6a358760477cbf8f42615b1c">locked</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns true if the <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html" title="A distributed set of Box objects which reside in the same index space.">BoxLevel</a> is locked.  <a href="#a8f53858f6a358760477cbf8f42615b1c"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Initialization and clearing methods</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrpafc8f3502deb26782605c28ae8508973"></a> </p>
<br/><br/></div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#a9b206530a59ce546b1bdbea4aa1dd5fc">initialize</a> (const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;ratio, const boost::shared_ptr&lt; const <a class="el" href="classSAMRAI_1_1hier_1_1BaseGridGeometry.html">BaseGridGeometry</a> &gt; &amp;grid_geom, const <a class="el" href="classSAMRAI_1_1tbox_1_1SAMRAI__MPI.html">tbox::SAMRAI_MPI</a> &amp;mpi=tbox::SAMRAI_MPI::getSAMRAIWorld(), const <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#a02c34699888ab34b06f59a210247bcb4">ParallelState</a> parallel_state=DISTRIBUTED)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Initialize the <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html" title="A distributed set of Box objects which reside in the same index space.">BoxLevel</a> without and Boxes.  <a href="#a9b206530a59ce546b1bdbea4aa1dd5fc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#ab1fd7baf5161fcdbbb830480f3f77293">swapInitialize</a> (<a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a> &amp;boxes, const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;ratio, const boost::shared_ptr&lt; const <a class="el" href="classSAMRAI_1_1hier_1_1BaseGridGeometry.html">BaseGridGeometry</a> &gt; &amp;grid_geom, const <a class="el" href="classSAMRAI_1_1tbox_1_1SAMRAI__MPI.html">tbox::SAMRAI_MPI</a> &amp;mpi=tbox::SAMRAI_MPI::getSAMRAIWorld(), const <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#a02c34699888ab34b06f59a210247bcb4">ParallelState</a> parallel_state=DISTRIBUTED)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Initialize the <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html" title="A distributed set of Box objects which reside in the same index space.">BoxLevel</a>.  <a href="#ab1fd7baf5161fcdbbb830480f3f77293"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#ad1993c509749c5b3e92c0c534a51e9fd">finalize</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Removes non-local boxes; computes bounding box, local number of boxes, local number of cells, max/min box size. To be called after all Boxes in a <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html" title="A distributed set of Box objects which reside in the same index space.">BoxLevel</a> have been added to indicate that the <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html" title="A distributed set of Box objects which reside in the same index space.">BoxLevel</a> is fully defined and ready to be used.  <a href="#ad1993c509749c5b3e92c0c534a51e9fd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#ab5f4c8b090dbff0226e778e316b21920">isInitialized</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns True if the object has been initialized.  <a href="#ab5f4c8b090dbff0226e778e316b21920"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#a2b2aeafd75c199736c5e2ed21dc015b3">removePeriodicImageBoxes</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Remove all the periodic image boxes in the <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html" title="A distributed set of Box objects which reside in the same index space.">BoxLevel</a>.  <a href="#a2b2aeafd75c199736c5e2ed21dc015b3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#ad1e2b6cbb81383c7661222048edd103c">clear</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Clear the internal state of the <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html" title="A distributed set of Box objects which reside in the same index space.">BoxLevel</a>.  <a href="#ad1e2b6cbb81383c7661222048edd103c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#aa94cf056421d4661cb39f485dd236ba3">clearForBoxChanges</a> (bool isInvalid=true)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Clear the globalized version and the persistent overlap connectors for data consistency.  <a href="#aa94cf056421d4661cb39f485dd236ba3"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Parallelism</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrp374424d359c920b4d388c77660224bd7"></a> </p>
<br/><br/></div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#a68a7c6544286b59ab1508695cadc0c99">setParallelState</a> (const <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#a02c34699888ab34b06f59a210247bcb4">ParallelState</a> parallel_state)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the parallel state.  <a href="#a68a7c6544286b59ab1508695cadc0c99"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#a02c34699888ab34b06f59a210247bcb4">ParallelState</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#ae0f03563c8ba07e61c0262ebac27b6c2">getParallelState</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the ParallelState of the object.  <a href="#ae0f03563c8ba07e61c0262ebac27b6c2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#a88d752dca7dd51b8c1b0b0aa27c3d64e">cacheGlobalReducedData</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">If global reduced data (global <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> count, global cell count and global bounding box) have not been updated, compute and cache them (communication required).  <a href="#a88d752dca7dd51b8c1b0b0aa27c3d64e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#a257e30e9541d393912b74e66e3f1393d">getGlobalizedVersion</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the globalized version of the <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html" title="A distributed set of Box objects which reside in the same index space.">BoxLevel</a>, creating it if needed.  <a href="#a257e30e9541d393912b74e66e3f1393d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#a0394ad7edaca17db2b72deefec2ecf3d">deallocateGlobalizedVersion</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Deallocate the internal globalized version of the <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html" title="A distributed set of Box objects which reside in the same index space.">BoxLevel</a>, if there is any.  <a href="#a0394ad7edaca17db2b72deefec2ecf3d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classSAMRAI_1_1tbox_1_1SAMRAI__MPI.html">tbox::SAMRAI_MPI</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#aa56ee65e5e67d58f580b4a6a700c431f">getMPI</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the SAMRAI_MPI communicator over which the Boxes are distributed.  <a href="#aa56ee65e5e67d58f580b4a6a700c431f"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Accessors</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrp04cb611d2bf0c8edd5b113799b30e174"></a> </p>
<br/><br/></div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#a1e75df2ef751e7ed7f42c9e9a0991fa3">getBoxes</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the container of local Boxes.  <a href="#a1e75df2ef751e7ed7f42c9e9a0991fa3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#afe03004a023ac5e76e01aef59fd6a612">getGlobalBoxes</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the container of global Boxes.  <a href="#afe03004a023ac5e76e01aef59fd6a612"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#a621aa4df7351bf32b53dcc2258890415">getGlobalBoxes</a> (<a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a> &amp;global_boxes) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Fill the container with the global Boxes.  <a href="#a621aa4df7351bf32b53dcc2258890415"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSAMRAI_1_1hier_1_1LocalId.html">LocalId</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#a153e6634835c71dcb5643609112995e6">getFirstLocalId</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the first <a class="el" href="classSAMRAI_1_1hier_1_1LocalId.html" title="Generic identifier for identifying things on the local process.">LocalId</a>, or one with a value of -1 if no local <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> exists.  <a href="#a153e6634835c71dcb5643609112995e6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSAMRAI_1_1hier_1_1LocalId.html">LocalId</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#aba0e4564fd0ccd65a4e91c0326b38789">getLastLocalId</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the last <a class="el" href="classSAMRAI_1_1hier_1_1LocalId.html" title="Generic identifier for identifying things on the local process.">LocalId</a>, or one with a value of -1 if no local <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> exists.  <a href="#aba0e4564fd0ccd65a4e91c0326b38789"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#a769ce9dbc1523384d0092a33aa0e5dbf">getRefinementRatio</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get const access to BoxLevel's refinement ratio (with respect to a reference level).  <a href="#a769ce9dbc1523384d0092a33aa0e5dbf"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#aa6bcc7e11f0cf5d80a6ac2cff54e4616">getLocalNumberOfBoxes</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return local number of boxes.  <a href="#aa6bcc7e11f0cf5d80a6ac2cff54e4616"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#afbf2d7a554955a940ba105cf9d22f988">getLocalNumberOfBoxes</a> (int rank) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return number of boxes local to the given rank.  <a href="#afbf2d7a554955a940ba105cf9d22f988"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#ad4838ed2fd92a444d15c5b01e069a898">getGlobalNumberOfBoxes</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return global number of Boxes.  <a href="#ad4838ed2fd92a444d15c5b01e069a898"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#a799ad52b977646d3c095c25463d4d15b">getMaxNumberOfBoxes</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return maximum number of Boxes over all processes.  <a href="#a799ad52b977646d3c095c25463d4d15b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#a922bbd77b18facc9efe362166f9f0a1c">getMinNumberOfBoxes</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return maximum number of Boxes over all processes.  <a href="#a922bbd77b18facc9efe362166f9f0a1c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#ac5422e0dc4aa9d6d58106895ff02bac4">getLocalNumberOfCells</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return local number of cells.  <a href="#ac5422e0dc4aa9d6d58106895ff02bac4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#ac581ae5959face79ca144e680c6b7055">getMaxNumberOfCells</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return maximum number of cells over all processes.  <a href="#ac581ae5959face79ca144e680c6b7055"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#ad6f98b4539ae7b7a8d5aa7ab859a1648">getMinNumberOfCells</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return maximum number of cells over all processes.  <a href="#ad6f98b4539ae7b7a8d5aa7ab859a1648"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#ac163b80b716511ad09233ffb5576c87e">getLocalNumberOfCells</a> (int rank) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return number of cells local to the given rank.  <a href="#ac163b80b716511ad09233ffb5576c87e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">long int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#aafc96890ca6771f8580bb155cbddb2b3">getGlobalNumberOfCells</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return global number of cells.  <a href="#aafc96890ca6771f8580bb155cbddb2b3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#aa0e3992e8720b4df0bdbbca45546fc1f">getLocalBoundingBox</a> (int block_number) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return bounding box for local Boxes in a block.  <a href="#aa0e3992e8720b4df0bdbbca45546fc1f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#a9deaa634cf3fe5ab246fe7aca0d70a43">getGlobalBoundingBox</a> (int block_number) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return bounding box for global Boxes in a block.  <a href="#a9deaa634cf3fe5ab246fe7aca0d70a43"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#a38cd4acb77caa36d41515252db0e1102">getLocalMaxBoxSize</a> (int block_number) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return size of the largest local <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> in a block.  <a href="#a38cd4acb77caa36d41515252db0e1102"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#ac1e3b956ec5dd8504d7375960545755c">getLocalMinBoxSize</a> (int block_number) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return size of the smallest local <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> in a block.  <a href="#ac1e3b956ec5dd8504d7375960545755c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#a27a9f68acbf0a41fae9538cfa249406a">getGlobalMaxBoxSize</a> (int block_number) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return size of the largest <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> globally in a block.  <a href="#a27a9f68acbf0a41fae9538cfa249406a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#a38e7e581ec5d2ceb7f0130eca279a84f">getGlobalMinBoxSize</a> (int block_number) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return size of the smallest <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> globally in a block.  <a href="#a38e7e581ec5d2ceb7f0130eca279a84f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classSAMRAI_1_1tbox_1_1Dimension.html">tbox::Dimension</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#a9a051730fadf4671bf844259fe45fd39">getDim</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the dimension of this object.  <a href="#a9a051730fadf4671bf844259fe45fd39"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const boost::shared_ptr&lt; const <br class="typebreak"/>
<a class="el" href="classSAMRAI_1_1hier_1_1BaseGridGeometry.html">BaseGridGeometry</a> &gt; &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#aec78d23ef813cea9c1f08b30d6cec25f">getGridGeometry</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the grid geometry associated with this object.  <a href="#aec78d23ef813cea9c1f08b30d6cec25f"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Methods to modify all Boxes.</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrpba0bd31a8566dcc6d95c161c18dd6f82"></a> </p>
<br/><br/></div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#af9d572999cb352e26876d5641c89f28c">refineBoxes</a> (<a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a> &amp;finer, const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;ratio, const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;final_ratio) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Refine all Boxes of this <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html" title="A distributed set of Box objects which reside in the same index space.">BoxLevel</a> by ratio placing result into finer making finer's ratio final_ratio.  <a href="#af9d572999cb352e26876d5641c89f28c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#a6d08a9ac95f9c25ffb319bbc0e79f7b1">coarsenBoxes</a> (<a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a> &amp;coarser, const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;ratio, const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;final_ratio) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Coarsen all Boxes of this <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html" title="A distributed set of Box objects which reside in the same index space.">BoxLevel</a> by ratio placing result into coarser making coarser's ratio final_ratio.  <a href="#a6d08a9ac95f9c25ffb319bbc0e79f7b1"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Individual Box methods.</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrp606d2612d4bb55314a54064cf57480a0"></a> </p>
<br/><br/></div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer_1_1BoxContainerConstIterator.html">BoxContainer::const_iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#a7f03d7672157b32ea927b73751663872">addBox</a> (const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> &amp;box, const <a class="el" href="classSAMRAI_1_1hier_1_1BlockId.html">BlockId</a> &amp;block_id)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create new local <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> from given <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> and add it to this level.  <a href="#a7f03d7672157b32ea927b73751663872"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#a7a80e5adb2b547f075125db37be16ff7">addBox</a> (const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> &amp;box)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Add a <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> to this level.  <a href="#a7a80e5adb2b547f075125db37be16ff7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#a7192f8a642329533e870d08ac4affb08">addBoxWithoutUpdate</a> (const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> &amp;box)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Add a <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> to this level without updating summary data such as local number of boxes/cells, bounding box, max/min box size. Meant to be used during the construction of a <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html" title="A distributed set of Box objects which reside in the same index space.">BoxLevel</a> as Boxes belonging to the level are found. <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#ad1993c509749c5b3e92c0c534a51e9fd" title="Removes non-local boxes; computes bounding box, local number of boxes, local number...">finalize()</a> should be called at the end of construction making use of addBoxWithoutUpdate.  <a href="#a7192f8a642329533e870d08ac4affb08"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#a1efaddb0a58895344bfdc03003e1aa9d">addPeriodicBox</a> (const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> &amp;existing_box, const <a class="el" href="classSAMRAI_1_1hier_1_1PeriodicId.html">PeriodicId</a> &amp;shift_number)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Insert given periodic image of an existing <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a>.  <a href="#a1efaddb0a58895344bfdc03003e1aa9d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#a960befb3bc83403345c75c7ed6a177e8">eraseBox</a> (<a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer_1_1BoxContainerIterator.html">BoxContainer::iterator</a> &amp;ibox)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Erase the existing <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> specified by its iterator.  <a href="#a960befb3bc83403345c75c7ed6a177e8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#aac786eaec7c2fa5256f41a685c945257">eraseBox</a> (const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> &amp;box)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Erase the <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> matching the one given.  <a href="#aac786eaec7c2fa5256f41a685c945257"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#a0ee46cb63c7d8409c8688f3700605a98">eraseBoxWithoutUpdate</a> (const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> &amp;box)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Erases the <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> matching the supplied <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> from this level without updating summary data such as local number of boxes/cells, bounding box, max/min box size. Meant to be used during the construction of a <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html" title="A distributed set of Box objects which reside in the same index space.">BoxLevel</a> as Boxes not belonging to the level are found. <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#ad1993c509749c5b3e92c0c534a51e9fd" title="Removes non-local boxes; computes bounding box, local number of boxes, local number...">finalize()</a> should be called at the end of construction making use of eraseBoxWithoutUpdate.  <a href="#a0ee46cb63c7d8409c8688f3700605a98"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer_1_1BoxContainerConstIterator.html">BoxContainer::const_iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#aae14445c8c9e8c06bc7d3132ee490555">getBox</a> (const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> &amp;box) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Find the <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> matching the one given.  <a href="#aae14445c8c9e8c06bc7d3132ee490555"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer_1_1BoxContainerConstIterator.html">BoxContainer::const_iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#a2fc9a3140f7ad64850ad6556d53223ec">getBox</a> (const <a class="el" href="classSAMRAI_1_1hier_1_1BoxId.html">BoxId</a> &amp;box_id) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Find the <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> specified by the given <a class="el" href="classSAMRAI_1_1hier_1_1BoxId.html" title="Identifier for a Box, consisting of a GlobalId and a PeriodicId.">BoxId</a> and periodic shift.  <a href="#a2fc9a3140f7ad64850ad6556d53223ec"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer_1_1BoxContainerConstIterator.html">BoxContainer::const_iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#aeb1f97fa84af6ba5c273c64c0ea0c80c">getBoxStrict</a> (const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> &amp;box) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Find the <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> matching the one given.  <a href="#aeb1f97fa84af6ba5c273c64c0ea0c80c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer_1_1BoxContainerConstIterator.html">BoxContainer::const_iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#a5d59700b00e6da268bf003a842f626ee">getBoxStrict</a> (const <a class="el" href="classSAMRAI_1_1hier_1_1BoxId.html">BoxId</a> &amp;box_id) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Find the <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> specified by the given <a class="el" href="classSAMRAI_1_1hier_1_1BoxId.html" title="Identifier for a Box, consisting of a GlobalId and a PeriodicId.">BoxId</a>.  <a href="#a5d59700b00e6da268bf003a842f626ee"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#ac33526f84722654e4eec9ef11093aaac">getSpatiallyEqualBox</a> (const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> &amp;box_to_match, const <a class="el" href="classSAMRAI_1_1hier_1_1BlockId.html">BlockId</a> &amp;block_id, <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> &amp;matching_box) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Find the <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> with the given <a class="el" href="classSAMRAI_1_1hier_1_1BlockId.html" title="Generic identifier for identifying the block id.">BlockId</a> which is spatially equal to the supplied <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a>.  <a href="#ac33526f84722654e4eec9ef11093aaac"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#aa36386f372e60084d09119c9e8c36718">hasBox</a> (const <a class="el" href="classSAMRAI_1_1hier_1_1BoxId.html">BoxId</a> &amp;box_id) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns true when the object has a <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> specified by the <a class="el" href="classSAMRAI_1_1hier_1_1BoxId.html" title="Identifier for a Box, consisting of a GlobalId and a PeriodicId.">BoxId</a>.  <a href="#aa36386f372e60084d09119c9e8c36718"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#a1d8a2324f2425898efad09a23f1f61f6">hasBox</a> (const <a class="el" href="classSAMRAI_1_1hier_1_1GlobalId.html">GlobalId</a> &amp;global_id, const <a class="el" href="classSAMRAI_1_1hier_1_1PeriodicId.html">PeriodicId</a> &amp;periodic_id) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns true when the object has a <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> consistent with all of the arguments.  <a href="#a1d8a2324f2425898efad09a23f1f61f6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#a3b57ea9786676c090d5619abde08bd63">hasBox</a> (const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> &amp;box) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns true when this <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html" title="A distributed set of Box objects which reside in the same index space.">BoxLevel</a> has a <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> matching the <a class="el" href="classSAMRAI_1_1hier_1_1BoxId.html" title="Identifier for a Box, consisting of a GlobalId and a PeriodicId.">BoxId</a> of the given box.  <a href="#a3b57ea9786676c090d5619abde08bd63"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">IO support.</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrp9aa4bbf234a0ba09f9c7cb444fde5cbc"></a> </p>
<br/><br/></div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#a8ec0ee23695893a76962ad8a8922f2a1">putToRestart</a> (const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Database.html">tbox::Database</a> &gt; &amp;restart_db) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Write the <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html" title="A distributed set of Box objects which reside in the same index space.">BoxLevel</a> to a restart database.  <a href="#a8ec0ee23695893a76962ad8a8922f2a1"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Methods for outputs, error checking and debugging.</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrp07fc647c021b02262ecaa0771f6fba5c"></a> </p>
<br/><br/></div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#a00c11404f06b3a72323cb3fc5d650309">recursivePrint</a> (std::ostream &amp;os, const std::string &amp;border, int detail_depth=2) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Print <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> info from this level.  <a href="#a00c11404f06b3a72323cb3fc5d650309"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel_1_1Outputter.html">Outputter</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#aef7ffb368ef636b78732ba7b64c51277">format</a> (const std::string &amp;border=std::string(), int detail_depth=2) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return a object that can format the <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html" title="A distributed set of Box objects which reside in the same index space.">BoxLevel</a> for inserting into output streams.  <a href="#aef7ffb368ef636b78732ba7b64c51277"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel_1_1Outputter.html">Outputter</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#a0358ed57086330055c464956136feac8">formatStatistics</a> (const std::string &amp;border=std::string()) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return a object that can format the <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html" title="A distributed set of Box objects which reside in the same index space.">BoxLevel</a> for inserting its global statistics into output streams.  <a href="#a0358ed57086330055c464956136feac8"></a><br/></td></tr>
<tr><td colspan="2"><h2>Static Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#a9eebd53c534a0b42c59cf9cb08f2777e">swap</a> (<a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a> &amp;level_a, <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a> &amp;level_b)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Swap the contents of two <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html" title="A distributed set of Box objects which reside in the same index space.">BoxLevel</a> objects.  <a href="#a9eebd53c534a0b42c59cf9cb08f2777e"></a><br/></td></tr>
<tr><td colspan="2"><h2>Friends</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#ae17fc1942f6de54c13321a9481366cd1">PersistentOverlapConnectors</a></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>A distributed set of <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> objects which reside in the same index space. </p>
<p>TODO: Are we eliminating DLBG terminology?</p>
<p>This class is a part of the distributed layered box graph (DLBG) for managing SAMR meshes in parallel. A <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html" title="A distributed set of Box objects which reside in the same index space.">BoxLevel</a> is a set of boxes in the same index space. Relationships (e.g., neighbor adjacency) among boxes is contained in a <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html" title="A container which holds relationship connections between two BoxLevels.">Connector</a> object. Also, each <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html" title="A distributed set of Box objects which reside in the same index space.">BoxLevel</a> has an refinement ratio vector describing the relationship of the index space to that of a reference level in a patch hierarchy (typically the coarsest level or level zero).</p>
<p>Like a <a class="el" href="classSAMRAI_1_1hier_1_1PatchLevel.html" title="Container class for patches defined at a single level of the AMR hierarchy.">PatchLevel</a>, a <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html" title="A distributed set of Box objects which reside in the same index space.">BoxLevel</a> is a parallel object. The Boxes of a <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html" title="A distributed set of Box objects which reside in the same index space.">BoxLevel</a> may be distributed across all the processors in an MPI communicator and can be in one of two parallel states:</p>
<ul>
<li><b>DISTRIBUTED:</b> Each MPI process knows only the Boxes in the set that are "owned" by that process. This is analogous to a <a class="el" href="classSAMRAI_1_1hier_1_1PatchLevel.html" title="Container class for patches defined at a single level of the AMR hierarchy.">PatchLevel</a> which owns only the Patches that reside on a process.</li>
</ul>
<ul>
<li><b>GLOBALIZED:</b> All processes know all Boxes in the set. This is analogous to <a class="el" href="classSAMRAI_1_1hier_1_1PatchLevel.html" title="Container class for patches defined at a single level of the AMR hierarchy.">PatchLevel</a> <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html" title="A container for Boxes.">BoxContainer</a> state when it is globalized (<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classSAMRAI_1_1hier_1_1PatchLevel.html#ad425bff9332a3eb2bbfb7509ccf13dc9" title="Get the box defining the patches on the level.">PatchLevel::getBoxes()</a>).</dd></dl>
<dl class="user"><dt><b>Performance notes</b></dt><dd><ul>
<li>
<p class="startli">The parallel state is changed by calling <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#a68a7c6544286b59ab1508695cadc0c99" title="Set the parallel state.">setParallelState()</a>. Going from DISTRIBUTED to GLOBALIZED state is an expensive operation requiring all-to-all communication. Using this state can incur a significant performance penalty.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">The GLOBALIZED state requires more memory.</p>
<p class="endli"></p>
</li>
<li>
Transitioning from GLOBALIZED state to DISTRIBUTED state is cheap. </li>
</ul>
</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>The general attributes of a <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html" title="A distributed set of Box objects which reside in the same index space.">BoxLevel</a> are <ul>
<li>
the set of <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> objects with unique BoxIds, </li>
<li>
the refinement ratio defining their index space, and </li>
<li>
the parallel state. </li>
</ul>
</dd></dl>
<a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> object uniqueness is based on the <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> equality operator, which compares owner MPI ranks and local indices. Therefore, a valid <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html" title="A distributed set of Box objects which reside in the same index space.">BoxLevel</a> does not contain two Boxes with the same owner and index. </li>
</ul>
<hr/><h2>Member Enumeration Documentation</h2>
<a class="anchor" id="a02c34699888ab34b06f59a210247bcb4"></a><!-- doxytag: member="SAMRAI::hier::BoxLevel::ParallelState" ref="a02c34699888ab34b06f59a210247bcb4" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#a02c34699888ab34b06f59a210247bcb4">SAMRAI::hier::BoxLevel::ParallelState</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Names of parallel states. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="a02c34699888ab34b06f59a210247bcb4a50fcdd33dde8ec1597aa318dcb384578"></a><!-- doxytag: member="DISTRIBUTED" ref="a02c34699888ab34b06f59a210247bcb4a50fcdd33dde8ec1597aa318dcb384578" args="" -->DISTRIBUTED</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a02c34699888ab34b06f59a210247bcb4a2dbf00b87512ae236e2dbde25acb952f"></a><!-- doxytag: member="GLOBALIZED" ref="a02c34699888ab34b06f59a210247bcb4a2dbf00b87512ae236e2dbde25acb952f" args="" -->GLOBALIZED</em>&nbsp;</td><td>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a35b7fce14d4b31de23aa5d5bdf1a472e"></a><!-- doxytag: member="SAMRAI::hier::BoxLevel::BoxLevel" ref="a35b7fce14d4b31de23aa5d5bdf1a472e" args="(const tbox::Dimension &amp;dim, tbox::Database &amp;restart_db, const boost::shared_ptr&lt; const BaseGridGeometry &gt; &amp;grid_geom)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SAMRAI::hier::BoxLevel::BoxLevel </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1tbox_1_1Dimension.html">tbox::Dimension</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>dim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1tbox_1_1Database.html">tbox::Database</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>restart_db</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const boost::shared_ptr&lt; const <a class="el" href="classSAMRAI_1_1hier_1_1BaseGridGeometry.html">BaseGridGeometry</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>grid_geom</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Construct a <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html" title="A distributed set of Box objects which reside in the same index space.">BoxLevel</a> which will be initialized from the supplied restart database. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>dim</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>restart_db</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>grid_geom</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab8771dd90200a99a9e60cb6b356fcecf"></a><!-- doxytag: member="SAMRAI::hier::BoxLevel::BoxLevel" ref="ab8771dd90200a99a9e60cb6b356fcecf" args="(const BoxLevel &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SAMRAI::hier::BoxLevel::BoxLevel </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Copy constructor. </p>
<p>New object has the same parallel state as original.</p>
<p>Persistent Connectors are not duplicated. This decision was based on expected usage, which is that copies are either for short term usage or meant to be changed in some way and will invalidate Connectors.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>rhs</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af19ca6a464561b4f23133b91d77d4470"></a><!-- doxytag: member="SAMRAI::hier::BoxLevel::BoxLevel" ref="af19ca6a464561b4f23133b91d77d4470" args="(const IntVector &amp;ratio, const boost::shared_ptr&lt; const BaseGridGeometry &gt; &amp;grid_geom, const tbox::SAMRAI_MPI &amp;mpi=tbox::SAMRAI_MPI::getSAMRAIWorld(), const ParallelState parallel_state=DISTRIBUTED)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SAMRAI::hier::BoxLevel::BoxLevel </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>ratio</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const boost::shared_ptr&lt; const <a class="el" href="classSAMRAI_1_1hier_1_1BaseGridGeometry.html">BaseGridGeometry</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>grid_geom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1tbox_1_1SAMRAI__MPI.html">tbox::SAMRAI_MPI</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>mpi</em> = <code>tbox::SAMRAI_MPI::getSAMRAIWorld()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#a02c34699888ab34b06f59a210247bcb4">ParallelState</a>&nbsp;</td>
          <td class="paramname"> <em>parallel_state</em> = <code>DISTRIBUTED</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Constructs an empty, initialized object. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#a7f03d7672157b32ea927b73751663872" title="Create new local Box from given Box and add it to this level.">addBox()</a> </dd>
<dd>
<a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#a9b206530a59ce546b1bdbea4aa1dd5fc" title="Initialize the BoxLevel without and Boxes.">initialize()</a></dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>ratio</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>grid_geom</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>mpi</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>parallel_state</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="BoxLevel_8C_source.html#l00225">initialize()</a>.</p>

</div>
</div>
<a class="anchor" id="a962662fdff601ac5bc5fe60440c67d83"></a><!-- doxytag: member="SAMRAI::hier::BoxLevel::~BoxLevel" ref="a962662fdff601ac5bc5fe60440c67d83" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SAMRAI::hier::BoxLevel::~BoxLevel </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Destructor. </p>
<p>Deallocate internal data. </p>

<p>References <a class="el" href="BoxLevel_8C_source.html#l00408">clear()</a>.</p>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a9b206530a59ce546b1bdbea4aa1dd5fc"></a><!-- doxytag: member="SAMRAI::hier::BoxLevel::initialize" ref="a9b206530a59ce546b1bdbea4aa1dd5fc" args="(const IntVector &amp;ratio, const boost::shared_ptr&lt; const BaseGridGeometry &gt; &amp;grid_geom, const tbox::SAMRAI_MPI &amp;mpi=tbox::SAMRAI_MPI::getSAMRAIWorld(), const ParallelState parallel_state=DISTRIBUTED)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::hier::BoxLevel::initialize </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>ratio</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const boost::shared_ptr&lt; const <a class="el" href="classSAMRAI_1_1hier_1_1BaseGridGeometry.html">BaseGridGeometry</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>grid_geom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1tbox_1_1SAMRAI__MPI.html">tbox::SAMRAI_MPI</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>mpi</em> = <code>tbox::SAMRAI_MPI::getSAMRAIWorld()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#a02c34699888ab34b06f59a210247bcb4">ParallelState</a>&nbsp;</td>
          <td class="paramname"> <em>parallel_state</em> = <code>DISTRIBUTED</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Initialize the <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html" title="A distributed set of Box objects which reside in the same index space.">BoxLevel</a> without and Boxes. </p>
<p>The content and state of the object before calling this function is discarded.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#a7f03d7672157b32ea927b73751663872" title="Create new local Box from given Box and add it to this level.">addBox()</a> </dd>
<dd>
initialize(const BoxContainer&amp;, const IntVector&amp;, const tbox::SAMRAI_MPI&amp;, const ParallelState)</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>ratio</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>grid_geom</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>mpi</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>parallel_state</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="BoxContainer_8h_source.html#l00860">SAMRAI::hier::BoxContainer::clear()</a>, <a class="el" href="BoxLevel_8h_source.html#l01587">locked()</a>, <a class="el" href="BoxContainer_8C_source.html#l01416">SAMRAI::hier::BoxContainer::order()</a>, and <a class="el" href="Utilities_8h_source.html#l00060">TBOX_ERROR</a>.</p>

<p>Referenced by <a class="el" href="BoxLevel_8C_source.html#l00127">BoxLevel()</a>, and <a class="el" href="ChopAndPackLoadBalancer_8C_source.html#l00254">SAMRAI::mesh::ChopAndPackLoadBalancer::loadBalanceBoxLevel()</a>.</p>

</div>
</div>
<a class="anchor" id="ab1fd7baf5161fcdbbb830480f3f77293"></a><!-- doxytag: member="SAMRAI::hier::BoxLevel::swapInitialize" ref="ab1fd7baf5161fcdbbb830480f3f77293" args="(BoxContainer &amp;boxes, const IntVector &amp;ratio, const boost::shared_ptr&lt; const BaseGridGeometry &gt; &amp;grid_geom, const tbox::SAMRAI_MPI &amp;mpi=tbox::SAMRAI_MPI::getSAMRAIWorld(), const ParallelState parallel_state=DISTRIBUTED)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::hier::BoxLevel::swapInitialize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>boxes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>ratio</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const boost::shared_ptr&lt; const <a class="el" href="classSAMRAI_1_1hier_1_1BaseGridGeometry.html">BaseGridGeometry</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>grid_geom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1tbox_1_1SAMRAI__MPI.html">tbox::SAMRAI_MPI</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>mpi</em> = <code>tbox::SAMRAI_MPI::getSAMRAIWorld()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#a02c34699888ab34b06f59a210247bcb4">ParallelState</a>&nbsp;</td>
          <td class="paramname"> <em>parallel_state</em> = <code>DISTRIBUTED</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Initialize the <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html" title="A distributed set of Box objects which reside in the same index space.">BoxLevel</a>. </p>
<p>Similar to initialize(const BoxContainer&amp;, const IntVector&amp;, const tbox::SAMRAI_MPI&amp;, const ParallelState), except that the <code>boxes</code> are mutable.</p>
<p>The state of the object before calling this function is discarded. The <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> content before calling this function is returned via the <code>boxes</code> argument.</p>
<dl class="see"><dt><b>See also:</b></dt><dd>initializePrivate()</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>boxes</em>&nbsp;</td><td>On input, this should contain the Boxes to place in the <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html" title="A distributed set of Box objects which reside in the same index space.">BoxLevel</a>. On output, it contains the Boxes that were in the <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html" title="A distributed set of Box objects which reside in the same index space.">BoxLevel</a> before the call.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>boxes</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>ratio</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>grid_geom</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>mpi</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>parallel_state</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>&amp;boxes != &amp;<a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#a1e75df2ef751e7ed7f42c9e9a0991fa3" title="Returns the container of local Boxes.">getBoxes()</a> </dd></dl>

<p>References <a class="el" href="BoxLevel_8h_source.html#l01587">locked()</a>, <a class="el" href="BoxContainer_8C_source.html#l01416">SAMRAI::hier::BoxContainer::order()</a>, <a class="el" href="BoxContainer_8h_source.html#l00877">SAMRAI::hier::BoxContainer::swap()</a>, <a class="el" href="Utilities_8h_source.html#l00110">TBOX_ASSERT</a>, and <a class="el" href="Utilities_8h_source.html#l00060">TBOX_ERROR</a>.</p>

</div>
</div>
<a class="anchor" id="ad1993c509749c5b3e92c0c534a51e9fd"></a><!-- doxytag: member="SAMRAI::hier::BoxLevel::finalize" ref="ad1993c509749c5b3e92c0c534a51e9fd" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::hier::BoxLevel::finalize </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Removes non-local boxes; computes bounding box, local number of boxes, local number of cells, max/min box size. To be called after all Boxes in a <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html" title="A distributed set of Box objects which reside in the same index space.">BoxLevel</a> have been added to indicate that the <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html" title="A distributed set of Box objects which reside in the same index space.">BoxLevel</a> is fully defined and ready to be used. </p>

<p>References <a class="el" href="BoxContainer_8h_source.html#l00701">SAMRAI::hier::BoxContainer::begin()</a>, <a class="el" href="BoxContainer_8h_source.html#l00712">SAMRAI::hier::BoxContainer::end()</a>, <a class="el" href="BoxContainer_8C_source.html#l01456">SAMRAI::hier::BoxContainer::erase()</a>, <a class="el" href="SAMRAI__MPI_8h_source.html#l00214">SAMRAI::tbox::SAMRAI_MPI::getRank()</a>, <a class="el" href="BoxLevel_8h_source.html#l01587">locked()</a>, and <a class="el" href="Utilities_8h_source.html#l00060">TBOX_ERROR</a>.</p>

<p>Referenced by <a class="el" href="BoxLevelConnectorUtils_8C_source.html#l01210">SAMRAI::hier::BoxLevelConnectorUtils::addPeriodicImages()</a>.</p>

</div>
</div>
<a class="anchor" id="ab5f4c8b090dbff0226e778e316b21920"></a><!-- doxytag: member="SAMRAI::hier::BoxLevel::isInitialized" ref="ab5f4c8b090dbff0226e778e316b21920" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SAMRAI::hier::BoxLevel::isInitialized </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns True if the object has been initialized. </p>

<p>Referenced by <a class="el" href="BoxLevelStatistics_8C_source.html#l00044">SAMRAI::hier::BoxLevelStatistics::BoxLevelStatistics()</a>, <a class="el" href="BoxLevel_8C_source.html#l00567">cacheGlobalReducedData()</a>, <a class="el" href="BoxLevel_8C_source.html#l00408">clear()</a>, <a class="el" href="BoxLevel_8C_source.html#l01303">getFirstLocalId()</a>, <a class="el" href="BoxLevel_8C_source.html#l01269">getGlobalizedVersion()</a>, <a class="el" href="BoxLevel_8h_source.html#l00609">getGlobalNumberOfBoxes()</a>, <a class="el" href="BoxLevel_8h_source.html#l00738">getGlobalNumberOfCells()</a>, <a class="el" href="BoxLevel_8C_source.html#l01320">getLastLocalId()</a>, <a class="el" href="BoxLevel_8C_source.html#l00694">getLocalNumberOfBoxes()</a>, <a class="el" href="BoxLevel_8C_source.html#l00723">getLocalNumberOfCells()</a>, <a class="el" href="BoxLevel_8h_source.html#l00629">getMaxNumberOfBoxes()</a>, <a class="el" href="BoxLevel_8h_source.html#l00683">getMaxNumberOfCells()</a>, <a class="el" href="BoxLevel_8h_source.html#l00649">getMinNumberOfBoxes()</a>, <a class="el" href="BoxLevel_8h_source.html#l00703">getMinNumberOfCells()</a>, <a class="el" href="BoxLevel_8C_source.html#l01595">recursivePrint()</a>, <a class="el" href="BoxLevel_8C_source.html#l00384">removePeriodicImageBoxes()</a>, <a class="el" href="Connector_8C_source.html#l00628">SAMRAI::hier::Connector::setBase()</a>, <a class="el" href="Connector_8C_source.html#l00650">SAMRAI::hier::Connector::setHead()</a>, <a class="el" href="BoxLevel_8C_source.html#l00775">setParallelState()</a>, and <a class="el" href="BoxLevel_8C_source.html#l00438">swap()</a>.</p>

</div>
</div>
<a class="anchor" id="a2b2aeafd75c199736c5e2ed21dc015b3"></a><!-- doxytag: member="SAMRAI::hier::BoxLevel::removePeriodicImageBoxes" ref="a2b2aeafd75c199736c5e2ed21dc015b3" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::hier::BoxLevel::removePeriodicImageBoxes </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Remove all the periodic image boxes in the <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html" title="A distributed set of Box objects which reside in the same index space.">BoxLevel</a>. </p>

<p>References <a class="el" href="BoxLevel_8h_source.html#l00263">clearForBoxChanges()</a>, <a class="el" href="BoxLevel_8h_source.html#l00104">GLOBALIZED</a>, <a class="el" href="BoxLevel_8h_source.html#l00227">isInitialized()</a>, <a class="el" href="BoxLevel_8h_source.html#l01587">locked()</a>, <a class="el" href="BoxContainer_8C_source.html#l00580">SAMRAI::hier::BoxContainer::removePeriodicImageBoxes()</a>, and <a class="el" href="Utilities_8h_source.html#l00060">TBOX_ERROR</a>.</p>

<p>Referenced by <a class="el" href="TreeLoadBalancer_8C_source.html#l00165">SAMRAI::mesh::TreeLoadBalancer::loadBalanceBoxLevel()</a>, <a class="el" href="GraphLoadBalancer_8C_source.html#l00072">SAMRAI::mesh::GraphLoadBalancer::loadBalanceBoxLevel()</a>, and <a class="el" href="CascadePartitioner_8C_source.html#l00157">SAMRAI::mesh::CascadePartitioner::loadBalanceBoxLevel()</a>.</p>

</div>
</div>
<a class="anchor" id="ad1e2b6cbb81383c7661222048edd103c"></a><!-- doxytag: member="SAMRAI::hier::BoxLevel::clear" ref="ad1e2b6cbb81383c7661222048edd103c" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::hier::BoxLevel::clear </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Clear the internal state of the <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html" title="A distributed set of Box objects which reside in the same index space.">BoxLevel</a>. </p>
<p>The <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html" title="A distributed set of Box objects which reside in the same index space.">BoxLevel</a> will be in an uninitialized state after a call to this method. </p>

<p>References <a class="el" href="BoxContainer_8h_source.html#l00860">SAMRAI::hier::BoxContainer::clear()</a>, <a class="el" href="BoxLevel_8h_source.html#l00263">clearForBoxChanges()</a>, <a class="el" href="BoxLevel_8h_source.html#l00104">DISTRIBUTED</a>, <a class="el" href="BoxLevel_8h_source.html#l00227">isInitialized()</a>, <a class="el" href="BoxLevel_8h_source.html#l01587">locked()</a>, <a class="el" href="SAMRAI__MPI_8h_source.html#l00037">MPI_COMM_NULL</a>, and <a class="el" href="Utilities_8h_source.html#l00060">TBOX_ERROR</a>.</p>

<p>Referenced by <a class="el" href="BoxLevel_8C_source.html#l00165">~BoxLevel()</a>.</p>

</div>
</div>
<a class="anchor" id="aa94cf056421d4661cb39f485dd236ba3"></a><!-- doxytag: member="SAMRAI::hier::BoxLevel::clearForBoxChanges" ref="aa94cf056421d4661cb39f485dd236ba3" args="(bool isInvalid=true)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::hier::BoxLevel::clearForBoxChanges </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>isInvalid</em> = <code>true</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Clear the globalized version and the persistent overlap connectors for data consistency. </p>
<p>Most of the time, this method is automatically called by methods that know when some data is stale and needs to be cleared. For example, adding a box makes the global number of boxes stale. However, sometimes it is necessary to call this method manually. For example, when only some processes add boxes while others do not, resulting in some processes not knowing that the global number of boxes is inconsistent.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>isInvalid</em>&nbsp;</td><td>A flag indicating that boxes have been (or will be) removed, thus invalidating the handle. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="BoxLevel_8h_source.html#l01330">clearPersistentOverlapConnectors()</a>, <a class="el" href="BoxLevel_8h_source.html#l00363">deallocateGlobalizedVersion()</a>, <a class="el" href="BoxLevel_8h_source.html#l01587">locked()</a>, and <a class="el" href="Utilities_8h_source.html#l00060">TBOX_ERROR</a>.</p>

<p>Referenced by <a class="el" href="BoxLevel_8C_source.html#l00993">addBox()</a>, <a class="el" href="BoxLevel_8C_source.html#l01055">addPeriodicBox()</a>, <a class="el" href="BoxLevelConnectorUtils_8C_source.html#l01270">SAMRAI::hier::BoxLevelConnectorUtils::addPeriodicImagesAndRelationships()</a>, <a class="el" href="BoxLevel_8C_source.html#l00408">clear()</a>, <a class="el" href="BoxLevel_8C_source.html#l01185">eraseBox()</a>, and <a class="el" href="BoxLevel_8C_source.html#l00384">removePeriodicImageBoxes()</a>.</p>

</div>
</div>
<a class="anchor" id="a68a7c6544286b59ab1508695cadc0c99"></a><!-- doxytag: member="SAMRAI::hier::BoxLevel::setParallelState" ref="a68a7c6544286b59ab1508695cadc0c99" args="(const ParallelState parallel_state)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::hier::BoxLevel::setParallelState </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#a02c34699888ab34b06f59a210247bcb4">ParallelState</a>&nbsp;</td>
          <td class="paramname"> <em>parallel_state</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set the parallel state. </p>
<p>This method is potentially expensive. Acquiring remote <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> information (when going to GLOBALIZED mode) triggers all-gather communication. More memory is required to store additional Boxes.</p>
<p>Data not used by the new state gets deallocated.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>parallel_state</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="pre"><dt><b>Precondition:</b></dt><dd><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#ab5f4c8b090dbff0226e778e316b21920" title="Returns True if the object has been initialized.">isInitialized()</a> </dd></dl>

<p>References <a class="el" href="BoxContainer_8h_source.html#l00860">SAMRAI::hier::BoxContainer::clear()</a>, <a class="el" href="BoxLevel_8h_source.html#l00104">DISTRIBUTED</a>, <a class="el" href="BoxLevel_8h_source.html#l00104">GLOBALIZED</a>, <a class="el" href="BoxLevel_8h_source.html#l00227">isInitialized()</a>, <a class="el" href="BoxLevel_8h_source.html#l01587">locked()</a>, and <a class="el" href="Utilities_8h_source.html#l00060">TBOX_ERROR</a>.</p>

<p>Referenced by <a class="el" href="BoxLevel_8C_source.html#l01269">getGlobalizedVersion()</a>, and <a class="el" href="ChopAndPackLoadBalancer_8C_source.html#l00254">SAMRAI::mesh::ChopAndPackLoadBalancer::loadBalanceBoxLevel()</a>.</p>

</div>
</div>
<a class="anchor" id="ae0f03563c8ba07e61c0262ebac27b6c2"></a><!-- doxytag: member="SAMRAI::hier::BoxLevel::getParallelState" ref="ae0f03563c8ba07e61c0262ebac27b6c2" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#a02c34699888ab34b06f59a210247bcb4">ParallelState</a> SAMRAI::hier::BoxLevel::getParallelState </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the ParallelState of the object. </p>

<p>Referenced by <a class="el" href="BoxLevel_8h_source.html#l00991">addBoxWithoutUpdate()</a>, <a class="el" href="Connector_8C_source.html#l01598">SAMRAI::hier::Connector::checkConsistencyWithHead()</a>, <a class="el" href="BoxLevel_8h_source.html#l00363">deallocateGlobalizedVersion()</a>, <a class="el" href="Connector_8C_source.html#l00543">SAMRAI::hier::Connector::finalizeContext()</a>, <a class="el" href="BoxLevel_8h_source.html#l01138">getBox()</a>, <a class="el" href="BoxLevel_8C_source.html#l01269">getGlobalizedVersion()</a>, <a class="el" href="TreeLoadBalancer_8C_source.html#l00165">SAMRAI::mesh::TreeLoadBalancer::loadBalanceBoxLevel()</a>, and <a class="el" href="BoxLevel_8C_source.html#l01595">recursivePrint()</a>.</p>

</div>
</div>
<a class="anchor" id="a88d752dca7dd51b8c1b0b0aa27c3d64e"></a><!-- doxytag: member="SAMRAI::hier::BoxLevel::cacheGlobalReducedData" ref="a88d752dca7dd51b8c1b0b0aa27c3d64e" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::hier::BoxLevel::cacheGlobalReducedData </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>If global reduced data (global <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> count, global cell count and global bounding box) have not been updated, compute and cache them (communication required). </p>
<p>After this method is called, data requiring global reduction can be accessed without further communications, until the object changes.</p>
<p>Sets d_global_data_up_to_date to true;</p>
<dl class="pre"><dt><b>Precondition:</b></dt><dd><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#ab5f4c8b090dbff0226e778e316b21920" title="Returns True if the object has been initialized.">isInitialized()</a> </dd></dl>

<p>References <a class="el" href="SAMRAI__MPI_8C_source.html#l00716">SAMRAI::tbox::SAMRAI_MPI::Allreduce()</a>, <a class="el" href="BoxLevel_8h_source.html#l00827">getDim()</a>, <a class="el" href="BoxLevel_8h_source.html#l00575">getLocalNumberOfBoxes()</a>, <a class="el" href="BoxLevel_8h_source.html#l00664">getLocalNumberOfCells()</a>, <a class="el" href="SAMRAI__MPI_8h_source.html#l00224">SAMRAI::tbox::SAMRAI_MPI::getSize()</a>, <a class="el" href="Dimension_8h_source.html#l00133">SAMRAI::tbox::Dimension::getValue()</a>, <a class="el" href="BoxLevel_8h_source.html#l00104">GLOBALIZED</a>, <a class="el" href="BoxLevel_8h_source.html#l00227">isInitialized()</a>, <a class="el" href="SAMRAI__MPI_8h_source.html#l00052">MPI_INT</a>, <a class="el" href="SAMRAI__MPI_8h_source.html#l00053">MPI_LONG</a>, <a class="el" href="SAMRAI__MPI_8h_source.html#l00061">MPI_MAX</a>, <a class="el" href="SAMRAI__MPI_8h_source.html#l00063">MPI_SUM</a>, <a class="el" href="BoxContainer_8C_source.html#l01929">SAMRAI::hier::BoxContainer::realBegin()</a>, <a class="el" href="BoxContainer_8C_source.html#l01935">SAMRAI::hier::BoxContainer::realEnd()</a>, and <a class="el" href="Utilities_8h_source.html#l00110">TBOX_ASSERT</a>.</p>

<p>Referenced by <a class="el" href="BoxLevel_8h_source.html#l00764">getGlobalBoundingBox()</a>, <a class="el" href="BoxLevel_8h_source.html#l00800">getGlobalMaxBoxSize()</a>, <a class="el" href="BoxLevel_8h_source.html#l00816">getGlobalMinBoxSize()</a>, <a class="el" href="BoxLevel_8h_source.html#l00609">getGlobalNumberOfBoxes()</a>, <a class="el" href="BoxLevel_8h_source.html#l00738">getGlobalNumberOfCells()</a>, <a class="el" href="BoxLevel_8h_source.html#l00629">getMaxNumberOfBoxes()</a>, <a class="el" href="BoxLevel_8h_source.html#l00683">getMaxNumberOfCells()</a>, <a class="el" href="BoxLevel_8h_source.html#l00649">getMinNumberOfBoxes()</a>, and <a class="el" href="BoxLevel_8h_source.html#l00703">getMinNumberOfCells()</a>.</p>

</div>
</div>
<a class="anchor" id="a257e30e9541d393912b74e66e3f1393d"></a><!-- doxytag: member="SAMRAI::hier::BoxLevel::getGlobalizedVersion" ref="a257e30e9541d393912b74e66e3f1393d" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a> &amp; SAMRAI::hier::BoxLevel::getGlobalizedVersion </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return the globalized version of the <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html" title="A distributed set of Box objects which reside in the same index space.">BoxLevel</a>, creating it if needed. </p>
<p>If the <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html" title="A distributed set of Box objects which reside in the same index space.">BoxLevel</a> is in globalized state, return <code>*this</code>. If not, create and cache a globalized version (if necessary) and return that.</p>
<p>The cached version remains until it is removed by <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#a0394ad7edaca17db2b72deefec2ecf3d" title="Deallocate the internal globalized version of the BoxLevel, if there is any.">deallocateGlobalizedVersion()</a> or a method that can potentially change the Boxes is called. Note that globalizing and globalized data is not scalable. Use only when necessary.</p>
<p>Obviously, when the globalized version must be created (when the <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html" title="A distributed set of Box objects which reside in the same index space.">BoxLevel</a> is in DISTRIBUTED state and there is no cached version yet), all processes must make this call at the same point.</p>
<dl class="pre"><dt><b>Precondition:</b></dt><dd><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#ab5f4c8b090dbff0226e778e316b21920" title="Returns True if the object has been initialized.">isInitialized()</a></dd></dl>
<dl class="post"><dt><b>Postcondition:</b></dt><dd>d_globalized_version-&gt;<a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#ae0f03563c8ba07e61c0262ebac27b6c2" title="Returns the ParallelState of the object.">getParallelState()</a> == GLOBALIZED </dd></dl>

<p>References <a class="el" href="BoxLevel_8h_source.html#l00309">getParallelState()</a>, <a class="el" href="BoxLevel_8h_source.html#l00104">GLOBALIZED</a>, <a class="el" href="BoxLevel_8h_source.html#l00227">isInitialized()</a>, <a class="el" href="BoxLevel_8C_source.html#l00775">setParallelState()</a>, and <a class="el" href="Utilities_8h_source.html#l00110">TBOX_ASSERT</a>.</p>

<p>Referenced by <a class="el" href="Connector_8C_source.html#l01598">SAMRAI::hier::Connector::checkConsistencyWithHead()</a>, <a class="el" href="Connector_8C_source.html#l01236">SAMRAI::hier::Connector::checkTransposeCorrectness()</a>, <a class="el" href="Connector_8C_source.html#l00882">SAMRAI::hier::Connector::doTransposeWork()</a>, <a class="el" href="MappingConnector_8C_source.html#l00165">SAMRAI::hier::MappingConnector::findMappingErrors()</a>, <a class="el" href="Connector_8C_source.html#l01673">SAMRAI::hier::Connector::findOverlapErrors()</a>, and <a class="el" href="OverlapConnectorAlgorithm_8C_source.html#l00305">SAMRAI::hier::OverlapConnectorAlgorithm::findOverlaps()</a>.</p>

</div>
</div>
<a class="anchor" id="a0394ad7edaca17db2b72deefec2ecf3d"></a><!-- doxytag: member="SAMRAI::hier::BoxLevel::deallocateGlobalizedVersion" ref="a0394ad7edaca17db2b72deefec2ecf3d" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::hier::BoxLevel::deallocateGlobalizedVersion </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Deallocate the internal globalized version of the <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html" title="A distributed set of Box objects which reside in the same index space.">BoxLevel</a>, if there is any. </p>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>(d_globalized_version == 0) || (d_globalized_version-&gt;<a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#ae0f03563c8ba07e61c0262ebac27b6c2" title="Returns the ParallelState of the object.">getParallelState()</a> == GLOBALIZED) </dd></dl>

<p>References <a class="el" href="BoxLevel_8h_source.html#l00309">getParallelState()</a>, <a class="el" href="BoxLevel_8h_source.html#l00104">GLOBALIZED</a>, and <a class="el" href="Utilities_8h_source.html#l00110">TBOX_ASSERT</a>.</p>

<p>Referenced by <a class="el" href="BoxLevel_8h_source.html#l00263">clearForBoxChanges()</a>, and <a class="el" href="BoxLevel_8C_source.html#l00181">operator=()</a>.</p>

</div>
</div>
<a class="anchor" id="aa56ee65e5e67d58f580b4a6a700c431f"></a><!-- doxytag: member="SAMRAI::hier::BoxLevel::getMPI" ref="aa56ee65e5e67d58f580b4a6a700c431f" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classSAMRAI_1_1tbox_1_1SAMRAI__MPI.html">tbox::SAMRAI_MPI</a>&amp; SAMRAI::hier::BoxLevel::getMPI </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the SAMRAI_MPI communicator over which the Boxes are distributed. </p>

<p>Referenced by <a class="el" href="VoucherTransitLoad_8C_source.html#l00204">SAMRAI::mesh::VoucherTransitLoad::assignToLocalAndPopulateMaps()</a>, <a class="el" href="BoxTransitSet_8C_source.html#l00187">SAMRAI::mesh::BoxTransitSet::assignToLocalAndPopulateMaps()</a>, <a class="el" href="BoxLevelConnectorUtils_8C_source.html#l00095">SAMRAI::hier::BoxLevelConnectorUtils::baseNestsInHead()</a>, <a class="el" href="OverlapConnectorAlgorithm_8C_source.html#l00465">SAMRAI::hier::OverlapConnectorAlgorithm::bridge()</a>, <a class="el" href="OverlapConnectorAlgorithm_8C_source.html#l00394">SAMRAI::hier::OverlapConnectorAlgorithm::bridgeWithNesting()</a>, <a class="el" href="PatchLevelInteriorFillPattern_8C_source.html#l00061">SAMRAI::xfer::PatchLevelInteriorFillPattern::computeFillBoxesAndNeighborhoodSets()</a>, <a class="el" href="PatchLevelFullFillPattern_8C_source.html#l00060">SAMRAI::xfer::PatchLevelFullFillPattern::computeFillBoxesAndNeighborhoodSets()</a>, <a class="el" href="PatchLevelEnhancedFillPattern_8C_source.html#l00052">SAMRAI::xfer::PatchLevelEnhancedFillPattern::computeFillBoxesAndNeighborhoodSets()</a>, <a class="el" href="PatchLevelBorderFillPattern_8C_source.html#l00053">SAMRAI::xfer::PatchLevelBorderFillPattern::computeFillBoxesAndNeighborhoodSets()</a>, <a class="el" href="PatchLevelBorderAndInteriorFillPattern_8C_source.html#l00052">SAMRAI::xfer::PatchLevelBorderAndInteriorFillPattern::computeFillBoxesAndNeighborhoodSets()</a>, <a class="el" href="BalanceUtilities_8C_source.html#l02096">SAMRAI::mesh::BalanceUtilities::constrainMaxBoxSizes()</a>, <a class="el" href="Connector_8C_source.html#l00882">SAMRAI::hier::Connector::doTransposeWork()</a>, <a class="el" href="TileClustering_8C_source.html#l00115">SAMRAI::mesh::TileClustering::findBoxesContainingTags()</a>, <a class="el" href="BalanceUtilities_8C_source.html#l01774">SAMRAI::mesh::BalanceUtilities::findSmallBoxesInPostbalance()</a>, <a class="el" href="BoxLevel_8h_source.html#l01138">getBox()</a>, <a class="el" href="Connector_8h_source.html#l00924">SAMRAI::hier::Connector::getMPI()</a>, <a class="el" href="TreeLoadBalancer_8C_source.html#l00165">SAMRAI::mesh::TreeLoadBalancer::loadBalanceBoxLevel()</a>, <a class="el" href="GraphLoadBalancer_8C_source.html#l00072">SAMRAI::mesh::GraphLoadBalancer::loadBalanceBoxLevel()</a>, <a class="el" href="ChopAndPackLoadBalancer_8C_source.html#l00254">SAMRAI::mesh::ChopAndPackLoadBalancer::loadBalanceBoxLevel()</a>, <a class="el" href="CascadePartitioner_8C_source.html#l00157">SAMRAI::mesh::CascadePartitioner::loadBalanceBoxLevel()</a>, <a class="el" href="BoxLevelConnectorUtils_8C_source.html#l00362">SAMRAI::hier::BoxLevelConnectorUtils::makeSortingMap()</a>, <a class="el" href="BalanceUtilities_8C_source.html#l02201">SAMRAI::mesh::BalanceUtilities::prebalanceBoxLevel()</a>, <a class="el" href="BoxTransitSet_8C_source.html#l00450">SAMRAI::mesh::BoxTransitSet::putInBoxLevel()</a>, <a class="el" href="Connector_8C_source.html#l00628">SAMRAI::hier::Connector::setBase()</a>, and <a class="el" href="PatchLevel_8C_source.html#l00532">SAMRAI::hier::PatchLevel::setCoarsenedPatchLevel()</a>.</p>

</div>
</div>
<a class="anchor" id="a13c61b0dbe112df0eca5960e378f35c5"></a><!-- doxytag: member="SAMRAI::hier::BoxLevel::operator=" ref="a13c61b0dbe112df0eca5960e378f35c5" args="(const BoxLevel &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a> &amp; SAMRAI::hier::BoxLevel::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Assignment operator duplicates all internal data, including parallel mode. </p>
<p>Assignment is a modifying operation, causing the <a class="el" href="classSAMRAI_1_1hier_1_1PersistentOverlapConnectors.html" title="A managager of overlap Connectors incident from a BoxLevel, used to store and, if...">PersistentOverlapConnectors</a> to be cleared.</p>
<p>Persistent Connectors are not duplicated. This decision was based on expected usage, which is that copies are either for short term usage or meant to be changed in some way (thus invalidating current Connectors anyway).</p>
<dl class="see"><dt><b>See also:</b></dt><dd>getPersistentOverlapConnectors()</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>rhs</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="BoxLevel_8h_source.html#l01330">clearPersistentOverlapConnectors()</a>, <a class="el" href="BoxLevel_8h_source.html#l00363">deallocateGlobalizedVersion()</a>, <a class="el" href="BoxLevel_8h_source.html#l01587">locked()</a>, and <a class="el" href="Utilities_8h_source.html#l00060">TBOX_ERROR</a>.</p>

</div>
</div>
<a class="anchor" id="a9eebd53c534a0b42c59cf9cb08f2777e"></a><!-- doxytag: member="SAMRAI::hier::BoxLevel::swap" ref="a9eebd53c534a0b42c59cf9cb08f2777e" args="(BoxLevel &amp;level_a, BoxLevel &amp;level_b)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::hier::BoxLevel::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>level_a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>level_b</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Swap the contents of two <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html" title="A distributed set of Box objects which reside in the same index space.">BoxLevel</a> objects. </p>
<p>Swapping is a modifying operation, so the <a class="el" href="classSAMRAI_1_1hier_1_1PersistentOverlapConnectors.html" title="A managager of overlap Connectors incident from a BoxLevel, used to store and, if...">PersistentOverlapConnectors</a> of the operands are cleared.</p>
<p>Persistent Connectors are not swapped. This decision was based on expected usage, which is that copies are either for short term usage or meant to be changed in some way (thus invalidating current Connectors anyway).</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>level_a</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>level_b</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>(&amp;level_a == &amp;level_b) || !level_a.<a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#ab5f4c8b090dbff0226e778e316b21920" title="Returns True if the object has been initialized.">isInitialized()</a> || !level_b.<a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#ab5f4c8b090dbff0226e778e316b21920" title="Returns True if the object has been initialized.">isInitialized()</a> || (level_a.getDim() == level_b.getDim()) </dd></dl>

<p>References <a class="el" href="BoxLevel_8h_source.html#l01330">clearPersistentOverlapConnectors()</a>, <a class="el" href="BoxLevel_8h_source.html#l00827">getDim()</a>, <a class="el" href="BoxLevel_8h_source.html#l00838">getGridGeometry()</a>, <a class="el" href="BoxLevel_8h_source.html#l00227">isInitialized()</a>, <a class="el" href="BoxLevel_8h_source.html#l01587">locked()</a>, <a class="el" href="SAMRAI__MPI_8h_source.html#l00037">MPI_COMM_NULL</a>, <a class="el" href="BoxContainer_8h_source.html#l00877">SAMRAI::hier::BoxContainer::swap()</a>, <a class="el" href="Utilities_8h_source.html#l00182">TBOX_ASSERT_OBJDIM_EQUALITY2</a>, and <a class="el" href="Utilities_8h_source.html#l00060">TBOX_ERROR</a>.</p>

<p>Referenced by <a class="el" href="BalanceUtilities_8C_source.html#l02096">SAMRAI::mesh::BalanceUtilities::constrainMaxBoxSizes()</a>, and <a class="el" href="BalanceUtilities_8C_source.html#l02201">SAMRAI::mesh::BalanceUtilities::prebalanceBoxLevel()</a>.</p>

</div>
</div>
<a class="anchor" id="aab19edd439fc4c1124ca533ad1146381"></a><!-- doxytag: member="SAMRAI::hier::BoxLevel::operator==" ref="aab19edd439fc4c1124ca533ad1146381" args="(const BoxLevel &amp;rhs) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SAMRAI::hier::BoxLevel::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Equality comparison. </p>
<p>All data required to initialize the object is compared, except for the parallel state. Thus equality here means just the local parts are equal. <b>BEWARE!</b> This means that one processor may see the equality differently from another.</p>
<p>The cost for the comparison is on the order of the local <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> count. An object may be compared to itself, an efficient operation that always returns true.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>rhs</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="BoxLevel_8h_source.html#l00500">getBoxes()</a>.</p>

</div>
</div>
<a class="anchor" id="ac944ca2251fa1c7ac06c5570919ae734"></a><!-- doxytag: member="SAMRAI::hier::BoxLevel::operator!=" ref="ac944ca2251fa1c7ac06c5570919ae734" args="(const BoxLevel &amp;rhs) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SAMRAI::hier::BoxLevel::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Inequality comparison. </p>
<p>All data required to initialize the object is compared, except for the parallel state. Thus equality here means just the local parts are equal. <b>BEWARE!</b> This means that one processor may see the inequality differently from another.</p>
<p>The cost for the comparison is on the order of the local <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> count. However, an object may be compared to itself, an efficient operation that always returns false.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>rhs</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="BoxLevel_8h_source.html#l00500">getBoxes()</a>.</p>

</div>
</div>
<a class="anchor" id="a1e75df2ef751e7ed7f42c9e9a0991fa3"></a><!-- doxytag: member="SAMRAI::hier::BoxLevel::getBoxes" ref="a1e75df2ef751e7ed7f42c9e9a0991fa3" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a>&amp; SAMRAI::hier::BoxLevel::getBoxes </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the container of local Boxes. </p>
<dl class="user"><dt><b>Important</b></dt><dd>The <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html" title="A container for Boxes.">BoxContainer</a> returned contains periodic image Boxes (if any). To iterate through real Boxes only, see <a class="el" href="classSAMRAI_1_1hier_1_1RealBoxConstIterator.html" title="Iterator through real Boxes (not periodic images) in a const BoxContainer.">RealBoxConstIterator</a>.</dd></dl>
<p>You cannot directly modify the <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html" title="A container for Boxes.">BoxContainer</a> because it may invalidate other internal data. Use other methods for modifying the <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html" title="A container for Boxes.">BoxContainer</a>.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>It is possible that one may wish to perform repeated searches on the Boxes in the <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html" title="A container for Boxes.">BoxContainer</a> returned by this method. As noted in BoxContainer's documentation, it may be advantageous to call the makeTree method on the <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html" title="A container for Boxes.">BoxContainer</a> in this case. If you do, remember that the GridGeometry passed to makeTree must be the GridGeometry held by this <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html" title="A distributed set of Box objects which reside in the same index space.">BoxLevel</a>. Thus the proper use of makeTree with the result of a call to this method will look like: <div class="fragment"><pre class="fragment">
    *    box_level.getBoxes().makeTree(box_level.getGridGeometry());
    * </pre></div></dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#ad4838ed2fd92a444d15c5b01e069a898" title="Return global number of Boxes.">getGlobalNumberOfBoxes()</a> </dd>
<dd>
<a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#aa6bcc7e11f0cf5d80a6ac2cff54e4616" title="Return local number of boxes.">getLocalNumberOfBoxes()</a> </dd></dl>

<p>Referenced by <a class="el" href="BoxLevelConnectorUtils_8C_source.html#l01210">SAMRAI::hier::BoxLevelConnectorUtils::addPeriodicImages()</a>, <a class="el" href="BoxLevelConnectorUtils_8C_source.html#l01270">SAMRAI::hier::BoxLevelConnectorUtils::addPeriodicImagesAndRelationships()</a>, <a class="el" href="VoucherTransitLoad_8C_source.html#l00204">SAMRAI::mesh::VoucherTransitLoad::assignToLocalAndPopulateMaps()</a>, <a class="el" href="BoxLevelConnectorUtils_8C_source.html#l00171">SAMRAI::hier::BoxLevelConnectorUtils::baseNestsInHead()</a>, <a class="el" href="PatchLevelInteriorFillPattern_8C_source.html#l00061">SAMRAI::xfer::PatchLevelInteriorFillPattern::computeFillBoxesAndNeighborhoodSets()</a>, <a class="el" href="PatchLevelFullFillPattern_8C_source.html#l00060">SAMRAI::xfer::PatchLevelFullFillPattern::computeFillBoxesAndNeighborhoodSets()</a>, <a class="el" href="PatchLevelEnhancedFillPattern_8C_source.html#l00052">SAMRAI::xfer::PatchLevelEnhancedFillPattern::computeFillBoxesAndNeighborhoodSets()</a>, <a class="el" href="PatchLevelBorderFillPattern_8C_source.html#l00053">SAMRAI::xfer::PatchLevelBorderFillPattern::computeFillBoxesAndNeighborhoodSets()</a>, <a class="el" href="PatchLevelBorderAndInteriorFillPattern_8C_source.html#l00052">SAMRAI::xfer::PatchLevelBorderAndInteriorFillPattern::computeFillBoxesAndNeighborhoodSets()</a>, <a class="el" href="BoxLevelConnectorUtils_8C_source.html#l01486">SAMRAI::hier::BoxLevelConnectorUtils::computeNonIntersectingParts()</a>, <a class="el" href="BalanceUtilities_8C_source.html#l02096">SAMRAI::mesh::BalanceUtilities::constrainMaxBoxSizes()</a>, <a class="el" href="Connector_8C_source.html#l00807">SAMRAI::hier::Connector::doLocalTransposeWork()</a>, <a class="el" href="TileClustering_8C_source.html#l00115">SAMRAI::mesh::TileClustering::findBoxesContainingTags()</a>, <a class="el" href="MappingConnector_8C_source.html#l00165">SAMRAI::hier::MappingConnector::findMappingErrors()</a>, <a class="el" href="BalanceUtilities_8C_source.html#l01774">SAMRAI::mesh::BalanceUtilities::findSmallBoxesInPostbalance()</a>, <a class="el" href="BoxLevel_8C_source.html#l01303">getFirstLocalId()</a>, <a class="el" href="BoxLevel_8C_source.html#l01320">getLastLocalId()</a>, <a class="el" href="TreeLoadBalancer_8C_source.html#l00165">SAMRAI::mesh::TreeLoadBalancer::loadBalanceBoxLevel()</a>, <a class="el" href="GraphLoadBalancer_8C_source.html#l00072">SAMRAI::mesh::GraphLoadBalancer::loadBalanceBoxLevel()</a>, <a class="el" href="CascadePartitioner_8C_source.html#l00157">SAMRAI::mesh::CascadePartitioner::loadBalanceBoxLevel()</a>, <a class="el" href="BoxLevelConnectorUtils_8C_source.html#l01084">SAMRAI::hier::BoxLevelConnectorUtils::makeRemainderMap()</a>, <a class="el" href="BoxLevelConnectorUtils_8C_source.html#l00362">SAMRAI::hier::BoxLevelConnectorUtils::makeSortingMap()</a>, <a class="el" href="BoxLevel_8C_source.html#l00353">operator!=()</a>, <a class="el" href="BoxLevel_8C_source.html#l00330">operator==()</a>, <a class="el" href="BalanceUtilities_8C_source.html#l02201">SAMRAI::mesh::BalanceUtilities::prebalanceBoxLevel()</a>, and <a class="el" href="BoxLevel_8C_source.html#l01463">putToRestart()</a>.</p>

</div>
</div>
<a class="anchor" id="afe03004a023ac5e76e01aef59fd6a612"></a><!-- doxytag: member="SAMRAI::hier::BoxLevel::getGlobalBoxes" ref="afe03004a023ac5e76e01aef59fd6a612" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a>&amp; SAMRAI::hier::BoxLevel::getGlobalBoxes </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the container of global Boxes. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>It is possible that one may wish to perform repeated searches on the Boxes in the <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html" title="A container for Boxes.">BoxContainer</a> returned by this method. As noted in BoxContainer's documentation, it may be advantageous to call the makeTree method on the <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html" title="A container for Boxes.">BoxContainer</a> in this case. If you do, remember that the GridGeometry passed to makeTree must be the GridGeometry held by this <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html" title="A distributed set of Box objects which reside in the same index space.">BoxLevel</a>. Thus the proper use of makeTree with the result of a call to this method will look like: <div class="fragment"><pre class="fragment">
    *    box_level.getBoxes().makeTree(box_level.getGridGeometry());
    * </pre></div> </dd></dl>

<p>Referenced by <a class="el" href="Connector_8C_source.html#l01598">SAMRAI::hier::Connector::checkConsistencyWithHead()</a>, <a class="el" href="Connector_8C_source.html#l00882">SAMRAI::hier::Connector::doTransposeWork()</a>, <a class="el" href="GraphLoadBalancer_8C_source.html#l00072">SAMRAI::mesh::GraphLoadBalancer::loadBalanceBoxLevel()</a>, and <a class="el" href="ChopAndPackLoadBalancer_8C_source.html#l00254">SAMRAI::mesh::ChopAndPackLoadBalancer::loadBalanceBoxLevel()</a>.</p>

</div>
</div>
<a class="anchor" id="a621aa4df7351bf32b53dcc2258890415"></a><!-- doxytag: member="SAMRAI::hier::BoxLevel::getGlobalBoxes" ref="a621aa4df7351bf32b53dcc2258890415" args="(BoxContainer &amp;global_boxes) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::hier::BoxLevel::getGlobalBoxes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>global_boxes</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Fill the container with the global Boxes. </p>

<p>References <a class="el" href="BoxContainer_8h_source.html#l00701">SAMRAI::hier::BoxContainer::begin()</a>, <a class="el" href="BoxContainer_8h_source.html#l00712">SAMRAI::hier::BoxContainer::end()</a>, and <a class="el" href="BoxContainer_8h_source.html#l01071">SAMRAI::hier::BoxContainer::pushBack()</a>.</p>

</div>
</div>
<a class="anchor" id="a153e6634835c71dcb5643609112995e6"></a><!-- doxytag: member="SAMRAI::hier::BoxLevel::getFirstLocalId" ref="a153e6634835c71dcb5643609112995e6" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSAMRAI_1_1hier_1_1LocalId.html">LocalId</a> SAMRAI::hier::BoxLevel::getFirstLocalId </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the first <a class="el" href="classSAMRAI_1_1hier_1_1LocalId.html" title="Generic identifier for identifying things on the local process.">LocalId</a>, or one with a value of -1 if no local <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> exists. </p>
<dl class="pre"><dt><b>Precondition:</b></dt><dd><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#ab5f4c8b090dbff0226e778e316b21920" title="Returns True if the object has been initialized.">isInitialized()</a> </dd></dl>

<p>References <a class="el" href="BoxContainer_8h_source.html#l00701">SAMRAI::hier::BoxContainer::begin()</a>, <a class="el" href="BoxContainer_8h_source.html#l00712">SAMRAI::hier::BoxContainer::end()</a>, <a class="el" href="BoxLevel_8h_source.html#l00500">getBoxes()</a>, <a class="el" href="BoxContainer_8h_source.html#l00677">SAMRAI::hier::BoxContainer::isEmpty()</a>, <a class="el" href="BoxLevel_8h_source.html#l00227">isInitialized()</a>, and <a class="el" href="Utilities_8h_source.html#l00110">TBOX_ASSERT</a>.</p>

</div>
</div>
<a class="anchor" id="aba0e4564fd0ccd65a4e91c0326b38789"></a><!-- doxytag: member="SAMRAI::hier::BoxLevel::getLastLocalId" ref="aba0e4564fd0ccd65a4e91c0326b38789" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSAMRAI_1_1hier_1_1LocalId.html">LocalId</a> SAMRAI::hier::BoxLevel::getLastLocalId </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the last <a class="el" href="classSAMRAI_1_1hier_1_1LocalId.html" title="Generic identifier for identifying things on the local process.">LocalId</a>, or one with a value of -1 if no local <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> exists. </p>
<dl class="pre"><dt><b>Precondition:</b></dt><dd><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#ab5f4c8b090dbff0226e778e316b21920" title="Returns True if the object has been initialized.">isInitialized()</a> </dd></dl>

<p>References <a class="el" href="BoxContainer_8h_source.html#l00701">SAMRAI::hier::BoxContainer::begin()</a>, <a class="el" href="BoxContainer_8h_source.html#l00712">SAMRAI::hier::BoxContainer::end()</a>, <a class="el" href="BoxLevel_8h_source.html#l00500">getBoxes()</a>, <a class="el" href="BoxContainer_8h_source.html#l00677">SAMRAI::hier::BoxContainer::isEmpty()</a>, <a class="el" href="BoxLevel_8h_source.html#l00227">isInitialized()</a>, and <a class="el" href="Utilities_8h_source.html#l00110">TBOX_ASSERT</a>.</p>

<p>Referenced by <a class="el" href="VoucherTransitLoad_8C_source.html#l00204">SAMRAI::mesh::VoucherTransitLoad::assignToLocalAndPopulateMaps()</a>, <a class="el" href="PatchLevelEnhancedFillPattern_8C_source.html#l00052">SAMRAI::xfer::PatchLevelEnhancedFillPattern::computeFillBoxesAndNeighborhoodSets()</a>, <a class="el" href="PatchLevelBorderFillPattern_8C_source.html#l00053">SAMRAI::xfer::PatchLevelBorderFillPattern::computeFillBoxesAndNeighborhoodSets()</a>, <a class="el" href="PatchLevelBorderAndInteriorFillPattern_8C_source.html#l00052">SAMRAI::xfer::PatchLevelBorderAndInteriorFillPattern::computeFillBoxesAndNeighborhoodSets()</a>, and <a class="el" href="BalanceUtilities_8C_source.html#l02096">SAMRAI::mesh::BalanceUtilities::constrainMaxBoxSizes()</a>.</p>

</div>
</div>
<a class="anchor" id="a769ce9dbc1523384d0092a33aa0e5dbf"></a><!-- doxytag: member="SAMRAI::hier::BoxLevel::getRefinementRatio" ref="a769ce9dbc1523384d0092a33aa0e5dbf" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a>&amp; SAMRAI::hier::BoxLevel::getRefinementRatio </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get const access to BoxLevel's refinement ratio (with respect to a reference level). </p>

<p>Referenced by <a class="el" href="BoxLevelConnectorUtils_8C_source.html#l01210">SAMRAI::hier::BoxLevelConnectorUtils::addPeriodicImages()</a>, <a class="el" href="BoxLevelConnectorUtils_8C_source.html#l01270">SAMRAI::hier::BoxLevelConnectorUtils::addPeriodicImagesAndRelationships()</a>, <a class="el" href="BoxLevelConnectorUtils_8C_source.html#l00095">SAMRAI::hier::BoxLevelConnectorUtils::baseNestsInHead()</a>, <a class="el" href="Connector_8C_source.html#l01598">SAMRAI::hier::Connector::checkConsistencyWithHead()</a>, <a class="el" href="Connector_8C_source.html#l01236">SAMRAI::hier::Connector::checkTransposeCorrectness()</a>, <a class="el" href="PatchLevelInteriorFillPattern_8C_source.html#l00105">SAMRAI::xfer::PatchLevelInteriorFillPattern::computeDestinationFillBoxesOnSourceProc()</a>, <a class="el" href="PatchLevelFullFillPattern_8C_source.html#l00102">SAMRAI::xfer::PatchLevelFullFillPattern::computeDestinationFillBoxesOnSourceProc()</a>, <a class="el" href="PatchLevelInteriorFillPattern_8C_source.html#l00061">SAMRAI::xfer::PatchLevelInteriorFillPattern::computeFillBoxesAndNeighborhoodSets()</a>, <a class="el" href="PatchLevelFullFillPattern_8C_source.html#l00060">SAMRAI::xfer::PatchLevelFullFillPattern::computeFillBoxesAndNeighborhoodSets()</a>, <a class="el" href="PatchLevelEnhancedFillPattern_8C_source.html#l00052">SAMRAI::xfer::PatchLevelEnhancedFillPattern::computeFillBoxesAndNeighborhoodSets()</a>, <a class="el" href="PatchLevelBorderFillPattern_8C_source.html#l00053">SAMRAI::xfer::PatchLevelBorderFillPattern::computeFillBoxesAndNeighborhoodSets()</a>, <a class="el" href="PatchLevelBorderAndInteriorFillPattern_8C_source.html#l00052">SAMRAI::xfer::PatchLevelBorderAndInteriorFillPattern::computeFillBoxesAndNeighborhoodSets()</a>, <a class="el" href="BalanceUtilities_8C_source.html#l02096">SAMRAI::mesh::BalanceUtilities::constrainMaxBoxSizes()</a>, <a class="el" href="Connector_8C_source.html#l00807">SAMRAI::hier::Connector::doLocalTransposeWork()</a>, <a class="el" href="OverlapConnectorAlgorithm_8C_source.html#l00121">SAMRAI::hier::OverlapConnectorAlgorithm::extractNeighbors()</a>, <a class="el" href="Connector_8C_source.html#l00543">SAMRAI::hier::Connector::finalizeContext()</a>, <a class="el" href="TileClustering_8C_source.html#l00115">SAMRAI::mesh::TileClustering::findBoxesContainingTags()</a>, <a class="el" href="Connector_8C_source.html#l00931">SAMRAI::hier::Connector::isTransposeOf()</a>, <a class="el" href="TreeLoadBalancer_8C_source.html#l00165">SAMRAI::mesh::TreeLoadBalancer::loadBalanceBoxLevel()</a>, <a class="el" href="GraphLoadBalancer_8C_source.html#l00072">SAMRAI::mesh::GraphLoadBalancer::loadBalanceBoxLevel()</a>, <a class="el" href="ChopAndPackLoadBalancer_8C_source.html#l00254">SAMRAI::mesh::ChopAndPackLoadBalancer::loadBalanceBoxLevel()</a>, <a class="el" href="CascadePartitioner_8C_source.html#l00157">SAMRAI::mesh::CascadePartitioner::loadBalanceBoxLevel()</a>, <a class="el" href="PatchHierarchy_8C_source.html#l00718">SAMRAI::hier::PatchHierarchy::makeNewPatchLevel()</a>, <a class="el" href="BoxLevelConnectorUtils_8C_source.html#l00362">SAMRAI::hier::BoxLevelConnectorUtils::makeSortingMap()</a>, <a class="el" href="PatchLevel_8C_source.html#l00087">SAMRAI::hier::PatchLevel::PatchLevel()</a>, <a class="el" href="BalanceUtilities_8C_source.html#l02201">SAMRAI::mesh::BalanceUtilities::prebalanceBoxLevel()</a>, <a class="el" href="Connector_8C_source.html#l01056">SAMRAI::hier::Connector::recursivePrint()</a>, <a class="el" href="BoxLevel_8C_source.html#l01595">recursivePrint()</a>, and <a class="el" href="Connector_8C_source.html#l00354">SAMRAI::hier::Connector::shrinkWidth()</a>.</p>

</div>
</div>
<a class="anchor" id="aa6bcc7e11f0cf5d80a6ac2cff54e4616"></a><!-- doxytag: member="SAMRAI::hier::BoxLevel::getLocalNumberOfBoxes" ref="aa6bcc7e11f0cf5d80a6ac2cff54e4616" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t SAMRAI::hier::BoxLevel::getLocalNumberOfBoxes </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return local number of boxes. </p>
<p>Periodic image Boxes are excluded.</p>
<dl class="pre"><dt><b>Precondition:</b></dt><dd><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#ab5f4c8b090dbff0226e778e316b21920" title="Returns True if the object has been initialized.">isInitialized()</a> </dd></dl>

<p>References <a class="el" href="BoxLevel_8h_source.html#l00227">isInitialized()</a>, and <a class="el" href="Utilities_8h_source.html#l00110">TBOX_ASSERT</a>.</p>

<p>Referenced by <a class="el" href="BoxLevel_8C_source.html#l00567">cacheGlobalReducedData()</a>, <a class="el" href="TreeLoadBalancer_8C_source.html#l00165">SAMRAI::mesh::TreeLoadBalancer::loadBalanceBoxLevel()</a>, <a class="el" href="BoxLevelConnectorUtils_8C_source.html#l00362">SAMRAI::hier::BoxLevelConnectorUtils::makeSortingMap()</a>, and <a class="el" href="Connector_8C_source.html#l01056">SAMRAI::hier::Connector::recursivePrint()</a>.</p>

</div>
</div>
<a class="anchor" id="afbf2d7a554955a940ba105cf9d22f988"></a><!-- doxytag: member="SAMRAI::hier::BoxLevel::getLocalNumberOfBoxes" ref="afbf2d7a554955a940ba105cf9d22f988" args="(int rank) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t SAMRAI::hier::BoxLevel::getLocalNumberOfBoxes </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>rank</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return number of boxes local to the given rank. </p>
<p>Periodic image Boxes are excluded.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>rank</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="pre"><dt><b>Precondition:</b></dt><dd><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#ab5f4c8b090dbff0226e778e316b21920" title="Returns True if the object has been initialized.">isInitialized()</a> </dd>
<dd>
(<a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#ae0f03563c8ba07e61c0262ebac27b6c2" title="Returns the ParallelState of the object.">getParallelState()</a> == GLOBALIZED) || (rank == <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#aa56ee65e5e67d58f580b4a6a700c431f" title="Returns the SAMRAI_MPI communicator over which the Boxes are distributed.">getMPI()</a>.getRank()) </dd>
<dd>
(rank &gt;= 0) &amp;&amp; (rank &lt; <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#aa56ee65e5e67d58f580b4a6a700c431f" title="Returns the SAMRAI_MPI communicator over which the Boxes are distributed.">getMPI()</a>.getSize()) </dd></dl>

<p>References <a class="el" href="BoxContainer_8h_source.html#l00701">SAMRAI::hier::BoxContainer::begin()</a>, <a class="el" href="BoxLevel_8h_source.html#l00104">DISTRIBUTED</a>, <a class="el" href="BoxContainer_8h_source.html#l00712">SAMRAI::hier::BoxContainer::end()</a>, <a class="el" href="SAMRAI__MPI_8h_source.html#l00214">SAMRAI::tbox::SAMRAI_MPI::getRank()</a>, <a class="el" href="SAMRAI__MPI_8h_source.html#l00224">SAMRAI::tbox::SAMRAI_MPI::getSize()</a>, <a class="el" href="BoxLevel_8h_source.html#l00227">isInitialized()</a>, <a class="el" href="Utilities_8h_source.html#l00110">TBOX_ASSERT</a>, and <a class="el" href="Utilities_8h_source.html#l00060">TBOX_ERROR</a>.</p>

</div>
</div>
<a class="anchor" id="ad4838ed2fd92a444d15c5b01e069a898"></a><!-- doxytag: member="SAMRAI::hier::BoxLevel::getGlobalNumberOfBoxes" ref="ad4838ed2fd92a444d15c5b01e069a898" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int SAMRAI::hier::BoxLevel::getGlobalNumberOfBoxes </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return global number of Boxes. </p>
<p>This requires a global reduction, if the global-reduced data has not been computed and cached. When communication is required, all processors must call this method. To ensure that no communication is needed, call <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#a88d752dca7dd51b8c1b0b0aa27c3d64e" title="If global reduced data (global Box count, global cell count and global bounding box)...">cacheGlobalReducedData()</a> first.</p>
<p>Periodic image Boxes are excluded.</p>
<dl class="pre"><dt><b>Precondition:</b></dt><dd><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#ab5f4c8b090dbff0226e778e316b21920" title="Returns True if the object has been initialized.">isInitialized()</a> </dd></dl>

<p>References <a class="el" href="BoxLevel_8C_source.html#l00567">cacheGlobalReducedData()</a>, <a class="el" href="BoxLevel_8h_source.html#l00227">isInitialized()</a>, and <a class="el" href="Utilities_8h_source.html#l00110">TBOX_ASSERT</a>.</p>

<p>Referenced by <a class="el" href="GraphLoadBalancer_8C_source.html#l00072">SAMRAI::mesh::GraphLoadBalancer::loadBalanceBoxLevel()</a>.</p>

</div>
</div>
<a class="anchor" id="a799ad52b977646d3c095c25463d4d15b"></a><!-- doxytag: member="SAMRAI::hier::BoxLevel::getMaxNumberOfBoxes" ref="a799ad52b977646d3c095c25463d4d15b" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int SAMRAI::hier::BoxLevel::getMaxNumberOfBoxes </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return maximum number of Boxes over all processes. </p>
<p>This requires a global reduction, if the global-reduced data has not been computed and cached. When communication is required, all processors must call this method. To ensure that no communication is needed, call <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#a88d752dca7dd51b8c1b0b0aa27c3d64e" title="If global reduced data (global Box count, global cell count and global bounding box)...">cacheGlobalReducedData()</a> first.</p>
<p>Periodic image Boxes are excluded.</p>
<dl class="pre"><dt><b>Precondition:</b></dt><dd><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#ab5f4c8b090dbff0226e778e316b21920" title="Returns True if the object has been initialized.">isInitialized()</a> </dd></dl>

<p>References <a class="el" href="BoxLevel_8C_source.html#l00567">cacheGlobalReducedData()</a>, <a class="el" href="BoxLevel_8h_source.html#l00227">isInitialized()</a>, and <a class="el" href="Utilities_8h_source.html#l00110">TBOX_ASSERT</a>.</p>

</div>
</div>
<a class="anchor" id="a922bbd77b18facc9efe362166f9f0a1c"></a><!-- doxytag: member="SAMRAI::hier::BoxLevel::getMinNumberOfBoxes" ref="a922bbd77b18facc9efe362166f9f0a1c" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int SAMRAI::hier::BoxLevel::getMinNumberOfBoxes </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return maximum number of Boxes over all processes. </p>
<p>This requires a global reduction, if the global-reduced data has not been computed and cached. When communication is required, all processors must call this method. To ensure that no communication is needed, call <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#a88d752dca7dd51b8c1b0b0aa27c3d64e" title="If global reduced data (global Box count, global cell count and global bounding box)...">cacheGlobalReducedData()</a> first.</p>
<p>Periodic image Boxes are excluded.</p>
<dl class="pre"><dt><b>Precondition:</b></dt><dd><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#ab5f4c8b090dbff0226e778e316b21920" title="Returns True if the object has been initialized.">isInitialized()</a> </dd></dl>

<p>References <a class="el" href="BoxLevel_8C_source.html#l00567">cacheGlobalReducedData()</a>, <a class="el" href="BoxLevel_8h_source.html#l00227">isInitialized()</a>, and <a class="el" href="Utilities_8h_source.html#l00110">TBOX_ASSERT</a>.</p>

</div>
</div>
<a class="anchor" id="ac5422e0dc4aa9d6d58106895ff02bac4"></a><!-- doxytag: member="SAMRAI::hier::BoxLevel::getLocalNumberOfCells" ref="ac5422e0dc4aa9d6d58106895ff02bac4" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t SAMRAI::hier::BoxLevel::getLocalNumberOfCells </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return local number of cells. </p>
<p>Cells in periodic image Boxes are excluded.</p>
<dl class="pre"><dt><b>Precondition:</b></dt><dd><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#ab5f4c8b090dbff0226e778e316b21920" title="Returns True if the object has been initialized.">isInitialized()</a> </dd></dl>

<p>References <a class="el" href="BoxLevel_8h_source.html#l00227">isInitialized()</a>, and <a class="el" href="Utilities_8h_source.html#l00110">TBOX_ASSERT</a>.</p>

<p>Referenced by <a class="el" href="VoucherTransitLoad_8C_source.html#l00204">SAMRAI::mesh::VoucherTransitLoad::assignToLocalAndPopulateMaps()</a>, and <a class="el" href="BoxLevel_8C_source.html#l00567">cacheGlobalReducedData()</a>.</p>

</div>
</div>
<a class="anchor" id="ac581ae5959face79ca144e680c6b7055"></a><!-- doxytag: member="SAMRAI::hier::BoxLevel::getMaxNumberOfCells" ref="ac581ae5959face79ca144e680c6b7055" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int SAMRAI::hier::BoxLevel::getMaxNumberOfCells </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return maximum number of cells over all processes. </p>
<p>This requires a global reduction, if the global-reduced data has not been computed and cached. When communication is required, all processors must call this method. To ensure that no communication is needed, call <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#a88d752dca7dd51b8c1b0b0aa27c3d64e" title="If global reduced data (global Box count, global cell count and global bounding box)...">cacheGlobalReducedData()</a> first.</p>
<p>Periodic image Boxes are excluded.</p>
<dl class="pre"><dt><b>Precondition:</b></dt><dd><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#ab5f4c8b090dbff0226e778e316b21920" title="Returns True if the object has been initialized.">isInitialized()</a> </dd></dl>

<p>References <a class="el" href="BoxLevel_8C_source.html#l00567">cacheGlobalReducedData()</a>, <a class="el" href="BoxLevel_8h_source.html#l00227">isInitialized()</a>, and <a class="el" href="Utilities_8h_source.html#l00110">TBOX_ASSERT</a>.</p>

</div>
</div>
<a class="anchor" id="ad6f98b4539ae7b7a8d5aa7ab859a1648"></a><!-- doxytag: member="SAMRAI::hier::BoxLevel::getMinNumberOfCells" ref="ad6f98b4539ae7b7a8d5aa7ab859a1648" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int SAMRAI::hier::BoxLevel::getMinNumberOfCells </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return maximum number of cells over all processes. </p>
<p>This requires a global reduction, if the global-reduced data has not been computed and cached. When communication is required, all processors must call this method. To ensure that no communication is needed, call <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#a88d752dca7dd51b8c1b0b0aa27c3d64e" title="If global reduced data (global Box count, global cell count and global bounding box)...">cacheGlobalReducedData()</a> first.</p>
<p>Periodic image Boxes are excluded.</p>
<dl class="pre"><dt><b>Precondition:</b></dt><dd><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#ab5f4c8b090dbff0226e778e316b21920" title="Returns True if the object has been initialized.">isInitialized()</a> </dd></dl>

<p>References <a class="el" href="BoxLevel_8C_source.html#l00567">cacheGlobalReducedData()</a>, <a class="el" href="BoxLevel_8h_source.html#l00227">isInitialized()</a>, and <a class="el" href="Utilities_8h_source.html#l00110">TBOX_ASSERT</a>.</p>

</div>
</div>
<a class="anchor" id="ac163b80b716511ad09233ffb5576c87e"></a><!-- doxytag: member="SAMRAI::hier::BoxLevel::getLocalNumberOfCells" ref="ac163b80b716511ad09233ffb5576c87e" args="(int rank) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t SAMRAI::hier::BoxLevel::getLocalNumberOfCells </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>rank</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return number of cells local to the given rank. </p>
<p>Cells in periodic image Boxes are excluded.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>rank</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="pre"><dt><b>Precondition:</b></dt><dd><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#ab5f4c8b090dbff0226e778e316b21920" title="Returns True if the object has been initialized.">isInitialized()</a> </dd>
<dd>
(<a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#ae0f03563c8ba07e61c0262ebac27b6c2" title="Returns the ParallelState of the object.">getParallelState()</a> == GLOBALIZED) || (rank == <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#aa56ee65e5e67d58f580b4a6a700c431f" title="Returns the SAMRAI_MPI communicator over which the Boxes are distributed.">getMPI()</a>.getRank()) </dd>
<dd>
(rank &gt;= 0) &amp;&amp; (rank &lt; <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#aa56ee65e5e67d58f580b4a6a700c431f" title="Returns the SAMRAI_MPI communicator over which the Boxes are distributed.">getMPI()</a>.getSize()) </dd></dl>

<p>References <a class="el" href="BoxContainer_8h_source.html#l00701">SAMRAI::hier::BoxContainer::begin()</a>, <a class="el" href="BoxLevel_8h_source.html#l00104">DISTRIBUTED</a>, <a class="el" href="BoxContainer_8h_source.html#l00712">SAMRAI::hier::BoxContainer::end()</a>, <a class="el" href="SAMRAI__MPI_8h_source.html#l00214">SAMRAI::tbox::SAMRAI_MPI::getRank()</a>, <a class="el" href="SAMRAI__MPI_8h_source.html#l00224">SAMRAI::tbox::SAMRAI_MPI::getSize()</a>, <a class="el" href="BoxLevel_8h_source.html#l00227">isInitialized()</a>, <a class="el" href="Utilities_8h_source.html#l00110">TBOX_ASSERT</a>, and <a class="el" href="Utilities_8h_source.html#l00060">TBOX_ERROR</a>.</p>

</div>
</div>
<a class="anchor" id="aafc96890ca6771f8580bb155cbddb2b3"></a><!-- doxytag: member="SAMRAI::hier::BoxLevel::getGlobalNumberOfCells" ref="aafc96890ca6771f8580bb155cbddb2b3" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long int SAMRAI::hier::BoxLevel::getGlobalNumberOfCells </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return global number of cells. </p>
<p>This requires a global reduction if the global-reduced data has not been computed and cached. When communication is required, all processors must call this method. To ensure that no communication is needed, call <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#a88d752dca7dd51b8c1b0b0aa27c3d64e" title="If global reduced data (global Box count, global cell count and global bounding box)...">cacheGlobalReducedData()</a> first.</p>
<p>Cells in periodic image Boxes are excluded.</p>
<dl class="pre"><dt><b>Precondition:</b></dt><dd><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#ab5f4c8b090dbff0226e778e316b21920" title="Returns True if the object has been initialized.">isInitialized()</a> </dd></dl>

<p>References <a class="el" href="BoxLevel_8C_source.html#l00567">cacheGlobalReducedData()</a>, <a class="el" href="BoxLevel_8h_source.html#l00227">isInitialized()</a>, and <a class="el" href="Utilities_8h_source.html#l00110">TBOX_ASSERT</a>.</p>

</div>
</div>
<a class="anchor" id="aa0e3992e8720b4df0bdbbca45546fc1f"></a><!-- doxytag: member="SAMRAI::hier::BoxLevel::getLocalBoundingBox" ref="aa0e3992e8720b4df0bdbbca45546fc1f" args="(int block_number) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a>&amp; SAMRAI::hier::BoxLevel::getLocalBoundingBox </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>block_number</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return bounding box for local Boxes in a block. </p>

<p>Referenced by <a class="el" href="BoxLevel_8C_source.html#l01595">recursivePrint()</a>.</p>

</div>
</div>
<a class="anchor" id="a9deaa634cf3fe5ab246fe7aca0d70a43"></a><!-- doxytag: member="SAMRAI::hier::BoxLevel::getGlobalBoundingBox" ref="a9deaa634cf3fe5ab246fe7aca0d70a43" args="(int block_number) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a>&amp; SAMRAI::hier::BoxLevel::getGlobalBoundingBox </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>block_number</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return bounding box for global Boxes in a block. </p>
<p>This requires a global reduction if the global bounding box has not been computed and cached. When communication is required, all processors must call this method. To ensure that no communication is needed, call <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#a88d752dca7dd51b8c1b0b0aa27c3d64e" title="If global reduced data (global Box count, global cell count and global bounding box)...">cacheGlobalReducedData()</a> first. </p>

<p>References <a class="el" href="BoxLevel_8C_source.html#l00567">cacheGlobalReducedData()</a>.</p>

<p>Referenced by <a class="el" href="BoxLevel_8C_source.html#l01595">recursivePrint()</a>.</p>

</div>
</div>
<a class="anchor" id="a38cd4acb77caa36d41515252db0e1102"></a><!-- doxytag: member="SAMRAI::hier::BoxLevel::getLocalMaxBoxSize" ref="a38cd4acb77caa36d41515252db0e1102" args="(int block_number) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a>&amp; SAMRAI::hier::BoxLevel::getLocalMaxBoxSize </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>block_number</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return size of the largest local <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> in a block. </p>

</div>
</div>
<a class="anchor" id="ac1e3b956ec5dd8504d7375960545755c"></a><!-- doxytag: member="SAMRAI::hier::BoxLevel::getLocalMinBoxSize" ref="ac1e3b956ec5dd8504d7375960545755c" args="(int block_number) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a>&amp; SAMRAI::hier::BoxLevel::getLocalMinBoxSize </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>block_number</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return size of the smallest local <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> in a block. </p>

</div>
</div>
<a class="anchor" id="a27a9f68acbf0a41fae9538cfa249406a"></a><!-- doxytag: member="SAMRAI::hier::BoxLevel::getGlobalMaxBoxSize" ref="a27a9f68acbf0a41fae9538cfa249406a" args="(int block_number) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a>&amp; SAMRAI::hier::BoxLevel::getGlobalMaxBoxSize </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>block_number</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return size of the largest <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> globally in a block. </p>
<p>This requires a global reduction if the global bounding box has not been computed and cached. When communication is required, all processors must call this method. To ensure that no communication is needed, call <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#a88d752dca7dd51b8c1b0b0aa27c3d64e" title="If global reduced data (global Box count, global cell count and global bounding box)...">cacheGlobalReducedData()</a> first. </p>

<p>References <a class="el" href="BoxLevel_8C_source.html#l00567">cacheGlobalReducedData()</a>.</p>

</div>
</div>
<a class="anchor" id="a38e7e581ec5d2ceb7f0130eca279a84f"></a><!-- doxytag: member="SAMRAI::hier::BoxLevel::getGlobalMinBoxSize" ref="a38e7e581ec5d2ceb7f0130eca279a84f" args="(int block_number) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a>&amp; SAMRAI::hier::BoxLevel::getGlobalMinBoxSize </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>block_number</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return size of the smallest <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> globally in a block. </p>
<p>This requires a global reduction if the global bounding box has not been computed and cached. When communication is required, all processors must call this method. To ensure that no communication is needed, call <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#a88d752dca7dd51b8c1b0b0aa27c3d64e" title="If global reduced data (global Box count, global cell count and global bounding box)...">cacheGlobalReducedData()</a> first. </p>

<p>References <a class="el" href="BoxLevel_8C_source.html#l00567">cacheGlobalReducedData()</a>.</p>

</div>
</div>
<a class="anchor" id="a9a051730fadf4671bf844259fe45fd39"></a><!-- doxytag: member="SAMRAI::hier::BoxLevel::getDim" ref="a9a051730fadf4671bf844259fe45fd39" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classSAMRAI_1_1tbox_1_1Dimension.html">tbox::Dimension</a>&amp; SAMRAI::hier::BoxLevel::getDim </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return the dimension of this object. </p>

<p>References <a class="el" href="IntVector_8h_source.html#l00719">SAMRAI::hier::IntVector::getDim()</a>.</p>

<p>Referenced by <a class="el" href="BoxLevel_8C_source.html#l00993">addBox()</a>, <a class="el" href="BoxLevel_8C_source.html#l01055">addPeriodicBox()</a>, <a class="el" href="BoxLevelConnectorUtils_8C_source.html#l01210">SAMRAI::hier::BoxLevelConnectorUtils::addPeriodicImages()</a>, <a class="el" href="BoxLevelConnectorUtils_8C_source.html#l00095">SAMRAI::hier::BoxLevelConnectorUtils::baseNestsInHead()</a>, <a class="el" href="BoxLevel_8C_source.html#l00567">cacheGlobalReducedData()</a>, <a class="el" href="BalanceUtilities_8C_source.html#l02096">SAMRAI::mesh::BalanceUtilities::constrainMaxBoxSizes()</a>, <a class="el" href="BalanceUtilities_8C_source.html#l01836">SAMRAI::mesh::BalanceUtilities::findSmallBoxesInPostbalance()</a>, <a class="el" href="BoxLevel_8h_source.html#l01167">getBox()</a>, <a class="el" href="BoxLevel_8C_source.html#l01407">getBoxStrict()</a>, <a class="el" href="BoxLevel_8h_source.html#l01249">hasBox()</a>, <a class="el" href="GraphLoadBalancer_8C_source.html#l00072">SAMRAI::mesh::GraphLoadBalancer::loadBalanceBoxLevel()</a>, <a class="el" href="BoxLevelConnectorUtils_8C_source.html#l01084">SAMRAI::hier::BoxLevelConnectorUtils::makeRemainderMap()</a>, <a class="el" href="BoxLevelConnectorUtils_8C_source.html#l00362">SAMRAI::hier::BoxLevelConnectorUtils::makeSortingMap()</a>, <a class="el" href="BalanceUtilities_8C_source.html#l02201">SAMRAI::mesh::BalanceUtilities::prebalanceBoxLevel()</a>, <a class="el" href="BoxLevel_8C_source.html#l01595">recursivePrint()</a>, and <a class="el" href="BoxLevel_8C_source.html#l00438">swap()</a>.</p>

</div>
</div>
<a class="anchor" id="aec78d23ef813cea9c1f08b30d6cec25f"></a><!-- doxytag: member="SAMRAI::hier::BoxLevel::getGridGeometry" ref="aec78d23ef813cea9c1f08b30d6cec25f" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const boost::shared_ptr&lt;const <a class="el" href="classSAMRAI_1_1hier_1_1BaseGridGeometry.html">BaseGridGeometry</a>&gt;&amp; SAMRAI::hier::BoxLevel::getGridGeometry </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return the grid geometry associated with this object. </p>
<p>If object has never been initialized, return NULL pointer. </p>

<p>Referenced by <a class="el" href="BoxLevelConnectorUtils_8C_source.html#l00171">SAMRAI::hier::BoxLevelConnectorUtils::baseNestsInHead()</a>, <a class="el" href="Connector_8C_source.html#l01798">SAMRAI::hier::Connector::checkOverlapCorrectness()</a>, <a class="el" href="PatchLevelInteriorFillPattern_8C_source.html#l00105">SAMRAI::xfer::PatchLevelInteriorFillPattern::computeDestinationFillBoxesOnSourceProc()</a>, <a class="el" href="PatchLevelFullFillPattern_8C_source.html#l00102">SAMRAI::xfer::PatchLevelFullFillPattern::computeDestinationFillBoxesOnSourceProc()</a>, <a class="el" href="PatchLevelInteriorFillPattern_8C_source.html#l00061">SAMRAI::xfer::PatchLevelInteriorFillPattern::computeFillBoxesAndNeighborhoodSets()</a>, <a class="el" href="PatchLevelFullFillPattern_8C_source.html#l00060">SAMRAI::xfer::PatchLevelFullFillPattern::computeFillBoxesAndNeighborhoodSets()</a>, <a class="el" href="PatchLevelEnhancedFillPattern_8C_source.html#l00052">SAMRAI::xfer::PatchLevelEnhancedFillPattern::computeFillBoxesAndNeighborhoodSets()</a>, <a class="el" href="PatchLevelBorderFillPattern_8C_source.html#l00053">SAMRAI::xfer::PatchLevelBorderFillPattern::computeFillBoxesAndNeighborhoodSets()</a>, <a class="el" href="PatchLevelBorderAndInteriorFillPattern_8C_source.html#l00052">SAMRAI::xfer::PatchLevelBorderAndInteriorFillPattern::computeFillBoxesAndNeighborhoodSets()</a>, <a class="el" href="BalanceUtilities_8C_source.html#l02096">SAMRAI::mesh::BalanceUtilities::constrainMaxBoxSizes()</a>, <a class="el" href="OverlapConnectorAlgorithm_8C_source.html#l00121">SAMRAI::hier::OverlapConnectorAlgorithm::extractNeighbors()</a>, <a class="el" href="Connector_8C_source.html#l00543">SAMRAI::hier::Connector::finalizeContext()</a>, <a class="el" href="TileClustering_8C_source.html#l00115">SAMRAI::mesh::TileClustering::findBoxesContainingTags()</a>, <a class="el" href="TreeLoadBalancer_8C_source.html#l00165">SAMRAI::mesh::TreeLoadBalancer::loadBalanceBoxLevel()</a>, <a class="el" href="GraphLoadBalancer_8C_source.html#l00072">SAMRAI::mesh::GraphLoadBalancer::loadBalanceBoxLevel()</a>, <a class="el" href="ChopAndPackLoadBalancer_8C_source.html#l00254">SAMRAI::mesh::ChopAndPackLoadBalancer::loadBalanceBoxLevel()</a>, <a class="el" href="CascadePartitioner_8C_source.html#l00157">SAMRAI::mesh::CascadePartitioner::loadBalanceBoxLevel()</a>, <a class="el" href="PatchHierarchy_8C_source.html#l00718">SAMRAI::hier::PatchHierarchy::makeNewPatchLevel()</a>, <a class="el" href="BoxLevelConnectorUtils_8C_source.html#l00362">SAMRAI::hier::BoxLevelConnectorUtils::makeSortingMap()</a>, <a class="el" href="BalanceUtilities_8C_source.html#l02201">SAMRAI::mesh::BalanceUtilities::prebalanceBoxLevel()</a>, and <a class="el" href="BoxLevel_8C_source.html#l00438">swap()</a>.</p>

</div>
</div>
<a class="anchor" id="af9d572999cb352e26876d5641c89f28c"></a><!-- doxytag: member="SAMRAI::hier::BoxLevel::refineBoxes" ref="af9d572999cb352e26876d5641c89f28c" args="(BoxLevel &amp;finer, const IntVector &amp;ratio, const IntVector &amp;final_ratio) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::hier::BoxLevel::refineBoxes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>finer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>ratio</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>final_ratio</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Refine all Boxes of this <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html" title="A distributed set of Box objects which reside in the same index space.">BoxLevel</a> by ratio placing result into finer making finer's ratio final_ratio. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>finer</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>ratio</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>final_ratio</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="BoxLevel_8h_source.html#l00104">GLOBALIZED</a>, and <a class="el" href="BoxContainer_8C_source.html#l01590">SAMRAI::hier::BoxContainer::refine()</a>.</p>

<p>Referenced by <a class="el" href="BaseGridGeometry_8C_source.html#l01243">SAMRAI::hier::BaseGridGeometry::computePhysicalDomain()</a>.</p>

</div>
</div>
<a class="anchor" id="a6d08a9ac95f9c25ffb319bbc0e79f7b1"></a><!-- doxytag: member="SAMRAI::hier::BoxLevel::coarsenBoxes" ref="a6d08a9ac95f9c25ffb319bbc0e79f7b1" args="(BoxLevel &amp;coarser, const IntVector &amp;ratio, const IntVector &amp;final_ratio) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::hier::BoxLevel::coarsenBoxes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>coarser</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>ratio</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>final_ratio</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Coarsen all Boxes of this <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html" title="A distributed set of Box objects which reside in the same index space.">BoxLevel</a> by ratio placing result into coarser making coarser's ratio final_ratio. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>coarser</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>ratio</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>final_ratio</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="BoxContainer_8C_source.html#l01602">SAMRAI::hier::BoxContainer::coarsen()</a>, and <a class="el" href="BoxLevel_8h_source.html#l00104">GLOBALIZED</a>.</p>

<p>Referenced by <a class="el" href="BaseGridGeometry_8C_source.html#l01243">SAMRAI::hier::BaseGridGeometry::computePhysicalDomain()</a>.</p>

</div>
</div>
<a class="anchor" id="a7f03d7672157b32ea927b73751663872"></a><!-- doxytag: member="SAMRAI::hier::BoxLevel::addBox" ref="a7f03d7672157b32ea927b73751663872" args="(const Box &amp;box, const BlockId &amp;block_id)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer_1_1BoxContainerConstIterator.html">BoxContainer::const_iterator</a> SAMRAI::hier::BoxLevel::addBox </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>box</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1BlockId.html">BlockId</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>block_id</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create new local <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> from given <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> and add it to this level. </p>
<p>The new <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> will be assigned an unused local index, so the input box need not have a valid one. To be efficient, no communication will be used. Therefore, the state must be distributed.</p>
<p>The new <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> will have a periodic shift number corresponding to zero-shift.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>It is imperative that applications which call addBox also call invalidateGlobalData. It is possible for some processes to add Boxes and for others to not. Since the addBox method sets d_global_data_up_to_date to false, some processes in this situation will have this flag set to true and others will not. This will result in a hang in cacheGlobalReducedData when global data is accessed. We could have performed and allReduce of this flag to the top of cacheGlobalReducedData but this would have added a costly call for every access of global data.</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>box</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>block_id</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>iterator to the new <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a></dd></dl>
<dl class="pre"><dt><b>Precondition:</b></dt><dd><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#ae0f03563c8ba07e61c0262ebac27b6c2" title="Returns the ParallelState of the object.">getParallelState()</a> == DISTRIBUTED </dd>
<dd>
(box.getBlockId() == <a class="el" href="classSAMRAI_1_1hier_1_1BlockId.html#af5ec2c3b87256cd021571cd78a897d92" title="Get the designated invalid value for this class.">BlockId::invalidId()</a>) || (box.getBlockId() == block_id) </dd></dl>

<p>References <a class="el" href="BoxContainer_8h_source.html#l00701">SAMRAI::hier::BoxContainer::begin()</a>, <a class="el" href="BoxLevel_8h_source.html#l00263">clearForBoxChanges()</a>, <a class="el" href="BoxLevel_8h_source.html#l00104">DISTRIBUTED</a>, <a class="el" href="BoxContainer_8h_source.html#l00712">SAMRAI::hier::BoxContainer::end()</a>, <a class="el" href="Box_8h_source.html#l00326">SAMRAI::hier::Box::getBlockId()</a>, <a class="el" href="BlockId_8h_source.html#l00095">SAMRAI::hier::BlockId::getBlockValue()</a>, <a class="el" href="PeriodicShiftCatalog_8C_source.html#l00044">SAMRAI::hier::PeriodicShiftCatalog::getCatalog()</a>, <a class="el" href="BoxLevel_8h_source.html#l00827">getDim()</a>, <a class="el" href="SAMRAI__MPI_8h_source.html#l00214">SAMRAI::tbox::SAMRAI_MPI::getRank()</a>, <a class="el" href="LocalId_8h_source.html#l00120">SAMRAI::hier::LocalId::getZero()</a>, <a class="el" href="PeriodicShiftCatalog_8h_source.html#l00148">SAMRAI::hier::PeriodicShiftCatalog::getZeroShiftNumber()</a>, <a class="el" href="BoxContainer_8C_source.html#l00290">SAMRAI::hier::BoxContainer::insert()</a>, <a class="el" href="BlockId_8h_source.html#l00113">SAMRAI::hier::BlockId::invalidId()</a>, <a class="el" href="BoxContainer_8h_source.html#l00677">SAMRAI::hier::BoxContainer::isEmpty()</a>, <a class="el" href="BoxLevel_8h_source.html#l01587">locked()</a>, <a class="el" href="Box_8h_source.html#l00641">SAMRAI::hier::Box::size()</a>, <a class="el" href="Utilities_8h_source.html#l00110">TBOX_ASSERT</a>, and <a class="el" href="Utilities_8h_source.html#l00060">TBOX_ERROR</a>.</p>

<p>Referenced by <a class="el" href="ChopAndPackLoadBalancer_8C_source.html#l00254">SAMRAI::mesh::ChopAndPackLoadBalancer::loadBalanceBoxLevel()</a>, and <a class="el" href="BoxTransitSet_8C_source.html#l00450">SAMRAI::mesh::BoxTransitSet::putInBoxLevel()</a>.</p>

</div>
</div>
<a class="anchor" id="a7a80e5adb2b547f075125db37be16ff7"></a><!-- doxytag: member="SAMRAI::hier::BoxLevel::addBox" ref="a7a80e5adb2b547f075125db37be16ff7" args="(const Box &amp;box)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::hier::BoxLevel::addBox </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>box</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Add a <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> to this level. </p>
<dl class="user"><dt><b>CAUTION</b></dt><dd>To be efficient, no checks are made to make sure the <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html" title="A distributed set of Box objects which reside in the same index space.">BoxLevel</a> representation is consistent across all processors. Setting inconsistent data leads potentially elusive bugs.</dd></dl>
<dl class="user"><dt><b>Errors</b></dt><dd>It is an error to add a periodic image of a <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> that is not a part of the <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html" title="A distributed set of Box objects which reside in the same index space.">BoxLevel</a>.</dd></dl>
<p>It is an error to add any <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> that already exists.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>It is imperative that applications which call addBox also call invalidateGlobalData. It is possible for some processes to add Boxes and for others to not. Since the addBox method sets d_global_data_up_to_date to false, some processes in this situation will have this flag set to true and others will not. This will result in a hang in cacheGlobalReducedData when global data is accessed. We could have performed and allReduce of this flag to the top of cacheGlobalReducedData but this would have added a costly call for every access of global data.</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>box</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="BoxLevel_8h_source.html#l00263">clearForBoxChanges()</a>, <a class="el" href="BoxContainer_8h_source.html#l00712">SAMRAI::hier::BoxContainer::end()</a>, <a class="el" href="BoxContainer_8h_source.html#l01578">SAMRAI::hier::BoxContainer::find()</a>, <a class="el" href="Box_8h_source.html#l00326">SAMRAI::hier::Box::getBlockId()</a>, <a class="el" href="BlockId_8h_source.html#l00095">SAMRAI::hier::BlockId::getBlockValue()</a>, <a class="el" href="PeriodicShiftCatalog_8C_source.html#l00044">SAMRAI::hier::PeriodicShiftCatalog::getCatalog()</a>, <a class="el" href="BoxLevel_8h_source.html#l00827">getDim()</a>, <a class="el" href="Box_8h_source.html#l00347">SAMRAI::hier::Box::getGlobalId()</a>, <a class="el" href="Box_8h_source.html#l00340">SAMRAI::hier::Box::getLocalId()</a>, <a class="el" href="Box_8h_source.html#l00354">SAMRAI::hier::Box::getOwnerRank()</a>, <a class="el" href="SAMRAI__MPI_8h_source.html#l00214">SAMRAI::tbox::SAMRAI_MPI::getRank()</a>, <a class="el" href="PeriodicShiftCatalog_8h_source.html#l00148">SAMRAI::hier::PeriodicShiftCatalog::getZeroShiftNumber()</a>, <a class="el" href="BoxLevel_8h_source.html#l00104">GLOBALIZED</a>, <a class="el" href="BoxContainer_8C_source.html#l00290">SAMRAI::hier::BoxContainer::insert()</a>, <a class="el" href="Box_8h_source.html#l00372">SAMRAI::hier::Box::isPeriodicImage()</a>, <a class="el" href="LocalId_8h_source.html#l00111">SAMRAI::hier::LocalId::isValid()</a>, <a class="el" href="BoxLevel_8h_source.html#l01587">locked()</a>, <a class="el" href="Box_8h_source.html#l00610">SAMRAI::hier::Box::numberCells()</a>, <a class="el" href="Box_8h_source.html#l00641">SAMRAI::hier::Box::size()</a>, <a class="el" href="Utilities_8h_source.html#l00110">TBOX_ASSERT</a>, and <a class="el" href="Utilities_8h_source.html#l00060">TBOX_ERROR</a>.</p>

</div>
</div>
<a class="anchor" id="a7192f8a642329533e870d08ac4affb08"></a><!-- doxytag: member="SAMRAI::hier::BoxLevel::addBoxWithoutUpdate" ref="a7192f8a642329533e870d08ac4affb08" args="(const Box &amp;box)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::hier::BoxLevel::addBoxWithoutUpdate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>box</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Add a <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> to this level without updating summary data such as local number of boxes/cells, bounding box, max/min box size. Meant to be used during the construction of a <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html" title="A distributed set of Box objects which reside in the same index space.">BoxLevel</a> as Boxes belonging to the level are found. <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#ad1993c509749c5b3e92c0c534a51e9fd" title="Removes non-local boxes; computes bounding box, local number of boxes, local number...">finalize()</a> should be called at the end of construction making use of addBoxWithoutUpdate. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>box</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="BoxLevel_8h_source.html#l00309">getParallelState()</a>, <a class="el" href="BoxLevel_8h_source.html#l00104">GLOBALIZED</a>, <a class="el" href="BoxContainer_8C_source.html#l00290">SAMRAI::hier::BoxContainer::insert()</a>, <a class="el" href="BoxLevel_8h_source.html#l01587">locked()</a>, and <a class="el" href="Utilities_8h_source.html#l00060">TBOX_ERROR</a>.</p>

<p>Referenced by <a class="el" href="BaseGridGeometry_8C_source.html#l01243">SAMRAI::hier::BaseGridGeometry::computePhysicalDomain()</a>.</p>

</div>
</div>
<a class="anchor" id="a1efaddb0a58895344bfdc03003e1aa9d"></a><!-- doxytag: member="SAMRAI::hier::BoxLevel::addPeriodicBox" ref="a1efaddb0a58895344bfdc03003e1aa9d" args="(const Box &amp;existing_box, const PeriodicId &amp;shift_number)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::hier::BoxLevel::addPeriodicBox </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>existing_box</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1PeriodicId.html">PeriodicId</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>shift_number</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Insert given periodic image of an existing <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a>. </p>
<p>Unlike adding a regular <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a>, it is OK to add a periodic image <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> that already exists. However, that is a no-op.</p>
<dl class="user"><dt><b>CAUTION</b></dt><dd>To be efficient, no checks are made to make sure the <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html" title="A distributed set of Box objects which reside in the same index space.">BoxLevel</a> representation is consistent across all processors. Setting inconsistent data leads to potentially elusive bugs.</dd></dl>
<dl class="user"><dt><b>Errors</b></dt><dd>It is an error to add a periodic image of a <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> that does not exist.</dd></dl>
<p>TODO: Should we prevent this operation if persistent overlap Connectors are attached to this object?</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>existing_box</em>&nbsp;</td><td>An existing <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> for reference. This <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> must be in the <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html" title="A distributed set of Box objects which reside in the same index space.">BoxLevel</a>. The <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> added is an image of the reference <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> but shifted to another position. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>shift_number</em>&nbsp;</td><td>The valid shift number for the <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> being added. The shift amount is taken from the <a class="el" href="classSAMRAI_1_1hier_1_1PeriodicShiftCatalog.html" title="Singleton for cataloging periodic shifts and assigning each one a unique &quot;shift...">PeriodicShiftCatalog</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>shift_number != <a class="el" href="classSAMRAI_1_1hier_1_1PeriodicShiftCatalog.html#a4d449652b3f43509048878b9e0a9d6e1" title="Get the singleton object.">PeriodicShiftCatalog::getCatalog</a>(<a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#a9a051730fadf4671bf844259fe45fd39" title="Return the dimension of this object.">getDim()</a>)-&gt;getZeroShiftNumber() </dd></dl>

<p>References <a class="el" href="BoxLevel_8h_source.html#l00263">clearForBoxChanges()</a>, <a class="el" href="BoxLevel_8h_source.html#l00104">DISTRIBUTED</a>, <a class="el" href="BoxContainer_8h_source.html#l00712">SAMRAI::hier::BoxContainer::end()</a>, <a class="el" href="BoxContainer_8h_source.html#l01578">SAMRAI::hier::BoxContainer::find()</a>, <a class="el" href="PeriodicShiftCatalog_8C_source.html#l00044">SAMRAI::hier::PeriodicShiftCatalog::getCatalog()</a>, <a class="el" href="BoxLevel_8h_source.html#l00827">getDim()</a>, <a class="el" href="Box_8h_source.html#l00347">SAMRAI::hier::Box::getGlobalId()</a>, <a class="el" href="Box_8h_source.html#l00354">SAMRAI::hier::Box::getOwnerRank()</a>, <a class="el" href="SAMRAI__MPI_8h_source.html#l00214">SAMRAI::tbox::SAMRAI_MPI::getRank()</a>, <a class="el" href="PeriodicShiftCatalog_8h_source.html#l00148">SAMRAI::hier::PeriodicShiftCatalog::getZeroShiftNumber()</a>, <a class="el" href="BoxLevel_8h_source.html#l00104">GLOBALIZED</a>, <a class="el" href="BoxContainer_8C_source.html#l00290">SAMRAI::hier::BoxContainer::insert()</a>, <a class="el" href="BoxLevel_8h_source.html#l01587">locked()</a>, and <a class="el" href="Utilities_8h_source.html#l00060">TBOX_ERROR</a>.</p>

<p>Referenced by <a class="el" href="BoxLevelConnectorUtils_8C_source.html#l01210">SAMRAI::hier::BoxLevelConnectorUtils::addPeriodicImages()</a>, and <a class="el" href="BoxLevelConnectorUtils_8C_source.html#l01270">SAMRAI::hier::BoxLevelConnectorUtils::addPeriodicImagesAndRelationships()</a>.</p>

</div>
</div>
<a class="anchor" id="a960befb3bc83403345c75c7ed6a177e8"></a><!-- doxytag: member="SAMRAI::hier::BoxLevel::eraseBox" ref="a960befb3bc83403345c75c7ed6a177e8" args="(BoxContainer::iterator &amp;ibox)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::hier::BoxLevel::eraseBox </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer_1_1BoxContainerIterator.html">BoxContainer::iterator</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>ibox</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Erase the existing <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> specified by its iterator. </p>
<p>The given iterator <em>MUST</em> be a valid iterator pointing to a <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> currently in this object. After erasing, the iterator is advanced to the next valid <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> (or the end of its <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html" title="A container for Boxes.">BoxContainer</a>).</p>
<p>Erasing a <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> also erases all of its periodic images.</p>
<p>TODO: Should we prevent this operation if the object has persistent overlap Connectors?</p>
<dl class="note"><dt><b>Note:</b></dt><dd>It is imperative that applications which call eraseBox also call invalidateGlobalData. It is possible for some processes to erase Boxes and for others to not. Since the eraseBox method sets d_global_data_up_to_date to false, some processes in this situation will have this flag set to true and others will not. This will result in a hang in cacheGlobalReducedData when global data is accessed. We could have performed and allReduce of this flag to the top of cacheGlobalReducedData but this would have erased a costly call for every access of global data.</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>ibox</em>&nbsp;</td><td>The iterator of the <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> to erase.</td></tr>
  </table>
  </dd>
</dl>
<dl class="pre"><dt><b>Precondition:</b></dt><dd><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#ae0f03563c8ba07e61c0262ebac27b6c2" title="Returns the ParallelState of the object.">getParallelState()</a> == DISTRIBUTED </dd>
<dd>
ibox == <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#a1e75df2ef751e7ed7f42c9e9a0991fa3" title="Returns the container of local Boxes.">getBoxes()</a>.find(*ibox) </dd></dl>

<p>References <a class="el" href="BoxLevel_8h_source.html#l00263">clearForBoxChanges()</a>, <a class="el" href="BoxLevel_8h_source.html#l00104">DISTRIBUTED</a>, <a class="el" href="BoxContainer_8h_source.html#l00712">SAMRAI::hier::BoxContainer::end()</a>, <a class="el" href="BoxContainer_8C_source.html#l01456">SAMRAI::hier::BoxContainer::erase()</a>, <a class="el" href="BoxContainer_8h_source.html#l01578">SAMRAI::hier::BoxContainer::find()</a>, <a class="el" href="BoxLevel_8h_source.html#l01587">locked()</a>, and <a class="el" href="Utilities_8h_source.html#l00060">TBOX_ERROR</a>.</p>

</div>
</div>
<a class="anchor" id="aac786eaec7c2fa5256f41a685c945257"></a><!-- doxytag: member="SAMRAI::hier::BoxLevel::eraseBox" ref="aac786eaec7c2fa5256f41a685c945257" args="(const Box &amp;box)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::hier::BoxLevel::eraseBox </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>box</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Erase the <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> matching the one given. </p>
<p>The given <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> <em>MUST</em> match a <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> currently in this object. Matching means that the BoxId's match (disregarding the spatial coordinates).</p>
<p>Erasing a <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> also erases all of its periodic images.</p>
<p>TODO: Should we prevent this operation if the object has persistent overlap Connectors?</p>
<dl class="note"><dt><b>Note:</b></dt><dd>It is imperative that applications which call eraseBox also call invalidateGlobalData. It is possible for some processes to erase Boxes and for others to not. Since the eraseBox method sets d_global_data_up_to_date to false, some processes in this situation will have this flag set to true and others will not. This will result in a hang in cacheGlobalReducedData when global data is accessed. We could have performed and allReduce of this flag to the top of cacheGlobalReducedData but this would have erased a costly call for every access of global data.</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>box</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="pre"><dt><b>Precondition:</b></dt><dd><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#ae0f03563c8ba07e61c0262ebac27b6c2" title="Returns the ParallelState of the object.">getParallelState()</a> == DISTRIBUTED </dd>
<dd>
<a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#a1e75df2ef751e7ed7f42c9e9a0991fa3" title="Returns the container of local Boxes.">getBoxes()</a>.find(box) != <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#a1e75df2ef751e7ed7f42c9e9a0991fa3" title="Returns the container of local Boxes.">getBoxes()</a>.end() </dd></dl>

<p>References <a class="el" href="BoxLevel_8h_source.html#l00263">clearForBoxChanges()</a>, <a class="el" href="BoxLevel_8h_source.html#l00104">DISTRIBUTED</a>, <a class="el" href="BoxContainer_8h_source.html#l00712">SAMRAI::hier::BoxContainer::end()</a>, <a class="el" href="BoxContainer_8C_source.html#l01456">SAMRAI::hier::BoxContainer::erase()</a>, <a class="el" href="BoxContainer_8h_source.html#l01578">SAMRAI::hier::BoxContainer::find()</a>, <a class="el" href="BoxLevel_8h_source.html#l01587">locked()</a>, and <a class="el" href="Utilities_8h_source.html#l00060">TBOX_ERROR</a>.</p>

</div>
</div>
<a class="anchor" id="a0ee46cb63c7d8409c8688f3700605a98"></a><!-- doxytag: member="SAMRAI::hier::BoxLevel::eraseBoxWithoutUpdate" ref="a0ee46cb63c7d8409c8688f3700605a98" args="(const Box &amp;box)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::hier::BoxLevel::eraseBoxWithoutUpdate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>box</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Erases the <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> matching the supplied <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> from this level without updating summary data such as local number of boxes/cells, bounding box, max/min box size. Meant to be used during the construction of a <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html" title="A distributed set of Box objects which reside in the same index space.">BoxLevel</a> as Boxes not belonging to the level are found. <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#ad1993c509749c5b3e92c0c534a51e9fd" title="Removes non-local boxes; computes bounding box, local number of boxes, local number...">finalize()</a> should be called at the end of construction making use of eraseBoxWithoutUpdate. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>box</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="BoxContainer_8C_source.html#l01456">SAMRAI::hier::BoxContainer::erase()</a>, <a class="el" href="BoxLevel_8h_source.html#l01587">locked()</a>, and <a class="el" href="Utilities_8h_source.html#l00060">TBOX_ERROR</a>.</p>

</div>
</div>
<a class="anchor" id="aae14445c8c9e8c06bc7d3132ee490555"></a><!-- doxytag: member="SAMRAI::hier::BoxLevel::getBox" ref="aae14445c8c9e8c06bc7d3132ee490555" args="(const Box &amp;box) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer_1_1BoxContainerConstIterator.html">BoxContainer::const_iterator</a> SAMRAI::hier::BoxLevel::getBox </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>box</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Find the <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> matching the one given. </p>
<p>Only the <a class="el" href="classSAMRAI_1_1hier_1_1BoxId.html" title="Identifier for a Box, consisting of a GlobalId and a PeriodicId.">BoxId</a> matters in matching, so the actual <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> can be anything.</p>
<p>If <code>box</code> is not a local <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a>, the state must be GLOBALIZED.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>box</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Iterator to the box, or <code>getBoxes(owner)</code>.end() if box does not exist in set.</dd></dl>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>(box.getOwnerRank() == <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#aa56ee65e5e67d58f580b4a6a700c431f" title="Returns the SAMRAI_MPI communicator over which the Boxes are distributed.">getMPI()</a>.getRank()) || (<a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#ae0f03563c8ba07e61c0262ebac27b6c2" title="Returns the ParallelState of the object.">getParallelState()</a> == GLOBALIZED) </dd></dl>

<p>References <a class="el" href="BoxContainer_8h_source.html#l01578">SAMRAI::hier::BoxContainer::find()</a>, <a class="el" href="BoxLevel_8h_source.html#l00377">getMPI()</a>, <a class="el" href="Box_8h_source.html#l00354">SAMRAI::hier::Box::getOwnerRank()</a>, <a class="el" href="BoxLevel_8h_source.html#l00309">getParallelState()</a>, <a class="el" href="SAMRAI__MPI_8h_source.html#l00214">SAMRAI::tbox::SAMRAI_MPI::getRank()</a>, <a class="el" href="BoxLevel_8h_source.html#l00104">GLOBALIZED</a>, and <a class="el" href="Utilities_8h_source.html#l00060">TBOX_ERROR</a>.</p>

<p>Referenced by <a class="el" href="Connector_8C_source.html#l01236">SAMRAI::hier::Connector::checkTransposeCorrectness()</a>, <a class="el" href="PatchLevelInteriorFillPattern_8C_source.html#l00061">SAMRAI::xfer::PatchLevelInteriorFillPattern::computeFillBoxesAndNeighborhoodSets()</a>, <a class="el" href="PatchLevelBorderAndInteriorFillPattern_8C_source.html#l00052">SAMRAI::xfer::PatchLevelBorderAndInteriorFillPattern::computeFillBoxesAndNeighborhoodSets()</a>, <a class="el" href="Connector_8C_source.html#l00807">SAMRAI::hier::Connector::doLocalTransposeWork()</a>, <a class="el" href="OverlapConnectorAlgorithm_8C_source.html#l00121">SAMRAI::hier::OverlapConnectorAlgorithm::extractNeighbors()</a>, <a class="el" href="BoxLevel_8h_source.html#l01167">getBox()</a>, <a class="el" href="GraphLoadBalancer_8C_source.html#l00072">SAMRAI::mesh::GraphLoadBalancer::loadBalanceBoxLevel()</a>, and <a class="el" href="Connector_8C_source.html#l01056">SAMRAI::hier::Connector::recursivePrint()</a>.</p>

</div>
</div>
<a class="anchor" id="a2fc9a3140f7ad64850ad6556d53223ec"></a><!-- doxytag: member="SAMRAI::hier::BoxLevel::getBox" ref="a2fc9a3140f7ad64850ad6556d53223ec" args="(const BoxId &amp;box_id) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer_1_1BoxContainerConstIterator.html">BoxContainer::const_iterator</a> SAMRAI::hier::BoxLevel::getBox </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1BoxId.html">BoxId</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>box_id</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Find the <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> specified by the given <a class="el" href="classSAMRAI_1_1hier_1_1BoxId.html" title="Identifier for a Box, consisting of a GlobalId and a PeriodicId.">BoxId</a> and periodic shift. </p>
<p>If <code>box</code> is not a local <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a>, the state must be GLOBALIZED. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>box_id</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Iterator to the box, or <code>getBoxes(owner)</code>.end() if box does not exist in set. </dd></dl>

<p>References <a class="el" href="BoxLevel_8h_source.html#l01138">getBox()</a>, and <a class="el" href="BoxLevel_8h_source.html#l00827">getDim()</a>.</p>

</div>
</div>
<a class="anchor" id="aeb1f97fa84af6ba5c273c64c0ea0c80c"></a><!-- doxytag: member="SAMRAI::hier::BoxLevel::getBoxStrict" ref="aeb1f97fa84af6ba5c273c64c0ea0c80c" args="(const Box &amp;box) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer_1_1BoxContainerConstIterator.html">BoxContainer::const_iterator</a> SAMRAI::hier::BoxLevel::getBoxStrict </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>box</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Find the <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> matching the one given. </p>
<p>Only the <a class="el" href="classSAMRAI_1_1hier_1_1BoxId.html" title="Identifier for a Box, consisting of a GlobalId and a PeriodicId.">BoxId</a> matters in matching, so the actual <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> can be anything.</p>
<p>If <code>box</code> is not owned by the local process, the state must be GLOBALIZED.</p>
<p>You cannot directly modify the <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html" title="A container for Boxes.">BoxContainer</a> because it may invalidate other internal data. Use other methods for modifying the <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html" title="A container for Boxes.">BoxContainer</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>box</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Iterator to the box.</dd></dl>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>((box.getOwnerRank() == <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#aa56ee65e5e67d58f580b4a6a700c431f" title="Returns the SAMRAI_MPI communicator over which the Boxes are distributed.">getMPI()</a>.getRank()) &amp;&amp; (<a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#a1e75df2ef751e7ed7f42c9e9a0991fa3" title="Returns the container of local Boxes.">getBoxes()</a>.find(box) != <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#a1e75df2ef751e7ed7f42c9e9a0991fa3" title="Returns the container of local Boxes.">getBoxes()</a>.end())) || ((box.getOwnerRank() != <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#aa56ee65e5e67d58f580b4a6a700c431f" title="Returns the SAMRAI_MPI communicator over which the Boxes are distributed.">getMPI()</a>.getRank()) &amp;&amp; (<a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#ae0f03563c8ba07e61c0262ebac27b6c2" title="Returns the ParallelState of the object.">getParallelState()</a> == GLOBALIZED) &amp;&amp; (<a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#afe03004a023ac5e76e01aef59fd6a612" title="Returns the container of global Boxes.">getGlobalBoxes()</a>.find(box) != <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#afe03004a023ac5e76e01aef59fd6a612" title="Returns the container of global Boxes.">getGlobalBoxes()</a>.end())) </dd></dl>

<p>References <a class="el" href="BoxContainer_8h_source.html#l00712">SAMRAI::hier::BoxContainer::end()</a>, <a class="el" href="BoxContainer_8h_source.html#l01578">SAMRAI::hier::BoxContainer::find()</a>, <a class="el" href="Box_8h_source.html#l00354">SAMRAI::hier::Box::getOwnerRank()</a>, <a class="el" href="SAMRAI__MPI_8h_source.html#l00214">SAMRAI::tbox::SAMRAI_MPI::getRank()</a>, <a class="el" href="BoxLevel_8h_source.html#l00104">GLOBALIZED</a>, and <a class="el" href="Utilities_8h_source.html#l00060">TBOX_ERROR</a>.</p>

<p>Referenced by <a class="el" href="Connector_8C_source.html#l01798">SAMRAI::hier::Connector::checkOverlapCorrectness()</a>, <a class="el" href="Connector_8C_source.html#l01236">SAMRAI::hier::Connector::checkTransposeCorrectness()</a>, <a class="el" href="MappingConnector_8C_source.html#l00165">SAMRAI::hier::MappingConnector::findMappingErrors()</a>, and <a class="el" href="Connector_8C_source.html#l00354">SAMRAI::hier::Connector::shrinkWidth()</a>.</p>

</div>
</div>
<a class="anchor" id="a5d59700b00e6da268bf003a842f626ee"></a><!-- doxytag: member="SAMRAI::hier::BoxLevel::getBoxStrict" ref="a5d59700b00e6da268bf003a842f626ee" args="(const BoxId &amp;box_id) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer_1_1BoxContainerConstIterator.html">BoxContainer::const_iterator</a> SAMRAI::hier::BoxLevel::getBoxStrict </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1BoxId.html">BoxId</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>box_id</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Find the <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> specified by the given <a class="el" href="classSAMRAI_1_1hier_1_1BoxId.html" title="Identifier for a Box, consisting of a GlobalId and a PeriodicId.">BoxId</a>. </p>
<p>You cannot directly modify the <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html" title="A container for Boxes.">BoxContainer</a> because it may invalidate other internal data. Use other methods for modifying the <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html" title="A container for Boxes.">BoxContainer</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>box_id</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Iterator to the box.</dd></dl>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>(box_id.getOwnerRank() == <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#aa56ee65e5e67d58f580b4a6a700c431f" title="Returns the SAMRAI_MPI communicator over which the Boxes are distributed.">getMPI()</a>.getRank()) || (<a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#ae0f03563c8ba07e61c0262ebac27b6c2" title="Returns the ParallelState of the object.">getParallelState()</a> == GLOBALIZED) </dd>
<dd>
box with supplied <a class="el" href="classSAMRAI_1_1hier_1_1BoxId.html" title="Identifier for a Box, consisting of a GlobalId and a PeriodicId.">BoxId</a> exists in the <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html" title="A distributed set of Box objects which reside in the same index space.">BoxLevel</a> </dd></dl>

<p>References <a class="el" href="BoxContainer_8h_source.html#l00712">SAMRAI::hier::BoxContainer::end()</a>, <a class="el" href="BoxContainer_8h_source.html#l01578">SAMRAI::hier::BoxContainer::find()</a>, <a class="el" href="BoxLevel_8h_source.html#l00827">getDim()</a>, <a class="el" href="Box_8h_source.html#l00354">SAMRAI::hier::Box::getOwnerRank()</a>, <a class="el" href="BoxId_8h_source.html#l00127">SAMRAI::hier::BoxId::getOwnerRank()</a>, <a class="el" href="SAMRAI__MPI_8h_source.html#l00214">SAMRAI::tbox::SAMRAI_MPI::getRank()</a>, <a class="el" href="BoxLevel_8h_source.html#l00104">GLOBALIZED</a>, and <a class="el" href="Utilities_8h_source.html#l00060">TBOX_ERROR</a>.</p>

</div>
</div>
<a class="anchor" id="ac33526f84722654e4eec9ef11093aaac"></a><!-- doxytag: member="SAMRAI::hier::BoxLevel::getSpatiallyEqualBox" ref="ac33526f84722654e4eec9ef11093aaac" args="(const Box &amp;box_to_match, const BlockId &amp;block_id, Box &amp;matching_box) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SAMRAI::hier::BoxLevel::getSpatiallyEqualBox </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>box_to_match</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1BlockId.html">BlockId</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>block_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>matching_box</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Find the <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> with the given <a class="el" href="classSAMRAI_1_1hier_1_1BlockId.html" title="Generic identifier for identifying the block id.">BlockId</a> which is spatially equal to the supplied <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>box_to_match</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>block_id</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>matching_box</em>&nbsp;</td><td>If there is a box with the supplied <a class="el" href="classSAMRAI_1_1hier_1_1BlockId.html" title="Generic identifier for identifying the block id.">BlockId</a> spatially equal to box_to_match then this is set to that <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if a match is found. </dd></dl>

<p>References <a class="el" href="BoxContainer_8h_source.html#l00701">SAMRAI::hier::BoxContainer::begin()</a>, <a class="el" href="BoxContainer_8h_source.html#l00712">SAMRAI::hier::BoxContainer::end()</a>, and <a class="el" href="Box_8h_source.html#l00740">SAMRAI::hier::Box::isSpatiallyEqual()</a>.</p>

</div>
</div>
<a class="anchor" id="aa36386f372e60084d09119c9e8c36718"></a><!-- doxytag: member="SAMRAI::hier::BoxLevel::hasBox" ref="aa36386f372e60084d09119c9e8c36718" args="(const BoxId &amp;box_id) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SAMRAI::hier::BoxLevel::hasBox </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1BoxId.html">BoxId</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>box_id</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns true when the object has a <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> specified by the <a class="el" href="classSAMRAI_1_1hier_1_1BoxId.html" title="Identifier for a Box, consisting of a GlobalId and a PeriodicId.">BoxId</a>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>box_id</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="BoxLevel_8h_source.html#l00827">getDim()</a>.</p>

<p>Referenced by <a class="el" href="Connector_8C_source.html#l01476">SAMRAI::hier::Connector::checkConsistencyWithBase()</a>, <a class="el" href="Connector_8C_source.html#l01236">SAMRAI::hier::Connector::checkTransposeCorrectness()</a>, <a class="el" href="Connector_8C_source.html#l00807">SAMRAI::hier::Connector::doLocalTransposeWork()</a>, <a class="el" href="OverlapConnectorAlgorithm_8C_source.html#l00121">SAMRAI::hier::OverlapConnectorAlgorithm::extractNeighbors()</a>, <a class="el" href="Connector_8C_source.html#l00543">SAMRAI::hier::Connector::finalizeContext()</a>, <a class="el" href="MappingConnector_8C_source.html#l00165">SAMRAI::hier::MappingConnector::findMappingErrors()</a>, and <a class="el" href="BoxLevel_8h_source.html#l01264">hasBox()</a>.</p>

</div>
</div>
<a class="anchor" id="a1d8a2324f2425898efad09a23f1f61f6"></a><!-- doxytag: member="SAMRAI::hier::BoxLevel::hasBox" ref="a1d8a2324f2425898efad09a23f1f61f6" args="(const GlobalId &amp;global_id, const PeriodicId &amp;periodic_id) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SAMRAI::hier::BoxLevel::hasBox </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1GlobalId.html">GlobalId</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>global_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1PeriodicId.html">PeriodicId</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>periodic_id</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns true when the object has a <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> consistent with all of the arguments. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>global_id</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>periodic_id</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="BoxLevel_8h_source.html#l00827">getDim()</a>, and <a class="el" href="BoxLevel_8h_source.html#l01249">hasBox()</a>.</p>

</div>
</div>
<a class="anchor" id="a3b57ea9786676c090d5619abde08bd63"></a><!-- doxytag: member="SAMRAI::hier::BoxLevel::hasBox" ref="a3b57ea9786676c090d5619abde08bd63" args="(const Box &amp;box) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SAMRAI::hier::BoxLevel::hasBox </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>box</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns true when this <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html" title="A distributed set of Box objects which reside in the same index space.">BoxLevel</a> has a <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> matching the <a class="el" href="classSAMRAI_1_1hier_1_1BoxId.html" title="Identifier for a Box, consisting of a GlobalId and a PeriodicId.">BoxId</a> of the given box. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>box</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>(box.getOwnerRank() == <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#aa56ee65e5e67d58f580b4a6a700c431f" title="Returns the SAMRAI_MPI communicator over which the Boxes are distributed.">getMPI()</a>.getRank()) || (<a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#ae0f03563c8ba07e61c0262ebac27b6c2" title="Returns the ParallelState of the object.">getParallelState()</a> == GLOBALIZED) </dd></dl>

<p>References <a class="el" href="BoxLevel_8h_source.html#l00104">DISTRIBUTED</a>, <a class="el" href="BoxContainer_8h_source.html#l00712">SAMRAI::hier::BoxContainer::end()</a>, <a class="el" href="BoxContainer_8h_source.html#l01578">SAMRAI::hier::BoxContainer::find()</a>, <a class="el" href="Box_8h_source.html#l00354">SAMRAI::hier::Box::getOwnerRank()</a>, <a class="el" href="SAMRAI__MPI_8h_source.html#l00214">SAMRAI::tbox::SAMRAI_MPI::getRank()</a>, and <a class="el" href="Utilities_8h_source.html#l00060">TBOX_ERROR</a>.</p>

</div>
</div>
<a class="anchor" id="a8ec0ee23695893a76962ad8a8922f2a1"></a><!-- doxytag: member="SAMRAI::hier::BoxLevel::putToRestart" ref="a8ec0ee23695893a76962ad8a8922f2a1" args="(const boost::shared_ptr&lt; tbox::Database &gt; &amp;restart_db) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::hier::BoxLevel::putToRestart </td>
          <td>(</td>
          <td class="paramtype">const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Database.html">tbox::Database</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>restart_db</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Write the <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html" title="A distributed set of Box objects which reside in the same index space.">BoxLevel</a> to a restart database. </p>
<p>Write only local parts regardless of parallel state (to avoid writing tons of repetitive data).</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>restart_db</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="BoxLevel_8h_source.html#l00500">getBoxes()</a>, <a class="el" href="IntVector_8h_source.html#l00719">SAMRAI::hier::IntVector::getDim()</a>, <a class="el" href="SAMRAI__MPI_8h_source.html#l00214">SAMRAI::tbox::SAMRAI_MPI::getRank()</a>, <a class="el" href="SAMRAI__MPI_8h_source.html#l00224">SAMRAI::tbox::SAMRAI_MPI::getSize()</a>, <a class="el" href="Dimension_8h_source.html#l00133">SAMRAI::tbox::Dimension::getValue()</a>, and <a class="el" href="BoxContainer_8C_source.html#l01647">SAMRAI::hier::BoxContainer::putToRestart()</a>.</p>

</div>
</div>
<a class="anchor" id="af26bd3d728ba0f8094ee6b9acb593040"></a><!-- doxytag: member="SAMRAI::hier::BoxLevel::invalidateGlobalData" ref="af26bd3d728ba0f8094ee6b9acb593040" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::hier::BoxLevel::invalidateGlobalData </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets d_global_data_up_to_date to false. Must be called after calls to addBox or eraseBox. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#a7f03d7672157b32ea927b73751663872" title="Create new local Box from given Box and add it to this level.">addBox()</a> </dd>
<dd>
<a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#a960befb3bc83403345c75c7ed6a177e8" title="Erase the existing Box specified by its iterator.">eraseBox()</a> </dd></dl>

<p>References <a class="el" href="BoxLevel_8h_source.html#l01587">locked()</a>, and <a class="el" href="Utilities_8h_source.html#l00060">TBOX_ERROR</a>.</p>

</div>
</div>
<a class="anchor" id="a8ce8fadb18fcfcdd48f1b373a1b979a8"></a><!-- doxytag: member="SAMRAI::hier::BoxLevel::clearPersistentOverlapConnectors" ref="a8ce8fadb18fcfcdd48f1b373a1b979a8" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::hier::BoxLevel::clearPersistentOverlapConnectors </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Deallocate persistent overlap Connectors, if there are any. </p>

<p>Referenced by <a class="el" href="BoxLevel_8h_source.html#l00263">clearForBoxChanges()</a>, <a class="el" href="BoxLevel_8C_source.html#l00181">operator=()</a>, and <a class="el" href="BoxLevel_8C_source.html#l00438">swap()</a>.</p>

</div>
</div>
<a class="anchor" id="ad4ef30985671aaeac06be82bf7a238cb"></a><!-- doxytag: member="SAMRAI::hier::BoxLevel::findConnector" ref="ad4ef30985671aaeac06be82bf7a238cb" args="(const BoxLevel &amp;head, const IntVector &amp;min_connector_width, ConnectorNotFoundAction not_found_action, bool exact_width_only=false) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">Connector</a>&amp; SAMRAI::hier::BoxLevel::findConnector </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>head</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>min_connector_width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceSAMRAI_1_1hier.html#a256cef944748f7494c84017f5829101a">ConnectorNotFoundAction</a>&nbsp;</td>
          <td class="paramname"> <em>not_found_action</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>exact_width_only</em> = <code>false</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Find an overlap <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html" title="A container which holds relationship connections between two BoxLevels.">Connector</a> with the given head and minimum <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html" title="A container which holds relationship connections between two BoxLevels.">Connector</a> width. If the specified <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html" title="A container which holds relationship connections between two BoxLevels.">Connector</a> is not found, take the specified action. </p>
<p>If multiple Connectors fit the criteria, the one with the smallest ghost cell width (based on the algebraic sum of the components) is selected.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>head</em>&nbsp;</td><td>Find the overlap <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html" title="A container which holds relationship connections between two BoxLevels.">Connector</a> with this specified head. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>min_connector_width</em>&nbsp;</td><td>Find the overlap <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html" title="A container which holds relationship connections between two BoxLevels.">Connector</a> satisfying this minimum <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html" title="A container which holds relationship connections between two BoxLevels.">Connector</a> width. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>not_found_action</em>&nbsp;</td><td>Action to take if <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html" title="A container which holds relationship connections between two BoxLevels.">Connector</a> is not found. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>exact_width_only</em>&nbsp;</td><td>If true, reject Connectors that do not match the requested width exactly.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html" title="A container which holds relationship connections between two BoxLevels.">Connector</a> which matches the search criterion.</dd></dl>
<dl class="pre"><dt><b>Precondition:</b></dt><dd><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#ab5f4c8b090dbff0226e778e316b21920" title="Returns True if the object has been initialized.">isInitialized()</a> </dd>
<dd>
head.isInitialized() </dd></dl>

<p>Referenced by <a class="el" href="PatchLevelBorderFillPattern_8C_source.html#l00053">SAMRAI::xfer::PatchLevelBorderFillPattern::computeFillBoxesAndNeighborhoodSets()</a>, and <a class="el" href="PatchLevelBorderAndInteriorFillPattern_8C_source.html#l00052">SAMRAI::xfer::PatchLevelBorderAndInteriorFillPattern::computeFillBoxesAndNeighborhoodSets()</a>.</p>

</div>
</div>
<a class="anchor" id="a9ef122b8e4b1c02fa4850a6a81976110"></a><!-- doxytag: member="SAMRAI::hier::BoxLevel::findConnectorWithTranspose" ref="a9ef122b8e4b1c02fa4850a6a81976110" args="(const BoxLevel &amp;head, const IntVector &amp;min_connector_width, const IntVector &amp;transpose_min_connector_width, ConnectorNotFoundAction not_found_action, bool exact_width_only=false) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">Connector</a>&amp; SAMRAI::hier::BoxLevel::findConnectorWithTranspose </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>head</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>min_connector_width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>transpose_min_connector_width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceSAMRAI_1_1hier.html#a256cef944748f7494c84017f5829101a">ConnectorNotFoundAction</a>&nbsp;</td>
          <td class="paramname"> <em>not_found_action</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>exact_width_only</em> = <code>false</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Find an overlap <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html" title="A container which holds relationship connections between two BoxLevels.">Connector</a> with its transpose with the given head and minimum <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html" title="A container which holds relationship connections between two BoxLevels.">Connector</a> widths. If the specified <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html" title="A container which holds relationship connections between two BoxLevels.">Connector</a> is not found, take the specified action. </p>
<p>If multiple Connectors fit the criteria, the one with the smallest ghost cell width (based on the algebraic sum of the components) is selected.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>head</em>&nbsp;</td><td>Find the overlap <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html" title="A container which holds relationship connections between two BoxLevels.">Connector</a> with this specified head. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>min_connector_width</em>&nbsp;</td><td>Find the overlap <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html" title="A container which holds relationship connections between two BoxLevels.">Connector</a> satisfying this minimum <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html" title="A container which holds relationship connections between two BoxLevels.">Connector</a> width. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>transpose_min_connector_width</em>&nbsp;</td><td>Find the transpose overlap <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html" title="A container which holds relationship connections between two BoxLevels.">Connector</a> satisfying this minimum <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html" title="A container which holds relationship connections between two BoxLevels.">Connector</a> width. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>not_found_action</em>&nbsp;</td><td>Action to take if <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html" title="A container which holds relationship connections between two BoxLevels.">Connector</a> is not found. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>exact_width_only</em>&nbsp;</td><td>If true, reject Connectors that do not match the requested width exactly.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html" title="A container which holds relationship connections between two BoxLevels.">Connector</a> which matches the search criterion.</dd></dl>
<dl class="pre"><dt><b>Precondition:</b></dt><dd><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#ab5f4c8b090dbff0226e778e316b21920" title="Returns True if the object has been initialized.">isInitialized()</a> </dd>
<dd>
head.isInitialized() </dd></dl>

</div>
</div>
<a class="anchor" id="a02aa235c3d2e5b9700a81e6853294fb7"></a><!-- doxytag: member="SAMRAI::hier::BoxLevel::createConnector" ref="a02aa235c3d2e5b9700a81e6853294fb7" args="(const BoxLevel &amp;head, const IntVector &amp;connector_width) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">Connector</a>&amp; SAMRAI::hier::BoxLevel::createConnector </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>head</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>connector_width</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create an overlap <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html" title="A container which holds relationship connections between two BoxLevels.">Connector</a>, computing relationships by globalizing data. </p>
<p>The base will be this <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html" title="A distributed set of Box objects which reside in the same index space.">BoxLevel</a>. Find <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html" title="A container which holds relationship connections between two BoxLevels.">Connector</a> relationships using a (non-scalable) global search.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classSAMRAI_1_1hier_1_1Connector.html" title="A container which holds relationship connections between two BoxLevels.">hier::Connector</a> </dd>
<dd>
hier::Connector::initialize()</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>head</em>&nbsp;</td><td>This <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html" title="A distributed set of Box objects which reside in the same index space.">BoxLevel</a> will be the head. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>connector_width</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A const reference to the newly created overlap <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html" title="A container which holds relationship connections between two BoxLevels.">Connector</a>.</dd></dl>
<dl class="pre"><dt><b>Precondition:</b></dt><dd><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#ab5f4c8b090dbff0226e778e316b21920" title="Returns True if the object has been initialized.">isInitialized()</a> </dd>
<dd>
head.isInitialized() </dd></dl>

</div>
</div>
<a class="anchor" id="a85bf92f1e262d7e182442aa09316640d"></a><!-- doxytag: member="SAMRAI::hier::BoxLevel::createConnectorWithTranspose" ref="a85bf92f1e262d7e182442aa09316640d" args="(const BoxLevel &amp;head, const IntVector &amp;connector_width, const IntVector &amp;transpose_connector_width) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">Connector</a>&amp; SAMRAI::hier::BoxLevel::createConnectorWithTranspose </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>head</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>connector_width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>transpose_connector_width</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create an overlap <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html" title="A container which holds relationship connections between two BoxLevels.">Connector</a> with its transpose, computing relationships by globalizing data. </p>
<p>The base will be this <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html" title="A distributed set of Box objects which reside in the same index space.">BoxLevel</a>. Find <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html" title="A container which holds relationship connections between two BoxLevels.">Connector</a> relationships using a (non-scalable) global search.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classSAMRAI_1_1hier_1_1Connector.html" title="A container which holds relationship connections between two BoxLevels.">hier::Connector</a> </dd>
<dd>
hier::Connector::initialize()</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>head</em>&nbsp;</td><td>This <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html" title="A distributed set of Box objects which reside in the same index space.">BoxLevel</a> will be the head. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>connector_width</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>transpose_connector_width</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A const reference to the newly created overlap <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html" title="A container which holds relationship connections between two BoxLevels.">Connector</a>.</dd></dl>
<dl class="pre"><dt><b>Precondition:</b></dt><dd><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#ab5f4c8b090dbff0226e778e316b21920" title="Returns True if the object has been initialized.">isInitialized()</a> </dd>
<dd>
head.isInitialized() </dd></dl>

</div>
</div>
<a class="anchor" id="a6caf4ac1f3c3b137a4bc890e3680c710"></a><!-- doxytag: member="SAMRAI::hier::BoxLevel::cacheConnector" ref="a6caf4ac1f3c3b137a4bc890e3680c710" args="(boost::shared_ptr&lt; Connector &gt; &amp;connector) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::hier::BoxLevel::cacheConnector </td>
          <td>(</td>
          <td class="paramtype">boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">Connector</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>connector</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Cache the supplied overlap <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html" title="A container which holds relationship connections between two BoxLevels.">Connector</a> and its transpose if it exists. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>connector</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="pre"><dt><b>Precondition:</b></dt><dd><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#ab5f4c8b090dbff0226e778e316b21920" title="Returns True if the object has been initialized.">isInitialized()</a> </dd>
<dd>
connector </dd></dl>

</div>
</div>
<a class="anchor" id="a5843797f8b24c016bb92eb4b963f65ac"></a><!-- doxytag: member="SAMRAI::hier::BoxLevel::hasConnector" ref="a5843797f8b24c016bb92eb4b963f65ac" args="(const BoxLevel &amp;head, const IntVector &amp;min_connector_width, bool exact_width_only=false) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SAMRAI::hier::BoxLevel::hasConnector </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>head</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>min_connector_width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>exact_width_only</em> = <code>false</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns whether the object has overlap Connectors with the given head and minimum <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html" title="A container which holds relationship connections between two BoxLevels.">Connector</a> width. </p>
<p>TODO: does the following comment mean that this must be called before the call to findConnector?</p>
<p>If this returns true, the <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html" title="A container which holds relationship connections between two BoxLevels.">Connector</a> fitting the specification exists and <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#ad4ef30985671aaeac06be82bf7a238cb" title="Find an overlap Connector with the given head and minimum Connector width. If the...">findConnector()</a> will not throw an assertion.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>head</em>&nbsp;</td><td>Find the overlap <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html" title="A container which holds relationship connections between two BoxLevels.">Connector</a> with this specified head. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>min_connector_width</em>&nbsp;</td><td>Find the overlap <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html" title="A container which holds relationship connections between two BoxLevels.">Connector</a> satisfying this minimum ghost cell width. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>exact_width_only</em>&nbsp;</td><td>If true, reject Connectors that do not match the requested width exactly.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>True if a <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html" title="A container which holds relationship connections between two BoxLevels.">Connector</a> is found, otherwise false. </dd></dl>

</div>
</div>
<a class="anchor" id="ad28ae9914fffcd6712061af51e0fbfef"></a><!-- doxytag: member="SAMRAI::hier::BoxLevel::getBoxLevelHandle" ref="ad28ae9914fffcd6712061af51e0fbfef" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const boost::shared_ptr&lt;<a class="el" href="classSAMRAI_1_1hier_1_1BoxLevelHandle.html">BoxLevelHandle</a>&gt;&amp; SAMRAI::hier::BoxLevel::getBoxLevelHandle </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the handle with which Connectors reference the <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html" title="A distributed set of Box objects which reside in the same index space.">BoxLevel</a> instead of referencing the <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html" title="A distributed set of Box objects which reside in the same index space.">BoxLevel</a> itself. Not for general use. </p>
<p>Connectors referencing their base and head BoxLevels should reference their handles instead of the BoxLevels themselves. As long as the <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html" title="A distributed set of Box objects which reside in the same index space.">BoxLevel</a> does not change in a way that can invalidate <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html" title="A container which holds relationship connections between two BoxLevels.">Connector</a> data, you can access the <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html" title="A distributed set of Box objects which reside in the same index space.">BoxLevel</a> from the <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevelHandle.html" title="A handle for Connectors to access their head and base BoxLevels. A BoxLevel automatically...">BoxLevelHandle</a>.</p>
<p>If the <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html" title="A distributed set of Box objects which reside in the same index space.">BoxLevel</a> go out of scope before the <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html" title="A container which holds relationship connections between two BoxLevels.">Connector</a> disconnects, this boost::shared_ptr object will stay around until all Connectors have disconnected.</p>
<p>Operations that can invalidate <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html" title="A container which holds relationship connections between two BoxLevels.">Connector</a> data are those that remove information from the <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html" title="A distributed set of Box objects which reside in the same index space.">BoxLevel</a>. These are:</p>
<ul>
<li><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#a9b206530a59ce546b1bdbea4aa1dd5fc" title="Initialize the BoxLevel without and Boxes.">initialize()</a> </li>
<li><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#ab1fd7baf5161fcdbbb830480f3f77293" title="Initialize the BoxLevel.">swapInitialize()</a> </li>
<li><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#a9eebd53c534a0b42c59cf9cb08f2777e" title="Swap the contents of two BoxLevel objects.">swap()</a> </li>
<li><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#ad1e2b6cbb81383c7661222048edd103c" title="Clear the internal state of the BoxLevel.">clear()</a> </li>
<li><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#a13c61b0dbe112df0eca5960e378f35c5" title="Assignment operator duplicates all internal data, including parallel mode.">operator=()</a> (assignment) (Exception: assigning to self is a no-op, which does not invalidate <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html" title="A container which holds relationship connections between two BoxLevels.">Connector</a> data. </li>
<li><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#a960befb3bc83403345c75c7ed6a177e8" title="Erase the existing Box specified by its iterator.">eraseBox()</a> (Note that adding a <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> does not invalidate <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html" title="A container which holds relationship connections between two BoxLevels.">Connector</a> data.) </li>
<li>going out of scope</li>
</ul>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevelHandle.html" title="A handle for Connectors to access their head and base BoxLevels. A BoxLevel automatically...">BoxLevelHandle</a>.</dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A boost::shared_ptr to the <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevelHandle.html" title="A handle for Connectors to access their head and base BoxLevels. A BoxLevel automatically...">BoxLevelHandle</a></dd></dl>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>!d_handle || (d_handle-&gt;d_box_level == this) </dd></dl>

<p>References <a class="el" href="Utilities_8h_source.html#l00060">TBOX_ERROR</a>.</p>

<p>Referenced by <a class="el" href="BoxLevelHandle_8C_source.html#l00040">SAMRAI::hier::BoxLevelHandle::getBoxLevel()</a>, <a class="el" href="Connector_8C_source.html#l00628">SAMRAI::hier::Connector::setBase()</a>, and <a class="el" href="Connector_8C_source.html#l00650">SAMRAI::hier::Connector::setHead()</a>.</p>

</div>
</div>
<a class="anchor" id="add9723ad7a88b27b00f7a691d6eb2e0c"></a><!-- doxytag: member="SAMRAI::hier::BoxLevel::lock" ref="add9723ad7a88b27b00f7a691d6eb2e0c" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::hier::BoxLevel::lock </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Effectively makes a non-const <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html" title="A distributed set of Box objects which reside in the same index space.">BoxLevel</a> const. Prevents any non-const method from executing. </p>

</div>
</div>
<a class="anchor" id="a8f53858f6a358760477cbf8f42615b1c"></a><!-- doxytag: member="SAMRAI::hier::BoxLevel::locked" ref="a8f53858f6a358760477cbf8f42615b1c" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SAMRAI::hier::BoxLevel::locked </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns true if the <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html" title="A distributed set of Box objects which reside in the same index space.">BoxLevel</a> is locked. </p>

<p>Referenced by <a class="el" href="BoxLevel_8C_source.html#l00993">addBox()</a>, <a class="el" href="BoxLevel_8h_source.html#l00991">addBoxWithoutUpdate()</a>, <a class="el" href="BoxLevel_8C_source.html#l01055">addPeriodicBox()</a>, <a class="el" href="BoxLevel_8C_source.html#l00408">clear()</a>, <a class="el" href="BoxLevel_8h_source.html#l00263">clearForBoxChanges()</a>, <a class="el" href="BoxLevel_8C_source.html#l01185">eraseBox()</a>, <a class="el" href="BoxLevel_8h_source.html#l01110">eraseBoxWithoutUpdate()</a>, <a class="el" href="BoxLevel_8C_source.html#l00267">finalize()</a>, <a class="el" href="BoxLevel_8C_source.html#l00225">initialize()</a>, <a class="el" href="BoxLevel_8h_source.html#l01317">invalidateGlobalData()</a>, <a class="el" href="BoxLevel_8C_source.html#l00181">operator=()</a>, <a class="el" href="BoxLevel_8C_source.html#l00384">removePeriodicImageBoxes()</a>, <a class="el" href="BoxLevel_8C_source.html#l00775">setParallelState()</a>, <a class="el" href="BoxLevel_8C_source.html#l00438">swap()</a>, and <a class="el" href="BoxLevel_8C_source.html#l00246">swapInitialize()</a>.</p>

</div>
</div>
<a class="anchor" id="a00c11404f06b3a72323cb3fc5d650309"></a><!-- doxytag: member="SAMRAI::hier::BoxLevel::recursivePrint" ref="a00c11404f06b3a72323cb3fc5d650309" args="(std::ostream &amp;os, const std::string &amp;border, int detail_depth=2) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::hier::BoxLevel::recursivePrint </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&nbsp;</td>
          <td class="paramname"> <em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>border</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>detail_depth</em> = <code>2</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Print <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> info from this level. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>os</em>&nbsp;</td><td>The output stream </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>border</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>detail_depth</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="BoxContainer_8h_source.html#l00701">SAMRAI::hier::BoxContainer::begin()</a>, <a class="el" href="BoxLevel_8h_source.html#l00104">DISTRIBUTED</a>, <a class="el" href="BoxContainer_8h_source.html#l00712">SAMRAI::hier::BoxContainer::end()</a>, <a class="el" href="SAMRAI__MPI_8h_source.html#l00233">SAMRAI::tbox::SAMRAI_MPI::getCommunicator()</a>, <a class="el" href="BoxLevel_8h_source.html#l00827">getDim()</a>, <a class="el" href="BoxLevel_8h_source.html#l00764">getGlobalBoundingBox()</a>, <a class="el" href="BoxLevel_8h_source.html#l00749">getLocalBoundingBox()</a>, <a class="el" href="BoxLevel_8h_source.html#l00309">getParallelState()</a>, <a class="el" href="SAMRAI__MPI_8h_source.html#l00214">SAMRAI::tbox::SAMRAI_MPI::getRank()</a>, <a class="el" href="BoxLevel_8h_source.html#l00562">getRefinementRatio()</a>, <a class="el" href="SAMRAI__MPI_8h_source.html#l00224">SAMRAI::tbox::SAMRAI_MPI::getSize()</a>, <a class="el" href="BoxLevel_8h_source.html#l00104">GLOBALIZED</a>, <a class="el" href="BoxLevel_8h_source.html#l00227">isInitialized()</a>, and <a class="el" href="Box_8h_source.html#l00610">SAMRAI::hier::Box::numberCells()</a>.</p>

<p>Referenced by <a class="el" href="BoxLevel_8C_source.html#l01547">SAMRAI::hier::operator&lt;&lt;()</a>.</p>

</div>
</div>
<a class="anchor" id="aef7ffb368ef636b78732ba7b64c51277"></a><!-- doxytag: member="SAMRAI::hier::BoxLevel::format" ref="aef7ffb368ef636b78732ba7b64c51277" args="(const std::string &amp;border=std::string(), int detail_depth=2) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel_1_1Outputter.html">BoxLevel::Outputter</a> SAMRAI::hier::BoxLevel::format </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>border</em> = <code>std::string()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>detail_depth</em> = <code>2</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return a object that can format the <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html" title="A distributed set of Box objects which reside in the same index space.">BoxLevel</a> for inserting into output streams. </p>
<p>Usage example: </p>
<div class="fragment"><pre class="fragment">    <a class="code" href="namespaceSAMRAI_1_1tbox.html#ab84041705493761fb17a8127e3a2dca2">tbox::plog</a> &lt;&lt; <span class="stringliteral">&quot;my box_level:\n&quot;</span> &lt;&lt; box_level.format() &lt;&lt; endl;
</pre></div><dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>border</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>detail_depth</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>

<p>Referenced by <a class="el" href="BoxLevelConnectorUtils_8C_source.html#l01270">SAMRAI::hier::BoxLevelConnectorUtils::addPeriodicImagesAndRelationships()</a>, <a class="el" href="MappingConnector_8C_source.html#l00143">SAMRAI::hier::MappingConnector::assertMappingValidity()</a>, <a class="el" href="Connector_8C_source.html#l00807">SAMRAI::hier::Connector::doLocalTransposeWork()</a>, <a class="el" href="OverlapConnectorAlgorithm_8C_source.html#l00121">SAMRAI::hier::OverlapConnectorAlgorithm::extractNeighbors()</a>, <a class="el" href="Connector_8C_source.html#l00543">SAMRAI::hier::Connector::finalizeContext()</a>, <a class="el" href="TreeLoadBalancer_8C_source.html#l00165">SAMRAI::mesh::TreeLoadBalancer::loadBalanceBoxLevel()</a>, <a class="el" href="CascadePartitioner_8C_source.html#l00157">SAMRAI::mesh::CascadePartitioner::loadBalanceBoxLevel()</a>, <a class="el" href="PatchHierarchy_8C_source.html#l00881">SAMRAI::hier::PatchHierarchy::logMetadataStatistics()</a>, and <a class="el" href="MappingConnectorAlgorithm_8C_source.html#l00115">SAMRAI::hier::MappingConnectorAlgorithm::modify()</a>.</p>

</div>
</div>
<a class="anchor" id="a0358ed57086330055c464956136feac8"></a><!-- doxytag: member="SAMRAI::hier::BoxLevel::formatStatistics" ref="a0358ed57086330055c464956136feac8" args="(const std::string &amp;border=std::string()) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel_1_1Outputter.html">BoxLevel::Outputter</a> SAMRAI::hier::BoxLevel::formatStatistics </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>border</em> = <code>std::string()</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return a object that can format the <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html" title="A distributed set of Box objects which reside in the same index space.">BoxLevel</a> for inserting its global statistics into output streams. </p>
<p>Usage example: </p>
<div class="fragment"><pre class="fragment">    std::cout &lt;&lt; <span class="stringliteral">&quot;my box_level statistics:\n&quot;</span>
              &lt;&lt; box_level.formatStatistics(<span class="stringliteral">&quot;  &quot;</span>) &lt;&lt; std::endl;
</pre></div><dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>border</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>

<p>Referenced by <a class="el" href="PatchHierarchy_8C_source.html#l00881">SAMRAI::hier::PatchHierarchy::logMetadataStatistics()</a>.</p>

</div>
</div>
<hr/><h2>Friends And Related Function Documentation</h2>
<a class="anchor" id="ae17fc1942f6de54c13321a9481366cd1"></a><!-- doxytag: member="SAMRAI::hier::BoxLevel::PersistentOverlapConnectors" ref="ae17fc1942f6de54c13321a9481366cd1" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="classSAMRAI_1_1hier_1_1PersistentOverlapConnectors.html">PersistentOverlapConnectors</a><code> [friend]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>source/SAMRAI/hier/<a class="el" href="BoxLevel_8h.html">BoxLevel.h</a></li>
<li>source/SAMRAI/hier/<a class="el" href="BoxLevel_8C.html">BoxLevel.C</a></li>
</ul>
</div>
<hr size="1"/><address style="text-align: right;"><small>Generated on 8 Oct 2014 for SAMRAI by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.1 </small></address>
</body>
</html>
