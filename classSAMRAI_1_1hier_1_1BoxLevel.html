<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>SAMRAI: SAMRAI::hier::BoxLevel Class Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.7 -->
<div class="tabs">
  <ul>
    <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="namespaces.html"><span>Namespaces</span></a></li>
    <li id="current"><a href="annotated.html"><span>Classes</span></a></li>
    <li><a href="files.html"><span>Files</span></a></li>
    <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
  </ul></div>
<div class="tabs">
  <ul>
    <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
    <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
    <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
  </ul></div>
<div class="nav">
<a class="el" href="namespaceSAMRAI.html">SAMRAI</a>::<a class="el" href="namespaceSAMRAI_1_1hier.html">hier</a>::<a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a></div>
<h1>SAMRAI::hier::BoxLevel Class Reference</h1><!-- doxytag: class="SAMRAI::hier::BoxLevel" -->A distributed set of <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> objects which reside in the same index space.  
<a href="#_details">More...</a>
<p>
<code>#include &lt;source/SAMRAI/hier/BoxLevel.h&gt;</code>
<p>
<a href="classSAMRAI_1_1hier_1_1BoxLevel-members.html">List of all members.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Types</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#25e22f80d254d035cab74ae07032c228ed64b0ef3f3b9fe551c2a39a3f8f1b16">DISTRIBUTED</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#25e22f80d254d035cab74ae07032c228ff24ef90739a7fb75f8ddd6116ae57d9">GLOBALIZED</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#25e22f80d254d035cab74ae07032c228">ParallelState</a> { <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#25e22f80d254d035cab74ae07032c228ed64b0ef3f3b9fe551c2a39a3f8f1b16">DISTRIBUTED</a>, 
<a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#25e22f80d254d035cab74ae07032c228ff24ef90739a7fb75f8ddd6116ae57d9">GLOBALIZED</a>
 }</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Names of parallel states.  <a href="classSAMRAI_1_1hier_1_1BoxLevel.html#25e22f80d254d035cab74ae07032c228">More...</a><br></td></tr>
<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#115042428e91396f4e208ce0bff37598">BoxLevel</a> (const <a class="el" href="classSAMRAI_1_1tbox_1_1Dimension.html">tbox::Dimension</a> &amp;dim)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Construct uninitialized object.  <a href="#115042428e91396f4e208ce0bff37598"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#8a7df5000273f99c391159d8152772ac">BoxLevel</a> (const <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a> &amp;rhs)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copy constructor.  <a href="#8a7df5000273f99c391159d8152772ac"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#2f7394e394f93a033c711da6c67317c6">BoxLevel</a> (const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;ratio, const boost::shared_ptr&lt; const <a class="el" href="classSAMRAI_1_1hier_1_1BaseGridGeometry.html">BaseGridGeometry</a> &gt; &amp;grid_geom, const <a class="el" href="classSAMRAI_1_1tbox_1_1SAMRAI__MPI.html">tbox::SAMRAI_MPI</a> &amp;mpi=tbox::SAMRAI_MPI::getSAMRAIWorld(), const <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#25e22f80d254d035cab74ae07032c228">ParallelState</a> parallel_state=DISTRIBUTED)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Constructs an empty, initialized object.  <a href="#2f7394e394f93a033c711da6c67317c6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#84ac3b21ade6b0977ca85fc232d527ba">~BoxLevel</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Destructor.  <a href="#84ac3b21ade6b0977ca85fc232d527ba"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#ed880bc6c4c1b4fd4b73ee348d65231d">operator=</a> (const <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a> &amp;rhs)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Assignment operator duplicates all internal data, including parallel mode.  <a href="#ed880bc6c4c1b4fd4b73ee348d65231d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#7b2de85d142331f8eb0bfcf9df58b8a6">operator==</a> (const <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a> &amp;rhs) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Equality comparison.  <a href="#7b2de85d142331f8eb0bfcf9df58b8a6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#0c6d525f947858fcd68f739ec95a2be2">operator!=</a> (const <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a> &amp;rhs) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Inequality comparison.  <a href="#0c6d525f947858fcd68f739ec95a2be2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classSAMRAI_1_1hier_1_1PersistentOverlapConnectors.html">PersistentOverlapConnectors</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#f86fbfacb3f47f8f317e087c43d7f5a3">getPersistentOverlapConnectors</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the collection of overlap Connectors dedicated to provide overlap neighbors for this <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a>.  <a href="#f86fbfacb3f47f8f317e087c43d7f5a3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevelHandle.html">BoxLevelHandle</a> &gt; &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#422572b300c7750956c4b4cccca8d258">getBoxLevelHandle</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the handle with which Connectors reference the <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a> instead of referencing the <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a> itself. Not for general use.  <a href="#422572b300c7750956c4b4cccca8d258"></a><br></td></tr>
<tr><td colspan="2"><div class="groupHeader">Initialization and clearing methods</div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#66d3522a2b18ef07a01876c00b7a7682">initialize</a> (const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;ratio, const boost::shared_ptr&lt; const <a class="el" href="classSAMRAI_1_1hier_1_1BaseGridGeometry.html">BaseGridGeometry</a> &gt; &amp;grid_geom, const <a class="el" href="classSAMRAI_1_1tbox_1_1SAMRAI__MPI.html">tbox::SAMRAI_MPI</a> &amp;mpi=tbox::SAMRAI_MPI::getSAMRAIWorld(), const <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#25e22f80d254d035cab74ae07032c228">ParallelState</a> parallel_state=DISTRIBUTED)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Initialize the <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a> without and Boxes.  <a href="#66d3522a2b18ef07a01876c00b7a7682"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#fb06eb2fc44ba9619cf5dd1a0bbb5293">swapInitialize</a> (<a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a> &amp;boxes, const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;ratio, const boost::shared_ptr&lt; const <a class="el" href="classSAMRAI_1_1hier_1_1BaseGridGeometry.html">BaseGridGeometry</a> &gt; &amp;grid_geom, const <a class="el" href="classSAMRAI_1_1tbox_1_1SAMRAI__MPI.html">tbox::SAMRAI_MPI</a> &amp;mpi=tbox::SAMRAI_MPI::getSAMRAIWorld(), const <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#25e22f80d254d035cab74ae07032c228">ParallelState</a> parallel_state=DISTRIBUTED)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Initialize the <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a>.  <a href="#fb06eb2fc44ba9619cf5dd1a0bbb5293"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#a171283d1d5bc3f5d11732ac14e2df24">finalize</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Removes non-local boxes; computes bounding box, local number of boxes, local number of cells, max/min box size. To be called after all Boxes in a <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a> have been added to indicate that the <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a> is fully defined and ready to be used.  <a href="#a171283d1d5bc3f5d11732ac14e2df24"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#7a75dbd23c213da59cca0a946d0a8c5e">isInitialized</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns True if the object has been initialized.  <a href="#7a75dbd23c213da59cca0a946d0a8c5e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#e5d1505eb27d9868ed5512ae882b4b01">removePeriodicImageBoxes</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Remove all the periodic image boxes in the <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a>.  <a href="#e5d1505eb27d9868ed5512ae882b4b01"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#453187b7a435ed78ad8cf2819342f20f">clear</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Clear the internal state of the <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a>.  <a href="#453187b7a435ed78ad8cf2819342f20f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#0f8980401950dde69dfe1f05209429be">clearForBoxChanges</a> (bool isInvalid=true)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Clear the globalized version and the persistent overlap connectors for data consistency.  <a href="#0f8980401950dde69dfe1f05209429be"></a><br></td></tr>
<tr><td colspan="2"><div class="groupHeader">Parallelism</div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#0599cc9d03e8586f32b37882f2551908">setParallelState</a> (const <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#25e22f80d254d035cab74ae07032c228">ParallelState</a> parallel_state)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the parallel state.  <a href="#0599cc9d03e8586f32b37882f2551908"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#25e22f80d254d035cab74ae07032c228">ParallelState</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#8ea9e52f223207d7dfca86f8bd8b44a5">getParallelState</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the ParallelState of the object.  <a href="#8ea9e52f223207d7dfca86f8bd8b44a5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#183b36593e2211131739690181396e99">cacheGlobalReducedData</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">If global reduced data (global <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> count, global cell count and global bounding box) have not been updated, compute and cache them (communication required).  <a href="#183b36593e2211131739690181396e99"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">const <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#4b99ccba3c6901f6fb072d286fc32c21">getGlobalizedVersion</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the globalized version of the <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a>, creating it if needed.  <a href="#4b99ccba3c6901f6fb072d286fc32c21"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#60a3ceeaefceb53990af46b9697c6b32">deallocateGlobalizedVersion</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Deallocate the internal globalized version of the <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a>, if there is any.  <a href="#60a3ceeaefceb53990af46b9697c6b32"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">const <a class="el" href="classSAMRAI_1_1tbox_1_1SAMRAI__MPI.html">tbox::SAMRAI_MPI</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#09139ebc67a5fead7e6e4d985889152d">getMPI</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the SAMRAI_MPI communicator over which the Boxes are distributed.  <a href="#09139ebc67a5fead7e6e4d985889152d"></a><br></td></tr>
<tr><td colspan="2"><div class="groupHeader">Accessors</div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">const <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#2d2bb306ab54429cc5ad2fc888b62f1d">getBoxes</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the container of local Boxes.  <a href="#2d2bb306ab54429cc5ad2fc888b62f1d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">const <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#cf1a4a576d843618c7c1c76da337766d">getGlobalBoxes</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the container of global Boxes.  <a href="#cf1a4a576d843618c7c1c76da337766d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#0ffab2fec2c0a3b512eccee8f3cc5863">getGlobalBoxes</a> (<a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a> &amp;global_boxes) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Fill the container with the global Boxes.  <a href="#0ffab2fec2c0a3b512eccee8f3cc5863"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classSAMRAI_1_1hier_1_1LocalId.html">LocalId</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#954dbe3f3df6982e7496fac5a1dac8a3">getFirstLocalId</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the first <a class="el" href="classSAMRAI_1_1hier_1_1LocalId.html">LocalId</a>, or one with a value of -1 if no local <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> exists.  <a href="#954dbe3f3df6982e7496fac5a1dac8a3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classSAMRAI_1_1hier_1_1LocalId.html">LocalId</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#5f55f201872b812e8b5c8870aa52e57e">getLastLocalId</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the last <a class="el" href="classSAMRAI_1_1hier_1_1LocalId.html">LocalId</a>, or one with a value of -1 if no local <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> exists.  <a href="#5f55f201872b812e8b5c8870aa52e57e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#57a5d512c910580b578e34b9473ca0b8">getRefinementRatio</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get const access to BoxLevel's refinement ratio (with respect to a reference level).  <a href="#57a5d512c910580b578e34b9473ca0b8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#5a8067d74ffcfcea775e899b149c7419">getLocalNumberOfBoxes</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return local number of boxes.  <a href="#5a8067d74ffcfcea775e899b149c7419"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#6ed65e220961665ab06fba294587cb68">getLocalNumberOfBoxes</a> (int rank) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return number of boxes local to the given rank.  <a href="#6ed65e220961665ab06fba294587cb68"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#2587c43d3bd495e4db0690a014bf2eb1">getGlobalNumberOfBoxes</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return global number of Boxes.  <a href="#2587c43d3bd495e4db0690a014bf2eb1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#c04928996f56ba42127c956e976610f4">getMaxNumberOfBoxes</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return maximum number of Boxes over all processes.  <a href="#c04928996f56ba42127c956e976610f4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#5cb56e921d2f7af5cbd809a0bbdfa4ba">getMinNumberOfBoxes</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return maximum number of Boxes over all processes.  <a href="#5cb56e921d2f7af5cbd809a0bbdfa4ba"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#8e018a0a522b3fb925003d8880168708">getLocalNumberOfCells</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return local number of cells.  <a href="#8e018a0a522b3fb925003d8880168708"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#78975b8d6869c071db8b66bc0c8fa34c">getMaxNumberOfCells</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return maximum number of cells over all processes.  <a href="#78975b8d6869c071db8b66bc0c8fa34c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#1fcedeb0804d152f78e9e3791f2cabff">getMinNumberOfCells</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return maximum number of cells over all processes.  <a href="#1fcedeb0804d152f78e9e3791f2cabff"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#907c93058e8a8bc5451c654da8116deb">getLocalNumberOfCells</a> (int rank) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return number of cells local to the given rank.  <a href="#907c93058e8a8bc5451c654da8116deb"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#364de76d3c5e21bea6a6398db5ea68e6">getGlobalNumberOfCells</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return global number of cells.  <a href="#364de76d3c5e21bea6a6398db5ea68e6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#13cce4466852fa2aa9a6cd2fa9e6f9ab">getLocalBoundingBox</a> (int block_number) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return bounding box for local Boxes in a block.  <a href="#13cce4466852fa2aa9a6cd2fa9e6f9ab"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#1497e6474d50396a2d3ca88a9539422c">getGlobalBoundingBox</a> (int block_number) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return bounding box for global Boxes in a block.  <a href="#1497e6474d50396a2d3ca88a9539422c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#135e075de4928ddcc412c28e7580cd7d">getLocalMaxBoxSize</a> (int block_number) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return size of the largest local <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> in a block.  <a href="#135e075de4928ddcc412c28e7580cd7d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#214830ea3fadba642162ed4d992a792f">getLocalMinBoxSize</a> (int block_number) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return size of the smallest local <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> in a block.  <a href="#214830ea3fadba642162ed4d992a792f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#5399ceaad82005b7a1515df5c9a29980">getGlobalMaxBoxSize</a> (int block_number) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return size of the largest <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> globally in a block.  <a href="#5399ceaad82005b7a1515df5c9a29980"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#488d1cb0fb2bf1fd55f79a798f1b4015">getGlobalMinBoxSize</a> (int block_number) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return size of the smallest <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> globally in a block.  <a href="#488d1cb0fb2bf1fd55f79a798f1b4015"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">const <a class="el" href="classSAMRAI_1_1tbox_1_1Dimension.html">tbox::Dimension</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#01ab4dc0bdd8111d1b225194a3a46724">getDim</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the dimension of this object.  <a href="#01ab4dc0bdd8111d1b225194a3a46724"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">const boost::shared_ptr&lt; const <br>
<a class="el" href="classSAMRAI_1_1hier_1_1BaseGridGeometry.html">BaseGridGeometry</a> &gt; &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#48f3d09fc617a1a40fbfb1f7079fbd71">getGridGeometry</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the grid geometry associated with this object.  <a href="#48f3d09fc617a1a40fbfb1f7079fbd71"></a><br></td></tr>
<tr><td colspan="2"><div class="groupHeader">Methods to modify all Boxes.</div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#4278fe56881640392e9fa8fc0a047fb2">refineBoxes</a> (<a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a> &amp;finer, const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;ratio, const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;final_ratio) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Refine all Boxes of this <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a> by ratio placing result into finer making finer's ratio final_ratio.  <a href="#4278fe56881640392e9fa8fc0a047fb2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#781a2e5bcc0ce41aa657eb006487789f">coarsenBoxes</a> (<a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a> &amp;coarser, const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;ratio, const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;final_ratio) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Coarsen all Boxes of this <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a> by ratio placing result into coarser making coarser's ratio final_ratio.  <a href="#781a2e5bcc0ce41aa657eb006487789f"></a><br></td></tr>
<tr><td colspan="2"><div class="groupHeader">Individual Box methods.</div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer_1_1BoxContainerConstIterator.html">BoxContainer::const_iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#31ca5a8d4b6d93df37ca53c4905833f1">addBox</a> (const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> &amp;box, const <a class="el" href="classSAMRAI_1_1hier_1_1BlockId.html">BlockId</a> &amp;block_id, const bool use_vacant_index=true)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create new local <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> from given <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> and add it to this level.  <a href="#31ca5a8d4b6d93df37ca53c4905833f1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#04569f993cb446a57d8d69de7067e579">addBox</a> (const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> &amp;box)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Add a <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> to this level.  <a href="#04569f993cb446a57d8d69de7067e579"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#0021b5651c94464d34c5bffce3fecbf4">addBoxWithoutUpdate</a> (const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> &amp;box)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Add a <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> to this level without updating summary data such as local number of boxes/cells, bounding box, max/min box size. Meant to be used during the construction of a <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a> as Boxes belonging to the level are found. <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#a171283d1d5bc3f5d11732ac14e2df24">finalize()</a> should be called at the end of construction making use of addBoxWithoutUpdate.  <a href="#0021b5651c94464d34c5bffce3fecbf4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#7a0aa4f5f03e39893cca82987ffb8401">addPeriodicBox</a> (const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> &amp;existing_box, const <a class="el" href="classSAMRAI_1_1hier_1_1PeriodicId.html">PeriodicId</a> &amp;shift_number)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Insert given periodic image of an existing <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a>.  <a href="#7a0aa4f5f03e39893cca82987ffb8401"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#5a1412abb328dce673eb1a98c67e9e64">eraseBox</a> (<a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer_1_1BoxContainerIterator.html">BoxContainer::iterator</a> &amp;ibox)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Erase the existing <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> specified by its iterator.  <a href="#5a1412abb328dce673eb1a98c67e9e64"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#d8b2f4c0e0cdf0da1885734c7307be47">eraseBox</a> (const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> &amp;box)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Erase the <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> matching the one given.  <a href="#d8b2f4c0e0cdf0da1885734c7307be47"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#c629faeea80bc319a1b1a215d1ff74b5">eraseBoxWithoutUpdate</a> (const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> &amp;box)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Erases the <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> matching the supplied <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> from this level without updating summary data such as local number of boxes/cells, bounding box, max/min box size. Meant to be used during the construction of a <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a> as Boxes not belonging to the level are found. <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#a171283d1d5bc3f5d11732ac14e2df24">finalize()</a> should be called at the end of construction making use of eraseBoxWithoutUpdate.  <a href="#c629faeea80bc319a1b1a215d1ff74b5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer_1_1BoxContainerConstIterator.html">BoxContainer::const_iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#1ce806b2a617a0be7d015528cbd5dfa0">getBox</a> (const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> &amp;box) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Find the <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> matching the one given.  <a href="#1ce806b2a617a0be7d015528cbd5dfa0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer_1_1BoxContainerConstIterator.html">BoxContainer::const_iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#c637cc96657034252d5fd800f30b8178">getBox</a> (const <a class="el" href="classSAMRAI_1_1hier_1_1BoxId.html">BoxId</a> &amp;box_id) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Find the <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> specified by the given <a class="el" href="classSAMRAI_1_1hier_1_1BoxId.html">BoxId</a> and periodic shift.  <a href="#c637cc96657034252d5fd800f30b8178"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer_1_1BoxContainerConstIterator.html">BoxContainer::const_iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#b3917d6bf64527ce45d1a6a0113aeaf3">getBoxStrict</a> (const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> &amp;box) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Find the <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> matching the one given.  <a href="#b3917d6bf64527ce45d1a6a0113aeaf3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer_1_1BoxContainerConstIterator.html">BoxContainer::const_iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#24923c783921933dc6f241ec059da82e">getBoxStrict</a> (const <a class="el" href="classSAMRAI_1_1hier_1_1BoxId.html">BoxId</a> &amp;box_id) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Find the <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> specified by the given <a class="el" href="classSAMRAI_1_1hier_1_1BoxId.html">BoxId</a>.  <a href="#24923c783921933dc6f241ec059da82e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#035bb795c44bc499f32f60e9b4e0bebc">getSpatiallyEqualBox</a> (const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> &amp;box_to_match, const <a class="el" href="classSAMRAI_1_1hier_1_1BlockId.html">BlockId</a> &amp;block_id, <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> &amp;matching_box) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Find the <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> with the given <a class="el" href="classSAMRAI_1_1hier_1_1BlockId.html">BlockId</a> which is spatially equal to the supplied <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a>.  <a href="#035bb795c44bc499f32f60e9b4e0bebc"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#a6342f7381b304e638b4313bd6a23fe3">hasBox</a> (const <a class="el" href="classSAMRAI_1_1hier_1_1BoxId.html">BoxId</a> &amp;box_id) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns true when the object has a <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> specified by the <a class="el" href="classSAMRAI_1_1hier_1_1BoxId.html">BoxId</a>.  <a href="#a6342f7381b304e638b4313bd6a23fe3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#4178a61a873d82cb74c15512ff73dd3e">hasBox</a> (const <a class="el" href="classSAMRAI_1_1hier_1_1GlobalId.html">GlobalId</a> &amp;global_id, const <a class="el" href="classSAMRAI_1_1hier_1_1PeriodicId.html">PeriodicId</a> &amp;periodic_id) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns true when the object has a <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> consistent with all of the arguments.  <a href="#4178a61a873d82cb74c15512ff73dd3e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#989a5937806c38349195694c449d1d2f">hasBox</a> (const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> &amp;box) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns true when this <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a> has a <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> matching the <a class="el" href="classSAMRAI_1_1hier_1_1BoxId.html">BoxId</a> of the given box.  <a href="#989a5937806c38349195694c449d1d2f"></a><br></td></tr>
<tr><td colspan="2"><div class="groupHeader">IO support.</div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#708bac92ccc04022a4d1f004252641ab">putUnregisteredToDatabase</a> (const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Database.html">tbox::Database</a> &gt; &amp;database) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Write the <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a> to a database.  <a href="#708bac92ccc04022a4d1f004252641ab"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#44c1f47418c7dfa2b597b7e1e1dd39f0">getFromDatabase</a> (<a class="el" href="classSAMRAI_1_1tbox_1_1Database.html">tbox::Database</a> &amp;database, const boost::shared_ptr&lt; const <a class="el" href="classSAMRAI_1_1hier_1_1BaseGridGeometry.html">BaseGridGeometry</a> &gt; &amp;grid_geom)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Read the <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a> from a database.  <a href="#44c1f47418c7dfa2b597b7e1e1dd39f0"></a><br></td></tr>
<tr><td colspan="2"><div class="groupHeader">Methods for outputs, error checking and debugging.</div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#e7eee9eaf5843c1f34ff54d036c42bc2">recursivePrint</a> (std::ostream &amp;os, const std::string &amp;border, int detail_depth=0) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Print <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> info from this level.  <a href="#e7eee9eaf5843c1f34ff54d036c42bc2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel_1_1Outputter.html">Outputter</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#63c33f123d563234febc5abfed9ba8f4">format</a> (const std::string &amp;border=std::string(), int detail_depth=0) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return a object that can format the <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a> for inserting into output streams.  <a href="#63c33f123d563234febc5abfed9ba8f4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel_1_1Outputter.html">Outputter</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#85b62ebfbe93f0e814e10a08e741cad4">formatStatistics</a> (const std::string &amp;border=std::string()) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return a object that can format the <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a> for inserting its global statistics into output streams.  <a href="#85b62ebfbe93f0e814e10a08e741cad4"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Static Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#125a90d67a15e87724013e21c5773e6a">swap</a> (<a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a> &amp;level_a, <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a> &amp;level_b)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Swap the contents of two <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a> objects.  <a href="#125a90d67a15e87724013e21c5773e6a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#19cd31335bfdfa84d45a8fb778aa9291">initializeCallback</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set up things for the entire class.  <a href="#19cd31335bfdfa84d45a8fb778aa9291"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#896e93d5776f9baa5a18aedd3052782b">finalizeCallback</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Free static timers.  <a href="#896e93d5776f9baa5a18aedd3052782b"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Friends</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#0ffde531e623d3f0ab07261aa48769ba">std::vector&lt; BoxLevel &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Allows std::vector to allocate objects with uninitialized dimensions.  <a href="#0ffde531e623d3f0ab07261aa48769ba"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Classes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel_1_1Outputter.html">Outputter</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A class for outputting <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a>.  <a href="classSAMRAI_1_1hier_1_1BoxLevel_1_1Outputter.html#_details">More...</a><br></td></tr>
</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
A distributed set of <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> objects which reside in the same index space. 
<p>
TODO: Are we eliminating DLBG terminology?<p>
This class is a part of the distributed layered box graph (DLBG) for managing SAMR meshes in parallel. A <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a> is a set of boxes in the same index space. Relationships (e.g., neighbor adjacency) among boxes is contained in a <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">Connector</a> object. Also, each <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a> has an refinement ratio vector describing the relationship of the index space to that of a reference level in a patch hierarchy (typically the coarsest level or level zero).<p>
Like a <a class="el" href="classSAMRAI_1_1hier_1_1PatchLevel.html">PatchLevel</a>, a <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a> is a parallel object. The Boxes of a <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a> may be distributed across all the processors in an MPI communicator and can be in one of two parallel states:<p>
<ul>
<li><b>DISTRIBUTED:</b> Each MPI process knows only the Boxes in the set that are "owned" by that process. This is analogous to a <a class="el" href="classSAMRAI_1_1hier_1_1PatchLevel.html">PatchLevel</a> which owns only the Patches that reside on a process.</li></ul>
<p>
<ul>
<li><b>GLOBALIZED:</b> All processes know all Boxes in the set. This is analogous to <a class="el" href="classSAMRAI_1_1hier_1_1PatchLevel.html">PatchLevel</a> <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a> state when it is globalized (<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classSAMRAI_1_1hier_1_1PatchLevel.html#83c5776a46614be72fef9ae625ed52fa">PatchLevel::getBoxes()</a>).</dd></dl>
<dl compact><dt><b>Performance notes</b></dt><dd><ul>
<li>
The parallel state is changed by calling <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#0599cc9d03e8586f32b37882f2551908">setParallelState()</a>. Going from DISTRIBUTED to GLOBALIZED state is an expensive operation requiring all-to-all communication. Using this state can incur a significant performance penalty.<p>
</li>
<li>
The GLOBALIZED state requires more memory.<p>
</li>
<li>
Transitioning from GLOBALIZED state to DISTRIBUTED state is cheap. </li>
</ul>
</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>The general attributes of a <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a> are <ul>
<li>
the set of <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> objects with unique BoxIds, </li>
<li>
the refinement ratio defining their index space, and </li>
<li>
the parallel state. </li>
</ul>
</dd></dl>
<a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> object uniqueness is based on the <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> equality operator, which compares owner MPI ranks and local indices. Therefore, a valid <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a> does not contain two Boxes with the same owner and index. </li></ul>

<p>
<hr><h2>Member Enumeration Documentation</h2>
<a class="anchor" name="25e22f80d254d035cab74ae07032c228"></a><!-- doxytag: member="SAMRAI::hier::BoxLevel::ParallelState" ref="25e22f80d254d035cab74ae07032c228" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#25e22f80d254d035cab74ae07032c228">SAMRAI::hier::BoxLevel::ParallelState</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Names of parallel states. 
<p>
<dl compact><dt><b>Enumerator: </b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" name="25e22f80d254d035cab74ae07032c228ed64b0ef3f3b9fe551c2a39a3f8f1b16"></a><!-- doxytag: member="DISTRIBUTED" ref="25e22f80d254d035cab74ae07032c228ed64b0ef3f3b9fe551c2a39a3f8f1b16" args="" -->DISTRIBUTED</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" name="25e22f80d254d035cab74ae07032c228ff24ef90739a7fb75f8ddd6116ae57d9"></a><!-- doxytag: member="GLOBALIZED" ref="25e22f80d254d035cab74ae07032c228ff24ef90739a7fb75f8ddd6116ae57d9" args="" -->GLOBALIZED</em>&nbsp;</td><td>
</td></tr>
</table>
</dl>

</div>
</div><p>
<hr><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" name="115042428e91396f4e208ce0bff37598"></a><!-- doxytag: member="SAMRAI::hier::BoxLevel::BoxLevel" ref="115042428e91396f4e208ce0bff37598" args="(const tbox::Dimension &amp;dim)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SAMRAI::hier::BoxLevel::BoxLevel           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1tbox_1_1Dimension.html">tbox::Dimension</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>dim</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Construct uninitialized object. 
<p>
Uninitialized objects can be initialized by calling <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#66d3522a2b18ef07a01876c00b7a7682">initialize()</a> or <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#fb06eb2fc44ba9619cf5dd1a0bbb5293">swapInitialize()</a>.<p>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#66d3522a2b18ef07a01876c00b7a7682">initialize()</a> <p>
<a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#fb06eb2fc44ba9619cf5dd1a0bbb5293">swapInitialize()</a></dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>dim</em>&nbsp;</td><td></td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="8a7df5000273f99c391159d8152772ac"></a><!-- doxytag: member="SAMRAI::hier::BoxLevel::BoxLevel" ref="8a7df5000273f99c391159d8152772ac" args="(const BoxLevel &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SAMRAI::hier::BoxLevel::BoxLevel           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Copy constructor. 
<p>
New object has the same parallel state as original.<p>
Persistent Connectors are not duplicated. This decision was based on expected usage, which is that copies are either for short term usage or meant to be changed in some way and will invalidate Connectors.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>rhs</em>&nbsp;</td><td></td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="2f7394e394f93a033c711da6c67317c6"></a><!-- doxytag: member="SAMRAI::hier::BoxLevel::BoxLevel" ref="2f7394e394f93a033c711da6c67317c6" args="(const IntVector &amp;ratio, const boost::shared_ptr&lt; const BaseGridGeometry &gt; &amp;grid_geom, const tbox::SAMRAI_MPI &amp;mpi=tbox::SAMRAI_MPI::getSAMRAIWorld(), const ParallelState parallel_state=DISTRIBUTED)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SAMRAI::hier::BoxLevel::BoxLevel           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>ratio</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const boost::shared_ptr&lt; const <a class="el" href="classSAMRAI_1_1hier_1_1BaseGridGeometry.html">BaseGridGeometry</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>grid_geom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1tbox_1_1SAMRAI__MPI.html">tbox::SAMRAI_MPI</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>mpi</em> = <code>tbox::SAMRAI_MPI::getSAMRAIWorld()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#25e22f80d254d035cab74ae07032c228">ParallelState</a>&nbsp;</td>
          <td class="paramname"> <em>parallel_state</em> = <code>DISTRIBUTED</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Constructs an empty, initialized object. 
<p>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#31ca5a8d4b6d93df37ca53c4905833f1">addBox()</a> <p>
<a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#31ca5a8d4b6d93df37ca53c4905833f1">addBox()</a> <p>
<a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#66d3522a2b18ef07a01876c00b7a7682">initialize()</a></dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>ratio</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>grid_geom</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>mpi</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>parallel_state</em>&nbsp;</td><td></td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="84ac3b21ade6b0977ca85fc232d527ba"></a><!-- doxytag: member="SAMRAI::hier::BoxLevel::~BoxLevel" ref="84ac3b21ade6b0977ca85fc232d527ba" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SAMRAI::hier::BoxLevel::~BoxLevel           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Destructor. 
<p>
Deallocate internal data. 
</div>
</div><p>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="66d3522a2b18ef07a01876c00b7a7682"></a><!-- doxytag: member="SAMRAI::hier::BoxLevel::initialize" ref="66d3522a2b18ef07a01876c00b7a7682" args="(const IntVector &amp;ratio, const boost::shared_ptr&lt; const BaseGridGeometry &gt; &amp;grid_geom, const tbox::SAMRAI_MPI &amp;mpi=tbox::SAMRAI_MPI::getSAMRAIWorld(), const ParallelState parallel_state=DISTRIBUTED)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::hier::BoxLevel::initialize           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>ratio</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const boost::shared_ptr&lt; const <a class="el" href="classSAMRAI_1_1hier_1_1BaseGridGeometry.html">BaseGridGeometry</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>grid_geom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1tbox_1_1SAMRAI__MPI.html">tbox::SAMRAI_MPI</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>mpi</em> = <code>tbox::SAMRAI_MPI::getSAMRAIWorld()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#25e22f80d254d035cab74ae07032c228">ParallelState</a>&nbsp;</td>
          <td class="paramname"> <em>parallel_state</em> = <code>DISTRIBUTED</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Initialize the <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a> without and Boxes. 
<p>
The content and state of the object before calling this function is discarded.<p>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#31ca5a8d4b6d93df37ca53c4905833f1">addBox()</a> <p>
<a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#31ca5a8d4b6d93df37ca53c4905833f1">addBox()</a> <p>
initialize(const BoxContainer&amp;, const IntVector&amp;, const tbox::SAMRAI_MPI&amp;, const ParallelState)</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>ratio</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>grid_geom</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>mpi</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>parallel_state</em>&nbsp;</td><td></td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="fb06eb2fc44ba9619cf5dd1a0bbb5293"></a><!-- doxytag: member="SAMRAI::hier::BoxLevel::swapInitialize" ref="fb06eb2fc44ba9619cf5dd1a0bbb5293" args="(BoxContainer &amp;boxes, const IntVector &amp;ratio, const boost::shared_ptr&lt; const BaseGridGeometry &gt; &amp;grid_geom, const tbox::SAMRAI_MPI &amp;mpi=tbox::SAMRAI_MPI::getSAMRAIWorld(), const ParallelState parallel_state=DISTRIBUTED)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::hier::BoxLevel::swapInitialize           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>boxes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>ratio</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const boost::shared_ptr&lt; const <a class="el" href="classSAMRAI_1_1hier_1_1BaseGridGeometry.html">BaseGridGeometry</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>grid_geom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1tbox_1_1SAMRAI__MPI.html">tbox::SAMRAI_MPI</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>mpi</em> = <code>tbox::SAMRAI_MPI::getSAMRAIWorld()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#25e22f80d254d035cab74ae07032c228">ParallelState</a>&nbsp;</td>
          <td class="paramname"> <em>parallel_state</em> = <code>DISTRIBUTED</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Initialize the <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a>. 
<p>
Similar to initialize(const BoxContainer&amp;, const IntVector&amp;, const tbox::SAMRAI_MPI&amp;, const ParallelState), except that the <code>boxes</code> are mutable.<p>
The state of the object before calling this function is discarded. The <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> content before calling this function is returned via the <code>boxes</code> argument.<p>
<dl compact><dt><b>See also:</b></dt><dd>initializePrivate()</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>boxes</em>&nbsp;</td><td>On input, this should contain the Boxes to place in the <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a>. On output, it contains the Boxes that were in the <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a> before the call.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>boxes</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>ratio</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>grid_geom</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>mpi</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>parallel_state</em>&nbsp;</td><td></td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="a171283d1d5bc3f5d11732ac14e2df24"></a><!-- doxytag: member="SAMRAI::hier::BoxLevel::finalize" ref="a171283d1d5bc3f5d11732ac14e2df24" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::hier::BoxLevel::finalize           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Removes non-local boxes; computes bounding box, local number of boxes, local number of cells, max/min box size. To be called after all Boxes in a <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a> have been added to indicate that the <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a> is fully defined and ready to be used. 
<p>

</div>
</div><p>
<a class="anchor" name="7a75dbd23c213da59cca0a946d0a8c5e"></a><!-- doxytag: member="SAMRAI::hier::BoxLevel::isInitialized" ref="7a75dbd23c213da59cca0a946d0a8c5e" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SAMRAI::hier::BoxLevel::isInitialized           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns True if the object has been initialized. 
<p>

</div>
</div><p>
<a class="anchor" name="e5d1505eb27d9868ed5512ae882b4b01"></a><!-- doxytag: member="SAMRAI::hier::BoxLevel::removePeriodicImageBoxes" ref="e5d1505eb27d9868ed5512ae882b4b01" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::hier::BoxLevel::removePeriodicImageBoxes           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Remove all the periodic image boxes in the <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a>. 
<p>

</div>
</div><p>
<a class="anchor" name="453187b7a435ed78ad8cf2819342f20f"></a><!-- doxytag: member="SAMRAI::hier::BoxLevel::clear" ref="453187b7a435ed78ad8cf2819342f20f" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::hier::BoxLevel::clear           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Clear the internal state of the <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a>. 
<p>
The <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a> will be in an uninitialized state after a call to this method. 
</div>
</div><p>
<a class="anchor" name="0f8980401950dde69dfe1f05209429be"></a><!-- doxytag: member="SAMRAI::hier::BoxLevel::clearForBoxChanges" ref="0f8980401950dde69dfe1f05209429be" args="(bool isInvalid=true)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::hier::BoxLevel::clearForBoxChanges           </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>isInvalid</em> = <code>true</code>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Clear the globalized version and the persistent overlap connectors for data consistency. 
<p>
Most of the time, this method is automatically called by methods that know when some data is stale and needs to be cleared. For example, adding a box makes the global number of boxes stale. However, sometimes it is necessary to call this method manually. For example, when only some processes add boxes while others do not, resulting in some processes not knowing that the global number of boxes is inconsistent.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>isInvalid</em>&nbsp;</td><td>A flag indicating that boxes have been (or will be) removed, thus invalidating the handle. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="0599cc9d03e8586f32b37882f2551908"></a><!-- doxytag: member="SAMRAI::hier::BoxLevel::setParallelState" ref="0599cc9d03e8586f32b37882f2551908" args="(const ParallelState parallel_state)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::hier::BoxLevel::setParallelState           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#25e22f80d254d035cab74ae07032c228">ParallelState</a>&nbsp;</td>
          <td class="paramname"> <em>parallel_state</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set the parallel state. 
<p>
This method is potentially expensive. Acquiring remote <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> information (when going to GLOBALIZED mode) triggers all-gather communication. More memory is required to store additional Boxes.<p>
Data not used by the new state gets deallocated.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>parallel_state</em>&nbsp;</td><td></td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="8ea9e52f223207d7dfca86f8bd8b44a5"></a><!-- doxytag: member="SAMRAI::hier::BoxLevel::getParallelState" ref="8ea9e52f223207d7dfca86f8bd8b44a5" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#25e22f80d254d035cab74ae07032c228">ParallelState</a> SAMRAI::hier::BoxLevel::getParallelState           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the ParallelState of the object. 
<p>

</div>
</div><p>
<a class="anchor" name="183b36593e2211131739690181396e99"></a><!-- doxytag: member="SAMRAI::hier::BoxLevel::cacheGlobalReducedData" ref="183b36593e2211131739690181396e99" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::hier::BoxLevel::cacheGlobalReducedData           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
If global reduced data (global <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> count, global cell count and global bounding box) have not been updated, compute and cache them (communication required). 
<p>
After this method is called, data requiring global reduction can be accessed without further communications, until the object changes.<p>
Sets d_global_data_up_to_date; 
</div>
</div><p>
<a class="anchor" name="4b99ccba3c6901f6fb072d286fc32c21"></a><!-- doxytag: member="SAMRAI::hier::BoxLevel::getGlobalizedVersion" ref="4b99ccba3c6901f6fb072d286fc32c21" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a> &amp; SAMRAI::hier::BoxLevel::getGlobalizedVersion           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return the globalized version of the <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a>, creating it if needed. 
<p>
If the <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a> is in globalized state, return <code>*this</code>. If not, create and cache a globalized version (if necessary) and return that.<p>
The cached version remains until it is removed by <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#60a3ceeaefceb53990af46b9697c6b32">deallocateGlobalizedVersion()</a> or a method that can potentially change the Boxes is called. Note that globalizing and globalized data is not scalable. Use only when necessary.<p>
Obviously, when the globalized version must be created (when the <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a> is in DISTRIBUTED state and there is no cached version yet), all processes must make this call at the same point. 
</div>
</div><p>
<a class="anchor" name="60a3ceeaefceb53990af46b9697c6b32"></a><!-- doxytag: member="SAMRAI::hier::BoxLevel::deallocateGlobalizedVersion" ref="60a3ceeaefceb53990af46b9697c6b32" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::hier::BoxLevel::deallocateGlobalizedVersion           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Deallocate the internal globalized version of the <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a>, if there is any. 
<p>

</div>
</div><p>
<a class="anchor" name="09139ebc67a5fead7e6e4d985889152d"></a><!-- doxytag: member="SAMRAI::hier::BoxLevel::getMPI" ref="09139ebc67a5fead7e6e4d985889152d" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classSAMRAI_1_1tbox_1_1SAMRAI__MPI.html">tbox::SAMRAI_MPI</a>&amp; SAMRAI::hier::BoxLevel::getMPI           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the SAMRAI_MPI communicator over which the Boxes are distributed. 
<p>

</div>
</div><p>
<a class="anchor" name="ed880bc6c4c1b4fd4b73ee348d65231d"></a><!-- doxytag: member="SAMRAI::hier::BoxLevel::operator=" ref="ed880bc6c4c1b4fd4b73ee348d65231d" args="(const BoxLevel &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a> &amp; SAMRAI::hier::BoxLevel::operator=           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Assignment operator duplicates all internal data, including parallel mode. 
<p>
Assignment is a modifying operation, causing the <a class="el" href="classSAMRAI_1_1hier_1_1PersistentOverlapConnectors.html">PersistentOverlapConnectors</a> to be cleared.<p>
Persistent Connectors are not duplicated. This decision was based on expected usage, which is that copies are either for short term usage or meant to be changed in some way (thus invalidating current Connectors anyway).<p>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#f86fbfacb3f47f8f317e087c43d7f5a3">getPersistentOverlapConnectors()</a></dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>rhs</em>&nbsp;</td><td></td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="125a90d67a15e87724013e21c5773e6a"></a><!-- doxytag: member="SAMRAI::hier::BoxLevel::swap" ref="125a90d67a15e87724013e21c5773e6a" args="(BoxLevel &amp;level_a, BoxLevel &amp;level_b)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::hier::BoxLevel::swap           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>level_a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>level_b</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Swap the contents of two <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a> objects. 
<p>
Swapping is a modifying operation, so the PersistentOverlapConnectorss of the operands are cleared.<p>
Persistent Connectors are not swapped. This decision was based on expected usage, which is that copies are either for short term usage or meant to be changed in some way (thus invalidating current Connectors anyway).<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>level_a</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>level_b</em>&nbsp;</td><td></td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="7b2de85d142331f8eb0bfcf9df58b8a6"></a><!-- doxytag: member="SAMRAI::hier::BoxLevel::operator==" ref="7b2de85d142331f8eb0bfcf9df58b8a6" args="(const BoxLevel &amp;rhs) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SAMRAI::hier::BoxLevel::operator==           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Equality comparison. 
<p>
All data required to initialize the object is compared, except for the parallel state. Thus equality here means just the local parts are equal. <b>BEWARE!</b> This means that one processor may see the equality differently from another.<p>
The cost for the comparison is on the order of the local <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> count. An object may be compared to itself, an efficient operation that always returns true.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>rhs</em>&nbsp;</td><td></td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="0c6d525f947858fcd68f739ec95a2be2"></a><!-- doxytag: member="SAMRAI::hier::BoxLevel::operator!=" ref="0c6d525f947858fcd68f739ec95a2be2" args="(const BoxLevel &amp;rhs) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SAMRAI::hier::BoxLevel::operator!=           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Inequality comparison. 
<p>
All data required to initialize the object is compared, except for the parallel state. Thus equality here means just the local parts are equal. <b>BEWARE!</b> This means that one processor may see the inequality differently from another.<p>
The cost for the comparison is on the order of the local <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> count. However, an object may be compared to itself, an efficient operation that always returns false.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>rhs</em>&nbsp;</td><td></td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="2d2bb306ab54429cc5ad2fc888b62f1d"></a><!-- doxytag: member="SAMRAI::hier::BoxLevel::getBoxes" ref="2d2bb306ab54429cc5ad2fc888b62f1d" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a>&amp; SAMRAI::hier::BoxLevel::getBoxes           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the container of local Boxes. 
<p>
<dl compact><dt><b>Important</b></dt><dd>The <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a> returned contains periodic image Boxes (if any). To iterate through real Boxes only, see <a class="el" href="classSAMRAI_1_1hier_1_1RealBoxConstIterator.html">RealBoxConstIterator</a>.</dd></dl>
You cannot directly modify the <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a> because it may invalidate other internal data. Use other methods for modifying the <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a>.<p>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#2587c43d3bd495e4db0690a014bf2eb1">getGlobalNumberOfBoxes()</a> <p>
<a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#5a8067d74ffcfcea775e899b149c7419">getLocalNumberOfBoxes()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="cf1a4a576d843618c7c1c76da337766d"></a><!-- doxytag: member="SAMRAI::hier::BoxLevel::getGlobalBoxes" ref="cf1a4a576d843618c7c1c76da337766d" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a>&amp; SAMRAI::hier::BoxLevel::getGlobalBoxes           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the container of global Boxes. 
<p>

</div>
</div><p>
<a class="anchor" name="0ffab2fec2c0a3b512eccee8f3cc5863"></a><!-- doxytag: member="SAMRAI::hier::BoxLevel::getGlobalBoxes" ref="0ffab2fec2c0a3b512eccee8f3cc5863" args="(BoxContainer &amp;global_boxes) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::hier::BoxLevel::getGlobalBoxes           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>global_boxes</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Fill the container with the global Boxes. 
<p>

</div>
</div><p>
<a class="anchor" name="954dbe3f3df6982e7496fac5a1dac8a3"></a><!-- doxytag: member="SAMRAI::hier::BoxLevel::getFirstLocalId" ref="954dbe3f3df6982e7496fac5a1dac8a3" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSAMRAI_1_1hier_1_1LocalId.html">LocalId</a> SAMRAI::hier::BoxLevel::getFirstLocalId           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the first <a class="el" href="classSAMRAI_1_1hier_1_1LocalId.html">LocalId</a>, or one with a value of -1 if no local <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> exists. 
<p>

</div>
</div><p>
<a class="anchor" name="5f55f201872b812e8b5c8870aa52e57e"></a><!-- doxytag: member="SAMRAI::hier::BoxLevel::getLastLocalId" ref="5f55f201872b812e8b5c8870aa52e57e" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSAMRAI_1_1hier_1_1LocalId.html">LocalId</a> SAMRAI::hier::BoxLevel::getLastLocalId           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the last <a class="el" href="classSAMRAI_1_1hier_1_1LocalId.html">LocalId</a>, or one with a value of -1 if no local <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> exists. 
<p>

</div>
</div><p>
<a class="anchor" name="57a5d512c910580b578e34b9473ca0b8"></a><!-- doxytag: member="SAMRAI::hier::BoxLevel::getRefinementRatio" ref="57a5d512c910580b578e34b9473ca0b8" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a>&amp; SAMRAI::hier::BoxLevel::getRefinementRatio           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get const access to BoxLevel's refinement ratio (with respect to a reference level). 
<p>

</div>
</div><p>
<a class="anchor" name="5a8067d74ffcfcea775e899b149c7419"></a><!-- doxytag: member="SAMRAI::hier::BoxLevel::getLocalNumberOfBoxes" ref="5a8067d74ffcfcea775e899b149c7419" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t SAMRAI::hier::BoxLevel::getLocalNumberOfBoxes           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return local number of boxes. 
<p>
Periodic image Boxes are excluded. 
</div>
</div><p>
<a class="anchor" name="6ed65e220961665ab06fba294587cb68"></a><!-- doxytag: member="SAMRAI::hier::BoxLevel::getLocalNumberOfBoxes" ref="6ed65e220961665ab06fba294587cb68" args="(int rank) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t SAMRAI::hier::BoxLevel::getLocalNumberOfBoxes           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>rank</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return number of boxes local to the given rank. 
<p>
Periodic image Boxes are excluded.<p>
Object must be in GLOBALIZED mode to use this method.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>rank</em>&nbsp;</td><td></td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="2587c43d3bd495e4db0690a014bf2eb1"></a><!-- doxytag: member="SAMRAI::hier::BoxLevel::getGlobalNumberOfBoxes" ref="2587c43d3bd495e4db0690a014bf2eb1" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int SAMRAI::hier::BoxLevel::getGlobalNumberOfBoxes           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return global number of Boxes. 
<p>
This requires a global reduction, if the global-reduced data has not been computed and cached. When communication is required, all processors must call this method. To ensure that no communication is needed, call <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#183b36593e2211131739690181396e99">cacheGlobalReducedData()</a> first.<p>
Periodic image Boxes are excluded. 
</div>
</div><p>
<a class="anchor" name="c04928996f56ba42127c956e976610f4"></a><!-- doxytag: member="SAMRAI::hier::BoxLevel::getMaxNumberOfBoxes" ref="c04928996f56ba42127c956e976610f4" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int SAMRAI::hier::BoxLevel::getMaxNumberOfBoxes           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return maximum number of Boxes over all processes. 
<p>
This requires a global reduction, if the global-reduced data has not been computed and cached. When communication is required, all processors must call this method. To ensure that no communication is needed, call <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#183b36593e2211131739690181396e99">cacheGlobalReducedData()</a> first.<p>
Periodic image Boxes are excluded. 
</div>
</div><p>
<a class="anchor" name="5cb56e921d2f7af5cbd809a0bbdfa4ba"></a><!-- doxytag: member="SAMRAI::hier::BoxLevel::getMinNumberOfBoxes" ref="5cb56e921d2f7af5cbd809a0bbdfa4ba" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int SAMRAI::hier::BoxLevel::getMinNumberOfBoxes           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return maximum number of Boxes over all processes. 
<p>
This requires a global reduction, if the global-reduced data has not been computed and cached. When communication is required, all processors must call this method. To ensure that no communication is needed, call <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#183b36593e2211131739690181396e99">cacheGlobalReducedData()</a> first.<p>
Periodic image Boxes are excluded. 
</div>
</div><p>
<a class="anchor" name="8e018a0a522b3fb925003d8880168708"></a><!-- doxytag: member="SAMRAI::hier::BoxLevel::getLocalNumberOfCells" ref="8e018a0a522b3fb925003d8880168708" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t SAMRAI::hier::BoxLevel::getLocalNumberOfCells           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return local number of cells. 
<p>
Cells in periodic image Boxes are excluded. 
</div>
</div><p>
<a class="anchor" name="78975b8d6869c071db8b66bc0c8fa34c"></a><!-- doxytag: member="SAMRAI::hier::BoxLevel::getMaxNumberOfCells" ref="78975b8d6869c071db8b66bc0c8fa34c" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int SAMRAI::hier::BoxLevel::getMaxNumberOfCells           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return maximum number of cells over all processes. 
<p>
This requires a global reduction, if the global-reduced data has not been computed and cached. When communication is required, all processors must call this method. To ensure that no communication is needed, call <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#183b36593e2211131739690181396e99">cacheGlobalReducedData()</a> first.<p>
Periodic image Boxes are excluded. 
</div>
</div><p>
<a class="anchor" name="1fcedeb0804d152f78e9e3791f2cabff"></a><!-- doxytag: member="SAMRAI::hier::BoxLevel::getMinNumberOfCells" ref="1fcedeb0804d152f78e9e3791f2cabff" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int SAMRAI::hier::BoxLevel::getMinNumberOfCells           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return maximum number of cells over all processes. 
<p>
This requires a global reduction, if the global-reduced data has not been computed and cached. When communication is required, all processors must call this method. To ensure that no communication is needed, call <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#183b36593e2211131739690181396e99">cacheGlobalReducedData()</a> first.<p>
Periodic image Boxes are excluded. 
</div>
</div><p>
<a class="anchor" name="907c93058e8a8bc5451c654da8116deb"></a><!-- doxytag: member="SAMRAI::hier::BoxLevel::getLocalNumberOfCells" ref="907c93058e8a8bc5451c654da8116deb" args="(int rank) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t SAMRAI::hier::BoxLevel::getLocalNumberOfCells           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>rank</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return number of cells local to the given rank. 
<p>
Cells in periodic image Boxes are excluded.<p>
Object must be in GLOBALIZED mode to use this method.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>rank</em>&nbsp;</td><td></td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="364de76d3c5e21bea6a6398db5ea68e6"></a><!-- doxytag: member="SAMRAI::hier::BoxLevel::getGlobalNumberOfCells" ref="364de76d3c5e21bea6a6398db5ea68e6" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int SAMRAI::hier::BoxLevel::getGlobalNumberOfCells           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return global number of cells. 
<p>
This requires a global reduction if the global-reduced data has not been computed and cached. When communication is required, all processors must call this method. To ensure that no communication is needed, call <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#183b36593e2211131739690181396e99">cacheGlobalReducedData()</a> first.<p>
Cells in periodic image Boxes are excluded. 
</div>
</div><p>
<a class="anchor" name="13cce4466852fa2aa9a6cd2fa9e6f9ab"></a><!-- doxytag: member="SAMRAI::hier::BoxLevel::getLocalBoundingBox" ref="13cce4466852fa2aa9a6cd2fa9e6f9ab" args="(int block_number) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a>&amp; SAMRAI::hier::BoxLevel::getLocalBoundingBox           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>block_number</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return bounding box for local Boxes in a block. 
<p>

</div>
</div><p>
<a class="anchor" name="1497e6474d50396a2d3ca88a9539422c"></a><!-- doxytag: member="SAMRAI::hier::BoxLevel::getGlobalBoundingBox" ref="1497e6474d50396a2d3ca88a9539422c" args="(int block_number) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a>&amp; SAMRAI::hier::BoxLevel::getGlobalBoundingBox           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>block_number</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return bounding box for global Boxes in a block. 
<p>
This requires a global reduction if the global bounding box has not been computed and cached. When communication is required, all processors must call this method. To ensure that no communication is needed, call <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#183b36593e2211131739690181396e99">cacheGlobalReducedData()</a> first. 
</div>
</div><p>
<a class="anchor" name="135e075de4928ddcc412c28e7580cd7d"></a><!-- doxytag: member="SAMRAI::hier::BoxLevel::getLocalMaxBoxSize" ref="135e075de4928ddcc412c28e7580cd7d" args="(int block_number) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a>&amp; SAMRAI::hier::BoxLevel::getLocalMaxBoxSize           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>block_number</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return size of the largest local <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> in a block. 
<p>

</div>
</div><p>
<a class="anchor" name="214830ea3fadba642162ed4d992a792f"></a><!-- doxytag: member="SAMRAI::hier::BoxLevel::getLocalMinBoxSize" ref="214830ea3fadba642162ed4d992a792f" args="(int block_number) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a>&amp; SAMRAI::hier::BoxLevel::getLocalMinBoxSize           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>block_number</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return size of the smallest local <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> in a block. 
<p>

</div>
</div><p>
<a class="anchor" name="5399ceaad82005b7a1515df5c9a29980"></a><!-- doxytag: member="SAMRAI::hier::BoxLevel::getGlobalMaxBoxSize" ref="5399ceaad82005b7a1515df5c9a29980" args="(int block_number) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a>&amp; SAMRAI::hier::BoxLevel::getGlobalMaxBoxSize           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>block_number</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return size of the largest <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> globally in a block. 
<p>
This requires a global reduction if the global bounding box has not been computed and cached. When communication is required, all processors must call this method. To ensure that no communication is needed, call <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#183b36593e2211131739690181396e99">cacheGlobalReducedData()</a> first. 
</div>
</div><p>
<a class="anchor" name="488d1cb0fb2bf1fd55f79a798f1b4015"></a><!-- doxytag: member="SAMRAI::hier::BoxLevel::getGlobalMinBoxSize" ref="488d1cb0fb2bf1fd55f79a798f1b4015" args="(int block_number) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a>&amp; SAMRAI::hier::BoxLevel::getGlobalMinBoxSize           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>block_number</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return size of the smallest <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> globally in a block. 
<p>
This requires a global reduction if the global bounding box has not been computed and cached. When communication is required, all processors must call this method. To ensure that no communication is needed, call <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#183b36593e2211131739690181396e99">cacheGlobalReducedData()</a> first. 
</div>
</div><p>
<a class="anchor" name="01ab4dc0bdd8111d1b225194a3a46724"></a><!-- doxytag: member="SAMRAI::hier::BoxLevel::getDim" ref="01ab4dc0bdd8111d1b225194a3a46724" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classSAMRAI_1_1tbox_1_1Dimension.html">tbox::Dimension</a>&amp; SAMRAI::hier::BoxLevel::getDim           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return the dimension of this object. 
<p>
If object has never been initialized, return <a class="el" href="classSAMRAI_1_1tbox_1_1Dimension.html#acba22b89da4fa98f35b4ea217e1264f">tbox::Dimension::getInvalidDimension()</a>. 
</div>
</div><p>
<a class="anchor" name="48f3d09fc617a1a40fbfb1f7079fbd71"></a><!-- doxytag: member="SAMRAI::hier::BoxLevel::getGridGeometry" ref="48f3d09fc617a1a40fbfb1f7079fbd71" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const boost::shared_ptr&lt;const <a class="el" href="classSAMRAI_1_1hier_1_1BaseGridGeometry.html">BaseGridGeometry</a>&gt;&amp; SAMRAI::hier::BoxLevel::getGridGeometry           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return the grid geometry associated with this object. 
<p>
If object has never been initialized, return NULL pointer. 
</div>
</div><p>
<a class="anchor" name="4278fe56881640392e9fa8fc0a047fb2"></a><!-- doxytag: member="SAMRAI::hier::BoxLevel::refineBoxes" ref="4278fe56881640392e9fa8fc0a047fb2" args="(BoxLevel &amp;finer, const IntVector &amp;ratio, const IntVector &amp;final_ratio) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::hier::BoxLevel::refineBoxes           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>finer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>ratio</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>final_ratio</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Refine all Boxes of this <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a> by ratio placing result into finer making finer's ratio final_ratio. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>finer</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>ratio</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>final_ratio</em>&nbsp;</td><td></td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="781a2e5bcc0ce41aa657eb006487789f"></a><!-- doxytag: member="SAMRAI::hier::BoxLevel::coarsenBoxes" ref="781a2e5bcc0ce41aa657eb006487789f" args="(BoxLevel &amp;coarser, const IntVector &amp;ratio, const IntVector &amp;final_ratio) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::hier::BoxLevel::coarsenBoxes           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>coarser</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>ratio</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>final_ratio</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Coarsen all Boxes of this <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a> by ratio placing result into coarser making coarser's ratio final_ratio. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>coarser</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>ratio</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>final_ratio</em>&nbsp;</td><td></td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="31ca5a8d4b6d93df37ca53c4905833f1"></a><!-- doxytag: member="SAMRAI::hier::BoxLevel::addBox" ref="31ca5a8d4b6d93df37ca53c4905833f1" args="(const Box &amp;box, const BlockId &amp;block_id, const bool use_vacant_index=true)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer_1_1BoxContainerConstIterator.html">BoxContainer::const_iterator</a> SAMRAI::hier::BoxLevel::addBox           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>box</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1BlockId.html">BlockId</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>block_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&nbsp;</td>
          <td class="paramname"> <em>use_vacant_index</em> = <code>true</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Create new local <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> from given <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> and add it to this level. 
<p>
The new <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> will be assigned an unused local index. To be efficient, no communication will be used. Therefore, the state must be distributed.<p>
The new <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> will have a periodic shift number corresponding to zero-shift.<p>
It is faster not to request a vacant index when adding a box.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>box</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>block_id</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>use_vacant_index</em>&nbsp;</td><td></td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>iterator to the new <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="04569f993cb446a57d8d69de7067e579"></a><!-- doxytag: member="SAMRAI::hier::BoxLevel::addBox" ref="04569f993cb446a57d8d69de7067e579" args="(const Box &amp;box)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::hier::BoxLevel::addBox           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>box</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Add a <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> to this level. 
<p>
Adding a remote <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> is allowed if the object is in GLOBALIZED mode.<p>
<dl compact><dt><b>CAUTION</b></dt><dd>To be efficient, no checks are made to make sure the <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a> representation is consistent across all processors. Setting inconsistent data leads potentially elusive bugs.</dd></dl>
<dl compact><dt><b>Errors</b></dt><dd>It is an error to add a periodic image of a <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> that is not a part of the <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a>.</dd></dl>
It is an error to add any <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> that already exists.<p>
FIXME: Should we prevent this operation if persistent overlap Connectors are attached to this object?<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>box</em>&nbsp;</td><td></td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="0021b5651c94464d34c5bffce3fecbf4"></a><!-- doxytag: member="SAMRAI::hier::BoxLevel::addBoxWithoutUpdate" ref="0021b5651c94464d34c5bffce3fecbf4" args="(const Box &amp;box)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::hier::BoxLevel::addBoxWithoutUpdate           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>box</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Add a <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> to this level without updating summary data such as local number of boxes/cells, bounding box, max/min box size. Meant to be used during the construction of a <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a> as Boxes belonging to the level are found. <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#a171283d1d5bc3f5d11732ac14e2df24">finalize()</a> should be called at the end of construction making use of addBoxWithoutUpdate. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>box</em>&nbsp;</td><td></td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="7a0aa4f5f03e39893cca82987ffb8401"></a><!-- doxytag: member="SAMRAI::hier::BoxLevel::addPeriodicBox" ref="7a0aa4f5f03e39893cca82987ffb8401" args="(const Box &amp;existing_box, const PeriodicId &amp;shift_number)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::hier::BoxLevel::addPeriodicBox           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>existing_box</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1PeriodicId.html">PeriodicId</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>shift_number</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Insert given periodic image of an existing <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a>. 
<p>
Adding a remote <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> is allowed if the object is in GLOBALIZED mode.<p>
Unlike adding a regular <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a>, it is OK to add a periodic image <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> that already exists. However, that is a no-op.<p>
<dl compact><dt><b>CAUTION</b></dt><dd>To be efficient, no checks are made to make sure the <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a> representation is consistent across all processors. Setting inconsistent data leads potentially elusive bugs.</dd></dl>
<dl compact><dt><b>Errors</b></dt><dd>It is an error to add a periodic image of a <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> that does not exist.</dd></dl>
FIXME: Should we prevent this operation if persistent overlap Connectors are attached to this object?<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>existing_box</em>&nbsp;</td><td>An existing <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> for reference. This <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> must be in the <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a>. The <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> added is an image of the reference <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> but shifted to another position. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>shift_number</em>&nbsp;</td><td>The valid shift number for the <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> being added. The shift amount is taken from the <a class="el" href="classSAMRAI_1_1hier_1_1PeriodicShiftCatalog.html">PeriodicShiftCatalog</a>. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="5a1412abb328dce673eb1a98c67e9e64"></a><!-- doxytag: member="SAMRAI::hier::BoxLevel::eraseBox" ref="5a1412abb328dce673eb1a98c67e9e64" args="(BoxContainer::iterator &amp;ibox)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::hier::BoxLevel::eraseBox           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer_1_1BoxContainerIterator.html">BoxContainer::iterator</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>ibox</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Erase the existing <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> specified by its iterator. 
<p>
The given iterator <em>MUST</em> be a valid iterator pointing to a <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> currently in this object. After erasing, the iterator is advanced to the next valid <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> (or the end of its <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a>).<p>
Erasing a <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> also erases all of its periodic images.<p>
FIXME: Should we prevent this operation if the object has persistent overlap Connectors?<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>ibox</em>&nbsp;</td><td>The iterator of the <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> to erase. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="d8b2f4c0e0cdf0da1885734c7307be47"></a><!-- doxytag: member="SAMRAI::hier::BoxLevel::eraseBox" ref="d8b2f4c0e0cdf0da1885734c7307be47" args="(const Box &amp;box)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::hier::BoxLevel::eraseBox           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>box</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Erase the <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> matching the one given. 
<p>
The given <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> <em>MUST</em> match a <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> currently in this object. Matching means that the BoxId's match (disregarding the spatial coordinates).<p>
Erasing a <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> also erases all of its periodic images.<p>
FIXME: Should we prevent this operation if the object has persistent overlap Connectors?<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>box</em>&nbsp;</td><td></td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="c629faeea80bc319a1b1a215d1ff74b5"></a><!-- doxytag: member="SAMRAI::hier::BoxLevel::eraseBoxWithoutUpdate" ref="c629faeea80bc319a1b1a215d1ff74b5" args="(const Box &amp;box)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::hier::BoxLevel::eraseBoxWithoutUpdate           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>box</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Erases the <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> matching the supplied <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> from this level without updating summary data such as local number of boxes/cells, bounding box, max/min box size. Meant to be used during the construction of a <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a> as Boxes not belonging to the level are found. <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#a171283d1d5bc3f5d11732ac14e2df24">finalize()</a> should be called at the end of construction making use of eraseBoxWithoutUpdate. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>box</em>&nbsp;</td><td></td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="1ce806b2a617a0be7d015528cbd5dfa0"></a><!-- doxytag: member="SAMRAI::hier::BoxLevel::getBox" ref="1ce806b2a617a0be7d015528cbd5dfa0" args="(const Box &amp;box) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer_1_1BoxContainerConstIterator.html">BoxContainer::const_iterator</a> SAMRAI::hier::BoxLevel::getBox           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>box</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Find the <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> matching the one given. 
<p>
Only the <a class="el" href="classSAMRAI_1_1hier_1_1BoxId.html">BoxId</a> matters in matching, so the actual <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> can be anything.<p>
If <code>box</code> is not a local <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a>, the state must be GLOBALIZED.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>box</em>&nbsp;</td><td></td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Iterator to the box, or <code>getBoxes(owner)</code>.end() if box does not exist in set. </dd></dl>

</div>
</div><p>
<a class="anchor" name="c637cc96657034252d5fd800f30b8178"></a><!-- doxytag: member="SAMRAI::hier::BoxLevel::getBox" ref="c637cc96657034252d5fd800f30b8178" args="(const BoxId &amp;box_id) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer_1_1BoxContainerConstIterator.html">BoxContainer::const_iterator</a> SAMRAI::hier::BoxLevel::getBox           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1BoxId.html">BoxId</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>box_id</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Find the <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> specified by the given <a class="el" href="classSAMRAI_1_1hier_1_1BoxId.html">BoxId</a> and periodic shift. 
<p>
If <code>box</code> is not a local <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a>, the state must be GLOBALIZED. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>box_id</em>&nbsp;</td><td></td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Iterator to the box, or <code>getBoxes(owner)</code>.end() if box does not exist in set. </dd></dl>

</div>
</div><p>
<a class="anchor" name="b3917d6bf64527ce45d1a6a0113aeaf3"></a><!-- doxytag: member="SAMRAI::hier::BoxLevel::getBoxStrict" ref="b3917d6bf64527ce45d1a6a0113aeaf3" args="(const Box &amp;box) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer_1_1BoxContainerConstIterator.html">BoxContainer::const_iterator</a> SAMRAI::hier::BoxLevel::getBoxStrict           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>box</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Find the <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> matching the one given. 
<p>
Only the <a class="el" href="classSAMRAI_1_1hier_1_1BoxId.html">BoxId</a> matters in matching, so the actual <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> can be anything.<p>
If <code>box</code> is not owned by the local process, the state must be GLOBALIZED.<p>
You cannot directly modify the <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a> because it may invalidate other internal data. Use other methods for modifying the <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a>.<p>
<dl compact><dt><b>Assertions</b></dt><dd>Throws an unrecoverable assertion if the <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> does not exist.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>box</em>&nbsp;</td><td></td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Iterator to the box. </dd></dl>

</div>
</div><p>
<a class="anchor" name="24923c783921933dc6f241ec059da82e"></a><!-- doxytag: member="SAMRAI::hier::BoxLevel::getBoxStrict" ref="24923c783921933dc6f241ec059da82e" args="(const BoxId &amp;box_id) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer_1_1BoxContainerConstIterator.html">BoxContainer::const_iterator</a> SAMRAI::hier::BoxLevel::getBoxStrict           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1BoxId.html">BoxId</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>box_id</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Find the <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> specified by the given <a class="el" href="classSAMRAI_1_1hier_1_1BoxId.html">BoxId</a>. 
<p>
You cannot directly modify the <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a> because it may invalidate other internal data. Use other methods for modifying the <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a>.<p>
<dl compact><dt><b>Assertions</b></dt><dd>Throw an unrecoverable assertion if the <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> does not exist.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>box_id</em>&nbsp;</td><td></td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Iterator to the box. </dd></dl>

</div>
</div><p>
<a class="anchor" name="035bb795c44bc499f32f60e9b4e0bebc"></a><!-- doxytag: member="SAMRAI::hier::BoxLevel::getSpatiallyEqualBox" ref="035bb795c44bc499f32f60e9b4e0bebc" args="(const Box &amp;box_to_match, const BlockId &amp;block_id, Box &amp;matching_box) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SAMRAI::hier::BoxLevel::getSpatiallyEqualBox           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>box_to_match</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1BlockId.html">BlockId</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>block_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>matching_box</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Find the <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> with the given <a class="el" href="classSAMRAI_1_1hier_1_1BlockId.html">BlockId</a> which is spatially equal to the supplied <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a>. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>box_to_match</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>block_id</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>matching_box</em>&nbsp;</td><td>If there is a box with the supplied <a class="el" href="classSAMRAI_1_1hier_1_1BlockId.html">BlockId</a> spatially equal to box_to_match then this is set to that <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a>.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>true if a match is found. </dd></dl>

</div>
</div><p>
<a class="anchor" name="a6342f7381b304e638b4313bd6a23fe3"></a><!-- doxytag: member="SAMRAI::hier::BoxLevel::hasBox" ref="a6342f7381b304e638b4313bd6a23fe3" args="(const BoxId &amp;box_id) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SAMRAI::hier::BoxLevel::hasBox           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1BoxId.html">BoxId</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>box_id</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns true when the object has a <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> specified by the <a class="el" href="classSAMRAI_1_1hier_1_1BoxId.html">BoxId</a>. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>box_id</em>&nbsp;</td><td></td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="4178a61a873d82cb74c15512ff73dd3e"></a><!-- doxytag: member="SAMRAI::hier::BoxLevel::hasBox" ref="4178a61a873d82cb74c15512ff73dd3e" args="(const GlobalId &amp;global_id, const PeriodicId &amp;periodic_id) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SAMRAI::hier::BoxLevel::hasBox           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1GlobalId.html">GlobalId</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>global_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1PeriodicId.html">PeriodicId</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>periodic_id</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns true when the object has a <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> consistent with all of the arguments. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>global_id</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>periodic_id</em>&nbsp;</td><td></td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="989a5937806c38349195694c449d1d2f"></a><!-- doxytag: member="SAMRAI::hier::BoxLevel::hasBox" ref="989a5937806c38349195694c449d1d2f" args="(const Box &amp;box) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SAMRAI::hier::BoxLevel::hasBox           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>box</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns true when this <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a> has a <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> matching the <a class="el" href="classSAMRAI_1_1hier_1_1BoxId.html">BoxId</a> of the given box. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>box</em>&nbsp;</td><td></td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="708bac92ccc04022a4d1f004252641ab"></a><!-- doxytag: member="SAMRAI::hier::BoxLevel::putUnregisteredToDatabase" ref="708bac92ccc04022a4d1f004252641ab" args="(const boost::shared_ptr&lt; tbox::Database &gt; &amp;database) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::hier::BoxLevel::putUnregisteredToDatabase           </td>
          <td>(</td>
          <td class="paramtype">const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Database.html">tbox::Database</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>database</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Write the <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a> to a database. 
<p>
Write only local parts regardless of parallel state (to avoid writing tons of repetitive data).<p>
<dl compact><dt><b>Assertions</b></dt><dd>Check that database is a non-null Pointer.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>database</em>&nbsp;</td><td></td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="44c1f47418c7dfa2b597b7e1e1dd39f0"></a><!-- doxytag: member="SAMRAI::hier::BoxLevel::getFromDatabase" ref="44c1f47418c7dfa2b597b7e1e1dd39f0" args="(tbox::Database &amp;database, const boost::shared_ptr&lt; const BaseGridGeometry &gt; &amp;grid_geom)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::hier::BoxLevel::getFromDatabase           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1tbox_1_1Database.html">tbox::Database</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>database</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const boost::shared_ptr&lt; const <a class="el" href="classSAMRAI_1_1hier_1_1BaseGridGeometry.html">BaseGridGeometry</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>grid_geom</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Read the <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a> from a database. 
<p>
Put the <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a> in the DISTRIBUTED parallel state and read only local parts.<p>
If the <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a> is initialized, use its SAMRAI_MPI object and require its refinement ratio to match that in the database. If the <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a> is uninitialized, it will be initialized to use <a class="el" href="classSAMRAI_1_1tbox_1_1SAMRAI__MPI.html#7a31310ba00a790a313d2122df8d7a6f">tbox::SAMRAI_MPI::getSAMRAIWorld()</a> for the SAMRAI_MPI object. Note that these behaviors have not been extensively discussed by the <a class="el" href="namespaceSAMRAI.html">SAMRAI</a> developers and may be subject to change.<p>
<dl compact><dt><b>Assertions</b></dt><dd>Check that database is a non-null Pointer.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>database</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>grid_geom</em>&nbsp;</td><td></td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="f86fbfacb3f47f8f317e087c43d7f5a3"></a><!-- doxytag: member="SAMRAI::hier::BoxLevel::getPersistentOverlapConnectors" ref="f86fbfacb3f47f8f317e087c43d7f5a3" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSAMRAI_1_1hier_1_1PersistentOverlapConnectors.html">PersistentOverlapConnectors</a> &amp; SAMRAI::hier::BoxLevel::getPersistentOverlapConnectors           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the collection of overlap Connectors dedicated to provide overlap neighbors for this <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a>. 
<p>
The <a class="el" href="classSAMRAI_1_1hier_1_1PersistentOverlapConnectors.html">PersistentOverlapConnectors</a> provides overlap neighbors for this <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a>. Its role is to create and manage persistent overlap Connectors based at this <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a> and persisting until the <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a> changes (so they should not be set up until the <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a> is in its final state). This is the mechanism by which code that can efficiently generate the overlap Connectors (usually the code that generated the <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a>) provides overlap data to code using the <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a>. The <a class="el" href="classSAMRAI_1_1hier_1_1PersistentOverlapConnectors.html">PersistentOverlapConnectors</a> are guaranteed to be correct, so any changes to the <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a> will cause current Connectors to be deallocated.<p>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classSAMRAI_1_1hier_1_1PersistentOverlapConnectors.html">PersistentOverlapConnectors</a> for instructions on creating the Connectors. </dd></dl>

</div>
</div><p>
<a class="anchor" name="422572b300c7750956c4b4cccca8d258"></a><!-- doxytag: member="SAMRAI::hier::BoxLevel::getBoxLevelHandle" ref="422572b300c7750956c4b4cccca8d258" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const boost::shared_ptr&lt;<a class="el" href="classSAMRAI_1_1hier_1_1BoxLevelHandle.html">BoxLevelHandle</a>&gt;&amp; SAMRAI::hier::BoxLevel::getBoxLevelHandle           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the handle with which Connectors reference the <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a> instead of referencing the <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a> itself. Not for general use. 
<p>
Connectors referencing their base and head BoxLevels should reference their handles instead of the BoxLevels themselves. As long as the <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a> does not change in a way that can invalidate <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">Connector</a> data, you can access the <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a> from the <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevelHandle.html">BoxLevelHandle</a>.<p>
If the <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a> go out of scope before the <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">Connector</a> disconnects, this boost::shared_ptr object will stay around until all Connectors have disconnected.<p>
Operations that can invalidate <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">Connector</a> data are those that remove information from the <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a>. These are:<p>
<ul>
<li><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#66d3522a2b18ef07a01876c00b7a7682">initialize()</a> </li>
<li><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#fb06eb2fc44ba9619cf5dd1a0bbb5293">swapInitialize()</a> </li>
<li><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#125a90d67a15e87724013e21c5773e6a">swap()</a> </li>
<li><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#453187b7a435ed78ad8cf2819342f20f">clear()</a> </li>
<li><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#ed880bc6c4c1b4fd4b73ee348d65231d">operator=()</a> (assignment) (Exception: assigning to self is a no-op, which does not invalidate <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">Connector</a> data. </li>
<li><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#5a1412abb328dce673eb1a98c67e9e64">eraseBox()</a> (Note that adding a <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> does not invalidate <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">Connector</a> data.) </li>
<li>going out of scope</li>
</ul>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevelHandle.html">BoxLevelHandle</a>.</dd></dl>
<dl compact><dt><b>Returns:</b></dt><dd>A boost::shared_ptr to the <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevelHandle.html">BoxLevelHandle</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="e7eee9eaf5843c1f34ff54d036c42bc2"></a><!-- doxytag: member="SAMRAI::hier::BoxLevel::recursivePrint" ref="e7eee9eaf5843c1f34ff54d036c42bc2" args="(std::ostream &amp;os, const std::string &amp;border, int detail_depth=0) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::hier::BoxLevel::recursivePrint           </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&nbsp;</td>
          <td class="paramname"> <em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>border</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>detail_depth</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Print <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> info from this level. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>os</em>&nbsp;</td><td>The output stream </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>border</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>detail_depth</em>&nbsp;</td><td></td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="63c33f123d563234febc5abfed9ba8f4"></a><!-- doxytag: member="SAMRAI::hier::BoxLevel::format" ref="63c33f123d563234febc5abfed9ba8f4" args="(const std::string &amp;border=std::string(), int detail_depth=0) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel_1_1Outputter.html">BoxLevel::Outputter</a> SAMRAI::hier::BoxLevel::format           </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>border</em> = <code>std::string()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>detail_depth</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return a object that can format the <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a> for inserting into output streams. 
<p>
Usage example: <div class="fragment"><pre class="fragment">    std::cout &lt;&lt; <span class="stringliteral">"my box_level:\n"</span>
              &lt;&lt; box_level.format(<span class="stringliteral">"  "</span>, 2) &lt;&lt; std::endl;
</pre></div><p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>border</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>detail_depth</em>&nbsp;</td><td></td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="85b62ebfbe93f0e814e10a08e741cad4"></a><!-- doxytag: member="SAMRAI::hier::BoxLevel::formatStatistics" ref="85b62ebfbe93f0e814e10a08e741cad4" args="(const std::string &amp;border=std::string()) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel_1_1Outputter.html">BoxLevel::Outputter</a> SAMRAI::hier::BoxLevel::formatStatistics           </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>border</em> = <code>std::string()</code>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return a object that can format the <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a> for inserting its global statistics into output streams. 
<p>
Usage example: <div class="fragment"><pre class="fragment">    std::cout &lt;&lt; <span class="stringliteral">"my box_level statistics:\n"</span>
              &lt;&lt; box_level.formatStatistics(<span class="stringliteral">"  "</span>) &lt;&lt; std::endl;
</pre></div><p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>border</em>&nbsp;</td><td></td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="19cd31335bfdfa84d45a8fb778aa9291"></a><!-- doxytag: member="SAMRAI::hier::BoxLevel::initializeCallback" ref="19cd31335bfdfa84d45a8fb778aa9291" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void SAMRAI::hier::BoxLevel::initializeCallback           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set up things for the entire class. 
<p>
Only called by StartupShutdownManager. 
</div>
</div><p>
<a class="anchor" name="896e93d5776f9baa5a18aedd3052782b"></a><!-- doxytag: member="SAMRAI::hier::BoxLevel::finalizeCallback" ref="896e93d5776f9baa5a18aedd3052782b" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void SAMRAI::hier::BoxLevel::finalizeCallback           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Free static timers. 
<p>
Only called by StartupShutdownManager. 
</div>
</div><p>
<hr><h2>Friends And Related Function Documentation</h2>
<a class="anchor" name="0ffde531e623d3f0ab07261aa48769ba"></a><!-- doxytag: member="SAMRAI::hier::BoxLevel::std::vector&lt; BoxLevel &gt;" ref="0ffde531e623d3f0ab07261aa48769ba" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">friend class std::vector&lt; <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a> &gt;<code> [friend]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Allows std::vector to allocate objects with uninitialized dimensions. 
<p>

</div>
</div><p>
<hr>The documentation for this class was generated from the following files:<ul>
<li>source/SAMRAI/hier/<a class="el" href="BoxLevel_8h.html">BoxLevel.h</a><li>source/SAMRAI/hier/<a class="el" href="BoxLevel_8C.html">BoxLevel.C</a></ul>
<hr size="1"><address style="align: right;"><small>Generated on Thu Jun 21 13:42:56 2012 for SAMRAI by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.7 </small></address>
</body>
</html>
