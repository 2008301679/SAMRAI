<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>SAMRAI: SAMRAI::solv::CellPoissonHypreSolver Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath"><a class="el" href="namespaceSAMRAI.html">SAMRAI</a>::<a class="el" href="namespaceSAMRAI_1_1solv.html">solv</a>::<a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonHypreSolver.html">CellPoissonHypreSolver</a>
  </div>
</div>
<div class="contents">
<h1>SAMRAI::solv::CellPoissonHypreSolver Class Reference</h1><!-- doxytag: class="SAMRAI::solv::CellPoissonHypreSolver" -->
<p>Use the HYPRE preconditioner library to solve (the cell-centered) Poisson's equation on a single level in a hierarchy.  
<a href="#_details">More...</a></p>

<p><code>#include &lt;source/SAMRAI/solv/CellPoissonHypreSolver.h&gt;</code></p>

<p><a href="classSAMRAI_1_1solv_1_1CellPoissonHypreSolver-members.html">List of all members.</a></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonHypreSolver.html#a5d29ddcfb79770a332e7f54c6136dc9e">CellPoissonHypreSolver</a> (const <a class="el" href="classSAMRAI_1_1tbox_1_1Dimension.html">tbox::Dimension</a> &amp;dim, const std::string &amp;object_name, const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Database.html">tbox::Database</a> &gt; &amp;input_db=boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Database.html">tbox::Database</a> &gt;())</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Constructor.  <a href="#a5d29ddcfb79770a332e7f54c6136dc9e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonHypreSolver.html#a09b35d1aa19d26a55bd5673fde493e8d">~CellPoissonHypreSolver</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonHypreSolver.html#a9811f250d6fe4fc22cfaaf71ee3f5a45">initializeSolverState</a> (const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchHierarchy.html">hier::PatchHierarchy</a> &gt; &amp;hierarchy, int ln=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Initialize to a given hierarchy.  <a href="#a9811f250d6fe4fc22cfaaf71ee3f5a45"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonHypreSolver.html#a657c7d64da8864c13d29aa195772c385">deallocateSolverState</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Reset to an uninitialized state.  <a href="#a657c7d64da8864c13d29aa195772c385"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonHypreSolver.html#abb4f038b8bf890ab367d4496cc8d58b9">setMatrixCoefficients</a> (const <a class="el" href="classSAMRAI_1_1solv_1_1PoissonSpecifications.html">PoissonSpecifications</a> &amp;spec)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the matrix coefficients.  <a href="#abb4f038b8bf890ab367d4496cc8d58b9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonHypreSolver.html#ade811981fb611b422f43bcfe60fc75f0">setSolnIdDepth</a> (const int depth)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set default depth of the solution data involved in the solve.  <a href="#ade811981fb611b422f43bcfe60fc75f0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonHypreSolver.html#af1df26d5e093f9b360bb02a23831551b">setRhsIdDepth</a> (const int depth)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set default depth of the rhs data involved in the solve.  <a href="#af1df26d5e093f9b360bb02a23831551b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonHypreSolver.html#af673ce6767563395fa428b0f992e1759">setStoppingCriteria</a> (const int max_iterations=10, const double relative_residual_tol=1.0e-6)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the stopping criteria (max iterations and residual tolerance) for the linear solver.  <a href="#af673ce6767563395fa428b0f992e1759"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonHypreSolver.html#a593a3c91dbc75cd49403dc21da522905">solveSystem</a> (const int u, const int f, bool homogeneous_bc=false)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Solve the linear system Au=f.  <a href="#a593a3c91dbc75cd49403dc21da522905"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonHypreSolver.html#ac363febdbbf7fb003fb99ed39d51d19f">getNumberOfIterations</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the number of iterations taken by the solver to converge.  <a href="#ac363febdbbf7fb003fb99ed39d51d19f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonHypreSolver.html#aab7fb7db32e9d27dd2336aaf73c7bfa5">getRelativeResidualNorm</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the final residual norm returned by the Hypre solve.  <a href="#aab7fb7db32e9d27dd2336aaf73c7bfa5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonHypreSolver.html#af289f4c71199b1d98f2f40b2eecbf6b4">setBoundaries</a> (const std::string &amp;boundary_type, const int fluxes=-1, const int flags=-1, int *bdry_types=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Specify boundary condition directly, without using a <a class="el" href="classSAMRAI_1_1solv_1_1RobinBcCoefStrategy.html" title="Interface for specifying Robin boundary conditions.">RobinBcCoefStrategy</a> object.  <a href="#af289f4c71199b1d98f2f40b2eecbf6b4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonHypreSolver.html#a132a9af79508ca10238e75eecb19ad2e">setPhysicalBcCoefObject</a> (const <a class="el" href="classSAMRAI_1_1solv_1_1RobinBcCoefStrategy.html">RobinBcCoefStrategy</a> *physical_bc_coef_strategy, const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1hier_1_1Variable.html">hier::Variable</a> &gt; &amp;variable=boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1hier_1_1Variable.html">hier::Variable</a> &gt;())</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Specify boundary condition through the use of a Robin boundary condition object.  <a href="#a132a9af79508ca10238e75eecb19ad2e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonHypreSolver.html#aeebc33c4fdc3ef65022a03d5a9073da4">setPrintSolverInfo</a> (const bool print)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the flag for printing solver information.  <a href="#aeebc33c4fdc3ef65022a03d5a9073da4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const std::string &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonHypreSolver.html#afb585a1004156e4f16a7f86ebe006804">getObjectName</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the name of this object.  <a href="#afb585a1004156e4f16a7f86ebe006804"></a><br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>Use the HYPRE preconditioner library to solve (the cell-centered) Poisson's equation on a single level in a hierarchy. </p>
<p>Class <a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonHypreSolver.html" title="Use the HYPRE preconditioner library to solve (the cell-centered) Poisson&#39;s equation...">CellPoissonHypreSolver</a> uses the HYPRE preconditioner library to solve linear equations of the form <img class="formulaInl" alt="$ \nabla ( D \nabla u ) + C u = f $" src="form_57.png"/>, where C is a cell-centered array, D is a face-centered array, and u and f are cell-centered arrays (see <a class="el" href="classSAMRAI_1_1solv_1_1PoissonSpecifications.html" title="Light class holding specifications for cell-centered implementation of the scalar...">PoissonSpecifications</a>). The discretization is the standard second order finite difference stencil.</p>
<p>Robin boundary conditions are used through the interface class <a class="el" href="classSAMRAI_1_1solv_1_1RobinBcCoefStrategy.html" title="Interface for specifying Robin boundary conditions.">RobinBcCoefStrategy</a>. Periodic boundary conditions are not supported yet.</p>
<p>The user must perform the following steps to use <a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonHypreSolver.html" title="Use the HYPRE preconditioner library to solve (the cell-centered) Poisson&#39;s equation...">CellPoissonHypreSolver</a>:</p>
<ul>
<li>Create a <a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonHypreSolver.html" title="Use the HYPRE preconditioner library to solve (the cell-centered) Poisson&#39;s equation...">CellPoissonHypreSolver</a> object.</li>
<li>Initialize <a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonHypreSolver.html" title="Use the HYPRE preconditioner library to solve (the cell-centered) Poisson&#39;s equation...">CellPoissonHypreSolver</a> object with a patch hierarchy, using the function <a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonHypreSolver.html#a9811f250d6fe4fc22cfaaf71ee3f5a45" title="Initialize to a given hierarchy.">initializeSolverState()</a>.</li>
<li>Use the functions <a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonHypreSolver.html#a132a9af79508ca10238e75eecb19ad2e" title="Specify boundary condition through the use of a Robin boundary condition object.">setPhysicalBcCoefObject()</a> to provide implementations of <a class="el" href="classSAMRAI_1_1solv_1_1RobinBcCoefStrategy.html" title="Interface for specifying Robin boundary conditions.">RobinBcCoefStrategy</a>. (For most problems you can probably find a suitable implementation to use without implementing the strategy yourself. See for example <a class="el" href="classSAMRAI_1_1solv_1_1SimpleCellRobinBcCoefs.html" title="A prefabricated Robin boundary condition coefficients with an interface like the...">SimpleCellRobinBcCoefs</a> and <a class="el" href="classSAMRAI_1_1solv_1_1GhostCellRobinBcCoefs.html" title="A prefabricated Robin boundary condition coefficients for the case where cell-centered...">GhostCellRobinBcCoefs</a>.)</li>
<li>Set the matrix coefficients in the linear system, using the function <a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonHypreSolver.html#abb4f038b8bf890ab367d4496cc8d58b9" title="Set the matrix coefficients.">setMatrixCoefficients()</a>.</li>
<li>Specify the stopping criteria using <a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonHypreSolver.html#af673ce6767563395fa428b0f992e1759" title="Set the stopping criteria (max iterations and residual tolerance) for the linear...">setStoppingCriteria()</a>.</li>
<li>Solve the linear system, passing in u and f as the patch indices of the solution and the right hand side, respectively.</li>
</ul>
<p><b> Input Parameters </b></p>
<p><b> Definitions: </b></p>
<ul>
<li><b>print_solver_info</b> whether to print some data for debugging</li>
</ul>
<ul>
<li><b>max_iterations</b> max iterations used by Hypre</li>
</ul>
<ul>
<li><b>relative_residual_tol</b> residual tolerance used by Hypre</li>
</ul>
<ul>
<li><b>num_pre_relax_steps</b> number of presmoothing steps used by Hypre</li>
</ul>
<ul>
<li><b>num_post_relax_steps</b> number of postsmoothing steps used by Hypre</li>
</ul>
<ul>
<li><b>use_smg</b> whether to use hypre's smg solver (alternative is the pfmg solver)</li>
</ul>
<p><b> Details: </b> <br/>
 </p>
<table border="1" cellspacing="3" cellpadding="3">
<tr>
<th><p>parameter </p>
</th><th><p>type </p>
</th><th><p>default </p>
</th><th><p>range </p>
</th><th><p>opt/req </p>
</th><th><p>behavior on restart  </p>
</th></tr>
<tr>
<td><p>print_solver_info </p>
</td><td><p>bool </p>
</td><td><p>FALSE </p>
</td><td><p>TRUE, FALSE </p>
</td><td><p>opt </p>
</td><td><p>Not written to restart. Value in input db used.  </p>
</td></tr>
<tr>
<td><p>max_iterations </p>
</td><td><p>int </p>
</td><td><p>10 </p>
</td><td><p>&gt;0 </p>
</td><td><p>opt </p>
</td><td><p>Not written to restart. Value in input db used.  </p>
</td></tr>
<tr>
<td><p>relative_residual_tol </p>
</td><td><p>double </p>
</td><td><p>1.0e-10 </p>
</td><td><p>&gt;0.0 </p>
</td><td><p>opt </p>
</td><td><p>Not written to restart. Value in input db used.  </p>
</td></tr>
<tr>
<td><p>num_pre_relax_steps </p>
</td><td><p>int </p>
</td><td><p>1 </p>
</td><td><p>&gt;=0 </p>
</td><td><p>opt </p>
</td><td><p>Not written to restart. Value in input db used.  </p>
</td></tr>
<tr>
<td><p>num_post_relax_steps </p>
</td><td><p>int </p>
</td><td><p>1 </p>
</td><td><p>&gt;=0 </p>
</td><td><p>opt </p>
</td><td><p>Not written to restart. Value in input db used.  </p>
</td></tr>
<tr>
<td><p>use_smg </p>
</td><td><p>bool </p>
</td><td><p>TRUE </p>
</td><td><p>TRUE, FALSE </p>
</td><td><p>opt </p>
</td><td><p>Not written to restart. Value in input db used.  </p>
</td></tr>
</table>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a5d29ddcfb79770a332e7f54c6136dc9e"></a><!-- doxytag: member="SAMRAI::solv::CellPoissonHypreSolver::CellPoissonHypreSolver" ref="a5d29ddcfb79770a332e7f54c6136dc9e" args="(const tbox::Dimension &amp;dim, const std::string &amp;object_name, const boost::shared_ptr&lt; tbox::Database &gt; &amp;input_db=boost::shared_ptr&lt; tbox::Database &gt;())" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SAMRAI::solv::CellPoissonHypreSolver::CellPoissonHypreSolver </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1tbox_1_1Dimension.html">tbox::Dimension</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>dim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>object_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Database.html">tbox::Database</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>input_db</em> = <code>boost::shared_ptr&lt;&nbsp;<a class="el" href="classSAMRAI_1_1tbox_1_1Database.html">tbox::Database</a>&nbsp;&gt;()</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Constructor. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dim</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>object_name</em>&nbsp;</td><td>Name of object. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>input_db</em>&nbsp;</td><td><a class="el" href="classSAMRAI_1_1tbox_1_1Database.html" title="Class Database is an abstract base class for the input, restart, and visualization...">tbox::Database</a> for input.</td></tr>
  </table>
  </dd>
</dl>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>(dim.getValue() == 2) || (dim.getValue() == 3) </dd></dl>

</div>
</div>
<a class="anchor" id="a09b35d1aa19d26a55bd5673fde493e8d"></a><!-- doxytag: member="SAMRAI::solv::CellPoissonHypreSolver::~CellPoissonHypreSolver" ref="a09b35d1aa19d26a55bd5673fde493e8d" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SAMRAI::solv::CellPoissonHypreSolver::~CellPoissonHypreSolver </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>The Poisson destructor releases all internally managed data. </p>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a9811f250d6fe4fc22cfaaf71ee3f5a45"></a><!-- doxytag: member="SAMRAI::solv::CellPoissonHypreSolver::initializeSolverState" ref="a9811f250d6fe4fc22cfaaf71ee3f5a45" args="(const boost::shared_ptr&lt; hier::PatchHierarchy &gt; &amp;hierarchy, int ln=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::solv::CellPoissonHypreSolver::initializeSolverState </td>
          <td>(</td>
          <td class="paramtype">const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchHierarchy.html">hier::PatchHierarchy</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>hierarchy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>ln</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Initialize to a given hierarchy. </p>
<p>Initializer Poisson solver for a patch level in a hierarchy.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hierarchy</em>&nbsp;</td><td>Hierarchy </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ln</em>&nbsp;</td><td>Level number</td></tr>
  </table>
  </dd>
</dl>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>hierarchy </dd>
<dd>
d_dim == hierarchy-&gt;getDim() </dd></dl>

</div>
</div>
<a class="anchor" id="a657c7d64da8864c13d29aa195772c385"></a><!-- doxytag: member="SAMRAI::solv::CellPoissonHypreSolver::deallocateSolverState" ref="a657c7d64da8864c13d29aa195772c385" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::solv::CellPoissonHypreSolver::deallocateSolverState </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reset to an uninitialized state. </p>

</div>
</div>
<a class="anchor" id="abb4f038b8bf890ab367d4496cc8d58b9"></a><!-- doxytag: member="SAMRAI::solv::CellPoissonHypreSolver::setMatrixCoefficients" ref="abb4f038b8bf890ab367d4496cc8d58b9" args="(const PoissonSpecifications &amp;spec)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::solv::CellPoissonHypreSolver::setMatrixCoefficients </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1solv_1_1PoissonSpecifications.html">PoissonSpecifications</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>spec</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set the matrix coefficients. </p>
<p>For information describing the Poisson equation parameters, see the light-weight <a class="el" href="classSAMRAI_1_1solv_1_1PoissonSpecifications.html" title="Light class holding specifications for cell-centered implementation of the scalar...">PoissonSpecifications</a> class where you set the values of C and D.</p>
<p>This method must be called before <a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonHypreSolver.html#a593a3c91dbc75cd49403dc21da522905" title="Solve the linear system Au=f.">solveSystem()</a>.</p>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>d_physical_bc_coef_strategy != 0 </dd></dl>

</div>
</div>
<a class="anchor" id="ade811981fb611b422f43bcfe60fc75f0"></a><!-- doxytag: member="SAMRAI::solv::CellPoissonHypreSolver::setSolnIdDepth" ref="ade811981fb611b422f43bcfe60fc75f0" args="(const int depth)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::solv::CellPoissonHypreSolver::setSolnIdDepth </td>
          <td>(</td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>depth</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set default depth of the solution data involved in the solve. </p>
<p>If the solution data has multiple depths, the solver uses just one depth at a time. The default depth is the first depth. Use this function to change it. This is not used to set the depth of the data (which is not controled by this class) but the depth used in the solve.</p>
<p>Changing the depth after setting up the matrix is permissible, as the solution data does not affect the matrix. </p>

</div>
</div>
<a class="anchor" id="af1df26d5e093f9b360bb02a23831551b"></a><!-- doxytag: member="SAMRAI::solv::CellPoissonHypreSolver::setRhsIdDepth" ref="af1df26d5e093f9b360bb02a23831551b" args="(const int depth)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::solv::CellPoissonHypreSolver::setRhsIdDepth </td>
          <td>(</td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>depth</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set default depth of the rhs data involved in the solve. </p>
<p>If the rhs data has multiple depths, the solver uses just one depth at a time. The default depth is the first depth. Use this function to change it. This is not used to set the depth of the data (which is not controled by this class) but the depth used in the solve.</p>
<p>Changing the depth after setting up the matrix is permissible, as the rhs data does not affect the matrix. </p>

</div>
</div>
<a class="anchor" id="af673ce6767563395fa428b0f992e1759"></a><!-- doxytag: member="SAMRAI::solv::CellPoissonHypreSolver::setStoppingCriteria" ref="af673ce6767563395fa428b0f992e1759" args="(const int max_iterations=10, const double relative_residual_tol=1.0e&#45;6)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::solv::CellPoissonHypreSolver::setStoppingCriteria </td>
          <td>(</td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>max_iterations</em> = <code>10</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>relative_residual_tol</em> = <code>1.0e-6</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set the stopping criteria (max iterations and residual tolerance) for the linear solver. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>max_iterations</em>&nbsp;</td><td>gives the maximum number of iterations </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>relative_residual_tol</em>&nbsp;</td><td>the maximum error tolerance</td></tr>
  </table>
  </dd>
</dl>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>max_iterations &gt;= 0 </dd>
<dd>
relative_residual_tol &gt;= 0.0 </dd></dl>

<p>References <a class="el" href="Utilities_8h_source.html#l00110">TBOX_ASSERT</a>.</p>

</div>
</div>
<a class="anchor" id="a593a3c91dbc75cd49403dc21da522905"></a><!-- doxytag: member="SAMRAI::solv::CellPoissonHypreSolver::solveSystem" ref="a593a3c91dbc75cd49403dc21da522905" args="(const int u, const int f, bool homogeneous_bc=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int SAMRAI::solv::CellPoissonHypreSolver::solveSystem </td>
          <td>(</td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>homogeneous_bc</em> = <code>false</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Solve the linear system Au=f. </p>
<p>The solution u and the right hand side f are specified via patch indices on the patch hierarchy.</p>
<p>Member functions <a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonHypreSolver.html#ac363febdbbf7fb003fb99ed39d51d19f" title="Return the number of iterations taken by the solver to converge.">getNumberOfIterations()</a> return the iterations from the solver. Note that the matrix coefficients and boundary condition object must have been set up before this function is called. As long as the matrix coefficients do not change, this routine may be called repeatedly to solve any number of linear systems (with the right-hand side varying). If the boundary conditions or matrix coefficients are changed then function <a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonHypreSolver.html#abb4f038b8bf890ab367d4496cc8d58b9" title="Set the matrix coefficients.">setMatrixCoefficients()</a> must be called again.</p>
<p>When computing the matrix coefficients in <a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonHypreSolver.html#abb4f038b8bf890ab367d4496cc8d58b9" title="Set the matrix coefficients.">setMatrixCoefficients()</a>, the inhomogeneous portion of the boundary condition (constant terms, independent of u and thus having no effect on the matrix) are saved and added to the source term, f, before performing the matrix solve. In some situations, it may be useful to not add the inhomogeneous portion to f. The flag argument <code>homoegneous_bc</code> is used for this. (This is a sort of optimization, to avoid having to re-call <a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonHypreSolver.html#abb4f038b8bf890ab367d4496cc8d58b9" title="Set the matrix coefficients.">setMatrixCoefficients()</a> to change the inhomogeneous portion.)</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>u</em>&nbsp;</td><td>Descriptor of cell-centered unknown variable. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>f</em>&nbsp;</td><td>Descriptor of cell-centered source variable. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>homogeneous_bc</em>&nbsp;</td><td>Whether homogeneous boundary conditions are assumed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>whether solver converged to specified level</dd></dl>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>d_physical_bc_coef_strategy != 0 </dd>
<dd>
u &gt;= 0 </dd>
<dd>
f &gt;= 0 </dd>
<dd>
u &lt; d_hierarchy-&gt;getPatchLevel(d_ln)-&gt;getPatchDescriptor()-&gt;getMaxNumberRegisteredComponents() </dd>
<dd>
v &lt; d_hierarchy-&gt;getPatchLevel(d_ln)-&gt;getPatchDescriptor()-&gt;getMaxNumberRegisteredComponents() </dd></dl>

</div>
</div>
<a class="anchor" id="ac363febdbbf7fb003fb99ed39d51d19f"></a><!-- doxytag: member="SAMRAI::solv::CellPoissonHypreSolver::getNumberOfIterations" ref="ac363febdbbf7fb003fb99ed39d51d19f" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int SAMRAI::solv::CellPoissonHypreSolver::getNumberOfIterations </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return the number of iterations taken by the solver to converge. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>number of iterations taken by the solver to converge </dd></dl>

</div>
</div>
<a class="anchor" id="aab7fb7db32e9d27dd2336aaf73c7bfa5"></a><!-- doxytag: member="SAMRAI::solv::CellPoissonHypreSolver::getRelativeResidualNorm" ref="aab7fb7db32e9d27dd2336aaf73c7bfa5" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double SAMRAI::solv::CellPoissonHypreSolver::getRelativeResidualNorm </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return the final residual norm returned by the Hypre solve. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>final residual norm returned by the Hypre solve. </dd></dl>

</div>
</div>
<a class="anchor" id="af289f4c71199b1d98f2f40b2eecbf6b4"></a><!-- doxytag: member="SAMRAI::solv::CellPoissonHypreSolver::setBoundaries" ref="af289f4c71199b1d98f2f40b2eecbf6b4" args="(const std::string &amp;boundary_type, const int fluxes=&#45;1, const int flags=&#45;1, int *bdry_types=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::solv::CellPoissonHypreSolver::setBoundaries </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>boundary_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>fluxes</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>flags</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>bdry_types</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Specify boundary condition directly, without using a <a class="el" href="classSAMRAI_1_1solv_1_1RobinBcCoefStrategy.html" title="Interface for specifying Robin boundary conditions.">RobinBcCoefStrategy</a> object. </p>
<p>Use <em>either</em> <a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonHypreSolver.html#af289f4c71199b1d98f2f40b2eecbf6b4" title="Specify boundary condition directly, without using a RobinBcCoefStrategy object.">setBoundaries()</a> <em>or</em> <a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonHypreSolver.html#a132a9af79508ca10238e75eecb19ad2e" title="Specify boundary condition through the use of a Robin boundary condition object.">setPhysicalBcCoefObject()</a>, but not both.</p>
<p>A SimpleCelBcCoef object is used to interpret and implement the specified boundary conditions. See <a class="el" href="classSAMRAI_1_1solv_1_1SimpleCellRobinBcCoefs.html#a44ecbac571459d7a1c8f2f2252c2bfd1" title="Specify the boundary conditions that are to be used at the physical domain boundary...">SimpleCellRobinBcCoefs::setBoundaries()</a> for an explanation of the arguments. </p>

<p>References <a class="el" href="SimpleCellRobinBcCoefs_8C_source.html#l00089">SAMRAI::solv::SimpleCellRobinBcCoefs::setBoundaries()</a>.</p>

</div>
</div>
<a class="anchor" id="a132a9af79508ca10238e75eecb19ad2e"></a><!-- doxytag: member="SAMRAI::solv::CellPoissonHypreSolver::setPhysicalBcCoefObject" ref="a132a9af79508ca10238e75eecb19ad2e" args="(const RobinBcCoefStrategy *physical_bc_coef_strategy, const boost::shared_ptr&lt; hier::Variable &gt; &amp;variable=boost::shared_ptr&lt; hier::Variable &gt;())" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::solv::CellPoissonHypreSolver::setPhysicalBcCoefObject </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1solv_1_1RobinBcCoefStrategy.html">RobinBcCoefStrategy</a> *&nbsp;</td>
          <td class="paramname"> <em>physical_bc_coef_strategy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1hier_1_1Variable.html">hier::Variable</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>variable</em> = <code>boost::shared_ptr&lt;<a class="el" href="classSAMRAI_1_1hier_1_1Variable.html">hier::Variable</a>&gt;()</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Specify boundary condition through the use of a Robin boundary condition object. </p>
<p>Use <em>either</em> <a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonHypreSolver.html#af289f4c71199b1d98f2f40b2eecbf6b4" title="Specify boundary condition directly, without using a RobinBcCoefStrategy object.">setBoundaries()</a> <em>or</em> <a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonHypreSolver.html#a132a9af79508ca10238e75eecb19ad2e" title="Specify boundary condition through the use of a Robin boundary condition object.">setPhysicalBcCoefObject()</a>, but not both.</p>
<p>The Robin boundary condition object is used when setting the matrix coefficient and when solving the system. If your boundary conditions are fixed values at ghost cell centers, use the <a class="el" href="classSAMRAI_1_1solv_1_1GhostCellRobinBcCoefs.html" title="A prefabricated Robin boundary condition coefficients for the case where cell-centered...">GhostCellRobinBcCoefs</a> implementation of the <a class="el" href="classSAMRAI_1_1solv_1_1RobinBcCoefStrategy.html" title="Interface for specifying Robin boundary conditions.">RobinBcCoefStrategy</a> strategy.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>physical_bc_coef_strategy</em>&nbsp;</td><td>Pointer to a concrete implementation of the Robin bc strategy. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>variable</em>&nbsp;</td><td><a class="el" href="classSAMRAI_1_1hier_1_1Variable.html">hier::Variable</a> pointer to be passed to <a class="el" href="classSAMRAI_1_1solv_1_1RobinBcCoefStrategy.html#adf2a5a6e621f5f3fa0ac4817d6504e58" title="User-supplied function to fill arrays of Robin boundary condition coefficients at...">RobinBcCoefStrategy::setBcCoefs()</a>, but otherwise unused by this class. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aeebc33c4fdc3ef65022a03d5a9073da4"></a><!-- doxytag: member="SAMRAI::solv::CellPoissonHypreSolver::setPrintSolverInfo" ref="aeebc33c4fdc3ef65022a03d5a9073da4" args="(const bool print)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::solv::CellPoissonHypreSolver::setPrintSolverInfo </td>
          <td>(</td>
          <td class="paramtype">const bool&nbsp;</td>
          <td class="paramname"> <em>print</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set the flag for printing solver information. </p>
<p>This optional function is used primarily for debugging.</p>
<p>If set true, it will print the HYPRE matrix information to the following files:</p>
<ul>
<li>mat_bA.out - before setting matrix coefficients in matrix assemble</li>
<li>mat_aA.out - after setting matrix coefficients in matrix assemble</li>
<li>sol0.out - u before solve (i.e. for system Au = b)</li>
<li>sol.out - u after solve</li>
<li>mat0.out - A before solve</li>
<li>mat.out - A after solve</li>
<li>rhs.out - b before and after solve</li>
</ul>
<p>If this method is not called, or the flag is set false, no printing will occur. </p>

</div>
</div>
<a class="anchor" id="afb585a1004156e4f16a7f86ebe006804"></a><!-- doxytag: member="SAMRAI::solv::CellPoissonHypreSolver::getObjectName" ref="afb585a1004156e4f16a7f86ebe006804" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::string&amp; SAMRAI::solv::CellPoissonHypreSolver::getObjectName </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the name of this object. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>The name of this object. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>source/SAMRAI/solv/<a class="el" href="CellPoissonHypreSolver_8h.html">CellPoissonHypreSolver.h</a></li>
</ul>
</div>
<hr size="1"/><address style="text-align: right;"><small>Generated on 8 Oct 2014 for SAMRAI by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.1 </small></address>
</body>
</html>
