<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>SAMRAI: SAMRAI::appu::CartesianBoundaryUtilities3 Struct Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.7 -->
<div class="tabs">
  <ul>
    <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="namespaces.html"><span>Namespaces</span></a></li>
    <li id="current"><a href="annotated.html"><span>Classes</span></a></li>
    <li><a href="files.html"><span>Files</span></a></li>
    <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
  </ul></div>
<div class="tabs">
  <ul>
    <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
    <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
    <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
  </ul></div>
<div class="nav">
<a class="el" href="namespaceSAMRAI.html">SAMRAI</a>::<a class="el" href="namespaceSAMRAI_1_1appu.html">appu</a>::<a class="el" href="structSAMRAI_1_1appu_1_1CartesianBoundaryUtilities3.html">CartesianBoundaryUtilities3</a></div>
<h1>SAMRAI::appu::CartesianBoundaryUtilities3 Struct Reference</h1><!-- doxytag: class="SAMRAI::appu::CartesianBoundaryUtilities3" -->Class <a class="el" href="structSAMRAI_1_1appu_1_1CartesianBoundaryUtilities3.html">CartesianBoundaryUtilities3</a> is a utility class that simplifies the implementation of simple physical boundary data in 3 spatial dimensions. It contains routines for reading boundary data information from input files, applying those boundary conditions, and error checking boundary data. These routines apply to the case of cell-centered double data only. One may use all of these capabilities, or use the input reading, boundary setting, and error checking routines independently.  
<a href="#_details">More...</a>
<p>
<code>#include &lt;source/SAMRAI/appu/CartesianBoundaryUtilities3.h&gt;</code>
<p>
<a href="structSAMRAI_1_1appu_1_1CartesianBoundaryUtilities3-members.html">List of all members.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Static Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSAMRAI_1_1appu_1_1CartesianBoundaryUtilities3.html#8fe85dc6938824b69c4c69f8f43f4f50">getFromInput</a> (<a class="el" href="classSAMRAI_1_1appu_1_1BoundaryUtilityStrategy.html">BoundaryUtilityStrategy</a> *bdry_strategy, const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Database.html">tbox::Database</a> &gt; &amp;input_db, std::vector&lt; int &gt; &amp;face_conds, std::vector&lt; int &gt; &amp;edge_conds, std::vector&lt; int &gt; &amp;node_conds, const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a> &amp;periodic)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSAMRAI_1_1appu_1_1CartesianBoundaryUtilities3.html#bc62365e181901f23d467b55c15a7b20">fillFaceBoundaryData</a> (const std::string &amp;varname, const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1pdat_1_1CellData.html">pdat::CellData</a>&lt; double &gt; &gt; &amp;vardata, const <a class="el" href="classSAMRAI_1_1hier_1_1Patch.html">hier::Patch</a> &amp;patch, const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a> &amp;ghost_width_to_fill, const std::vector&lt; int &gt; &amp;bdry_face_conds, const std::vector&lt; double &gt; &amp;bdry_face_values)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSAMRAI_1_1appu_1_1CartesianBoundaryUtilities3.html#c3b8e078632b4ee4a68e32df4cc69b5c">fillEdgeBoundaryData</a> (const std::string &amp;varname, const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1pdat_1_1CellData.html">pdat::CellData</a>&lt; double &gt; &gt; &amp;vardata, const <a class="el" href="classSAMRAI_1_1hier_1_1Patch.html">hier::Patch</a> &amp;patch, const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a> &amp;ghost_width_to_fill, const std::vector&lt; int &gt; &amp;bdry_edge_conds, const std::vector&lt; double &gt; &amp;bdry_face_values)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSAMRAI_1_1appu_1_1CartesianBoundaryUtilities3.html#a45e4fd1692a301caa211d8cecceb992">fillNodeBoundaryData</a> (const std::string &amp;varname, const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1pdat_1_1CellData.html">pdat::CellData</a>&lt; double &gt; &gt; &amp;vardata, const <a class="el" href="classSAMRAI_1_1hier_1_1Patch.html">hier::Patch</a> &amp;patch, const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a> &amp;ghost_width_to_fill, const std::vector&lt; int &gt; &amp;bdry_node_conds, const std::vector&lt; double &gt; &amp;bdry_face_values)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSAMRAI_1_1appu_1_1CartesianBoundaryUtilities3.html#b98159d41eb1fe0152cd431ea4bb8d3d">getFaceLocationForEdgeBdry</a> (int edge_loc, int edge_btype)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSAMRAI_1_1appu_1_1CartesianBoundaryUtilities3.html#9c01b91b459f2f01a2c64ed7ce6aba82">getFaceLocationForNodeBdry</a> (int node_loc, int node_btype)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSAMRAI_1_1appu_1_1CartesianBoundaryUtilities3.html#37bc7236cd30b83d987fd30cb121f3fd">checkBdryData</a> (const std::string &amp;varname, const <a class="el" href="classSAMRAI_1_1hier_1_1Patch.html">hier::Patch</a> &amp;patch, int data_id, int depth, const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a> &amp;gcw_to_check, const <a class="el" href="classSAMRAI_1_1hier_1_1BoundaryBox.html">hier::BoundaryBox</a> &amp;bbox, int bcase, const double &amp;bstate)</td></tr>

</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
Class <a class="el" href="structSAMRAI_1_1appu_1_1CartesianBoundaryUtilities3.html">CartesianBoundaryUtilities3</a> is a utility class that simplifies the implementation of simple physical boundary data in 3 spatial dimensions. It contains routines for reading boundary data information from input files, applying those boundary conditions, and error checking boundary data. These routines apply to the case of cell-centered double data only. One may use all of these capabilities, or use the input reading, boundary setting, and error checking routines independently. 
<p>
<b> Input Parameters </b><p>
To use the boundary condition input reading capabilities, the format of the input file section containing the boundary information must be as described next. Boundary face, node, and edge entries are only required for those that are not filled automatically when periodic conditions apply.<p>
The boundary condition for face "*" is provided in a section as follows:<p>
<div class="fragment"><pre class="fragment">    boundary_face_* {
       boundary_condition  = ...  <span class="comment">// boundary condition string identifier</span>
    }
</pre></div><p>
Allowable face identifiers (i.e., values for "*") are: <br>
 xlo, xhi, ylo, yhi, zlo, zhi <br>
 Supported face boundary_condition string values are: <br>
 "FLOW", "REFLECT", "DIRICHLET", "NEUMANN"<p>
The boundary condition for edge "*" is provided in a section as follows:<p>
<div class="fragment"><pre class="fragment">    boundary_edge_* {
       boundary_condition  = ...  <span class="comment">// boundary condition string identifier</span>
    }
</pre></div><p>
Allowable edge identifiers (i.e., values for "*") are: <br>
 ylo_zlo, yhi_zlo, ylo_zhi, yhi_zhi, xlo_zlo, xlo_zhi, xhi_zlo, xhi_zhi, xlo_ylo, xhi_ylo, xlo_yhi, xhi_yhi <br>
 Supported edge boundary_condition string values are: <br>
 "XFLOW", "YFLOW", "ZFLOW", "XREFLECT", "YREFLECT", "ZREFLECT", "XDIRICHLET", "YDIRICHLET", "ZDIRICHLET" "XNEUMANN", "YNEUMANN", "ZNEUMANN"<p>
Note that edge conditions must be consistent with adjacent face conditions.<p>
The boundary condition for node "*" is provided in a section as follows:<p>
<div class="fragment"><pre class="fragment">    boundary_node_* {
       boundary_condition  = ...  <span class="comment">// boundary condition string identifier</span>
    }
</pre></div><p>
Allowable node identifiers (i.e., values for "*") are: <br>
 xlo_ylo_zlo, xhi_ylo_zlo, xlo_yhi_zlo, xhi_yhi_zlo, xlo_ylo_zhi, xhi_ylo_zhi, xlo_yhi_zhi, xhi_yhi_zhi <br>
 Supported node boundary_condition values are: <br>
 "XFLOW", "YFLOW", "ZFLOW", "XREFLECT", "YREFLECT", "ZREFLECT", "XDIRICHLET", "YDIRICHLET", "ZDIRICHLET" "XNEUMANN", "YNEUMANN", "ZNEUMANN"<p>
Note that node conditions must be consistent with adjacent face conditions.<p>
See the include file <a class="el" href="CartesianBoundaryDefines_8h.html">CartesianBoundaryDefines.h</a> for integer constant definitions that apply for the various boundary types, locations, and boundary conditions. If you choose to use the input reading capabilities only and write your own boundary condition routines in FORTRAN, you should note that the integer constants for the various boundary condition types and locations are automatically "stuffed" into FORTRAN common blocks. This avoids potential problems with inconsistencies between C++ and FORTRAN usage. Please see the FORTRAN include file cartbdryparams3d.i for details.<p>
<dl compact><dt><b>See also:</b></dt><dd>appu::BoundaryUtilityStrategy3 </dd></dl>

<p>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="8fe85dc6938824b69c4c69f8f43f4f50"></a><!-- doxytag: member="SAMRAI::appu::CartesianBoundaryUtilities3::getFromInput" ref="8fe85dc6938824b69c4c69f8f43f4f50" args="(BoundaryUtilityStrategy *bdry_strategy, const boost::shared_ptr&lt; tbox::Database &gt; &amp;input_db, std::vector&lt; int &gt; &amp;face_conds, std::vector&lt; int &gt; &amp;edge_conds, std::vector&lt; int &gt; &amp;node_conds, const hier::IntVector &amp;periodic)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void SAMRAI::appu::CartesianBoundaryUtilities3::getFromInput           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1appu_1_1BoundaryUtilityStrategy.html">BoundaryUtilityStrategy</a> *&nbsp;</td>
          <td class="paramname"> <em>bdry_strategy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Database.html">tbox::Database</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>input_db</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>face_conds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>edge_conds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>node_conds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>periodic</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Function to read 3d boundary data from input database. The integer boundary condition types are placed in the integer arrays supplied by the caller (typically, the concrete <a class="el" href="classSAMRAI_1_1appu_1_1BoundaryUtilityStrategy.html">BoundaryUtilityStrategy</a> object provided). When DIRICHLET or NEUMANN conditions are specified, control is passed to the <a class="el" href="classSAMRAI_1_1appu_1_1BoundaryUtilityStrategy.html">BoundaryUtilityStrategy</a> to read the boundary state data specific to the problem.<p>
Errors will be reported and the program will abort whenever necessary boundary condition information is missing in the input database, or when the data read in is either unknown or inconsistent. The periodic domain information is used to determine which boundary face, edge, or node entries are not required from input. Error checking requires that node and edge boundary conditions are consistent with those specified for the faces.<p>
When assertion checking is active, assertions will result when any of the pointer arguments is null, or an array is passed in with the the wrong size.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>bdry_strategy</em>&nbsp;</td><td>user-defined object that reads DIRICHLET or NEUMANN conditions </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>input_db</em>&nbsp;</td><td>input database containing all boundary data </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>face_conds</em>&nbsp;</td><td>array into which integer face boundary condition types are read </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>edge_conds</em>&nbsp;</td><td>array into which integer edge boundary condition types are read </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>node_conds</em>&nbsp;</td><td>array into which integer node boundary condition types are read </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>periodic</em>&nbsp;</td><td>integer vector specifying which coordinate directions are periodic (e.g., value returned from GridGeometry2::getPeriodicShift())</td></tr>
  </table>
</dl>
<dl compact><dt><b>Precondition:</b></dt><dd>input_db <p>
periodic.getDim() == tbox::Dimension(3) <p>
bdry_strategy != 0 <p>
face_conds.size() == NUM_3D_FACES <p>
edge_conds.size() == NUM_3D_EDGES <p>
node_conds.size() == NUM_3D_NODES </dd></dl>

</div>
</div><p>
<a class="anchor" name="bc62365e181901f23d467b55c15a7b20"></a><!-- doxytag: member="SAMRAI::appu::CartesianBoundaryUtilities3::fillFaceBoundaryData" ref="bc62365e181901f23d467b55c15a7b20" args="(const std::string &amp;varname, const boost::shared_ptr&lt; pdat::CellData&lt; double &gt; &gt; &amp;vardata, const hier::Patch &amp;patch, const hier::IntVector &amp;ghost_width_to_fill, const std::vector&lt; int &gt; &amp;bdry_face_conds, const std::vector&lt; double &gt; &amp;bdry_face_values)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void SAMRAI::appu::CartesianBoundaryUtilities3::fillFaceBoundaryData           </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>varname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1pdat_1_1CellData.html">pdat::CellData</a>&lt; double &gt; &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>vardata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1Patch.html">hier::Patch</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>patch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>ghost_width_to_fill</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>bdry_face_conds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>bdry_face_values</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Function to fill 3d face boundary values for a patch.<p>
When assertion checking is active, assertions will result when any of the pointer arguments is null, or an array is passed in with the the wrong size.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>varname</em>&nbsp;</td><td>String name of variable (for error reporting). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>vardata</em>&nbsp;</td><td>Cell-centered patch data object to fill. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>patch</em>&nbsp;</td><td><a class="el" href="classSAMRAI_1_1hier_1_1Patch.html">hier::Patch</a> on which data object lives. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ghost_width_to_fill</em>&nbsp;</td><td>Width of ghost region to fill. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>bdry_face_conds</em>&nbsp;</td><td><a class="el" href="classSAMRAI_1_1tbox_1_1Array.html">tbox::Array</a> of boundary condition types for patch faces. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>bdry_face_values</em>&nbsp;</td><td><a class="el" href="classSAMRAI_1_1tbox_1_1Array.html">tbox::Array</a> of boundary values for patch faces.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Precondition:</b></dt><dd>!varname.empty() <p>
vardata <p>
bdry_face_conds.size() == NUM_3D_FACES <p>
bdry_face_values.size() == NUM_3D_FACES * (vardata-&gt;getDepth()) <p>
ghost_fill_width.getDim() == tbox::Dimension(3) <p>
(vardata-&gt;getDim() == patch.getDim()) &amp;&amp; (vardata-&gt;getDim() == ghost_fill_width.getDim()) </dd></dl>

</div>
</div><p>
<a class="anchor" name="c3b8e078632b4ee4a68e32df4cc69b5c"></a><!-- doxytag: member="SAMRAI::appu::CartesianBoundaryUtilities3::fillEdgeBoundaryData" ref="c3b8e078632b4ee4a68e32df4cc69b5c" args="(const std::string &amp;varname, const boost::shared_ptr&lt; pdat::CellData&lt; double &gt; &gt; &amp;vardata, const hier::Patch &amp;patch, const hier::IntVector &amp;ghost_width_to_fill, const std::vector&lt; int &gt; &amp;bdry_edge_conds, const std::vector&lt; double &gt; &amp;bdry_face_values)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void SAMRAI::appu::CartesianBoundaryUtilities3::fillEdgeBoundaryData           </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>varname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1pdat_1_1CellData.html">pdat::CellData</a>&lt; double &gt; &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>vardata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1Patch.html">hier::Patch</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>patch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>ghost_width_to_fill</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>bdry_edge_conds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>bdry_face_values</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Function to fill 3d edge boundary values for a patch.<p>
When assertion checking is active, assertions will result when any of the pointer arguments is null, or an array is passed in with the the wrong size.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>varname</em>&nbsp;</td><td>String name of variable (for error reporting). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>vardata</em>&nbsp;</td><td>Cell-centered patch data object to fill. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>patch</em>&nbsp;</td><td><a class="el" href="classSAMRAI_1_1hier_1_1Patch.html">hier::Patch</a> on which data object lives. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ghost_width_to_fill</em>&nbsp;</td><td>Width of ghost region to fill. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>bdry_edge_conds</em>&nbsp;</td><td><a class="el" href="classSAMRAI_1_1tbox_1_1Array.html">tbox::Array</a> of boundary condition types for patch edges. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>bdry_face_values</em>&nbsp;</td><td><a class="el" href="classSAMRAI_1_1tbox_1_1Array.html">tbox::Array</a> of boundary values for patch faces.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Precondition:</b></dt><dd>!varname.empty() <p>
vardata <p>
bdry_edge_conds.size() == NUM_3D_EDGES <p>
bdry_face_values.size() == NUM_3D_FACES * (vardata-&gt;getDepth()) <p>
ghost_fill_width.getDim() == tbox::Dimension(3) <p>
(vardata-&gt;getDim() == patch.getDim()) &amp;&amp; (vardata-&gt;getDim() == ghost_fill_width.getDim()) </dd></dl>

</div>
</div><p>
<a class="anchor" name="a45e4fd1692a301caa211d8cecceb992"></a><!-- doxytag: member="SAMRAI::appu::CartesianBoundaryUtilities3::fillNodeBoundaryData" ref="a45e4fd1692a301caa211d8cecceb992" args="(const std::string &amp;varname, const boost::shared_ptr&lt; pdat::CellData&lt; double &gt; &gt; &amp;vardata, const hier::Patch &amp;patch, const hier::IntVector &amp;ghost_width_to_fill, const std::vector&lt; int &gt; &amp;bdry_node_conds, const std::vector&lt; double &gt; &amp;bdry_face_values)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void SAMRAI::appu::CartesianBoundaryUtilities3::fillNodeBoundaryData           </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>varname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1pdat_1_1CellData.html">pdat::CellData</a>&lt; double &gt; &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>vardata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1Patch.html">hier::Patch</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>patch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>ghost_width_to_fill</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>bdry_node_conds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>bdry_face_values</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Function to fill 3d node boundary values for a patch.<p>
When assertion checking is active, assertions will result when any of the pointer arguments is null, or an array is passed in with the the wrong size.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>varname</em>&nbsp;</td><td>String name of variable (for error reporting). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>vardata</em>&nbsp;</td><td>Cell-centered patch data object to fill. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>patch</em>&nbsp;</td><td><a class="el" href="classSAMRAI_1_1hier_1_1Patch.html">hier::Patch</a> on which data object lives. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ghost_width_to_fill</em>&nbsp;</td><td>Width of ghost region to fill. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>bdry_node_conds</em>&nbsp;</td><td><a class="el" href="classSAMRAI_1_1tbox_1_1Array.html">tbox::Array</a> of boundary condition types for patch nodes. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>bdry_face_values</em>&nbsp;</td><td><a class="el" href="classSAMRAI_1_1tbox_1_1Array.html">tbox::Array</a> of boundary values for patch faces.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Precondition:</b></dt><dd>!varname.empty() <p>
vardata <p>
bdry_node_conds.size() == NUM_3D_NODES <p>
bdry_face_values.size() == NUM_3D_FACES * (vardata-&gt;getDepth()) <p>
ghost_fill_width.getDim() == tbox::Dimension(3) <p>
(vardata-&gt;getDim() == patch.getDim()) &amp;&amp; (vardata-&gt;getDim() == ghost_fill_width.getDim()) </dd></dl>

</div>
</div><p>
<a class="anchor" name="b98159d41eb1fe0152cd431ea4bb8d3d"></a><!-- doxytag: member="SAMRAI::appu::CartesianBoundaryUtilities3::getFaceLocationForEdgeBdry" ref="b98159d41eb1fe0152cd431ea4bb8d3d" args="(int edge_loc, int edge_btype)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int SAMRAI::appu::CartesianBoundaryUtilities3::getFaceLocationForEdgeBdry           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>edge_loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>edge_btype</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Function that returns the integer face boundary location corresponding to the given edge location and edge boundary condition.<p>
If the edge boundary condition type or edge location are unknown, or the boundary condition type is inconsistant with the edge location an error results.<p>
<dl compact><dt><b>Returns:</b></dt><dd>Integer face location for edge location and boundary condition type.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>edge_loc</em>&nbsp;</td><td>Integer location for edge. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>edge_btype</em>&nbsp;</td><td>Integer boundary condition type for edge.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Precondition:</b></dt><dd>(edge_btype == <a class="el" href="namespaceBdryCond.html#3665127406930080e9e4761f69dadaadcf88d17396a28569091ece804b21c567">BdryCond::XFLOW</a>) || (edge_btype == <a class="el" href="namespaceBdryCond.html#3665127406930080e9e4761f69dadaad150739d2a78130a2f916b16de9a4f608">BdryCond::XREFLECT</a>) || (edge_btype == <a class="el" href="namespaceBdryCond.html#3665127406930080e9e4761f69dadaad3c9e860dd167dcad173a79acb7dc2262">BdryCond::XDIRICHLET</a>) || (edge_btype == <a class="el" href="namespaceBdryCond.html#3665127406930080e9e4761f69dadaad792dfc264a6250ecd84af96348355b9f">BdryCond::XNEUMANN</a>) || (edge_btype == <a class="el" href="namespaceBdryCond.html#3665127406930080e9e4761f69dadaadd1a3e6984bb1f841ee584d9df40cbf3c">BdryCond::YFLOW</a>) || (edge_btype == <a class="el" href="namespaceBdryCond.html#3665127406930080e9e4761f69dadaad4ccdecd70cf8dd1eb41ff052c58acc12">BdryCond::YREFLECT</a>) || (edge_btype == <a class="el" href="namespaceBdryCond.html#3665127406930080e9e4761f69dadaaddc65a39ac25197e61295cd71afb73e28">BdryCond::YDIRICHLET</a>) || (edge_btype == <a class="el" href="namespaceBdryCond.html#3665127406930080e9e4761f69dadaad74353458cfc99547da62f64c8a49aff7">BdryCond::YNEUMANN</a>) || (edge_btype == <a class="el" href="namespaceBdryCond.html#3665127406930080e9e4761f69dadaadae2daa9e6bafe5e1cc7dcc81f80680a8">BdryCond::ZFLOW</a>) || (edge_btype == <a class="el" href="namespaceBdryCond.html#3665127406930080e9e4761f69dadaad14321946cc48a1fc327391914b81b638">BdryCond::ZREFLECT</a>) || (edge_btype == <a class="el" href="namespaceBdryCond.html#3665127406930080e9e4761f69dadaadb46918087847e9a62a2ef539ed9b0f57">BdryCond::ZDIRICHLET</a>) || (edge_btype == <a class="el" href="namespaceBdryCond.html#3665127406930080e9e4761f69dadaad3313306e80b3b14d6a333a33bd71e145">BdryCond::ZNEUMANN</a>) </dd></dl>

</div>
</div><p>
<a class="anchor" name="9c01b91b459f2f01a2c64ed7ce6aba82"></a><!-- doxytag: member="SAMRAI::appu::CartesianBoundaryUtilities3::getFaceLocationForNodeBdry" ref="9c01b91b459f2f01a2c64ed7ce6aba82" args="(int node_loc, int node_btype)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int SAMRAI::appu::CartesianBoundaryUtilities3::getFaceLocationForNodeBdry           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>node_loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>node_btype</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Function that returns the integer face boundary location corresponding to the given node location and node boundary condition.<p>
If the node boundary condition type or node location are unknown, or the boundary condition type is inconsistant with the node location an error results.<p>
<dl compact><dt><b>Returns:</b></dt><dd>Integer face location for node location and boundary condition type.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>node_loc</em>&nbsp;</td><td>Integer location for node. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>node_btype</em>&nbsp;</td><td>Integer boundary condition type for node.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Precondition:</b></dt><dd>(edge_btype == <a class="el" href="namespaceBdryCond.html#3665127406930080e9e4761f69dadaadcf88d17396a28569091ece804b21c567">BdryCond::XFLOW</a>) || (edge_btype == <a class="el" href="namespaceBdryCond.html#3665127406930080e9e4761f69dadaad150739d2a78130a2f916b16de9a4f608">BdryCond::XREFLECT</a>) || (edge_btype == <a class="el" href="namespaceBdryCond.html#3665127406930080e9e4761f69dadaad3c9e860dd167dcad173a79acb7dc2262">BdryCond::XDIRICHLET</a>) || (edge_btype == <a class="el" href="namespaceBdryCond.html#3665127406930080e9e4761f69dadaad792dfc264a6250ecd84af96348355b9f">BdryCond::XNEUMANN</a>) || (edge_btype == <a class="el" href="namespaceBdryCond.html#3665127406930080e9e4761f69dadaadd1a3e6984bb1f841ee584d9df40cbf3c">BdryCond::YFLOW</a>) || (edge_btype == <a class="el" href="namespaceBdryCond.html#3665127406930080e9e4761f69dadaad4ccdecd70cf8dd1eb41ff052c58acc12">BdryCond::YREFLECT</a>) || (edge_btype == <a class="el" href="namespaceBdryCond.html#3665127406930080e9e4761f69dadaaddc65a39ac25197e61295cd71afb73e28">BdryCond::YDIRICHLET</a>) || (edge_btype == <a class="el" href="namespaceBdryCond.html#3665127406930080e9e4761f69dadaad74353458cfc99547da62f64c8a49aff7">BdryCond::YNEUMANN</a>) || (edge_btype == <a class="el" href="namespaceBdryCond.html#3665127406930080e9e4761f69dadaadae2daa9e6bafe5e1cc7dcc81f80680a8">BdryCond::ZFLOW</a>) || (edge_btype == <a class="el" href="namespaceBdryCond.html#3665127406930080e9e4761f69dadaad14321946cc48a1fc327391914b81b638">BdryCond::ZREFLECT</a>) || (edge_btype == <a class="el" href="namespaceBdryCond.html#3665127406930080e9e4761f69dadaadb46918087847e9a62a2ef539ed9b0f57">BdryCond::ZDIRICHLET</a>) || (edge_btype == <a class="el" href="namespaceBdryCond.html#3665127406930080e9e4761f69dadaad3313306e80b3b14d6a333a33bd71e145">BdryCond::ZNEUMANN</a>) </dd></dl>

</div>
</div><p>
<a class="anchor" name="37bc7236cd30b83d987fd30cb121f3fd"></a><!-- doxytag: member="SAMRAI::appu::CartesianBoundaryUtilities3::checkBdryData" ref="37bc7236cd30b83d987fd30cb121f3fd" args="(const std::string &amp;varname, const hier::Patch &amp;patch, int data_id, int depth, const hier::IntVector &amp;gcw_to_check, const hier::BoundaryBox &amp;bbox, int bcase, const double &amp;bstate)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int SAMRAI::appu::CartesianBoundaryUtilities3::checkBdryData           </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>varname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1Patch.html">hier::Patch</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>patch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>data_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>depth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>gcw_to_check</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1BoundaryBox.html">hier::BoundaryBox</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>bbox</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>bcase</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double &amp;&nbsp;</td>
          <td class="paramname"> <em>bstate</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Function to check 3d boundary data for a patch data quantity on a patch after it is set. A warning message will be sent to log file for each bad boundary value that is found.<p>
When assertion checking is active, assertions will result when any of the pointer arguments is null, or an array is passed in with the the wrong size.<p>
<dl compact><dt><b>Returns:</b></dt><dd>Integer number of bad boundary values found.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>varname</em>&nbsp;</td><td>String name of variable (for error reporting). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>patch</em>&nbsp;</td><td><a class="el" href="classSAMRAI_1_1hier_1_1Patch.html">hier::Patch</a> on which data object lives. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>data_id</em>&nbsp;</td><td><a class="el" href="classSAMRAI_1_1hier_1_1Patch.html">hier::Patch</a> data index for data on patch. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>depth</em>&nbsp;</td><td>Depth index of patch data to check. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>gcw_to_check</em>&nbsp;</td><td>Width of ghost region to check. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>bbox</em>&nbsp;</td><td>Boundary box to check. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>bcase</em>&nbsp;</td><td>Boundary condition type for given edge or node. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>bstate</em>&nbsp;</td><td>Boundary value that applies in DIRICHLET or NEUMANN case.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Precondition:</b></dt><dd>!varname.empty() <p>
data_id &gt;= 0 <p>
depth &gt;= 0 <p>
gcw_to_check.getDim() == tbox::Dimension(3) <p>
(patch.getDim() == gcw_to_check.getDim() &amp;&amp; (patch.getDim() == bbox.getDim()) <p>
(bbox.getBoundaryType() == <a class="el" href="namespaceBdry.html#ad3d96e8fb5584ece448f695bc5055abeb57b9d5db99985835df377908fcb076">Bdry::FACE3D</a>) || (bbox.getBoundaryType() == <a class="el" href="namespaceBdry.html#ad3d96e8fb5584ece448f695bc5055ab545ab7e250abb928202f2203c20b96fe">Bdry::EDGE3D</a>) || (bbox.getBoundaryType() == <a class="el" href="namespaceBdry.html#ad3d96e8fb5584ece448f695bc5055ab54acdd9dff31c51ee6a89081fc11ab0a">Bdry::NODE3D</a>) <p>
((bbox.getBoundaryType() == <a class="el" href="namespaceBdry.html#ad3d96e8fb5584ece448f695bc5055abeb57b9d5db99985835df377908fcb076">Bdry::FACE3D</a>) &amp;&amp; ((bcase == <a class="el" href="namespaceBdryCond.html#3665127406930080e9e4761f69dadaad6508d34ee94eaac0aeec4dc93b670224">BdryCond::FLOW</a>) || (bcase == <a class="el" href="namespaceBdryCond.html#3665127406930080e9e4761f69dadaad3377087764e427bbf84bcf05490fe5c3">BdryCond::REFLECT</a>) || (bcase == <a class="el" href="namespaceBdryCond.html#3665127406930080e9e4761f69dadaadbcfde2b2403594f3acc9c523b3ccc844">BdryCond::DIRICHLET</a>) || (bcase == <a class="el" href="namespaceBdryCond.html#3665127406930080e9e4761f69dadaad78ba35a6bdfd280ae3127b910e5778ee">BdryCond::NEUMANN</a>))) || (((bbox.getBoundaryType() == <a class="el" href="namespaceBdry.html#ad3d96e8fb5584ece448f695bc5055ab545ab7e250abb928202f2203c20b96fe">Bdry::EDGE3D</a>) || (bbox.getBoundaryType() == <a class="el" href="namespaceBdry.html#ad3d96e8fb5584ece448f695bc5055ab54acdd9dff31c51ee6a89081fc11ab0a">Bdry::NODE3D</a>)) &amp;&amp; ((bcase == <a class="el" href="namespaceBdryCond.html#3665127406930080e9e4761f69dadaadcf88d17396a28569091ece804b21c567">BdryCond::XFLOW</a>) || (bcase == <a class="el" href="namespaceBdryCond.html#3665127406930080e9e4761f69dadaadd1a3e6984bb1f841ee584d9df40cbf3c">BdryCond::YFLOW</a>) || (bcase == <a class="el" href="namespaceBdryCond.html#3665127406930080e9e4761f69dadaadae2daa9e6bafe5e1cc7dcc81f80680a8">BdryCond::ZFLOW</a>) || (bcase == <a class="el" href="namespaceBdryCond.html#3665127406930080e9e4761f69dadaad150739d2a78130a2f916b16de9a4f608">BdryCond::XREFLECT</a>) || (bcase == <a class="el" href="namespaceBdryCond.html#3665127406930080e9e4761f69dadaad4ccdecd70cf8dd1eb41ff052c58acc12">BdryCond::YREFLECT</a>) || (bcase == <a class="el" href="namespaceBdryCond.html#3665127406930080e9e4761f69dadaad150739d2a78130a2f916b16de9a4f608">BdryCond::XREFLECT</a>) || (bcase == <a class="el" href="namespaceBdryCond.html#3665127406930080e9e4761f69dadaad3c9e860dd167dcad173a79acb7dc2262">BdryCond::XDIRICHLET</a>) || (bcase == <a class="el" href="namespaceBdryCond.html#3665127406930080e9e4761f69dadaaddc65a39ac25197e61295cd71afb73e28">BdryCond::YDIRICHLET</a>) || (bcase == <a class="el" href="namespaceBdryCond.html#3665127406930080e9e4761f69dadaadb46918087847e9a62a2ef539ed9b0f57">BdryCond::ZDIRICHLET</a>) || (bcase == <a class="el" href="namespaceBdryCond.html#3665127406930080e9e4761f69dadaad792dfc264a6250ecd84af96348355b9f">BdryCond::XNEUMANN</a>) || (bcase == <a class="el" href="namespaceBdryCond.html#3665127406930080e9e4761f69dadaad74353458cfc99547da62f64c8a49aff7">BdryCond::YNEUMANN</a>) || (bcase == <a class="el" href="namespaceBdryCond.html#3665127406930080e9e4761f69dadaad3313306e80b3b14d6a333a33bd71e145">BdryCond::ZNEUMANN</a>))) </dd></dl>

</div>
</div><p>
<hr>The documentation for this struct was generated from the following file:<ul>
<li>source/SAMRAI/appu/<a class="el" href="CartesianBoundaryUtilities3_8h.html">CartesianBoundaryUtilities3.h</a></ul>
<hr size="1"><address style="align: right;"><small>Generated on 3 Mar 2015 for SAMRAI by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.7 </small></address>
</body>
</html>
