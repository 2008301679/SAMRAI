<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>SAMRAI: SAMRAI::algs::HyperbolicPatchStrategy Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath"><a class="el" href="namespaceSAMRAI.html">SAMRAI</a>::<a class="el" href="namespaceSAMRAI_1_1algs.html">algs</a>::<a class="el" href="classSAMRAI_1_1algs_1_1HyperbolicPatchStrategy.html">HyperbolicPatchStrategy</a>
  </div>
</div>
<div class="contents">
<h1>SAMRAI::algs::HyperbolicPatchStrategy Class Reference</h1><!-- doxytag: class="SAMRAI::algs::HyperbolicPatchStrategy" --><!-- doxytag: inherits="SAMRAI::xfer::RefinePatchStrategy,SAMRAI::xfer::CoarsenPatchStrategy" -->
<p><code>#include &lt;source/SAMRAI/algs/HyperbolicPatchStrategy.h&gt;</code></p>
<div class="dynheader">
Inheritance diagram for SAMRAI::algs::HyperbolicPatchStrategy:</div>
<div class="dynsection">
 <div class="center">
  <img src="classSAMRAI_1_1algs_1_1HyperbolicPatchStrategy.gif" usemap="#SAMRAI::algs::HyperbolicPatchStrategy_map" alt=""/>
  <map id="SAMRAI::algs::HyperbolicPatchStrategy_map" name="SAMRAI::algs::HyperbolicPatchStrategy_map">
<area href="classSAMRAI_1_1xfer_1_1RefinePatchStrategy.html" alt="SAMRAI::xfer::RefinePatchStrategy" shape="rect" coords="0,0,236,24"/>
<area href="classSAMRAI_1_1xfer_1_1CoarsenPatchStrategy.html" alt="SAMRAI::xfer::CoarsenPatchStrategy" shape="rect" coords="246,0,482,24"/>
</map>
 </div>
</div>

<p><a href="classSAMRAI_1_1algs_1_1HyperbolicPatchStrategy-members.html">List of all members.</a></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1algs_1_1HyperbolicPatchStrategy.html#aedd6b70351a72080525733b3dfed6b14">HyperbolicPatchStrategy</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1algs_1_1HyperbolicPatchStrategy.html#aaa4bc1edb9920d6941819b5ca8eb5a15">~HyperbolicPatchStrategy</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1algs_1_1HyperbolicPatchStrategy.html#a4d86d87131ab8824d6884167639acb70">registerModelVariables</a> (<a class="el" href="classSAMRAI_1_1algs_1_1HyperbolicLevelIntegrator.html">HyperbolicLevelIntegrator</a> *integrator)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1algs_1_1HyperbolicPatchStrategy.html#a0daef6ee86089e2c854cc98e6ea90d5a">setupLoadBalancer</a> (<a class="el" href="classSAMRAI_1_1algs_1_1HyperbolicLevelIntegrator.html">HyperbolicLevelIntegrator</a> *integrator, <a class="el" href="classSAMRAI_1_1mesh_1_1GriddingAlgorithm.html">mesh::GriddingAlgorithm</a> *gridding_algorithm)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1algs_1_1HyperbolicPatchStrategy.html#ab8610a2fa09736537b72315a66bfa326">initializeDataOnPatch</a> (<a class="el" href="classSAMRAI_1_1hier_1_1Patch.html">hier::Patch</a> &amp;patch, const double data_time, const bool initial_time)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1algs_1_1HyperbolicPatchStrategy.html#adce818986288899185e5832fd7b565f6">computeStableDtOnPatch</a> (<a class="el" href="classSAMRAI_1_1hier_1_1Patch.html">hier::Patch</a> &amp;patch, const bool initial_time, const double dt_time)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1algs_1_1HyperbolicPatchStrategy.html#a6ae2404eb90897f5e311baafbe1a6fd3">computeFluxesOnPatch</a> (<a class="el" href="classSAMRAI_1_1hier_1_1Patch.html">hier::Patch</a> &amp;patch, const double time, const double dt)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1algs_1_1HyperbolicPatchStrategy.html#a5c416adf7d32d80d73eb8cef33b72e96">conservativeDifferenceOnPatch</a> (<a class="el" href="classSAMRAI_1_1hier_1_1Patch.html">hier::Patch</a> &amp;patch, const double time, const double dt, bool at_syncronization)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1algs_1_1HyperbolicPatchStrategy.html#a9ea18d3f8fb24ba1844bef95ed7e199d">preprocessAdvanceLevelState</a> (const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchLevel.html">hier::PatchLevel</a> &gt; &amp;level, double current_time, double dt, bool first_step, bool last_step, bool regrid_advance)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1algs_1_1HyperbolicPatchStrategy.html#a5004a132c246a33510ec13acc9b8c0ac">postprocessAdvanceLevelState</a> (const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchLevel.html">hier::PatchLevel</a> &gt; &amp;level, double current_time, double dt, bool first_step, bool last_step, bool regrid_advance)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1algs_1_1HyperbolicPatchStrategy.html#a7acd9a47ff0f33244ffe54a7352ce424">tagGradientDetectorCells</a> (<a class="el" href="classSAMRAI_1_1hier_1_1Patch.html">hier::Patch</a> &amp;patch, const double regrid_time, const bool initial_error, const int tag_index, const bool uses_richardson_extrapolation_too)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1algs_1_1HyperbolicPatchStrategy.html#aec657d0e4b2e91b3bf42fa11dd5fc67d">tagRichardsonExtrapolationCells</a> (<a class="el" href="classSAMRAI_1_1hier_1_1Patch.html">hier::Patch</a> &amp;patch, const int error_level_number, const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1hier_1_1VariableContext.html">hier::VariableContext</a> &gt; &amp;coarsened_fine, const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1hier_1_1VariableContext.html">hier::VariableContext</a> &gt; &amp;advanced_coarse, const double regrid_time, const double deltat, const int error_coarsen_ratio, const bool initial_error, const int tag_index, const bool uses_gradient_detector_too)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1algs_1_1HyperbolicPatchStrategy.html#af482fa0a13cf89f84276b5d1f6b09822">setPhysicalBoundaryConditions</a> (<a class="el" href="classSAMRAI_1_1hier_1_1Patch.html">hier::Patch</a> &amp;patch, const double fill_time, const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a> &amp;ghost_width_to_fill)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">boost::shared_ptr<br class="typebreak"/>
&lt; <a class="el" href="classSAMRAI_1_1hier_1_1VariableContext.html">hier::VariableContext</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1algs_1_1HyperbolicPatchStrategy.html#a396812b3487197d2dba1ff8a8ebd5af7">getDataContext</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1algs_1_1HyperbolicPatchStrategy.html#a024e4745981ac453284f616e187d3a01">setDataContext</a> (const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1hier_1_1VariableContext.html">hier::VariableContext</a> &gt; &amp;context)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1algs_1_1HyperbolicPatchStrategy.html#a7a96b203c4ce422aba0944c9bca0b469">clearDataContext</a> ()</td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>Class <a class="el" href="classSAMRAI_1_1algs_1_1HyperbolicPatchStrategy.html">HyperbolicPatchStrategy</a> is an abstract base class defining the interface between an <a class="el" href="classSAMRAI_1_1algs_1_1HyperbolicLevelIntegrator.html">HyperbolicLevelIntegrator</a> object and operations applied to a single patch in a structured AMR hierarchy. The operations include patch initialization, dt calculation, flux computation, conservative differencing, and error estimation. This class is derived from the <a class="el" href="classSAMRAI_1_1xfer_1_1RefinePatchStrategy.html" title="Abstract base class for user-defined patch data refining operations and physical...">xfer::RefinePatchStrategy</a> and <a class="el" href="classSAMRAI_1_1xfer_1_1CoarsenPatchStrategy.html" title="Abstract base class for user-defined patch data coarsening operations.">xfer::CoarsenPatchStrategy</a> abstract base classes. These base classes provide the interface for user-defined interlevel data refining and coarsening operations and the specification of physical boundary conditions. The functions <a class="el" href="classSAMRAI_1_1algs_1_1HyperbolicPatchStrategy.html#af482fa0a13cf89f84276b5d1f6b09822">setPhysicalBoundaryConditions()</a>, and pre/postprocessRefine() are overloaded from the class <a class="el" href="classSAMRAI_1_1xfer_1_1RefinePatchStrategy.html" title="Abstract base class for user-defined patch data refining operations and physical...">xfer::RefinePatchStrategy</a>. The operations pre/postprocessCoarsen() are overloaded from <a class="el" href="classSAMRAI_1_1xfer_1_1CoarsenPatchStrategy.html" title="Abstract base class for user-defined patch data coarsening operations.">xfer::CoarsenPatchStrategy</a>. The pre/postprocessCoarsen/Refine() operations are given empty implementations here so that the user does not need to proovide them if the operations are not needed.</p>
<p>It is important to recognize that for the concrete patch strategy subclass and the <a class="el" href="classSAMRAI_1_1algs_1_1HyperbolicLevelIntegrator.html">HyperbolicLevelIntegrator</a> to work together, the concrete strategy must know which patch data to operate on. The patch data storage is manipulated by the level integrator. The set/clearDataContext() methods allow the integrator to inform the patch strategy of the correct data context. The concrete patch strategy subclass can access the appropriate context via the <a class="el" href="classSAMRAI_1_1algs_1_1HyperbolicPatchStrategy.html#a396812b3487197d2dba1ff8a8ebd5af7">getDataContext()</a> method.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classSAMRAI_1_1algs_1_1HyperbolicLevelIntegrator.html">algs::HyperbolicLevelIntegrator</a> </dd>
<dd>
<a class="el" href="classSAMRAI_1_1xfer_1_1RefinePatchStrategy.html" title="Abstract base class for user-defined patch data refining operations and physical...">xfer::RefinePatchStrategy</a> </dd>
<dd>
<a class="el" href="classSAMRAI_1_1xfer_1_1CoarsenPatchStrategy.html" title="Abstract base class for user-defined patch data coarsening operations.">xfer::CoarsenPatchStrategy</a> </dd></dl>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="aedd6b70351a72080525733b3dfed6b14"></a><!-- doxytag: member="SAMRAI::algs::HyperbolicPatchStrategy::HyperbolicPatchStrategy" ref="aedd6b70351a72080525733b3dfed6b14" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SAMRAI::algs::HyperbolicPatchStrategy::HyperbolicPatchStrategy </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Blank constructor for <a class="el" href="classSAMRAI_1_1algs_1_1HyperbolicPatchStrategy.html">HyperbolicPatchStrategy</a>. </p>

</div>
</div>
<a class="anchor" id="aaa4bc1edb9920d6941819b5ca8eb5a15"></a><!-- doxytag: member="SAMRAI::algs::HyperbolicPatchStrategy::~HyperbolicPatchStrategy" ref="aaa4bc1edb9920d6941819b5ca8eb5a15" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SAMRAI::algs::HyperbolicPatchStrategy::~HyperbolicPatchStrategy </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Virtual destructor for <a class="el" href="classSAMRAI_1_1algs_1_1HyperbolicPatchStrategy.html">HyperbolicPatchStrategy</a>. </p>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a4d86d87131ab8824d6884167639acb70"></a><!-- doxytag: member="SAMRAI::algs::HyperbolicPatchStrategy::registerModelVariables" ref="a4d86d87131ab8824d6884167639acb70" args="(HyperbolicLevelIntegrator *integrator)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void SAMRAI::algs::HyperbolicPatchStrategy::registerModelVariables </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1algs_1_1HyperbolicLevelIntegrator.html">HyperbolicLevelIntegrator</a> *&nbsp;</td>
          <td class="paramname"> <em>integrator</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Register specific variables needed in the numerical routines with the hyperbolic level integrator using the registerVariable() function in that class. The integrator manipulates storage for the data and this registration defines the way in which data for each quantity will be manipulated on the patches. Typically, the derived data quantities for plotting are registered with a visualization data writer in this routine as well, since the hyperbolic level integrator provides the variable context for plotting (i.e., which data is available when a plot file is generated). The integrator pointer cannot be null in most cases.</p>
<p>The gridding algorithm pointer is provided so that patch data objects may be registered with the load balancer object (owned by the gridding algorithm) for non-uniform load balancing, if needed. </p>

</div>
</div>
<a class="anchor" id="a0daef6ee86089e2c854cc98e6ea90d5a"></a><!-- doxytag: member="SAMRAI::algs::HyperbolicPatchStrategy::setupLoadBalancer" ref="a0daef6ee86089e2c854cc98e6ea90d5a" args="(HyperbolicLevelIntegrator *integrator, mesh::GriddingAlgorithm *gridding_algorithm)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::algs::HyperbolicPatchStrategy::setupLoadBalancer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1algs_1_1HyperbolicLevelIntegrator.html">HyperbolicLevelIntegrator</a> *&nbsp;</td>
          <td class="paramname"> <em>integrator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1mesh_1_1GriddingAlgorithm.html">mesh::GriddingAlgorithm</a> *&nbsp;</td>
          <td class="paramname"> <em>gridding_algorithm</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Set up parameters in the load balancer object (owned by the gridding algorithm) if needed. This function is called immediately after the <a class="el" href="classSAMRAI_1_1algs_1_1HyperbolicPatchStrategy.html#a4d86d87131ab8824d6884167639acb70">registerModelVariables()</a> function is called. The hyperbolic level integrator pointer is provided so that the integrator can be used to manage data for the load balancer if needed (e.g., when using non-uniform load balancing).</p>
<p>Note that this function is not pure virtual. It is given a dummy implementation here so that users may ignore it when inheriting from this class. </p>

<p>References <a class="el" href="Utilities_8h_source.html#l00050">NULL_USE</a>.</p>

</div>
</div>
<a class="anchor" id="ab8610a2fa09736537b72315a66bfa326"></a><!-- doxytag: member="SAMRAI::algs::HyperbolicPatchStrategy::initializeDataOnPatch" ref="ab8610a2fa09736537b72315a66bfa326" args="(hier::Patch &amp;patch, const double data_time, const bool initial_time)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void SAMRAI::algs::HyperbolicPatchStrategy::initializeDataOnPatch </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1hier_1_1Patch.html">hier::Patch</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>patch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>data_time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&nbsp;</td>
          <td class="paramname"> <em>initial_time</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Set the initial data on a patch interior only. Note that no ghost cells need to be set in this routine regardless of whether the patch data corresponding to the context requires ghost cells. The data_time is the simulation time when the routine is called. The boolean initial_time is true if the routine is called at the initial time when the hierarchy is initially constructed, otherwise it is false. </p>

</div>
</div>
<a class="anchor" id="adce818986288899185e5832fd7b565f6"></a><!-- doxytag: member="SAMRAI::algs::HyperbolicPatchStrategy::computeStableDtOnPatch" ref="adce818986288899185e5832fd7b565f6" args="(hier::Patch &amp;patch, const bool initial_time, const double dt_time)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual double SAMRAI::algs::HyperbolicPatchStrategy::computeStableDtOnPatch </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1hier_1_1Patch.html">hier::Patch</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>patch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&nbsp;</td>
          <td class="paramname"> <em>initial_time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>dt_time</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Compute the stable time increment for a patch on the level with the given number. The boolean flag initial_time is true if the routine is called at the initial simulation time; otherwise it is false. The double argument dt_time is the simulation time. </p>

</div>
</div>
<a class="anchor" id="a6ae2404eb90897f5e311baafbe1a6fd3"></a><!-- doxytag: member="SAMRAI::algs::HyperbolicPatchStrategy::computeFluxesOnPatch" ref="a6ae2404eb90897f5e311baafbe1a6fd3" args="(hier::Patch &amp;patch, const double time, const double dt)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void SAMRAI::algs::HyperbolicPatchStrategy::computeFluxesOnPatch </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1hier_1_1Patch.html">hier::Patch</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>patch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>dt</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Compute TIME INTEGRALS of fluxes to be used in conservative difference for patch integration. That is, it is assumed that this numerical routine will compute the fluxes corresponding to the cell faces multiplied by the time increment. Typically, the numerical flux is the normal flux at the cell face. The flux integrals will be used in the conservative difference that updates the conserved quantities.</p>
<p>Note that the numerical routines in this method generally require ghost cells. Ghost cells data is filled before this routine is called. </p>

</div>
</div>
<a class="anchor" id="a5c416adf7d32d80d73eb8cef33b72e96"></a><!-- doxytag: member="SAMRAI::algs::HyperbolicPatchStrategy::conservativeDifferenceOnPatch" ref="a5c416adf7d32d80d73eb8cef33b72e96" args="(hier::Patch &amp;patch, const double time, const double dt, bool at_syncronization)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void SAMRAI::algs::HyperbolicPatchStrategy::conservativeDifferenceOnPatch </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1hier_1_1Patch.html">hier::Patch</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>patch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>dt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>at_syncronization</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Update patch data with a conservative difference (approximating the divergence theorem) using the flux integrals computed in <a class="el" href="classSAMRAI_1_1algs_1_1HyperbolicPatchStrategy.html#a6ae2404eb90897f5e311baafbe1a6fd3">computeFluxesOnPatch()</a> routine. The boolean flag is true when this routine is called during a flux synchronization step. Otherwise, it is false. Note that the <a class="el" href="classSAMRAI_1_1algs_1_1HyperbolicPatchStrategy.html#a6ae2404eb90897f5e311baafbe1a6fd3">computeFluxesOnPatch()</a> routine computes TIME INTEGRALs of the numerical fluxes (e.g., they have been multiplied by dt). So the conservative difference routine should be consistent with this. </p>

</div>
</div>
<a class="anchor" id="a9ea18d3f8fb24ba1844bef95ed7e199d"></a><!-- doxytag: member="SAMRAI::algs::HyperbolicPatchStrategy::preprocessAdvanceLevelState" ref="a9ea18d3f8fb24ba1844bef95ed7e199d" args="(const boost::shared_ptr&lt; hier::PatchLevel &gt; &amp;level, double current_time, double dt, bool first_step, bool last_step, bool regrid_advance)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::algs::HyperbolicPatchStrategy::preprocessAdvanceLevelState </td>
          <td>(</td>
          <td class="paramtype">const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchLevel.html">hier::PatchLevel</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>current_time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>dt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>first_step</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>last_step</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>regrid_advance</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This is an optional routine for user to process any application-specific patch strategy data BEFORE patches are advanced on the given level. This routine is called after patch boundary data is filled (i.e., ghosts) and before <a class="el" href="classSAMRAI_1_1algs_1_1HyperbolicPatchStrategy.html#a6ae2404eb90897f5e311baafbe1a6fd3">computeFluxesOnPatch()</a>. The arguments are: level -- level that will be advanced, current_time -- current integration time, dt -- current time increment, first_step -- boolean flag that is true if advance is first in time step sequence on level (i.e., previous advance step was on another level, false otherwise, last_step -- boolean flag that is true if advance is last in time step sequence on level (i.e., synchronization with coarser level will occur immediately after this advance), regrid_advance -- boolean flag that is true if the advance is during a regridding phase (i.e., the advance is not used to integrate data on the hierarchy) in which case the results of the advance will be discarded.</p>
<p>Note that when this routine is called, the scratch data is filled on all patches (i.e., ghost cells) and that data is the same as the current level data on all patch interiors. That is, both scratch and current data correspond to current_time.</p>
<p>Note that this function is not pure virtual. It is given a dummy implementation here so that users may ignore it when inheriting from this class. </p>

<p>References <a class="el" href="Utilities_8h_source.html#l00050">NULL_USE</a>.</p>

</div>
</div>
<a class="anchor" id="a5004a132c246a33510ec13acc9b8c0ac"></a><!-- doxytag: member="SAMRAI::algs::HyperbolicPatchStrategy::postprocessAdvanceLevelState" ref="a5004a132c246a33510ec13acc9b8c0ac" args="(const boost::shared_ptr&lt; hier::PatchLevel &gt; &amp;level, double current_time, double dt, bool first_step, bool last_step, bool regrid_advance)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::algs::HyperbolicPatchStrategy::postprocessAdvanceLevelState </td>
          <td>(</td>
          <td class="paramtype">const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchLevel.html">hier::PatchLevel</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>current_time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>dt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>first_step</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>last_step</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>regrid_advance</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This is an optional routine for user to process any application-specific patch strategy data AFTER patches are advanced on the given level. This routine is called after <a class="el" href="classSAMRAI_1_1algs_1_1HyperbolicPatchStrategy.html#a5c416adf7d32d80d73eb8cef33b72e96">conservativeDifferenceOnPatch()</a> is called and before <a class="el" href="classSAMRAI_1_1algs_1_1HyperbolicPatchStrategy.html#adce818986288899185e5832fd7b565f6">computeStableDtOnPatch()</a>. The arguments are: level -- level that will be advanced, current_time -- current integration time, dt -- current time increment, first_step -- boolean flag that is true if advance is first in time step sequence on level (i.e., previous advance step was on another level, false otherwise, last_step -- boolean flag that is true if advance is last in time step sequence on level (i.e., synchronization with coarser level will occur immediately after this advance), regrid_advance -- boolean flag that is true if the advance is during a regridding phase (i.e., the advance is not used to integrate data on the hierarchy) in which case the results of the advance will be discarded.</p>
<p>Note that when this routine is called, the scratch data is filled on all patches (i.e., ghost cells) and that data is the same as the new level data on all patch interiors. That is, both scratch and new data correspond to current_time + dt on patch interiors. The current data and ghost values correspond to the current_time.</p>
<p>Note that this function is not pure virtual. It is given a dummy implementation here so that users may ignore it when inheriting from this class. </p>

<p>References <a class="el" href="Utilities_8h_source.html#l00050">NULL_USE</a>.</p>

</div>
</div>
<a class="anchor" id="a7acd9a47ff0f33244ffe54a7352ce424"></a><!-- doxytag: member="SAMRAI::algs::HyperbolicPatchStrategy::tagGradientDetectorCells" ref="a7acd9a47ff0f33244ffe54a7352ce424" args="(hier::Patch &amp;patch, const double regrid_time, const bool initial_error, const int tag_index, const bool uses_richardson_extrapolation_too)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::algs::HyperbolicPatchStrategy::tagGradientDetectorCells </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1hier_1_1Patch.html">hier::Patch</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>patch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>regrid_time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&nbsp;</td>
          <td class="paramname"> <em>initial_error</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>tag_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&nbsp;</td>
          <td class="paramname"> <em>uses_richardson_extrapolation_too</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Tag cells on the given patch that require refinement based on application-specific numerical quantities. The tag index argument indicates the index of the tag data on the patch data array. The boolean argument initial_error is true if tagging is being done at the initial simulation time; otherwise, it is false. The other boolean flag uses_richardson_extrapolation_too is true when Richardson extrapolation is used in addition to the gradient detector. This flag helps users manage multiple regridding criteria.</p>
<p>Note that this function is not pure virtual. It is given a dummy implementation here so that users may ignore it when inheriting from this class. </p>

<p>References <a class="el" href="Utilities_8h_source.html#l00050">NULL_USE</a>, and <a class="el" href="Utilities_8h_source.html#l00060">TBOX_ERROR</a>.</p>

</div>
</div>
<a class="anchor" id="aec657d0e4b2e91b3bf42fa11dd5fc67d"></a><!-- doxytag: member="SAMRAI::algs::HyperbolicPatchStrategy::tagRichardsonExtrapolationCells" ref="aec657d0e4b2e91b3bf42fa11dd5fc67d" args="(hier::Patch &amp;patch, const int error_level_number, const boost::shared_ptr&lt; hier::VariableContext &gt; &amp;coarsened_fine, const boost::shared_ptr&lt; hier::VariableContext &gt; &amp;advanced_coarse, const double regrid_time, const double deltat, const int error_coarsen_ratio, const bool initial_error, const int tag_index, const bool uses_gradient_detector_too)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::algs::HyperbolicPatchStrategy::tagRichardsonExtrapolationCells </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1hier_1_1Patch.html">hier::Patch</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>patch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>error_level_number</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1hier_1_1VariableContext.html">hier::VariableContext</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>coarsened_fine</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1hier_1_1VariableContext.html">hier::VariableContext</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>advanced_coarse</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>regrid_time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>deltat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>error_coarsen_ratio</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&nbsp;</td>
          <td class="paramname"> <em>initial_error</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>tag_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&nbsp;</td>
          <td class="paramname"> <em>uses_gradient_detector_too</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Tag cells based from differences computed in the Richardson extrapolation. The Richardson extrapolation algorithm creates a coarsened version of some hierarchy patch level and advances data in time on both the coarsened patch level and the hierarchy level. This routine takes the data resulting from the advance on both the coarse and fine levels, compares them, and tags cells according to the difference. </p>
<div class="fragment"><pre class="fragment">
    *              (2)
    *      n+1 ^-------&gt;x finish      (1) advanced_coarse
    *          |        ^             (2) coarsened_fine
    *  time  n -        |
    *          ^        |(1)
    *          |        |
    *          &lt;--------o start
    *        fine     coarse
    * </pre></div><p>The patch supplied to this routine is on the coarsened level. However, the error_level_number corresponds to the actual hierarchy level from which it was coarsened. Data resides on this patch in two contexts - ``advanced_coarse'' and ``coarsened_fine''. Advanced coarse is data advanced on the coarsened version of the level, while coarsened fine is the data advanced on the fine level and then coarsened to the coarse level. The regrid time and the time increment are given for the actual hierarchy level. The error coarsen ratio argument is the ratio between the index spaces on the hierarchy level and the coarsened hierarchy level. The boolean flag ``initial_error'' is true when the error estimation is performed at the initial simulation time; i.e., when the hierarchy levels are being constructed for the first time. The tag index argument is the index of the tag data on the patch data array. The other boolean flag uses_gradient_detector_too is true when a gradient detector scheme is used in addition to Richardson extrapolation. This flag helps users manage multiple regridding criteria.</p>
<p>Note that this function is not pure virtual. It is given a dummy implementation here so that users may ignore it when inheriting from this class. </p>

<p>References <a class="el" href="Utilities_8h_source.html#l00050">NULL_USE</a>, and <a class="el" href="Utilities_8h_source.html#l00060">TBOX_ERROR</a>.</p>

</div>
</div>
<a class="anchor" id="af482fa0a13cf89f84276b5d1f6b09822"></a><!-- doxytag: member="SAMRAI::algs::HyperbolicPatchStrategy::setPhysicalBoundaryConditions" ref="af482fa0a13cf89f84276b5d1f6b09822" args="(hier::Patch &amp;patch, const double fill_time, const hier::IntVector &amp;ghost_width_to_fill)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void SAMRAI::algs::HyperbolicPatchStrategy::setPhysicalBoundaryConditions </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1hier_1_1Patch.html">hier::Patch</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>patch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>fill_time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>ghost_width_to_fill</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Set user-defined boundary conditions at the physical domain boundary. </p>

<p>Implements <a class="el" href="classSAMRAI_1_1xfer_1_1RefinePatchStrategy.html#ae6da055f3a0e95bb34761e76eda0744e">SAMRAI::xfer::RefinePatchStrategy</a>.</p>

</div>
</div>
<a class="anchor" id="a396812b3487197d2dba1ff8a8ebd5af7"></a><!-- doxytag: member="SAMRAI::algs::HyperbolicPatchStrategy::getDataContext" ref="a396812b3487197d2dba1ff8a8ebd5af7" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::shared_ptr&lt;<a class="el" href="classSAMRAI_1_1hier_1_1VariableContext.html">hier::VariableContext</a>&gt; SAMRAI::algs::HyperbolicPatchStrategy::getDataContext </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return pointer to patch data context. </p>

</div>
</div>
<a class="anchor" id="a024e4745981ac453284f616e187d3a01"></a><!-- doxytag: member="SAMRAI::algs::HyperbolicPatchStrategy::setDataContext" ref="a024e4745981ac453284f616e187d3a01" args="(const boost::shared_ptr&lt; hier::VariableContext &gt; &amp;context)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::algs::HyperbolicPatchStrategy::setDataContext </td>
          <td>(</td>
          <td class="paramtype">const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1hier_1_1VariableContext.html">hier::VariableContext</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>context</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>The hyperbolic integrator controls the context for the data to be used in the numerical routines implemented in the concrete patch strategy. The <a class="el" href="classSAMRAI_1_1algs_1_1HyperbolicPatchStrategy.html#a024e4745981ac453284f616e187d3a01">setDataContext()</a> allows the integrator to set the context for data on a patch on which to operate. </p>

</div>
</div>
<a class="anchor" id="a7a96b203c4ce422aba0944c9bca0b469"></a><!-- doxytag: member="SAMRAI::algs::HyperbolicPatchStrategy::clearDataContext" ref="a7a96b203c4ce422aba0944c9bca0b469" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::algs::HyperbolicPatchStrategy::clearDataContext </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>The <a class="el" href="classSAMRAI_1_1algs_1_1HyperbolicPatchStrategy.html#a7a96b203c4ce422aba0944c9bca0b469">clearDataContext()</a> routine resets the data context to be null. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>source/SAMRAI/algs/<a class="el" href="HyperbolicPatchStrategy_8h.html">HyperbolicPatchStrategy.h</a></li>
<li>source/SAMRAI/algs/<a class="el" href="HyperbolicPatchStrategy_8C.html">HyperbolicPatchStrategy.C</a></li>
</ul>
</div>
<hr size="1"/><address style="text-align: right;"><small>Generated on 3 Dec 2014 for SAMRAI by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.1 </small></address>
</body>
</html>
