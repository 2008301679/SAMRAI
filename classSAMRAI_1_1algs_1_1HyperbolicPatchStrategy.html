<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>SAMRAI: SAMRAI::algs::HyperbolicPatchStrategy Class Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.7 -->
<div class="tabs">
  <ul>
    <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="namespaces.html"><span>Namespaces</span></a></li>
    <li id="current"><a href="annotated.html"><span>Classes</span></a></li>
    <li><a href="files.html"><span>Files</span></a></li>
    <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
  </ul></div>
<div class="tabs">
  <ul>
    <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
    <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
    <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
  </ul></div>
<div class="nav">
<a class="el" href="namespaceSAMRAI.html">SAMRAI</a>::<a class="el" href="namespaceSAMRAI_1_1algs.html">algs</a>::<a class="el" href="classSAMRAI_1_1algs_1_1HyperbolicPatchStrategy.html">HyperbolicPatchStrategy</a></div>
<h1>SAMRAI::algs::HyperbolicPatchStrategy Class Reference</h1><!-- doxytag: class="SAMRAI::algs::HyperbolicPatchStrategy" --><!-- doxytag: inherits="SAMRAI::xfer::RefinePatchStrategy,SAMRAI::xfer::CoarsenPatchStrategy" --><code>#include &lt;source/SAMRAI/algs/HyperbolicPatchStrategy.h&gt;</code>
<p>
<p>Inheritance diagram for SAMRAI::algs::HyperbolicPatchStrategy:
<p><center><img src="classSAMRAI_1_1algs_1_1HyperbolicPatchStrategy.png" usemap="#SAMRAI::algs::HyperbolicPatchStrategy_map" border="0" alt=""></center>
<map name="SAMRAI::algs::HyperbolicPatchStrategy_map">
<area href="classSAMRAI_1_1xfer_1_1RefinePatchStrategy.html" alt="SAMRAI::xfer::RefinePatchStrategy" shape="rect" coords="0,0,236,24">
<area href="classSAMRAI_1_1xfer_1_1CoarsenPatchStrategy.html" alt="SAMRAI::xfer::CoarsenPatchStrategy" shape="rect" coords="246,0,482,24">
</map>
<a href="classSAMRAI_1_1algs_1_1HyperbolicPatchStrategy-members.html">List of all members.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1algs_1_1HyperbolicPatchStrategy.html#bfdd7c8bf839dd3eef9de00f5dc35d98">HyperbolicPatchStrategy</a> (const <a class="el" href="classSAMRAI_1_1tbox_1_1Dimension.html">tbox::Dimension</a> &amp;dim)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1algs_1_1HyperbolicPatchStrategy.html#6dee35e53e3f2a906eae433ab747dd42">~HyperbolicPatchStrategy</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1algs_1_1HyperbolicPatchStrategy.html#cca2469b4f8659d5e7dc41c1572853d0">registerModelVariables</a> (<a class="el" href="classSAMRAI_1_1algs_1_1HyperbolicLevelIntegrator.html">HyperbolicLevelIntegrator</a> *integrator)=0</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1algs_1_1HyperbolicPatchStrategy.html#0344a3099849a591f4d35ff3522745b0">setupLoadBalancer</a> (<a class="el" href="classSAMRAI_1_1algs_1_1HyperbolicLevelIntegrator.html">HyperbolicLevelIntegrator</a> *integrator, <a class="el" href="classSAMRAI_1_1mesh_1_1GriddingAlgorithm.html">mesh::GriddingAlgorithm</a> *gridding_algorithm)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1algs_1_1HyperbolicPatchStrategy.html#bcf54eff296e8898bb5c591aa17b5d68">initializeDataOnPatch</a> (<a class="el" href="classSAMRAI_1_1hier_1_1Patch.html">hier::Patch</a> &amp;patch, const double data_time, const bool initial_time)=0</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1algs_1_1HyperbolicPatchStrategy.html#9e803926bda95a5fb351472d082a1cfe">computeStableDtOnPatch</a> (<a class="el" href="classSAMRAI_1_1hier_1_1Patch.html">hier::Patch</a> &amp;patch, const bool initial_time, const double dt_time)=0</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1algs_1_1HyperbolicPatchStrategy.html#c6440f00550554375dc58e31fe4bfb97">computeFluxesOnPatch</a> (<a class="el" href="classSAMRAI_1_1hier_1_1Patch.html">hier::Patch</a> &amp;patch, const double time, const double dt)=0</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1algs_1_1HyperbolicPatchStrategy.html#932547caed02bc084f8efce9e2d1d1e8">conservativeDifferenceOnPatch</a> (<a class="el" href="classSAMRAI_1_1hier_1_1Patch.html">hier::Patch</a> &amp;patch, const double time, const double dt, bool at_syncronization)=0</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1algs_1_1HyperbolicPatchStrategy.html#df9cb776823440d62de812382fffb86d">preprocessAdvanceLevelState</a> (const <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchLevel.html">hier::PatchLevel</a> &gt; &amp;level, double current_time, double dt, bool first_step, bool last_step, bool regrid_advance)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1algs_1_1HyperbolicPatchStrategy.html#41982c51ee4f02590de5ea26c79fbaa3">postprocessAdvanceLevelState</a> (const <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchLevel.html">hier::PatchLevel</a> &gt; &amp;level, double current_time, double dt, bool first_step, bool last_step, bool regrid_advance)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1algs_1_1HyperbolicPatchStrategy.html#780ff3b9eb4b2b686bd152a381ab80ec">tagGradientDetectorCells</a> (<a class="el" href="classSAMRAI_1_1hier_1_1Patch.html">hier::Patch</a> &amp;patch, const double regrid_time, const bool initial_error, const int tag_index, const bool uses_richardson_extrapolation_too)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1algs_1_1HyperbolicPatchStrategy.html#6fb37f917f199c5f10f6501414d5291c">tagRichardsonExtrapolationCells</a> (<a class="el" href="classSAMRAI_1_1hier_1_1Patch.html">hier::Patch</a> &amp;patch, const int error_level_number, const <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1VariableContext.html">hier::VariableContext</a> &gt; coarsened_fine, const <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1VariableContext.html">hier::VariableContext</a> &gt; advanced_coarse, const double regrid_time, const double deltat, const int error_coarsen_ratio, const bool initial_error, const int tag_index, const bool uses_gradient_detector_too)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1algs_1_1HyperbolicPatchStrategy.html#31f097ee69de5a175f4b34d31c469bf8">setPhysicalBoundaryConditions</a> (<a class="el" href="classSAMRAI_1_1hier_1_1Patch.html">hier::Patch</a> &amp;patch, const double fill_time, const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a> &amp;ghost_width_to_fill)=0</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1algs_1_1HyperbolicPatchStrategy.html#63c4c0520b3c8eee51d337c2f6d337c0">getRefineOpStencilWidth</a> () const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1algs_1_1HyperbolicPatchStrategy.html#1c416232cfbb5e1ef07d860cff23f5fc">preprocessRefine</a> (<a class="el" href="classSAMRAI_1_1hier_1_1Patch.html">hier::Patch</a> &amp;fine, const <a class="el" href="classSAMRAI_1_1hier_1_1Patch.html">hier::Patch</a> &amp;coarse, const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">hier::Box</a> &amp;fine_box, const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a> &amp;ratio)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1algs_1_1HyperbolicPatchStrategy.html#a48e4adfa76b1e3a672abef8a27c53f8">postprocessRefine</a> (<a class="el" href="classSAMRAI_1_1hier_1_1Patch.html">hier::Patch</a> &amp;fine, const <a class="el" href="classSAMRAI_1_1hier_1_1Patch.html">hier::Patch</a> &amp;coarse, const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">hier::Box</a> &amp;fine_box, const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a> &amp;ratio)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Perform user-defined patch data refinement operations.  <a href="#a48e4adfa76b1e3a672abef8a27c53f8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1algs_1_1HyperbolicPatchStrategy.html#d9f2e566fe1cd9c77c65eaf2d396a0c2">getCoarsenOpStencilWidth</a> () const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1algs_1_1HyperbolicPatchStrategy.html#3480ca32124e2c7bb9964946b29db3b3">preprocessCoarsen</a> (<a class="el" href="classSAMRAI_1_1hier_1_1Patch.html">hier::Patch</a> &amp;coarse, const <a class="el" href="classSAMRAI_1_1hier_1_1Patch.html">hier::Patch</a> &amp;fine, const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">hier::Box</a> &amp;coarse_box, const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a> &amp;ratio)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1algs_1_1HyperbolicPatchStrategy.html#c049b88562fdf98350513952fb604176">postprocessCoarsen</a> (<a class="el" href="classSAMRAI_1_1hier_1_1Patch.html">hier::Patch</a> &amp;coarse, const <a class="el" href="classSAMRAI_1_1hier_1_1Patch.html">hier::Patch</a> &amp;fine, const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">hier::Box</a> &amp;coarse_box, const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a> &amp;ratio)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Perform user-defined patch data coarsening operations.  <a href="#c049b88562fdf98350513952fb604176"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1VariableContext.html">hier::VariableContext</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1algs_1_1HyperbolicPatchStrategy.html#e77e049ab5a575dc4eef7b870e8e428a">getDataContext</a> () const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1algs_1_1HyperbolicPatchStrategy.html#abb02eb6de95b63c5dd7d54c4b5cf340">setDataContext</a> (<a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1VariableContext.html">hier::VariableContext</a> &gt; context)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1algs_1_1HyperbolicPatchStrategy.html#bd85a561841ad406095e47db1d6d7e64">clearDataContext</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">const <a class="el" href="classSAMRAI_1_1tbox_1_1Dimension.html">tbox::Dimension</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1algs_1_1HyperbolicPatchStrategy.html#81deadcfc673b84af5ca41898f4cd8c2">getDim</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the dimension of this object.  <a href="#81deadcfc673b84af5ca41898f4cd8c2"></a><br></td></tr>
</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
Class <a class="el" href="classSAMRAI_1_1algs_1_1HyperbolicPatchStrategy.html">HyperbolicPatchStrategy</a> is an abstract base class defining the interface between an <a class="el" href="classSAMRAI_1_1algs_1_1HyperbolicLevelIntegrator.html">HyperbolicLevelIntegrator</a> object and operations applied to a single patch in a structured AMR hierarchy. The operations include patch initialization, dt calculation, flux computation, conservative differencing, and error estimation. This class is derived from the <a class="el" href="classSAMRAI_1_1xfer_1_1RefinePatchStrategy.html">xfer::RefinePatchStrategy</a> and <a class="el" href="classSAMRAI_1_1xfer_1_1CoarsenPatchStrategy.html">xfer::CoarsenPatchStrategy</a> abstract base classes. These base classes provide the interface for user-defined interlevel data refining and coarsening operations and the specification of physical boundary conditions. The functions <a class="el" href="classSAMRAI_1_1algs_1_1HyperbolicPatchStrategy.html#31f097ee69de5a175f4b34d31c469bf8">setPhysicalBoundaryConditions()</a>, and pre/postprocessRefine() are overloaded from the class <a class="el" href="classSAMRAI_1_1xfer_1_1RefinePatchStrategy.html">xfer::RefinePatchStrategy</a>. The operations pre/postprocessCoarsen() are overloaded from <a class="el" href="classSAMRAI_1_1xfer_1_1CoarsenPatchStrategy.html">xfer::CoarsenPatchStrategy</a>. The pre/postprocessCoarsen/Refine() operations are given empty implementations here so that the user does not need to proovide them if the operations are not needed.<p>
It is important to recognize that for the concrete patch strategy subclass and the <a class="el" href="classSAMRAI_1_1algs_1_1HyperbolicLevelIntegrator.html">HyperbolicLevelIntegrator</a> to work together, the concrete strategy must know which patch data to operate on. The patch data storage is manipulated by the level integrator. The set/clearDataContext() methods allow the integrator to inform the patch strategy of the correct data context. The concrete patch strategy subclass can access the appropriate context via the <a class="el" href="classSAMRAI_1_1algs_1_1HyperbolicPatchStrategy.html#e77e049ab5a575dc4eef7b870e8e428a">getDataContext()</a> method.<p>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classSAMRAI_1_1algs_1_1HyperbolicLevelIntegrator.html">algs::HyperbolicLevelIntegrator</a> <p>
<a class="el" href="classSAMRAI_1_1xfer_1_1RefinePatchStrategy.html">xfer::RefinePatchStrategy</a> <p>
<a class="el" href="classSAMRAI_1_1xfer_1_1CoarsenPatchStrategy.html">xfer::CoarsenPatchStrategy</a> </dd></dl>

<p>
<hr><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" name="bfdd7c8bf839dd3eef9de00f5dc35d98"></a><!-- doxytag: member="SAMRAI::algs::HyperbolicPatchStrategy::HyperbolicPatchStrategy" ref="bfdd7c8bf839dd3eef9de00f5dc35d98" args="(const tbox::Dimension &amp;dim)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SAMRAI::algs::HyperbolicPatchStrategy::HyperbolicPatchStrategy           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1tbox_1_1Dimension.html">tbox::Dimension</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>dim</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Blank constructor for <a class="el" href="classSAMRAI_1_1algs_1_1HyperbolicPatchStrategy.html">HyperbolicPatchStrategy</a>. 
</div>
</div><p>
<a class="anchor" name="6dee35e53e3f2a906eae433ab747dd42"></a><!-- doxytag: member="SAMRAI::algs::HyperbolicPatchStrategy::~HyperbolicPatchStrategy" ref="6dee35e53e3f2a906eae433ab747dd42" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SAMRAI::algs::HyperbolicPatchStrategy::~HyperbolicPatchStrategy           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Virtual destructor for <a class="el" href="classSAMRAI_1_1algs_1_1HyperbolicPatchStrategy.html">HyperbolicPatchStrategy</a>. 
</div>
</div><p>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="cca2469b4f8659d5e7dc41c1572853d0"></a><!-- doxytag: member="SAMRAI::algs::HyperbolicPatchStrategy::registerModelVariables" ref="cca2469b4f8659d5e7dc41c1572853d0" args="(HyperbolicLevelIntegrator *integrator)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void SAMRAI::algs::HyperbolicPatchStrategy::registerModelVariables           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1algs_1_1HyperbolicLevelIntegrator.html">HyperbolicLevelIntegrator</a> *&nbsp;</td>
          <td class="paramname"> <em>integrator</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Register specific variables needed in the numerical routines with the hyperbolic level integrator using the registerVariable() function in that class. The integrator manipulates storage for the data and this registration defines the way in which data for each quantity will be manipulated on the patches. Typically, the derived data quantities for plotting are registered with a visualization data writer in this routine as well, since the hyperbolic level integrator provides the variable context for plotting (i.e., which data is available when a plot file is generated). The integrator pointer cannot be null in most cases.<p>
The gridding algorithm pointer is provided so that patch data objects may be registered with the load balancer object (owned by the gridding algorithm) for non-uniform load balancing, if needed. 
</div>
</div><p>
<a class="anchor" name="0344a3099849a591f4d35ff3522745b0"></a><!-- doxytag: member="SAMRAI::algs::HyperbolicPatchStrategy::setupLoadBalancer" ref="0344a3099849a591f4d35ff3522745b0" args="(HyperbolicLevelIntegrator *integrator, mesh::GriddingAlgorithm *gridding_algorithm)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::algs::HyperbolicPatchStrategy::setupLoadBalancer           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1algs_1_1HyperbolicLevelIntegrator.html">HyperbolicLevelIntegrator</a> *&nbsp;</td>
          <td class="paramname"> <em>integrator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1mesh_1_1GriddingAlgorithm.html">mesh::GriddingAlgorithm</a> *&nbsp;</td>
          <td class="paramname"> <em>gridding_algorithm</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set up parameters in the load balancer object (owned by the gridding algorithm) if needed. This function is called immediately after the <a class="el" href="classSAMRAI_1_1algs_1_1HyperbolicPatchStrategy.html#cca2469b4f8659d5e7dc41c1572853d0">registerModelVariables()</a> function is called. The hyperbolic level integrator pointer is provided so that the integrator can be used to manage data for the load balancer if needed (e.g., when using non-uniform load balancing).<p>
Note that this function is not pure virtual. It is given a dummy implementation here so that users may ignore it when inheriting from this class. 
</div>
</div><p>
<a class="anchor" name="bcf54eff296e8898bb5c591aa17b5d68"></a><!-- doxytag: member="SAMRAI::algs::HyperbolicPatchStrategy::initializeDataOnPatch" ref="bcf54eff296e8898bb5c591aa17b5d68" args="(hier::Patch &amp;patch, const double data_time, const bool initial_time)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void SAMRAI::algs::HyperbolicPatchStrategy::initializeDataOnPatch           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1hier_1_1Patch.html">hier::Patch</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>patch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>data_time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&nbsp;</td>
          <td class="paramname"> <em>initial_time</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set the initial data on a patch interior only. Note that no ghost cells need to be set in this routine regardless of whether the patch data corresponding to the context requires ghost cells. The data_time is the simulation time when the routine is called. The boolean initial_time is true if the routine is called at the initial time when the hierarchy is initially constructed, otherwise it is false. 
</div>
</div><p>
<a class="anchor" name="9e803926bda95a5fb351472d082a1cfe"></a><!-- doxytag: member="SAMRAI::algs::HyperbolicPatchStrategy::computeStableDtOnPatch" ref="9e803926bda95a5fb351472d082a1cfe" args="(hier::Patch &amp;patch, const bool initial_time, const double dt_time)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual double SAMRAI::algs::HyperbolicPatchStrategy::computeStableDtOnPatch           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1hier_1_1Patch.html">hier::Patch</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>patch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&nbsp;</td>
          <td class="paramname"> <em>initial_time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>dt_time</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Compute the stable time increment for a patch on the level with the given number. The boolean flag initial_time is true if the routine is called at the initial simulation time; otherwise it is false. The double argument dt_time is the simulation time. 
</div>
</div><p>
<a class="anchor" name="c6440f00550554375dc58e31fe4bfb97"></a><!-- doxytag: member="SAMRAI::algs::HyperbolicPatchStrategy::computeFluxesOnPatch" ref="c6440f00550554375dc58e31fe4bfb97" args="(hier::Patch &amp;patch, const double time, const double dt)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void SAMRAI::algs::HyperbolicPatchStrategy::computeFluxesOnPatch           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1hier_1_1Patch.html">hier::Patch</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>patch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>dt</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Compute TIME INTEGRALS of fluxes to be used in conservative difference for patch integration. That is, it is assumed that this numerical routine will compute the fluxes corresponding to the cell faces multiplied by the time increment. Typically, the numerical flux is the normal flux at the cell face. The flux integrals will be used in the conservative difference that updates the conserved quantities.<p>
Note that the numerical routines in this method generally require ghost cells. Ghost cells data is filled before this routine is called. 
</div>
</div><p>
<a class="anchor" name="932547caed02bc084f8efce9e2d1d1e8"></a><!-- doxytag: member="SAMRAI::algs::HyperbolicPatchStrategy::conservativeDifferenceOnPatch" ref="932547caed02bc084f8efce9e2d1d1e8" args="(hier::Patch &amp;patch, const double time, const double dt, bool at_syncronization)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void SAMRAI::algs::HyperbolicPatchStrategy::conservativeDifferenceOnPatch           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1hier_1_1Patch.html">hier::Patch</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>patch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>dt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>at_syncronization</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Update patch data with a conservative difference (approximating the divergence theorem) using the flux integrals computed in <a class="el" href="classSAMRAI_1_1algs_1_1HyperbolicPatchStrategy.html#c6440f00550554375dc58e31fe4bfb97">computeFluxesOnPatch()</a> routine. The boolean flag is true when this routine is called during a flux synchronization step. Otherwise, it is false. Note that the <a class="el" href="classSAMRAI_1_1algs_1_1HyperbolicPatchStrategy.html#c6440f00550554375dc58e31fe4bfb97">computeFluxesOnPatch()</a> routine computes TIME INTEGRALs of the numerical fluxes (e.g., they have been multiplied by dt). So the conservative difference routine should be consistent with this. 
</div>
</div><p>
<a class="anchor" name="df9cb776823440d62de812382fffb86d"></a><!-- doxytag: member="SAMRAI::algs::HyperbolicPatchStrategy::preprocessAdvanceLevelState" ref="df9cb776823440d62de812382fffb86d" args="(const tbox::Pointer&lt; hier::PatchLevel &gt; &amp;level, double current_time, double dt, bool first_step, bool last_step, bool regrid_advance)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::algs::HyperbolicPatchStrategy::preprocessAdvanceLevelState           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchLevel.html">hier::PatchLevel</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>current_time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>dt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>first_step</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>last_step</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>regrid_advance</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This is an optional routine for user to process any application-specific patch strategy data BEFORE patches are advanced on the given level. This routine is called after patch boundary data is filled (i.e., ghosts) and before <a class="el" href="classSAMRAI_1_1algs_1_1HyperbolicPatchStrategy.html#c6440f00550554375dc58e31fe4bfb97">computeFluxesOnPatch()</a>. The arguments are: level -- level that will be advanced, current_time -- current integration time, dt -- current time increment, first_step -- boolean flag that is true if advance is first in time step sequence on level (i.e., previous advance step was on another level, false otherwise, last_step -- boolean flag that is true if advance is last in time step sequence on level (i.e., synchronization with coarser level will occur immediately after this advance), regrid_advance -- boolean flag that is true if the advance is during a regridding phase (i.e., the advance is not used to integrate data on the hierarchy) in which case the results of the advance will be discarded.<p>
Note that when this routine is called, the scratch data is filled on all patches (i.e., ghost cells) and that data is the same as the current level data on all patch interiors. That is, both scratch and current data correspond to current_time.<p>
Note that this function is not pure virtual. It is given a dummy implementation here so that users may ignore it when inheriting from this class. 
</div>
</div><p>
<a class="anchor" name="41982c51ee4f02590de5ea26c79fbaa3"></a><!-- doxytag: member="SAMRAI::algs::HyperbolicPatchStrategy::postprocessAdvanceLevelState" ref="41982c51ee4f02590de5ea26c79fbaa3" args="(const tbox::Pointer&lt; hier::PatchLevel &gt; &amp;level, double current_time, double dt, bool first_step, bool last_step, bool regrid_advance)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::algs::HyperbolicPatchStrategy::postprocessAdvanceLevelState           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchLevel.html">hier::PatchLevel</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>current_time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>dt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>first_step</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>last_step</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>regrid_advance</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This is an optional routine for user to process any application-specific patch strategy data AFTER patches are advanced on the given level. This routine is called after <a class="el" href="classSAMRAI_1_1algs_1_1HyperbolicPatchStrategy.html#932547caed02bc084f8efce9e2d1d1e8">conservativeDifferenceOnPatch()</a> is called and before <a class="el" href="classSAMRAI_1_1algs_1_1HyperbolicPatchStrategy.html#9e803926bda95a5fb351472d082a1cfe">computeStableDtOnPatch()</a>. The arguments are: level -- level that will be advanced, current_time -- current integration time, dt -- current time increment, first_step -- boolean flag that is true if advance is first in time step sequence on level (i.e., previous advance step was on another level, false otherwise, last_step -- boolean flag that is true if advance is last in time step sequence on level (i.e., synchronization with coarser level will occur immediately after this advance), regrid_advance -- boolean flag that is true if the advance is during a regridding phase (i.e., the advance is not used to integrate data on the hierarchy) in which case the results of the advance will be discarded.<p>
Note that when this routine is called, the scratch data is filled on all patches (i.e., ghost cells) and that data is the same as the new level data on all patch interiors. That is, both scratch and new data correspond to current_time + dt on patch interiors. The current data and ghost values correspond to the current_time.<p>
Note that this function is not pure virtual. It is given a dummy implementation here so that users may ignore it when inheriting from this class. 
</div>
</div><p>
<a class="anchor" name="780ff3b9eb4b2b686bd152a381ab80ec"></a><!-- doxytag: member="SAMRAI::algs::HyperbolicPatchStrategy::tagGradientDetectorCells" ref="780ff3b9eb4b2b686bd152a381ab80ec" args="(hier::Patch &amp;patch, const double regrid_time, const bool initial_error, const int tag_index, const bool uses_richardson_extrapolation_too)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::algs::HyperbolicPatchStrategy::tagGradientDetectorCells           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1hier_1_1Patch.html">hier::Patch</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>patch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>regrid_time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&nbsp;</td>
          <td class="paramname"> <em>initial_error</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>tag_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&nbsp;</td>
          <td class="paramname"> <em>uses_richardson_extrapolation_too</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Tag cells on the given patch that require refinement based on application-specific numerical quantities. The tag index argument indicates the index of the tag data on the patch data array. The boolean argument initial_error is true if tagging is being done at the initial simulation time; otherwise, it is false. The other boolean flag uses_richardson_extrapolation_too is true when Richardson extrapolation is used in addition to the gradient detector. This flag helps users manage multiple regridding criteria.<p>
Note that this function is not pure virtual. It is given a dummy implementation here so that users may ignore it when inheriting from this class. 
</div>
</div><p>
<a class="anchor" name="6fb37f917f199c5f10f6501414d5291c"></a><!-- doxytag: member="SAMRAI::algs::HyperbolicPatchStrategy::tagRichardsonExtrapolationCells" ref="6fb37f917f199c5f10f6501414d5291c" args="(hier::Patch &amp;patch, const int error_level_number, const tbox::Pointer&lt; hier::VariableContext &gt; coarsened_fine, const tbox::Pointer&lt; hier::VariableContext &gt; advanced_coarse, const double regrid_time, const double deltat, const int error_coarsen_ratio, const bool initial_error, const int tag_index, const bool uses_gradient_detector_too)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::algs::HyperbolicPatchStrategy::tagRichardsonExtrapolationCells           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1hier_1_1Patch.html">hier::Patch</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>patch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>error_level_number</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1VariableContext.html">hier::VariableContext</a> &gt;&nbsp;</td>
          <td class="paramname"> <em>coarsened_fine</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1VariableContext.html">hier::VariableContext</a> &gt;&nbsp;</td>
          <td class="paramname"> <em>advanced_coarse</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>regrid_time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>deltat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>error_coarsen_ratio</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&nbsp;</td>
          <td class="paramname"> <em>initial_error</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>tag_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&nbsp;</td>
          <td class="paramname"> <em>uses_gradient_detector_too</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Tag cells based from differences computed in the Richardson extrapolation. The Richardson extrapolation algorithm creates a coarsened version of some hierarchy patch level and advances data in time on both the coarsened patch level and the hierarchy level. This routine takes the data resulting from the advance on both the coarse and fine levels, compares them, and tags cells according to the difference. <div class="fragment"><pre class="fragment">    *              (2)
    *      n+1 ^-------&gt;x finish      (1) advanced_coarse
    *          |        ^             (2) coarsened_fine
    *  time  n -        |
    *          ^        |(1)
    *          |        |
    *          &lt;--------o start
    *        fine     coarse
    * </pre></div><p>
The patch supplied to this routine is on the coarsened level. However, the error_level_number corresponds to the actual hierarchy level from which it was coarsened. Data resides on this patch in two contexts - ``advanced_coarse'' and ``coarsened_fine''. Advanced coarse is data advanced on the coarsened version of the level, while coarsened fine is the data advanced on the fine level and then coarsened to the coarse level. The regrid time and the time increment are given for the actual hierarchy level. The error coarsen ratio argument is the ratio between the index spaces on the hierarchy level and the coarsened hierarchy level. The boolean flag ``initial_error'' is true when the error estimation is performed at the initial simulation time; i.e., when the hierarchy levels are being constructed for the first time. The tag index argument is the index of the tag data on the patch data array. The other boolean flag uses_gradient_detector_too is true when a gradient detector scheme is used in addition to Richardson extrapolation. This flag helps users manage multiple regridding criteria.<p>
Note that this function is not pure virtual. It is given a dummy implementation here so that users may ignore it when inheriting from this class. 
</div>
</div><p>
<a class="anchor" name="31f097ee69de5a175f4b34d31c469bf8"></a><!-- doxytag: member="SAMRAI::algs::HyperbolicPatchStrategy::setPhysicalBoundaryConditions" ref="31f097ee69de5a175f4b34d31c469bf8" args="(hier::Patch &amp;patch, const double fill_time, const hier::IntVector &amp;ghost_width_to_fill)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void SAMRAI::algs::HyperbolicPatchStrategy::setPhysicalBoundaryConditions           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1hier_1_1Patch.html">hier::Patch</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>patch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>fill_time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>ghost_width_to_fill</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set user-defined boundary conditions at the physical domain boundary. 
<p>
Implements <a class="el" href="classSAMRAI_1_1xfer_1_1RefinePatchStrategy.html#428a5d166ab97a9ce9c8344685817b26">SAMRAI::xfer::RefinePatchStrategy</a>.
</div>
</div><p>
<a class="anchor" name="63c4c0520b3c8eee51d337c2f6d337c0"></a><!-- doxytag: member="SAMRAI::algs::HyperbolicPatchStrategy::getRefineOpStencilWidth" ref="63c4c0520b3c8eee51d337c2f6d337c0" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a> SAMRAI::algs::HyperbolicPatchStrategy::getRefineOpStencilWidth           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return maximum stencil width needed for user-defined data interpolation operations. Default is to return zero, assuming no user-defined operations provided.<p>
Note that this function is not pure virtual. It is given a dummy implementation here so that users may ignore it when inheriting from this class. 
<p>
Implements <a class="el" href="classSAMRAI_1_1xfer_1_1RefinePatchStrategy.html#ac3c39692c90393a6748ea7a4f52facd">SAMRAI::xfer::RefinePatchStrategy</a>.
</div>
</div><p>
<a class="anchor" name="1c416232cfbb5e1ef07d860cff23f5fc"></a><!-- doxytag: member="SAMRAI::algs::HyperbolicPatchStrategy::preprocessRefine" ref="1c416232cfbb5e1ef07d860cff23f5fc" args="(hier::Patch &amp;fine, const hier::Patch &amp;coarse, const hier::Box &amp;fine_box, const hier::IntVector &amp;ratio)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::algs::HyperbolicPatchStrategy::preprocessRefine           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1hier_1_1Patch.html">hier::Patch</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>fine</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1Patch.html">hier::Patch</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>coarse</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">hier::Box</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>fine_box</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>ratio</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Pre- and post-processing routines for implementing user-defined spatial interpolation routines applied to variables. The interpolation routines are used in the hyperbolic AMR algorithm for filling patch ghost cells before advancing data on a level and after regridding a level to fill portions of the new level from some coarser level. These routines are called automatically from within patch boundary filling schedules; thus, some concrete function matching these signatures must be provided in the user's patch routines. However, the routines only need to perform some operations when "USER_DEFINED_REFINE" is given as the interpolation method for some variable when the patch routines register variables with the hyperbolic level integration algorithm, typically. If the user does not provide operations that refine such variables in either of these routines, then they will not be refined.<p>
The order in which these operations are used in each patch boundary filling schedule is:<p>
<ul>
<li><b></b>(1) {Call user's <a class="el" href="classSAMRAI_1_1algs_1_1HyperbolicPatchStrategy.html#1c416232cfbb5e1ef07d860cff23f5fc">preprocessRefine()</a> routine.}</li><li><b></b>(2) {Refine all variables with standard interpolation operators.}</li><li><b></b>(3) {Call user's <a class="el" href="classSAMRAI_1_1algs_1_1HyperbolicPatchStrategy.html#a48e4adfa76b1e3a672abef8a27c53f8">postprocessRefine()</a> routine.}</li></ul>
<p>
Note that these functions are not pure virtual. They are given dummy implementations here so that users may ignore them when inheriting from this class. 
<p>
Implements <a class="el" href="classSAMRAI_1_1xfer_1_1RefinePatchStrategy.html#c5d1588459650fb4ff5f7c5dd66ece46">SAMRAI::xfer::RefinePatchStrategy</a>.
</div>
</div><p>
<a class="anchor" name="a48e4adfa76b1e3a672abef8a27c53f8"></a><!-- doxytag: member="SAMRAI::algs::HyperbolicPatchStrategy::postprocessRefine" ref="a48e4adfa76b1e3a672abef8a27c53f8" args="(hier::Patch &amp;fine, const hier::Patch &amp;coarse, const hier::Box &amp;fine_box, const hier::IntVector &amp;ratio)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::algs::HyperbolicPatchStrategy::postprocessRefine           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1hier_1_1Patch.html">hier::Patch</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>fine</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1Patch.html">hier::Patch</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>coarse</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">hier::Box</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>fine_box</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>ratio</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Perform user-defined patch data refinement operations. 
<p>
This member function is called after standard refine operations (expressed using concrete subclasses of the RefineOperator base class). The preprocess function must refine data from the scratch components on the coarse patch into the scratch components of the fine patch on the specified fine box region. Recall that the scratch components are specified in calls to the registerRefine() function in the RefineAlgorithm class.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>fine</em>&nbsp;</td><td>Fine patch containing destination data. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>coarse</em>&nbsp;</td><td>Coarse patch containing source data. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>fine_box</em>&nbsp;</td><td>Box region on fine patch into which data is refined. *</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>ratio</em>&nbsp;</td><td>Refinement ratio between coarse and fine patches. </td></tr>
  </table>
</dl>

<p>
Implements <a class="el" href="classSAMRAI_1_1xfer_1_1RefinePatchStrategy.html#bd5a91534d2cd570b23e679555e4cf27">SAMRAI::xfer::RefinePatchStrategy</a>.
</div>
</div><p>
<a class="anchor" name="d9f2e566fe1cd9c77c65eaf2d396a0c2"></a><!-- doxytag: member="SAMRAI::algs::HyperbolicPatchStrategy::getCoarsenOpStencilWidth" ref="d9f2e566fe1cd9c77c65eaf2d396a0c2" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a> SAMRAI::algs::HyperbolicPatchStrategy::getCoarsenOpStencilWidth           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return maximum stencil width needed for user-defined data coarsen operations. Default is to return zero, assuming no user-defined operations provided.<p>
Note that this function is not pure virtual. It is given a dummy implementation here so that users may ignore it when inheriting from this class. 
<p>
Implements <a class="el" href="classSAMRAI_1_1xfer_1_1CoarsenPatchStrategy.html#50c94be067e77211d1c3b5c1e6c3b082">SAMRAI::xfer::CoarsenPatchStrategy</a>.
</div>
</div><p>
<a class="anchor" name="3480ca32124e2c7bb9964946b29db3b3"></a><!-- doxytag: member="SAMRAI::algs::HyperbolicPatchStrategy::preprocessCoarsen" ref="3480ca32124e2c7bb9964946b29db3b3" args="(hier::Patch &amp;coarse, const hier::Patch &amp;fine, const hier::Box &amp;coarse_box, const hier::IntVector &amp;ratio)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::algs::HyperbolicPatchStrategy::preprocessCoarsen           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1hier_1_1Patch.html">hier::Patch</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>coarse</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1Patch.html">hier::Patch</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>fine</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">hier::Box</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>coarse_box</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>ratio</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Pre- and post-processing routines for implementing user-defined spatial coarsening routines applied to variables. The coarsening routines are used in the hyperbolic AMR algorithm synchronizing coarse and fine levels when they have been integrated to the same point. These routines are called automatically from within the data synchronization coarsen schedules; thus, some concrete function matching these signatures must be provided in the user's patch routines. However, the routines only need to perform some operations when "USER_DEFINED_COARSEN" is given as the coarsening method for some variable when the patch routines register variables with the hyperbolic level integration algorithm, typically. If the user does not provide operations that coarsen such variables in either of these routines, then they will not be coarsened.<p>
The order in which these operations are used in each coarsening schedule is:<p>
<ul>
<li><b></b>(1) {Call user's <a class="el" href="classSAMRAI_1_1algs_1_1HyperbolicPatchStrategy.html#3480ca32124e2c7bb9964946b29db3b3">preprocessCoarsen()</a> routine.}</li><li><b></b>(2) {Coarsen all variables with standard coarsening operators.}</li><li><b></b>(3) {Call user's <a class="el" href="classSAMRAI_1_1algs_1_1HyperbolicPatchStrategy.html#c049b88562fdf98350513952fb604176">postprocessCoarsen()</a> routine.}</li></ul>
<p>
Note that these functions are not pure virtual. They are given dummy implementations here so that users may ignore them when inheriting from this class. 
<p>
Implements <a class="el" href="classSAMRAI_1_1xfer_1_1CoarsenPatchStrategy.html#0814ce9491959240638a20bd848a2350">SAMRAI::xfer::CoarsenPatchStrategy</a>.
</div>
</div><p>
<a class="anchor" name="c049b88562fdf98350513952fb604176"></a><!-- doxytag: member="SAMRAI::algs::HyperbolicPatchStrategy::postprocessCoarsen" ref="c049b88562fdf98350513952fb604176" args="(hier::Patch &amp;coarse, const hier::Patch &amp;fine, const hier::Box &amp;coarse_box, const hier::IntVector &amp;ratio)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::algs::HyperbolicPatchStrategy::postprocessCoarsen           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1hier_1_1Patch.html">hier::Patch</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>coarse</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1Patch.html">hier::Patch</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>fine</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">hier::Box</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>coarse_box</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>ratio</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Perform user-defined patch data coarsening operations. 
<p>
This member function is called after standard coarsening operations (expressed using concrete subclasses of the CoarsenOperator base class). The postprocess function should move data from the source components on the fine patch into the source components on the coarse patch in the specified coarse box region. Recall that the source components are specified in calls to the registerCoarsen() function in the CoarsenAlgorithm class.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>coarse[out]</em>&nbsp;</td><td>Coarse patch that will receive coarsened data. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>fine[in]</em>&nbsp;</td><td>Fine patch containing source data. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>coarse_box[in]</em>&nbsp;</td><td><a class="el" href="classSAMRAI_1_1hier_1_1Box.html">hier::Box</a> region on coarse patch into which data is coarsened. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ratio[in]</em>&nbsp;</td><td>Refinement ratio between coarse and fine patches. </td></tr>
  </table>
</dl>

<p>
Implements <a class="el" href="classSAMRAI_1_1xfer_1_1CoarsenPatchStrategy.html#a2d42bd7e5e5b39581df0d5a15059a33">SAMRAI::xfer::CoarsenPatchStrategy</a>.
</div>
</div><p>
<a class="anchor" name="e77e049ab5a575dc4eef7b870e8e428a"></a><!-- doxytag: member="SAMRAI::algs::HyperbolicPatchStrategy::getDataContext" ref="e77e049ab5a575dc4eef7b870e8e428a" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1VariableContext.html">hier::VariableContext</a> &gt; SAMRAI::algs::HyperbolicPatchStrategy::getDataContext           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return pointer to patch data context. 
</div>
</div><p>
<a class="anchor" name="abb02eb6de95b63c5dd7d54c4b5cf340"></a><!-- doxytag: member="SAMRAI::algs::HyperbolicPatchStrategy::setDataContext" ref="abb02eb6de95b63c5dd7d54c4b5cf340" args="(tbox::Pointer&lt; hier::VariableContext &gt; context)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::algs::HyperbolicPatchStrategy::setDataContext           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1VariableContext.html">hier::VariableContext</a> &gt;&nbsp;</td>
          <td class="paramname"> <em>context</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The hyperbolic integrator controls the context for the data to be used in the numerical routines implemented in the concrete patch strategy. The <a class="el" href="classSAMRAI_1_1algs_1_1HyperbolicPatchStrategy.html#abb02eb6de95b63c5dd7d54c4b5cf340">setDataContext()</a> allows the integrator to set the context for data on a patch on which to operate. 
</div>
</div><p>
<a class="anchor" name="bd85a561841ad406095e47db1d6d7e64"></a><!-- doxytag: member="SAMRAI::algs::HyperbolicPatchStrategy::clearDataContext" ref="bd85a561841ad406095e47db1d6d7e64" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::algs::HyperbolicPatchStrategy::clearDataContext           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The <a class="el" href="classSAMRAI_1_1algs_1_1HyperbolicPatchStrategy.html#bd85a561841ad406095e47db1d6d7e64">clearDataContext()</a> routine resets the data context to be null. 
</div>
</div><p>
<a class="anchor" name="81deadcfc673b84af5ca41898f4cd8c2"></a><!-- doxytag: member="SAMRAI::algs::HyperbolicPatchStrategy::getDim" ref="81deadcfc673b84af5ca41898f4cd8c2" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classSAMRAI_1_1tbox_1_1Dimension.html">tbox::Dimension</a> &amp; SAMRAI::algs::HyperbolicPatchStrategy::getDim           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return the dimension of this object. 
<p>

<p>
Reimplemented from <a class="el" href="classSAMRAI_1_1xfer_1_1CoarsenPatchStrategy.html#65bb799b527cc3099d996eb38d6670ae">SAMRAI::xfer::CoarsenPatchStrategy</a>.
</div>
</div><p>
<hr>The documentation for this class was generated from the following files:<ul>
<li>source/SAMRAI/algs/<a class="el" href="HyperbolicPatchStrategy_8h.html">HyperbolicPatchStrategy.h</a><li>source/SAMRAI/algs/<a class="el" href="HyperbolicPatchStrategy_8C.html">HyperbolicPatchStrategy.C</a></ul>
<hr size="1"><address style="align: right;"><small>Generated on Fri Mar 16 14:34:16 2012 for SAMRAI by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.7 </small></address>
</body>
</html>
