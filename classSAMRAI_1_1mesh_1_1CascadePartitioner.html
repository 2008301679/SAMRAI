<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>SAMRAI: SAMRAI::mesh::CascadePartitioner Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath"><a class="el" href="namespaceSAMRAI.html">SAMRAI</a>::<a class="el" href="namespaceSAMRAI_1_1mesh.html">mesh</a>::<a class="el" href="classSAMRAI_1_1mesh_1_1CascadePartitioner.html">CascadePartitioner</a>
  </div>
</div>
<div class="contents">
<h1>SAMRAI::mesh::CascadePartitioner Class Reference</h1><!-- doxytag: class="SAMRAI::mesh::CascadePartitioner" --><!-- doxytag: inherits="SAMRAI::mesh::LoadBalanceStrategy" -->
<p>Provides load balancing routines for AMR hierarchy by implemementing the LoadBalancerStrategy using the cascade partitioning algorithm.  
<a href="#_details">More...</a></p>

<p><code>#include &lt;source/SAMRAI/mesh/CascadePartitioner.h&gt;</code></p>
<div class="dynheader">
Inheritance diagram for SAMRAI::mesh::CascadePartitioner:</div>
<div class="dynsection">
 <div class="center">
  <img src="classSAMRAI_1_1mesh_1_1CascadePartitioner.gif" usemap="#SAMRAI::mesh::CascadePartitioner_map" alt=""/>
  <map id="SAMRAI::mesh::CascadePartitioner_map" name="SAMRAI::mesh::CascadePartitioner_map">
<area href="classSAMRAI_1_1mesh_1_1LoadBalanceStrategy.html" alt="SAMRAI::mesh::LoadBalanceStrategy" shape="rect" coords="0,0,222,24"/>
</map>
 </div>
</div>

<p><a href="classSAMRAI_1_1mesh_1_1CascadePartitioner-members.html">List of all members.</a></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1mesh_1_1CascadePartitioner.html#a143cef8d3e0e0d88e549862fcd1fa078">CascadePartitioner</a> (const <a class="el" href="classSAMRAI_1_1tbox_1_1Dimension.html">tbox::Dimension</a> &amp;dim, const std::string &amp;name, const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Database.html">tbox::Database</a> &gt; &amp;input_db=boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Database.html">tbox::Database</a> &gt;())</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Initializing constructor sets object state to default or, if database provided, to parameters in database.  <a href="#a143cef8d3e0e0d88e549862fcd1fa078"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1mesh_1_1CascadePartitioner.html#a6e839ee2c8c4fbd6d9b5dd290a731980">~CascadePartitioner</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Virtual destructor releases all internal storage.  <a href="#a6e839ee2c8c4fbd6d9b5dd290a731980"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1mesh_1_1CascadePartitioner.html#ab1c33f6a247c8e0d28b718365ea1365a">setSAMRAI_MPI</a> (const <a class="el" href="classSAMRAI_1_1tbox_1_1SAMRAI__MPI.html">tbox::SAMRAI_MPI</a> &amp;samrai_mpi)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the internal SAMRAI_MPI to a duplicate of the given SAMRAI_MPI.  <a href="#ab1c33f6a247c8e0d28b718365ea1365a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1mesh_1_1CascadePartitioner.html#a549aa54ee73d30dcd6089dca661e4cf6">freeMPICommunicator</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Free the internal MPI communicator, if any has been set.  <a href="#a549aa54ee73d30dcd6089dca661e4cf6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1mesh_1_1CascadePartitioner.html#a458871a2c15bc9a1d8cbfb6d82412b33">loadBalanceBoxLevel</a> (<a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">hier::BoxLevel</a> &amp;balance_box_level, <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">hier::Connector</a> *balance_to_anchor, const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchHierarchy.html">hier::PatchHierarchy</a> &gt; &amp;hierarchy, const int level_number, const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a> &amp;min_size, const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a> &amp;max_size, const <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">hier::BoxLevel</a> &amp;domain_box_level, const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a> &amp;bad_interval, const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a> &amp;cut_factor, const <a class="el" href="classSAMRAI_1_1tbox_1_1RankGroup.html">tbox::RankGroup</a> &amp;rank_group=<a class="el" href="classSAMRAI_1_1tbox_1_1RankGroup.html">tbox::RankGroup</a>()) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1mesh_1_1CascadePartitioner.html#ae254e7bec4e2dab59e91c25128e6fa82">printStatistics</a> (std::ostream &amp;output_stream=<a class="el" href="namespaceSAMRAI_1_1tbox.html#ab84041705493761fb17a8127e3a2dca2">tbox::plog</a>) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Write out statistics recorded for the most recent load balancing result.  <a href="#ae254e7bec4e2dab59e91c25128e6fa82"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const std::string &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1mesh_1_1CascadePartitioner.html#a1ce283a3904dd729cadffd4dc36b2341">getObjectName</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the name of this object.  <a href="#a1ce283a3904dd729cadffd4dc36b2341"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1mesh_1_1CascadePartitioner.html#a63ed88fe11c46bcddad860f23463cc7e">setWorkloadPatchDataIndex</a> (int data_id, int level_number=-1)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Configure the load balancer to use the data stored in the hierarchy at the specified descriptor index for estimating the workload on each cell.  <a href="#a63ed88fe11c46bcddad860f23463cc7e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1mesh_1_1CascadePartitioner.html#a132a7972786a2230b6035a3dbf2cd07d">getLoadBalanceDependsOnPatchData</a> (int level_number) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return true if load balancing procedure for given level depends on patch data on <a class="el" href="namespaceSAMRAI_1_1mesh.html">mesh</a>; otherwise return false.  <a href="#a132a7972786a2230b6035a3dbf2cd07d"></a><br/></td></tr>
<tr><td colspan="2"><h2>Friends</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1mesh_1_1CascadePartitioner.html#a5c31968636b34bf25ed3aa27b5444f76">CascadePartitionerTree</a></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>Provides load balancing routines for AMR hierarchy by implemementing the LoadBalancerStrategy using the cascade partitioning algorithm. </p>
<p>The algorithm is described in the article "Advances in Patch-Based
 Adaptive Mesh Refinement Scalability" submitted to JPDC. Scaling benchmark results are also in the article.</p>
<p>Currently, only uniform load balancing is supported. Eventually, non-uniform load balancing should be supported. (Non-uniform load balancing is supported by the CutAndPackLoadBalancer class.)</p>
<p><b> Input Parameters </b></p>
<p><b> Definitions: </b></p>
<ul>
<li><b>flexible_load_tolerance</b> Fraction of ideal load a process can take on in order to reduce box cutting and load movement. Higher values often reduce partitioning time and box count but produce less balanced work loads. Surplus work greater than this tolerance can still result due to other constraints, such as minimum box size.</li>
</ul>
<ul>
<li><b>tile_size</b> Tile size when using tile mode. Tile mode restricts box cuts to tile boundaries. Default is 1, which is equivalent to no restriction.</li>
</ul>
<ul>
<li><b>max_spread_procs</b> This parameter limits how many processes may receive the load of one process before updating Connectors. If a process has too much initial load, this limit causes the Connector to be updated gradually, alleviating the bottle-neck of one process doing an excessive amount of Connector updates.</li>
</ul>
<p><b> Details: </b> <br/>
 </p>
<table border="1" cellspacing="3" cellpadding="3">
<tr>
<th><p>parameter </p>
</th><th><p>type </p>
</th><th><p>default </p>
</th><th><p>range </p>
</th><th><p>opt/req </p>
</th><th><p>behavior on restart  </p>
</th></tr>
<tr>
<td><p>flexible_load_tolerance </p>
</td><td><p>double </p>
</td><td><p>0.05 </p>
</td><td><p>0-1 </p>
</td><td><p>opt </p>
</td><td><p>Not written to restart. Value in input db used.  </p>
</td></tr>
<tr>
<td><p>tile_size </p>
</td><td><p>IntVector </p>
</td><td><p>1 </p>
</td><td><p>1- </p>
</td><td><p>opt </p>
</td><td><p>Not written to restart. Value in input db used.  </p>
</td></tr>
<tr>
<td><p>max_spread_procs </p>
</td><td><p>int </p>
</td><td><p>500 </p>
</td><td><p>&gt; 1 </p>
</td><td><p>opt </p>
</td><td><p>Not written to restart. Value in input db used.  </p>
</td></tr>
</table>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a143cef8d3e0e0d88e549862fcd1fa078"></a><!-- doxytag: member="SAMRAI::mesh::CascadePartitioner::CascadePartitioner" ref="a143cef8d3e0e0d88e549862fcd1fa078" args="(const tbox::Dimension &amp;dim, const std::string &amp;name, const boost::shared_ptr&lt; tbox::Database &gt; &amp;input_db=boost::shared_ptr&lt; tbox::Database &gt;())" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SAMRAI::mesh::CascadePartitioner::CascadePartitioner </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1tbox_1_1Dimension.html">tbox::Dimension</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>dim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Database.html">tbox::Database</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>input_db</em> = <code>boost::shared_ptr&lt;<a class="el" href="classSAMRAI_1_1tbox_1_1Database.html">tbox::Database</a>&gt;()</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Initializing constructor sets object state to default or, if database provided, to parameters in database. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>dim</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>name</em>&nbsp;</td><td>User-defined identifier used for error reporting and timer names.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>input_db</em>&nbsp;</td><td>(optional) database pointer providing parameters from input file. This pointer may be null indicating no input is used.</td></tr>
  </table>
  </dd>
</dl>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>!name.empty() </dd></dl>

<p>References <a class="el" href="AsyncCommStage_8h_source.html#l00508">SAMRAI::tbox::AsyncCommStage::setCommunicationWaitTimer()</a>, <a class="el" href="MappingConnectorAlgorithm_8C_source.html#l01484">SAMRAI::hier::MappingConnectorAlgorithm::setTimerPrefix()</a>, and <a class="el" href="Utilities_8h_source.html#l00110">TBOX_ASSERT</a>.</p>

</div>
</div>
<a class="anchor" id="a6e839ee2c8c4fbd6d9b5dd290a731980"></a><!-- doxytag: member="SAMRAI::mesh::CascadePartitioner::~CascadePartitioner" ref="a6e839ee2c8c4fbd6d9b5dd290a731980" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SAMRAI::mesh::CascadePartitioner::~CascadePartitioner </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Virtual destructor releases all internal storage. </p>

<p>References <a class="el" href="CascadePartitioner_8C_source.html#l00594">freeMPICommunicator()</a>.</p>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="ab1c33f6a247c8e0d28b718365ea1365a"></a><!-- doxytag: member="SAMRAI::mesh::CascadePartitioner::setSAMRAI_MPI" ref="ab1c33f6a247c8e0d28b718365ea1365a" args="(const tbox::SAMRAI_MPI &amp;samrai_mpi)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::mesh::CascadePartitioner::setSAMRAI_MPI </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1tbox_1_1SAMRAI__MPI.html">tbox::SAMRAI_MPI</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>samrai_mpi</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set the internal SAMRAI_MPI to a duplicate of the given SAMRAI_MPI. </p>
<p>The given SAMRAI_MPI must have a valid communicator.</p>
<p>The given SAMRAI_MPI is duplicated for private use. This requires a global communication, so all processes in the communicator must call it. The advantage of a duplicate communicator is that it ensures the communications for the object won't accidentally interact with unrelated communications.</p>
<p>If the duplicate SAMRAI_MPI it is set, the <a class="el" href="classSAMRAI_1_1mesh_1_1CascadePartitioner.html" title="Provides load balancing routines for AMR hierarchy by implemementing the LoadBalancerStrategy...">CascadePartitioner</a> will only balance BoxLevels with congruent SAMRAI_MPI objects and will use the duplicate SAMRAI_MPI for communications. Otherwise, the SAMRAI_MPI of the BoxLevel will be used. The duplicate MPI communicator is freed when the object is destructed, or <a class="el" href="classSAMRAI_1_1mesh_1_1CascadePartitioner.html#a549aa54ee73d30dcd6089dca661e4cf6" title="Free the internal MPI communicator, if any has been set.">freeMPICommunicator()</a> is called.</p>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>samrai_mpi.getCommunicator() != <a class="el" href="classSAMRAI_1_1tbox_1_1SAMRAI__MPI.html#a67e6d6d61130222eed33f37725be9b8c">tbox::SAMRAI_MPI::commNull</a> </dd></dl>

<p>References <a class="el" href="SAMRAI__MPI_8h_source.html#l00145">SAMRAI::tbox::SAMRAI_MPI::commNull</a>, <a class="el" href="SAMRAI__MPI_8C_source.html#l01583">SAMRAI::tbox::SAMRAI_MPI::dupCommunicator()</a>, <a class="el" href="SAMRAI__MPI_8C_source.html#l01608">SAMRAI::tbox::SAMRAI_MPI::freeCommunicator()</a>, <a class="el" href="SAMRAI__MPI_8h_source.html#l00233">SAMRAI::tbox::SAMRAI_MPI::getCommunicator()</a>, <a class="el" href="MappingConnectorAlgorithm_8C_source.html#l00085">SAMRAI::hier::MappingConnectorAlgorithm::setSAMRAI_MPI()</a>, and <a class="el" href="Utilities_8h_source.html#l00060">TBOX_ERROR</a>.</p>

</div>
</div>
<a class="anchor" id="a549aa54ee73d30dcd6089dca661e4cf6"></a><!-- doxytag: member="SAMRAI::mesh::CascadePartitioner::freeMPICommunicator" ref="a549aa54ee73d30dcd6089dca661e4cf6" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::mesh::CascadePartitioner::freeMPICommunicator </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Free the internal MPI communicator, if any has been set. </p>
<p>This is automatically done by the destructor, if needed.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classSAMRAI_1_1mesh_1_1CascadePartitioner.html#ab1c33f6a247c8e0d28b718365ea1365a" title="Set the internal SAMRAI_MPI to a duplicate of the given SAMRAI_MPI.">setSAMRAI_MPI()</a>. </dd></dl>

<p>References <a class="el" href="SAMRAI__MPI_8h_source.html#l00145">SAMRAI::tbox::SAMRAI_MPI::commNull</a>, <a class="el" href="SAMRAI__MPI_8C_source.html#l00368">SAMRAI::tbox::SAMRAI_MPI::Finalized()</a>, <a class="el" href="SAMRAI__MPI_8C_source.html#l01608">SAMRAI::tbox::SAMRAI_MPI::freeCommunicator()</a>, <a class="el" href="SAMRAI__MPI_8h_source.html#l00233">SAMRAI::tbox::SAMRAI_MPI::getCommunicator()</a>, <a class="el" href="SAMRAI__MPI_8h_source.html#l00037">MPI_COMM_NULL</a>, and <a class="el" href="SAMRAI__MPI_8C_source.html#l01654">SAMRAI::tbox::SAMRAI_MPI::setCommunicator()</a>.</p>

<p>Referenced by <a class="el" href="CascadePartitioner_8C_source.html#l00109">~CascadePartitioner()</a>.</p>

</div>
</div>
<a class="anchor" id="a458871a2c15bc9a1d8cbfb6d82412b33"></a><!-- doxytag: member="SAMRAI::mesh::CascadePartitioner::loadBalanceBoxLevel" ref="a458871a2c15bc9a1d8cbfb6d82412b33" args="(hier::BoxLevel &amp;balance_box_level, hier::Connector *balance_to_anchor, const boost::shared_ptr&lt; hier::PatchHierarchy &gt; &amp;hierarchy, const int level_number, const hier::IntVector &amp;min_size, const hier::IntVector &amp;max_size, const hier::BoxLevel &amp;domain_box_level, const hier::IntVector &amp;bad_interval, const hier::IntVector &amp;cut_factor, const tbox::RankGroup &amp;rank_group=tbox::RankGroup()) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::mesh::CascadePartitioner::loadBalanceBoxLevel </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">hier::BoxLevel</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>balance_box_level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">hier::Connector</a> *&nbsp;</td>
          <td class="paramname"> <em>balance_to_anchor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchHierarchy.html">hier::PatchHierarchy</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>hierarchy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>level_number</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>min_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>max_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">hier::BoxLevel</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>domain_box_level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>bad_interval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>cut_factor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1tbox_1_1RankGroup.html">tbox::RankGroup</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>rank_group</em> = <code><a class="el" href="classSAMRAI_1_1tbox_1_1RankGroup.html">tbox::RankGroup</a>()</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Given a BoxLevel, representing the domain of a specified level in the AMR hierarchy, generate a new BoxLevel from which the patches for the level may be formed and update two Connectors incident on the changed BoxLevel. The union of the boxes in the balance_box_level is the same before and after the the method call.<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>balance_box_level</em>&nbsp;</td><td>Input BoxLevel. On input, this is the pre-balance BoxLevel. On output, it is the balanced BoxLevel.</td></tr>
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>balance_to_anchor</em>&nbsp;</td><td>Connector between the balance_box_level and some given "anchor box_level". This must be accurate on input. On putput, connects the newly balanced balance_box_level to the anchor box_level. If set to NULL, this parameter is ignored and Connector update is skipped.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>hierarchy</em>&nbsp;</td><td>The hierarchy where the work distribution data lives.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>level_number</em>&nbsp;</td><td>The number of the level where the work distribution data lives.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>min_size</em>&nbsp;</td><td><a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html" title="Simple integer vector class with size based on a dimension value.">hier::IntVector</a> representing mimimum box size.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>max_size</em>&nbsp;</td><td><a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html" title="Simple integer vector class with size based on a dimension value.">hier::IntVector</a> representing maximum box size.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>domain_box_level</em>&nbsp;</td><td>Description of the domain.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>bad_interval</em>&nbsp;</td><td><a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html" title="Simple integer vector class with size based on a dimension value.">hier::IntVector</a> indicating the length of an interval of cells along each side of the box where chopping the box may produce boxes with certain "bad" properties. For example, this is primiarily used to avoid generating ghost regions for patches that intersect the domain boundary in ways that may it difficult for a use to provide boundary values. Thus, it is typically related to the maximum ghost cell width in the problem. See <a class="el" href="structSAMRAI_1_1hier_1_1BoxUtilities.html">hier::BoxUtilities</a> header file for more information.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>cut_factor</em>&nbsp;</td><td><a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html" title="Simple integer vector class with size based on a dimension value.">hier::IntVector</a> indicating factor for chopping each side of a box; i.e., after chopping a box, the number of cells along each direction of each piece must be an integer multiple of the corresponding entry in the cut factor vector. For example, the cut factor may be related to the coarsen ratio between levels in the hierarchy in which case it may be used to produce boxes that can be coarsened by a certain factor if needed. See <a class="el" href="structSAMRAI_1_1hier_1_1BoxUtilities.html">hier::BoxUtilities</a> header file for more information.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>rank_group</em>&nbsp;</td><td>Input <a class="el" href="classSAMRAI_1_1tbox_1_1RankGroup.html">tbox::RankGroup</a> indicating a set of ranks on which all boxes in the output balance_box_level will be restricted. Some child classes may not make use of this argument. </td></tr>
  </table>
  </dd>
</dl>
</p>
<p>Note: This implementation does not yet support non-uniform load balancing.</p>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>!balance_to_anchor || balance_to_anchor-&gt;hasTranspose() </dd>
<dd>
!balance_to_anchor || balance_to_anchor-&gt;isTransposeOf(balance_to_anchor-&gt;getTranspose()) </dd>
<dd>
(d_dim == balance_box_level.getDim()) &amp;&amp; (d_dim == min_size.getDim()) &amp;&amp; (d_dim == max_size.getDim()) &amp;&amp; (d_dim == domain_box_level.getDim()) &amp;&amp; (d_dim == bad_interval.getDim()) &amp;&amp; (d_dim == cut_factor.getDim()) </dd>
<dd>
!hierarchy || (d_dim == hierarchy-&gt;getDim()) </dd>
<dd>
!d_mpi_is_dupe || (d_mpi.getSize() == balance_box_level.getMPI().getSize()) </dd>
<dd>
!d_mpi_is_dupe || (d_mpi.getSize() == balance_box_level.getMPI().getRank()) </dd></dl>

<p>Implements <a class="el" href="classSAMRAI_1_1mesh_1_1LoadBalanceStrategy.html#a2a6934691d740a0930f1644d5271d6b2">SAMRAI::mesh::LoadBalanceStrategy</a>.</p>

<p>References <a class="el" href="Connector_8C_source.html#l02205">SAMRAI::hier::Connector::checkOverlapCorrectness()</a>, <a class="el" href="Connector_8C_source.html#l01635">SAMRAI::hier::Connector::checkTransposeCorrectness()</a>, <a class="el" href="Connector_8h_source.html#l01487">SAMRAI::hier::Connector::format()</a>, <a class="el" href="BoxLevel_8C_source.html#l01642">SAMRAI::hier::BoxLevel::format()</a>, <a class="el" href="Connector_8h_source.html#l00753">SAMRAI::hier::Connector::getBase()</a>, <a class="el" href="BoxLevel_8h_source.html#l00521">SAMRAI::hier::BoxLevel::getBoxes()</a>, <a class="el" href="BoxLevel_8h_source.html#l00859">SAMRAI::hier::BoxLevel::getGridGeometry()</a>, <a class="el" href="BoxLevel_8h_source.html#l00596">SAMRAI::hier::BoxLevel::getLocalNumberOfBoxes()</a>, <a class="el" href="BoxLevel_8h_source.html#l00398">SAMRAI::hier::BoxLevel::getMPI()</a>, <a class="el" href="IntVector_8h_source.html#l00214">SAMRAI::hier::IntVector::getNumBlocks()</a>, <a class="el" href="IntVector_8h_source.html#l01143">SAMRAI::hier::IntVector::getOne()</a>, <a class="el" href="SAMRAI__MPI_8h_source.html#l00214">SAMRAI::tbox::SAMRAI_MPI::getRank()</a>, <a class="el" href="BoxLevel_8h_source.html#l00583">SAMRAI::hier::BoxLevel::getRefinementRatio()</a>, <a class="el" href="SAMRAI__MPI_8h_source.html#l00224">SAMRAI::tbox::SAMRAI_MPI::getSize()</a>, <a class="el" href="Connector_8h_source.html#l01147">SAMRAI::hier::Connector::getTranspose()</a>, <a class="el" href="Dimension_8h_source.html#l00136">SAMRAI::tbox::Dimension::getValue()</a>, <a class="el" href="Connector_8h_source.html#l01136">SAMRAI::hier::Connector::hasTranspose()</a>, <a class="el" href="SAMRAI__MPI_8h_source.html#l00307">SAMRAI::tbox::SAMRAI_MPI::isCongruentWith()</a>, <a class="el" href="Connector_8C_source.html#l01314">SAMRAI::hier::Connector::isTransposeOf()</a>, <a class="el" href="Utilities_8h_source.html#l00050">NULL_USE</a>, <a class="el" href="namespaceSAMRAI_1_1tbox.html#ad72fd66574b63c87061563d2c66b5475">SAMRAI::tbox::perr</a>, <a class="el" href="namespaceSAMRAI_1_1tbox.html#ab84041705493761fb17a8127e3a2dca2">SAMRAI::tbox::plog</a>, <a class="el" href="BalanceUtilities_8C_source.html#l01906">SAMRAI::mesh::BalanceUtilities::reduceAndReportLoadBalance()</a>, <a class="el" href="BoxLevel_8C_source.html#l00440">SAMRAI::hier::BoxLevel::removePeriodicImageBoxes()</a>, <a class="el" href="Connector_8h_source.html#l00605">SAMRAI::hier::Connector::removePeriodicRelationships()</a>, <a class="el" href="Connector_8C_source.html#l00996">SAMRAI::hier::Connector::setBase()</a>, <a class="el" href="RankGroup_8C_source.html#l00223">SAMRAI::tbox::RankGroup::size()</a>, <a class="el" href="Utilities_8h_source.html#l00110">TBOX_ASSERT</a>, <a class="el" href="Utilities_8h_source.html#l00233">TBOX_ASSERT_DIM_OBJDIM_EQUALITY1</a>, <a class="el" href="Utilities_8h_source.html#l00274">TBOX_ASSERT_DIM_OBJDIM_EQUALITY6</a>, and <a class="el" href="Utilities_8h_source.html#l00060">TBOX_ERROR</a>.</p>

</div>
</div>
<a class="anchor" id="ae254e7bec4e2dab59e91c25128e6fa82"></a><!-- doxytag: member="SAMRAI::mesh::CascadePartitioner::printStatistics" ref="ae254e7bec4e2dab59e91c25128e6fa82" args="(std::ostream &amp;output_stream=tbox::plog) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::mesh::CascadePartitioner::printStatistics </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&nbsp;</td>
          <td class="paramname"> <em>output_stream</em> = <code><a class="el" href="namespaceSAMRAI_1_1tbox.html#ab84041705493761fb17a8127e3a2dca2">tbox::plog</a></code></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Write out statistics recorded for the most recent load balancing result. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>output_stream</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="SAMRAI__MPI_8h_source.html#l00166">SAMRAI::tbox::SAMRAI_MPI::getSAMRAIWorld()</a>, and <a class="el" href="BalanceUtilities_8C_source.html#l01906">SAMRAI::mesh::BalanceUtilities::reduceAndReportLoadBalance()</a>.</p>

</div>
</div>
<a class="anchor" id="a1ce283a3904dd729cadffd4dc36b2341"></a><!-- doxytag: member="SAMRAI::mesh::CascadePartitioner::getObjectName" ref="a1ce283a3904dd729cadffd4dc36b2341" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::string&amp; SAMRAI::mesh::CascadePartitioner::getObjectName </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the name of this object. </p>

</div>
</div>
<a class="anchor" id="a63ed88fe11c46bcddad860f23463cc7e"></a><!-- doxytag: member="SAMRAI::mesh::CascadePartitioner::setWorkloadPatchDataIndex" ref="a63ed88fe11c46bcddad860f23463cc7e" args="(int data_id, int level_number=&#45;1)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::mesh::CascadePartitioner::setWorkloadPatchDataIndex </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>data_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>level_number</em> = <code>-1</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Configure the load balancer to use the data stored in the hierarchy at the specified descriptor index for estimating the workload on each cell. </p>
<p>Note: This method currently does not affect the results because this class does not yet support uniform load balancing.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>data_id</em>&nbsp;</td><td>Integer value of patch data identifier for workload estimate on each cell. An invalid value (i.e., &lt; 0) indicates that a spatially-uniform work estimate will be used. The default value is -1 (undefined) implying the uniform work estimate.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>level_number</em>&nbsp;</td><td>Optional integer number for level on which data id is used. If no value is given, the data will be used for all levels.</td></tr>
  </table>
  </dd>
</dl>
<dl class="pre"><dt><b>Precondition:</b></dt><dd><a class="el" href="classSAMRAI_1_1hier_1_1VariableDatabase.html#a9a9b3b6122833db2716a3a600dfa12e3" title="Return a pointer to the singleton variable database instance.">hier::VariableDatabase::getDatabase()</a>-&gt;getPatchDescriptor()-&gt;getPatchDataFactory(data_id) is actually a boost::shared_ptr&lt;pdat::CellDataFactory&lt;double&gt; &gt; </dd></dl>

<p>References <a class="el" href="Utilities_8h_source.html#l00149">BOOST_CAST</a>, <a class="el" href="VariableDatabase_8C_source.html#l00044">SAMRAI::hier::VariableDatabase::getDatabase()</a>, and <a class="el" href="Utilities_8h_source.html#l00110">TBOX_ASSERT</a>.</p>

</div>
</div>
<a class="anchor" id="a132a7972786a2230b6035a3dbf2cd07d"></a><!-- doxytag: member="SAMRAI::mesh::CascadePartitioner::getLoadBalanceDependsOnPatchData" ref="a132a7972786a2230b6035a3dbf2cd07d" args="(int level_number) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SAMRAI::mesh::CascadePartitioner::getLoadBalanceDependsOnPatchData </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>level_number</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return true if load balancing procedure for given level depends on patch data on <a class="el" href="namespaceSAMRAI_1_1mesh.html">mesh</a>; otherwise return false. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>level_number</em>&nbsp;</td><td>Integer patch level number. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classSAMRAI_1_1mesh_1_1LoadBalanceStrategy.html#a26cddcc6d628372374dd30549800bfc5">SAMRAI::mesh::LoadBalanceStrategy</a>.</p>

</div>
</div>
<hr/><h2>Friends And Related Function Documentation</h2>
<a class="anchor" id="a5c31968636b34bf25ed3aa27b5444f76"></a><!-- doxytag: member="SAMRAI::mesh::CascadePartitioner::CascadePartitionerTree" ref="a5c31968636b34bf25ed3aa27b5444f76" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="classSAMRAI_1_1mesh_1_1CascadePartitionerTree.html">CascadePartitionerTree</a><code> [friend]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>source/SAMRAI/mesh/<a class="el" href="CascadePartitioner_8h.html">CascadePartitioner.h</a></li>
<li>source/SAMRAI/mesh/<a class="el" href="CascadePartitioner_8C.html">CascadePartitioner.C</a></li>
</ul>
</div>
<hr size="1"/><address style="text-align: right;"><small>Generated on 5 Jun 2015 for SAMRAI by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.1 </small></address>
</body>
</html>
