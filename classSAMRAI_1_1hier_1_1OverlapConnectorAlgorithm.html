<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>SAMRAI: SAMRAI::hier::OverlapConnectorAlgorithm Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath"><a class="el" href="namespaceSAMRAI.html">SAMRAI</a>::<a class="el" href="namespaceSAMRAI_1_1hier.html">hier</a>::<a class="el" href="classSAMRAI_1_1hier_1_1OverlapConnectorAlgorithm.html">OverlapConnectorAlgorithm</a>
  </div>
</div>
<div class="contents">
<h1>SAMRAI::hier::OverlapConnectorAlgorithm Class Reference</h1><!-- doxytag: class="SAMRAI::hier::OverlapConnectorAlgorithm" --><!-- doxytag: inherits="SAMRAI::hier::BaseConnectorAlgorithm" -->
<p>Algorithms for working Connectors whose neighbor data represents overlaps.  
<a href="#_details">More...</a></p>

<p><code>#include &lt;source/SAMRAI/hier/OverlapConnectorAlgorithm.h&gt;</code></p>
<div class="dynheader">
Inheritance diagram for SAMRAI::hier::OverlapConnectorAlgorithm:</div>
<div class="dynsection">
 <div class="center">
  <img src="classSAMRAI_1_1hier_1_1OverlapConnectorAlgorithm.gif" usemap="#SAMRAI::hier::OverlapConnectorAlgorithm_map" alt=""/>
  <map id="SAMRAI::hier::OverlapConnectorAlgorithm_map" name="SAMRAI::hier::OverlapConnectorAlgorithm_map">
<area href="classSAMRAI_1_1hier_1_1BaseConnectorAlgorithm.html" alt="SAMRAI::hier::BaseConnectorAlgorithm" shape="rect" coords="0,0,252,24"/>
</map>
 </div>
</div>

<p><a href="classSAMRAI_1_1hier_1_1OverlapConnectorAlgorithm-members.html">List of all members.</a></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1OverlapConnectorAlgorithm.html#a5035bbebfa166de6e1601a7b6e3907f1">OverlapConnectorAlgorithm</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Constructor.  <a href="#a5035bbebfa166de6e1601a7b6e3907f1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1OverlapConnectorAlgorithm.html#a50b389f621cf8086641063518662bbcd">~OverlapConnectorAlgorithm</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Destructor.  <a href="#a50b389f621cf8086641063518662bbcd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1OverlapConnectorAlgorithm.html#a3698546884e96887a1efb39a099701ed">findOverlaps</a> (boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">Connector</a> &gt; &amp;connector, const <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a> &amp;base_box_level, const <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a> &amp;head_box_level, const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;base_width, const <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#a02c34699888ab34b06f59a210247bcb4">BoxLevel::ParallelState</a> parallel_state=BoxLevel::DISTRIBUTED, const bool ignore_self_overlap=false) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create overlap <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html" title="A container which holds relationship connections between two BoxLevels.">Connector</a> then discover and add overlaps from base to head to it.  <a href="#a3698546884e96887a1efb39a099701ed"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1OverlapConnectorAlgorithm.html#a4e31509736543b0a9ea202fcdbf99de1">findOverlapsWithTranspose</a> (boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">Connector</a> &gt; &amp;connector, const <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a> &amp;base_box_level, const <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a> &amp;head_box_level, const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;base_width, const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;transpose_base_width, const <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#a02c34699888ab34b06f59a210247bcb4">BoxLevel::ParallelState</a> parallel_state=BoxLevel::DISTRIBUTED, const bool ignore_self_overlap=false) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create overlap <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html" title="A container which holds relationship connections between two BoxLevels.">Connector</a> with its transpose then discover and add overlaps from base to head to it and overlaps from head to base to transpose.  <a href="#a4e31509736543b0a9ea202fcdbf99de1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1OverlapConnectorAlgorithm.html#ae332c260d625389d3d7ce6140fbcf788">findOverlaps</a> (<a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">Connector</a> &amp;connector, const bool ignore_self_overlap=false) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Discover and add overlaps from base to head for an overlap <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html" title="A container which holds relationship connections between two BoxLevels.">Connector</a>.  <a href="#ae332c260d625389d3d7ce6140fbcf788"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1OverlapConnectorAlgorithm.html#a5f56d7303025dffaef086edf0185cf4f">findOverlaps</a> (<a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">Connector</a> &amp;connector, const <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a> &amp;globalized_head, const bool ignore_self_overlap=false) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1OverlapConnectorAlgorithm.html#a6b340a8cc4df1d6d7567b9d8da3abe87">findOverlaps_assumedPartition</a> (<a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">Connector</a> &amp;connector) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1OverlapConnectorAlgorithm.html#a117ab34c4e5ec7b7e2942dca5bc6460f">extractNeighbors</a> (<a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">Connector::NeighborSet</a> &amp;neighbors, const <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">Connector</a> &amp;connector, const <a class="el" href="classSAMRAI_1_1hier_1_1BoxId.html">BoxId</a> &amp;box_id, const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;gcw) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">For a given <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html" title="A container which holds relationship connections between two BoxLevels.">Connector</a>, get the subset of overlapping neighbors defined by the given <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html" title="A container which holds relationship connections between two BoxLevels.">Connector</a> width.  <a href="#a117ab34c4e5ec7b7e2942dca5bc6460f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1OverlapConnectorAlgorithm.html#a00a49de1613717173249513c0e4a904a">extractNeighbors</a> (<a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">Connector</a> &amp;other, const <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">Connector</a> &amp;connector, const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;gcw) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Like extractNeighbors above except that it computes all neighborhoods of connector placing them into other.  <a href="#a00a49de1613717173249513c0e4a904a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1OverlapConnectorAlgorithm.html#a29e80a211de4749ecc033596e4fe5c37">bridgeWithNesting</a> (boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">Connector</a> &gt; &amp;west_to_east, const <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">Connector</a> &amp;west_to_center, const <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">Connector</a> &amp;center_to_east, const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;center_growth_to_nest_west, const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;center_growth_to_nest_east, const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;connector_width_limit, bool compute_transpose) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute the overlap Connectors between BoxLevels efficiently by using information from existing overlap Connectors.  <a href="#a29e80a211de4749ecc033596e4fe5c37"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1OverlapConnectorAlgorithm.html#a74e426410da5dfd3461c4ae7b268e4da">bridge</a> (boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">Connector</a> &gt; &amp;west_to_east, const <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">Connector</a> &amp;west_to_center, const <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">Connector</a> &amp;center_to_east, const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;connector_width_limit, bool compute_transpose) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A version of bridge without any guarantee of nesting.  <a href="#a74e426410da5dfd3461c4ae7b268e4da"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1OverlapConnectorAlgorithm.html#ace6a5dbe88186e63811080f3734826e4">bridge</a> (boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">Connector</a> &gt; &amp;west_to_east, const <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">Connector</a> &amp;west_to_center, const <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">Connector</a> &amp;center_to_east, bool compute_transpose) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A version of bridge without limiting the connector_width of the result.  <a href="#ace6a5dbe88186e63811080f3734826e4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1OverlapConnectorAlgorithm.html#a2eee26beb8ea8bbc4977f5ac1eb45768">bridge</a> (<a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">Connector</a> &amp;west_to_center, const <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">Connector</a> &amp;center_to_east, const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;connector_width_limit) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A version of bridge without any guarantee of nesting in which an input connector and its transpose are modified to form the resulting bridge connectors.  <a href="#a2eee26beb8ea8bbc4977f5ac1eb45768"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1OverlapConnectorAlgorithm.html#a99bf3a60edd92ad43916c7410c9d5129">setBarrierBeforeCommunication</a> (bool do_barrier)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set whether to barrier before potential major communication.  <a href="#a99bf3a60edd92ad43916c7410c9d5129"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1OverlapConnectorAlgorithm.html#a29f448936a23f8dd367ce65c371466a8">setSanityCheckMethodPreconditions</a> (bool do_check)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">When <code>do_check</code> is true, turn on sanity checks for input parameters.  <a href="#a29f448936a23f8dd367ce65c371466a8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1OverlapConnectorAlgorithm.html#a7088a2d599fd1d4c7efca3d078207e98">setSanityCheckMethodPostconditions</a> (bool do_check)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">When <code>do_check</code> is true, turn on sanity checks for outputs.  <a href="#a7088a2d599fd1d4c7efca3d078207e98"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1OverlapConnectorAlgorithm.html#a2c5d518cee5fba53a393387a4110bb14">setSAMRAI_MPI</a> (const <a class="el" href="classSAMRAI_1_1tbox_1_1SAMRAI__MPI.html">tbox::SAMRAI_MPI</a> &amp;mpi, bool make_duplicate=true)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the SAMRAI_MPI to use.  <a href="#a2c5d518cee5fba53a393387a4110bb14"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1OverlapConnectorAlgorithm.html#a2642092f5b583af36c564849ad2df1f7">setPrintSteps</a> (bool print_steps)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">When <code>print_steps</code> is true, print what the code is doing.  <a href="#a2642092f5b583af36c564849ad2df1f7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1OverlapConnectorAlgorithm.html#a8d69f7abe729ec94f3e4ca647116286e">setTimerPrefix</a> (const std::string &amp;timer_prefix)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Setup names of timers.  <a href="#a8d69f7abe729ec94f3e4ca647116286e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const std::string&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1OverlapConnectorAlgorithm.html#a8bb13003c85cb2ce6fbdc30488b9a6a4">getObjectName</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the name of this object.  <a href="#a8bb13003c85cb2ce6fbdc30488b9a6a4"></a><br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>Algorithms for working Connectors whose neighbor data represents overlaps. </p>
<p>An overlap <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html" title="A container which holds relationship connections between two BoxLevels.">Connector</a> is one in which neighbors represent a pair of overlapping Boxes. If a base <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> grown by the <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html" title="A container which holds relationship connections between two BoxLevels.">Connector</a> width overlaps a head <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a>, the head <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> is a neighbor of the base <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a>. This class implements some functions for working with a overlap Connectors.</p>
<p><a class="el" href="classSAMRAI_1_1hier_1_1OverlapConnectorAlgorithm.html" title="Algorithms for working Connectors whose neighbor data represents overlaps.">OverlapConnectorAlgorithm</a> objects create, check and operate on overlap Connectors. </p>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a5035bbebfa166de6e1601a7b6e3907f1"></a><!-- doxytag: member="SAMRAI::hier::OverlapConnectorAlgorithm::OverlapConnectorAlgorithm" ref="a5035bbebfa166de6e1601a7b6e3907f1" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SAMRAI::hier::OverlapConnectorAlgorithm::OverlapConnectorAlgorithm </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Constructor. </p>

<p>References <a class="el" href="OverlapConnectorAlgorithm_8C_source.html#l01864">setTimerPrefix()</a>.</p>

</div>
</div>
<a class="anchor" id="a50b389f621cf8086641063518662bbcd"></a><!-- doxytag: member="SAMRAI::hier::OverlapConnectorAlgorithm::~OverlapConnectorAlgorithm" ref="a50b389f621cf8086641063518662bbcd" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SAMRAI::hier::OverlapConnectorAlgorithm::~OverlapConnectorAlgorithm </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Destructor. </p>

<p>References <a class="el" href="SAMRAI__MPI_8C_source.html#l01608">SAMRAI::tbox::SAMRAI_MPI::freeCommunicator()</a>.</p>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a3698546884e96887a1efb39a099701ed"></a><!-- doxytag: member="SAMRAI::hier::OverlapConnectorAlgorithm::findOverlaps" ref="a3698546884e96887a1efb39a099701ed" args="(boost::shared_ptr&lt; Connector &gt; &amp;connector, const BoxLevel &amp;base_box_level, const BoxLevel &amp;head_box_level, const IntVector &amp;base_width, const BoxLevel::ParallelState parallel_state=BoxLevel::DISTRIBUTED, const bool ignore_self_overlap=false) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::hier::OverlapConnectorAlgorithm::findOverlaps </td>
          <td>(</td>
          <td class="paramtype">boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">Connector</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>connector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>base_box_level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>head_box_level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>base_width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#a02c34699888ab34b06f59a210247bcb4">BoxLevel::ParallelState</a>&nbsp;</td>
          <td class="paramname"> <em>parallel_state</em> = <code>BoxLevel::DISTRIBUTED</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&nbsp;</td>
          <td class="paramname"> <em>ignore_self_overlap</em> = <code>false</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create overlap <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html" title="A container which holds relationship connections between two BoxLevels.">Connector</a> then discover and add overlaps from base to head to it. </p>
<p>The Connector's neighbor information is modified.</p>
<p>If the Connector's head is not GLOBALIZED, a copy is made and globalized. Once a globalized head is obtained, this method simply calls findOverlaps(const BoxLevel &amp;globalized_head).</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>connector</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>base_box_level</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>head_box_level</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>base_width</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>parallel_state</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>ignore_self_overlap</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="BoxLevel_8C_source.html#l01310">SAMRAI::hier::BoxLevel::getGlobalizedVersion()</a>.</p>

<p>Referenced by <a class="el" href="BoxLevelConnectorUtils_8C_source.html#l00095">SAMRAI::hier::BoxLevelConnectorUtils::baseNestsInHead()</a>, <a class="el" href="OverlapConnectorAlgorithm_8C_source.html#l00387">findOverlaps()</a>, <a class="el" href="OverlapConnectorAlgorithm_8C_source.html#l00356">findOverlapsWithTranspose()</a>, <a class="el" href="BalanceUtilities_8C_source.html#l01838">SAMRAI::mesh::BalanceUtilities::findSmallBoxesInPostbalance()</a>, <a class="el" href="GraphLoadBalancer_8C_source.html#l00072">SAMRAI::mesh::GraphLoadBalancer::loadBalanceBoxLevel()</a>, <a class="el" href="ChopAndPackLoadBalancer_8C_source.html#l00240">SAMRAI::mesh::ChopAndPackLoadBalancer::loadBalanceBoxLevel()</a>, and <a class="el" href="GriddingAlgorithm_8C_source.html#l00322">SAMRAI::mesh::GriddingAlgorithm::makeCoarsestLevel()</a>.</p>

</div>
</div>
<a class="anchor" id="a4e31509736543b0a9ea202fcdbf99de1"></a><!-- doxytag: member="SAMRAI::hier::OverlapConnectorAlgorithm::findOverlapsWithTranspose" ref="a4e31509736543b0a9ea202fcdbf99de1" args="(boost::shared_ptr&lt; Connector &gt; &amp;connector, const BoxLevel &amp;base_box_level, const BoxLevel &amp;head_box_level, const IntVector &amp;base_width, const IntVector &amp;transpose_base_width, const BoxLevel::ParallelState parallel_state=BoxLevel::DISTRIBUTED, const bool ignore_self_overlap=false) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::hier::OverlapConnectorAlgorithm::findOverlapsWithTranspose </td>
          <td>(</td>
          <td class="paramtype">boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">Connector</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>connector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>base_box_level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>head_box_level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>base_width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>transpose_base_width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#a02c34699888ab34b06f59a210247bcb4">BoxLevel::ParallelState</a>&nbsp;</td>
          <td class="paramname"> <em>parallel_state</em> = <code>BoxLevel::DISTRIBUTED</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&nbsp;</td>
          <td class="paramname"> <em>ignore_self_overlap</em> = <code>false</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create overlap <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html" title="A container which holds relationship connections between two BoxLevels.">Connector</a> with its transpose then discover and add overlaps from base to head to it and overlaps from head to base to transpose. </p>
<p>The Connector's neighbor information is modified.</p>
<p>If the Connector's head is not GLOBALIZED, a copy is made and globalized. Once a globalized head is obtained, this method simply calls findOverlaps(const BoxLevel &amp;globalized_head).</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>connector</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>base_box_level</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>head_box_level</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>base_width</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>transpose_base_width</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>parallel_state</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>ignore_self_overlap</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="OverlapConnectorAlgorithm_8C_source.html#l00330">findOverlaps()</a>.</p>

</div>
</div>
<a class="anchor" id="ae332c260d625389d3d7ce6140fbcf788"></a><!-- doxytag: member="SAMRAI::hier::OverlapConnectorAlgorithm::findOverlaps" ref="ae332c260d625389d3d7ce6140fbcf788" args="(Connector &amp;connector, const bool ignore_self_overlap=false) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::hier::OverlapConnectorAlgorithm::findOverlaps </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">Connector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>connector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&nbsp;</td>
          <td class="paramname"> <em>ignore_self_overlap</em> = <code>false</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Discover and add overlaps from base to head for an overlap <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html" title="A container which holds relationship connections between two BoxLevels.">Connector</a>. </p>
<p>The Connector's neighbor information is modified.</p>
<p>If the Connector's head is not GLOBALIZED, a copy is made and globalized. Once a globalized head is obtained, this method simply calls findOverlaps(const BoxLevel &amp;globalized_head).</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>connector</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>ignore_self_overlap</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="OverlapConnectorAlgorithm_8C_source.html#l00330">findOverlaps()</a>, <a class="el" href="BoxLevel_8C_source.html#l01310">SAMRAI::hier::BoxLevel::getGlobalizedVersion()</a>, and <a class="el" href="Connector_8h_source.html#l00781">SAMRAI::hier::Connector::getHead()</a>.</p>

</div>
</div>
<a class="anchor" id="a5f56d7303025dffaef086edf0185cf4f"></a><!-- doxytag: member="SAMRAI::hier::OverlapConnectorAlgorithm::findOverlaps" ref="a5f56d7303025dffaef086edf0185cf4f" args="(Connector &amp;connector, const BoxLevel &amp;globalized_head, const bool ignore_self_overlap=false) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::hier::OverlapConnectorAlgorithm::findOverlaps </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">Connector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>connector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>globalized_head</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&nbsp;</td>
          <td class="paramname"> <em>ignore_self_overlap</em> = <code>false</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a6b340a8cc4df1d6d7567b9d8da3abe87"></a><!-- doxytag: member="SAMRAI::hier::OverlapConnectorAlgorithm::findOverlaps_assumedPartition" ref="a6b340a8cc4df1d6d7567b9d8da3abe87" args="(Connector &amp;connector) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::hier::OverlapConnectorAlgorithm::findOverlaps_assumedPartition </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">Connector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>connector</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>References <a class="el" href="BoxContainer_8h_source.html#l00828">SAMRAI::hier::BoxContainer::back()</a>, <a class="el" href="BoxContainer_8h_source.html#l00705">SAMRAI::hier::BoxContainer::begin()</a>, <a class="el" href="OverlapConnectorAlgorithm_8C_source.html#l00600">bridgeWithNesting()</a>, <a class="el" href="Connector_8h_source.html#l00173">SAMRAI::hier::Connector::clear()</a>, <a class="el" href="BoxContainer_8h_source.html#l00864">SAMRAI::hier::BoxContainer::clear()</a>, <a class="el" href="BoxContainer_8C_source.html#l01602">SAMRAI::hier::BoxContainer::coarsen()</a>, <a class="el" href="Connector_8C_source.html#l00439">SAMRAI::hier::Connector::computeTransposeOf()</a>, <a class="el" href="Connector_8C_source.html#l01294">SAMRAI::hier::Connector::convertHeadWidthToBase()</a>, <a class="el" href="BoxContainer_8h_source.html#l00716">SAMRAI::hier::BoxContainer::end()</a>, <a class="el" href="Connector_8h_source.html#l00754">SAMRAI::hier::Connector::getBase()</a>, <a class="el" href="BoxLevel_8h_source.html#l00521">SAMRAI::hier::BoxLevel::getBoxes()</a>, <a class="el" href="Connector_8h_source.html#l00982">SAMRAI::hier::Connector::getConnectorWidth()</a>, <a class="el" href="BoxLevel_8h_source.html#l00848">SAMRAI::hier::BoxLevel::getDim()</a>, <a class="el" href="BoxLevel_8h_source.html#l00785">SAMRAI::hier::BoxLevel::getGlobalBoundingBox()</a>, <a class="el" href="BoxLevel_8h_source.html#l00859">SAMRAI::hier::BoxLevel::getGridGeometry()</a>, <a class="el" href="Connector_8h_source.html#l00781">SAMRAI::hier::Connector::getHead()</a>, <a class="el" href="BoxLevel_8h_source.html#l00398">SAMRAI::hier::BoxLevel::getMPI()</a>, <a class="el" href="SAMRAI__MPI_8h_source.html#l00214">SAMRAI::tbox::SAMRAI_MPI::getRank()</a>, <a class="el" href="Connector_8h_source.html#l00798">SAMRAI::hier::Connector::getRatio()</a>, <a class="el" href="BoxLevel_8h_source.html#l00583">SAMRAI::hier::BoxLevel::getRefinementRatio()</a>, <a class="el" href="SAMRAI__MPI_8h_source.html#l00224">SAMRAI::tbox::SAMRAI_MPI::getSize()</a>, <a class="el" href="BoxContainer_8C_source.html#l01565">SAMRAI::hier::BoxContainer::grow()</a>, <a class="el" href="SAMRAI__MPI_8h_source.html#l00296">SAMRAI::tbox::SAMRAI_MPI::hasNullCommunicator()</a>, <a class="el" href="SAMRAI__MPI_8C_source.html#l01560">SAMRAI::tbox::SAMRAI_MPI::hasReceivableMessage()</a>, <a class="el" href="Connector_8h_source.html#l00562">SAMRAI::hier::Connector::insertLocalNeighbor()</a>, <a class="el" href="Connector_8C_source.html#l00294">SAMRAI::hier::Connector::insertNeighbors()</a>, <a class="el" href="SAMRAI__MPI_8h_source.html#l00307">SAMRAI::tbox::SAMRAI_MPI::isCongruentWith()</a>, <a class="el" href="SAMRAI__MPI_8h_source.html#l00045">MPI_ANY_SOURCE</a>, <a class="el" href="SAMRAI__MPI_8h_source.html#l00046">MPI_ANY_TAG</a>, <a class="el" href="namespaceSAMRAI_1_1tbox.html#ab84041705493761fb17a8127e3a2dca2">SAMRAI::tbox::plog</a>, <a class="el" href="BoxContainer_8h_source.html#l01107">SAMRAI::hier::BoxContainer::push_back()</a>, <a class="el" href="BoxContainer_8C_source.html#l01590">SAMRAI::hier::BoxContainer::refine()</a>, <a class="el" href="Connector_8C_source.html#l00910">SAMRAI::hier::Connector::setBase()</a>, <a class="el" href="Connector_8C_source.html#l00932">SAMRAI::hier::Connector::setHead()</a>, <a class="el" href="Connector_8h_source.html#l01167">SAMRAI::hier::Connector::setTranspose()</a>, <a class="el" href="Connector_8C_source.html#l00953">SAMRAI::hier::Connector::setWidth()</a>, <a class="el" href="Box_8h_source.html#l00668">SAMRAI::hier::Box::size()</a>, and <a class="el" href="Utilities_8h_source.html#l00060">TBOX_ERROR</a>.</p>

<p>Referenced by <a class="el" href="GriddingAlgorithm_8C_source.html#l00322">SAMRAI::mesh::GriddingAlgorithm::makeCoarsestLevel()</a>.</p>

</div>
</div>
<a class="anchor" id="a117ab34c4e5ec7b7e2942dca5bc6460f"></a><!-- doxytag: member="SAMRAI::hier::OverlapConnectorAlgorithm::extractNeighbors" ref="a117ab34c4e5ec7b7e2942dca5bc6460f" args="(Connector::NeighborSet &amp;neighbors, const Connector &amp;connector, const BoxId &amp;box_id, const IntVector &amp;gcw) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::hier::OverlapConnectorAlgorithm::extractNeighbors </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">Connector::NeighborSet</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>neighbors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">Connector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>connector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1BoxId.html">BoxId</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>box_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>gcw</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>For a given <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html" title="A container which holds relationship connections between two BoxLevels.">Connector</a>, get the subset of overlapping neighbors defined by the given <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html" title="A container which holds relationship connections between two BoxLevels.">Connector</a> width. </p>
<p>The difference between <a class="el" href="classSAMRAI_1_1hier_1_1OverlapConnectorAlgorithm.html#a117ab34c4e5ec7b7e2942dca5bc6460f" title="For a given Connector, get the subset of overlapping neighbors defined by the given...">extractNeighbors()</a> and Connector::getNeighbors() is that <a class="el" href="classSAMRAI_1_1hier_1_1OverlapConnectorAlgorithm.html#a117ab34c4e5ec7b7e2942dca5bc6460f" title="For a given Connector, get the subset of overlapping neighbors defined by the given...">extractNeighbors()</a> extracts the subset of the currently stored neighbors associated with the given <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html" title="A container which holds relationship connections between two BoxLevels.">Connector</a> width. getNeighbors() returns the entire neighbor set, which corresponds to the Connector's width. The specified <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html" title="A container which holds relationship connections between two BoxLevels.">Connector</a> width must be less than or equal to the Connector's width.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>neighbors</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>connector</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>box_id</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>gcw</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>gcw &lt;= connector.getConnectorWidth() </dd>
<dd>
(connector.getParallelState() == <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#a02c34699888ab34b06f59a210247bcb4a2dbf00b87512ae236e2dbde25acb952f">BoxLevel::GLOBALIZED</a>) || (box_id.getOwnerRank() == connector.getMPI().getRank()) </dd>
<dd>
connector.getBase().hasBox(box_id) </dd></dl>

<p>References <a class="el" href="Connector_8h_source.html#l00209">SAMRAI::hier::Connector::begin()</a>, <a class="el" href="BoxContainer_8h_source.html#l00864">SAMRAI::hier::BoxContainer::clear()</a>, <a class="el" href="MappingConnector_8C_source.html#l00023">dbgbord</a>, <a class="el" href="BoxContainer_8h_source.html#l00716">SAMRAI::hier::BoxContainer::end()</a>, <a class="el" href="Connector_8h_source.html#l00227">SAMRAI::hier::Connector::end()</a>, <a class="el" href="Connector_8h_source.html#l00300">SAMRAI::hier::Connector::findLocal()</a>, <a class="el" href="Connector_8h_source.html#l01488">SAMRAI::hier::Connector::format()</a>, <a class="el" href="BoxLevel_8C_source.html#l01608">SAMRAI::hier::BoxLevel::format()</a>, <a class="el" href="Connector_8h_source.html#l00754">SAMRAI::hier::Connector::getBase()</a>, <a class="el" href="Box_8h_source.html#l00331">SAMRAI::hier::Box::getBlockId()</a>, <a class="el" href="BoxLevel_8h_source.html#l01159">SAMRAI::hier::BoxLevel::getBox()</a>, <a class="el" href="Connector_8h_source.html#l00982">SAMRAI::hier::Connector::getConnectorWidth()</a>, <a class="el" href="IntVector_8h_source.html#l00721">SAMRAI::hier::IntVector::getDim()</a>, <a class="el" href="BoxLevel_8h_source.html#l00859">SAMRAI::hier::BoxLevel::getGridGeometry()</a>, <a class="el" href="Connector_8h_source.html#l00781">SAMRAI::hier::Connector::getHead()</a>, <a class="el" href="Connector_8h_source.html#l00826">SAMRAI::hier::Connector::getHeadCoarserFlag()</a>, <a class="el" href="Connector_8h_source.html#l00949">SAMRAI::hier::Connector::getMPI()</a>, <a class="el" href="BoxId_8h_source.html#l00127">SAMRAI::hier::BoxId::getOwnerRank()</a>, <a class="el" href="Connector_8h_source.html#l00937">SAMRAI::hier::Connector::getParallelState()</a>, <a class="el" href="SAMRAI__MPI_8h_source.html#l00214">SAMRAI::tbox::SAMRAI_MPI::getRank()</a>, <a class="el" href="Connector_8h_source.html#l00798">SAMRAI::hier::Connector::getRatio()</a>, <a class="el" href="BoxLevel_8h_source.html#l00583">SAMRAI::hier::BoxLevel::getRefinementRatio()</a>, <a class="el" href="BoxLevel_8h_source.html#l00104">SAMRAI::hier::BoxLevel::GLOBALIZED</a>, <a class="el" href="Box_8h_source.html#l00915">SAMRAI::hier::Box::grow()</a>, <a class="el" href="BoxLevel_8h_source.html#l01270">SAMRAI::hier::BoxLevel::hasBox()</a>, <a class="el" href="BoxContainer_8C_source.html#l00290">SAMRAI::hier::BoxContainer::insert()</a>, <a class="el" href="Box_8C_source.html#l00541">SAMRAI::hier::Box::intersects()</a>, <a class="el" href="Box_8C_source.html#l00635">SAMRAI::hier::Box::refine()</a>, <a class="el" href="Utilities_8h_source.html#l00110">TBOX_ASSERT</a>, and <a class="el" href="Utilities_8h_source.html#l00060">TBOX_ERROR</a>.</p>

</div>
</div>
<a class="anchor" id="a00a49de1613717173249513c0e4a904a"></a><!-- doxytag: member="SAMRAI::hier::OverlapConnectorAlgorithm::extractNeighbors" ref="a00a49de1613717173249513c0e4a904a" args="(Connector &amp;other, const Connector &amp;connector, const IntVector &amp;gcw) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::hier::OverlapConnectorAlgorithm::extractNeighbors </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">Connector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">Connector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>connector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>gcw</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Like extractNeighbors above except that it computes all neighborhoods of connector placing them into other. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>other</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>connector</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>gcw</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>gcw &lt;= connector.getConnectorWidth() </dd>
<dd>
for the box_id of each neighborhood base box in connector, (connector.getParallelState() == <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#a02c34699888ab34b06f59a210247bcb4a2dbf00b87512ae236e2dbde25acb952f">BoxLevel::GLOBALIZED</a>) || (box_id.getOwnerRank() == connector.getMPI().getRank()) </dd>
<dd>
for the box_id of each neighborhood base box in connector, connector.getBase().hasBox(box_id) </dd></dl>

<p>References <a class="el" href="Connector_8h_source.html#l00209">SAMRAI::hier::Connector::begin()</a>, <a class="el" href="Connector_8h_source.html#l00190">SAMRAI::hier::Connector::clearNeighborhoods()</a>, <a class="el" href="MappingConnector_8C_source.html#l00023">dbgbord</a>, <a class="el" href="Connector_8h_source.html#l00227">SAMRAI::hier::Connector::end()</a>, <a class="el" href="Connector_8h_source.html#l01488">SAMRAI::hier::Connector::format()</a>, <a class="el" href="BoxLevel_8C_source.html#l01608">SAMRAI::hier::BoxLevel::format()</a>, <a class="el" href="Connector_8h_source.html#l00754">SAMRAI::hier::Connector::getBase()</a>, <a class="el" href="Box_8h_source.html#l00331">SAMRAI::hier::Box::getBlockId()</a>, <a class="el" href="BoxLevel_8h_source.html#l01159">SAMRAI::hier::BoxLevel::getBox()</a>, <a class="el" href="Connector_8h_source.html#l00982">SAMRAI::hier::Connector::getConnectorWidth()</a>, <a class="el" href="IntVector_8h_source.html#l00721">SAMRAI::hier::IntVector::getDim()</a>, <a class="el" href="BoxLevel_8h_source.html#l00859">SAMRAI::hier::BoxLevel::getGridGeometry()</a>, <a class="el" href="Connector_8h_source.html#l00781">SAMRAI::hier::Connector::getHead()</a>, <a class="el" href="Connector_8h_source.html#l00826">SAMRAI::hier::Connector::getHeadCoarserFlag()</a>, <a class="el" href="Connector_8h_source.html#l00949">SAMRAI::hier::Connector::getMPI()</a>, <a class="el" href="BoxId_8h_source.html#l00127">SAMRAI::hier::BoxId::getOwnerRank()</a>, <a class="el" href="Connector_8h_source.html#l00937">SAMRAI::hier::Connector::getParallelState()</a>, <a class="el" href="SAMRAI__MPI_8h_source.html#l00214">SAMRAI::tbox::SAMRAI_MPI::getRank()</a>, <a class="el" href="Connector_8h_source.html#l00798">SAMRAI::hier::Connector::getRatio()</a>, <a class="el" href="BoxLevel_8h_source.html#l00583">SAMRAI::hier::BoxLevel::getRefinementRatio()</a>, <a class="el" href="BoxLevel_8h_source.html#l00104">SAMRAI::hier::BoxLevel::GLOBALIZED</a>, <a class="el" href="Box_8h_source.html#l00915">SAMRAI::hier::Box::grow()</a>, <a class="el" href="BoxLevel_8h_source.html#l01270">SAMRAI::hier::BoxLevel::hasBox()</a>, <a class="el" href="Connector_8h_source.html#l00562">SAMRAI::hier::Connector::insertLocalNeighbor()</a>, <a class="el" href="Box_8C_source.html#l00541">SAMRAI::hier::Box::intersects()</a>, <a class="el" href="Connector_8h_source.html#l00649">SAMRAI::hier::Connector::makeEmptyLocalNeighborhood()</a>, <a class="el" href="Box_8C_source.html#l00635">SAMRAI::hier::Box::refine()</a>, <a class="el" href="Utilities_8h_source.html#l00110">TBOX_ASSERT</a>, and <a class="el" href="Utilities_8h_source.html#l00060">TBOX_ERROR</a>.</p>

</div>
</div>
<a class="anchor" id="a29e80a211de4749ecc033596e4fe5c37"></a><!-- doxytag: member="SAMRAI::hier::OverlapConnectorAlgorithm::bridgeWithNesting" ref="a29e80a211de4749ecc033596e4fe5c37" args="(boost::shared_ptr&lt; Connector &gt; &amp;west_to_east, const Connector &amp;west_to_center, const Connector &amp;center_to_east, const IntVector &amp;center_growth_to_nest_west, const IntVector &amp;center_growth_to_nest_east, const IntVector &amp;connector_width_limit, bool compute_transpose) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::hier::OverlapConnectorAlgorithm::bridgeWithNesting </td>
          <td>(</td>
          <td class="paramtype">boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">Connector</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>west_to_east</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">Connector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>west_to_center</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">Connector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>center_to_east</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>center_growth_to_nest_west</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>center_growth_to_nest_east</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>connector_width_limit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>compute_transpose</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compute the overlap Connectors between BoxLevels efficiently by using information from existing overlap Connectors. </p>
<p>Let east, west and center be BoxLevels. Given overlap Connectors between center and east and between center and west, compute overlap Connectors between east and west.</p>
<div class="fragment"><pre class="fragment">               Input:                            Output:

                                               west to east
      (west)              (east)      (west) ---------------&gt; (east)
        \ ^                ^ /               &lt;---------------
         \ \center  center/ /                  east to west
          \ \ to     to  / /
       west\ \west  east/ /east
        to  \ \        / /  to
       center\ \      / /center
              v \    / v
               (center)
</pre></div><p>The "bridge" is the Connectors between <code>west</code> and <code>east</code>. Bridging is an algorithm for finding their overlaps using existing overlaps incident from <code>center</code>. This is more efficient than <a class="el" href="classSAMRAI_1_1hier_1_1OverlapConnectorAlgorithm.html#a3698546884e96887a1efb39a099701ed" title="Create overlap Connector then discover and add overlaps from base to head to it.">findOverlaps()</a> because it does not require acquiring, storing or searching globalized data.</p>
<p>Preconditions:</p>
<ul>
<li>Four input Connectors refer to the center <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html" title="A distributed set of Box objects which reside in the same index space.">BoxLevel</a>, two refer to the west, and two refer to the east. The center, east and west BoxLevels must be the same regardless of what <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html" title="A container which holds relationship connections between two BoxLevels.">Connector</a> is used to get them. For example, <code> &amp;west_to_center.getTranspose().getHead() == &amp;west_to_center.getBase() </code> must be true.</li>
</ul>
<p>Postconditions:</p>
<ul>
<li><code>west</code> and <code>east</code>, as referenced by the output Connectors are heads of west_to_center's transpose and <code>center_to_east</code>.</li>
</ul>
<ul>
<li>Widths of the output Connectors will be either <code>center_to_east's</code> width reduced by <code>center_growth_to_nest_west</code> or west_to_center's transpose's width reduced by <code>center_growth_to_nest_east</code>, which ever is greater. Output <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html" title="A container which holds relationship connections between two BoxLevels.">Connector</a> widths are still limited by the <code>connector_width_limit</code> argument. All comparisons are done after the appropriate index space conversions, of course.</li>
</ul>
<dl class="note"><dt><b>Note:</b></dt><dd></dd></dl>
<ul>
<li>Although <code>east</code>, <code>west</code> and <code>center</code> are not explicit parameters, they are specified implicitly through the input Connectors.</li>
</ul>
<ul>
<li>The bridge operation works in the degenerate case where <code>east</code> and <code>west</code> are the same object. In that case, <code>west_to_east</code> and its transpose should also be the same object.</li>
</ul>
<ul>
<li>Bridging finds as many overlaps as it can, given the inputs, but can only guarantee that the output Connectors are complete overlap Connectors if there is nesting as specified by the arguments <code>center_growth_to_nest_west</code> and/or <code>center_growth_to_nest_east</code>. Nesting is not checked, because checking requires an iterative non-scalable computation. Nesting is best determined by the code that created the BoxLevels involved. Bridging is meant to be fast and scalable.</li>
</ul>
<ul>
<li>Periodic relationships are automatically generated if a head <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> in its shifted position overlaps the grown base <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a>. However, because neighbors may be remote, we cannot scalably verify that the periodic neighbors actually exist in the heads of the output Connectors. Spurious periodic relationships may be generated when the periodic image simply has not be added to the head or when parts of east or west lie outside the domain extents. They can be discarded using <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html#aa34973973b4d43f6ec68b3ec9c390829" title="Remove all the periodic relationships in the Connector.">Connector::removePeriodicRelationships</a> and properly regenerated using <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevelConnectorUtils.html" title="Utilities for common operating on BoxLevels.">BoxLevelConnectorUtils</a>.</li>
</ul>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>west_to_east</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>west_to_center</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>center_to_east</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>center_growth_to_nest_west</em>&nbsp;</td><td>The amount by which the center <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html" title="A distributed set of Box objects which reside in the same index space.">BoxLevel</a> must grow to nest the west <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html" title="A distributed set of Box objects which reside in the same index space.">BoxLevel</a>. Bridging guarantees completeness if the width of <b>center_to_east</b> exceeds this amount. If unknown, set to negative value if unknown so it won't be considered when computing the output <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html" title="A container which holds relationship connections between two BoxLevels.">Connector</a> widths.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>center_growth_to_nest_east</em>&nbsp;</td><td>The amount by which the center <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html" title="A distributed set of Box objects which reside in the same index space.">BoxLevel</a> must grow to nest the east <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html" title="A distributed set of Box objects which reside in the same index space.">BoxLevel</a>. Bridging guarantees completeness if the width of <b>west_to_center's</b> transpose exceeds this amount. If unknown, set to negative value if unknown so it won't be considered when computing the output <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html" title="A container which holds relationship connections between two BoxLevels.">Connector</a> widths.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>connector_width_limit</em>&nbsp;</td><td>specifies the maximum <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html" title="A container which holds relationship connections between two BoxLevels.">Connector</a> width to compute overlaps for. The connector_width should be in the coarser of the east and west indices. If connector_width_limit is negative, use the default connector_width, which is the larger of the west_to_center's transpose and center_to_east Connectors', coarsened into the coarser of east and west indices.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>compute_transpose</em>&nbsp;</td><td>true if west_to_east's transpose should be computed</td></tr>
  </table>
  </dd>
</dl>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>west_to_cent.hasTranspose() </dd>
<dd>
cent_to_east.hasTranspose() </dd></dl>

<p>References <a class="el" href="SAMRAI__MPI_8C_source.html#l00768">SAMRAI::tbox::SAMRAI_MPI::Barrier()</a>, <a class="el" href="Connector_8h_source.html#l00754">SAMRAI::hier::Connector::getBase()</a>, <a class="el" href="IntVector_8h_source.html#l00721">SAMRAI::hier::IntVector::getDim()</a>, <a class="el" href="Connector_8h_source.html#l00781">SAMRAI::hier::Connector::getHead()</a>, <a class="el" href="BoxLevel_8h_source.html#l00398">SAMRAI::hier::BoxLevel::getMPI()</a>, <a class="el" href="Connector_8h_source.html#l01148">SAMRAI::hier::Connector::getTranspose()</a>, <a class="el" href="SAMRAI__MPI_8h_source.html#l00296">SAMRAI::tbox::SAMRAI_MPI::hasNullCommunicator()</a>, <a class="el" href="Connector_8h_source.html#l01137">SAMRAI::hier::Connector::hasTranspose()</a>, and <a class="el" href="Utilities_8h_source.html#l00110">TBOX_ASSERT</a>.</p>

<p>Referenced by <a class="el" href="OverlapConnectorAlgorithm_8C_source.html#l00436">findOverlaps_assumedPartition()</a>, <a class="el" href="GraphLoadBalancer_8C_source.html#l00072">SAMRAI::mesh::GraphLoadBalancer::loadBalanceBoxLevel()</a>, <a class="el" href="GriddingAlgorithm_8C_source.html#l00322">SAMRAI::mesh::GriddingAlgorithm::makeCoarsestLevel()</a>, and <a class="el" href="GriddingAlgorithm_8C_source.html#l00664">SAMRAI::mesh::GriddingAlgorithm::makeFinerLevel()</a>.</p>

</div>
</div>
<a class="anchor" id="a74e426410da5dfd3461c4ae7b268e4da"></a><!-- doxytag: member="SAMRAI::hier::OverlapConnectorAlgorithm::bridge" ref="a74e426410da5dfd3461c4ae7b268e4da" args="(boost::shared_ptr&lt; Connector &gt; &amp;west_to_east, const Connector &amp;west_to_center, const Connector &amp;center_to_east, const IntVector &amp;connector_width_limit, bool compute_transpose) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::hier::OverlapConnectorAlgorithm::bridge </td>
          <td>(</td>
          <td class="paramtype">boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">Connector</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>west_to_east</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">Connector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>west_to_center</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">Connector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>center_to_east</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>connector_width_limit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>compute_transpose</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>A version of bridge without any guarantee of nesting. </p>
<p>The east and west BoxLevels are assumed to nest in the center <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html" title="A distributed set of Box objects which reside in the same index space.">BoxLevel</a>. If they do not, the results are not guaranteed to be complete.</p>
<p>The output <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html" title="A container which holds relationship connections between two BoxLevels.">Connector</a> widths are the greater of the widths of <code>center_to_east</code> and <code>center_to_west</code> (converted into the proper index space, of course).</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>west_to_east</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>west_to_center</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>center_to_east</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>connector_width_limit</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>compute_transpose</em>&nbsp;</td><td>true if west_to_east's transpose should be computed</td></tr>
  </table>
  </dd>
</dl>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>west_to_cent.hasTranspose() </dd>
<dd>
cent_to_east.hasTranspose()</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd>bridgeWithNesting( Connector&amp; west_to_east, const Connector&amp; west_to_center, const Connector&amp; center_to_east, const IntVector&amp; center_growth_to_nest_west, const IntVector&amp; center_growth_to_nest_east, const IntVector&amp; connector_width_limit, bool compute_transpose) const; </dd></dl>

<p>References <a class="el" href="SAMRAI__MPI_8C_source.html#l00768">SAMRAI::tbox::SAMRAI_MPI::Barrier()</a>, <a class="el" href="Connector_8h_source.html#l00754">SAMRAI::hier::Connector::getBase()</a>, <a class="el" href="IntVector_8h_source.html#l00721">SAMRAI::hier::IntVector::getDim()</a>, <a class="el" href="Connector_8h_source.html#l00781">SAMRAI::hier::Connector::getHead()</a>, <a class="el" href="BoxLevel_8h_source.html#l00398">SAMRAI::hier::BoxLevel::getMPI()</a>, <a class="el" href="Connector_8h_source.html#l01148">SAMRAI::hier::Connector::getTranspose()</a>, <a class="el" href="IntVector_8h_source.html#l00732">SAMRAI::hier::IntVector::getZero()</a>, <a class="el" href="SAMRAI__MPI_8h_source.html#l00296">SAMRAI::tbox::SAMRAI_MPI::hasNullCommunicator()</a>, <a class="el" href="Connector_8h_source.html#l01137">SAMRAI::hier::Connector::hasTranspose()</a>, and <a class="el" href="Utilities_8h_source.html#l00110">TBOX_ASSERT</a>.</p>

<p>Referenced by <a class="el" href="BoxLevelConnectorUtils_8C_source.html#l01270">SAMRAI::hier::BoxLevelConnectorUtils::addPeriodicImagesAndRelationships()</a>.</p>

</div>
</div>
<a class="anchor" id="ace6a5dbe88186e63811080f3734826e4"></a><!-- doxytag: member="SAMRAI::hier::OverlapConnectorAlgorithm::bridge" ref="ace6a5dbe88186e63811080f3734826e4" args="(boost::shared_ptr&lt; Connector &gt; &amp;west_to_east, const Connector &amp;west_to_center, const Connector &amp;center_to_east, bool compute_transpose) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::hier::OverlapConnectorAlgorithm::bridge </td>
          <td>(</td>
          <td class="paramtype">boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">Connector</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>west_to_east</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">Connector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>west_to_center</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">Connector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>center_to_east</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>compute_transpose</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>A version of bridge without limiting the connector_width of the result. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>west_to_east</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>west_to_center</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>center_to_east</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>compute_transpose</em>&nbsp;</td><td>true if west_to_east's transpose should be computed</td></tr>
  </table>
  </dd>
</dl>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>west_to_cent.hasTranspose() </dd>
<dd>
cent_to_east.hasTranspose()</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd>bridge( Connector&amp; west_to_east, const Connector&amp; west_to_center, const Connector&amp; center_to_east, const IntVector&amp; connector_width_limit, bool compute_transpose) const; </dd></dl>

<p>References <a class="el" href="SAMRAI__MPI_8C_source.html#l00768">SAMRAI::tbox::SAMRAI_MPI::Barrier()</a>, <a class="el" href="Connector_8h_source.html#l00754">SAMRAI::hier::Connector::getBase()</a>, <a class="el" href="Connector_8h_source.html#l00982">SAMRAI::hier::Connector::getConnectorWidth()</a>, <a class="el" href="IntVector_8h_source.html#l00721">SAMRAI::hier::IntVector::getDim()</a>, <a class="el" href="Connector_8h_source.html#l00781">SAMRAI::hier::Connector::getHead()</a>, <a class="el" href="BoxLevel_8h_source.html#l00398">SAMRAI::hier::BoxLevel::getMPI()</a>, <a class="el" href="Connector_8h_source.html#l01148">SAMRAI::hier::Connector::getTranspose()</a>, <a class="el" href="IntVector_8h_source.html#l00732">SAMRAI::hier::IntVector::getZero()</a>, <a class="el" href="SAMRAI__MPI_8h_source.html#l00296">SAMRAI::tbox::SAMRAI_MPI::hasNullCommunicator()</a>, <a class="el" href="Connector_8h_source.html#l01137">SAMRAI::hier::Connector::hasTranspose()</a>, and <a class="el" href="Utilities_8h_source.html#l00110">TBOX_ASSERT</a>.</p>

</div>
</div>
<a class="anchor" id="a2eee26beb8ea8bbc4977f5ac1eb45768"></a><!-- doxytag: member="SAMRAI::hier::OverlapConnectorAlgorithm::bridge" ref="a2eee26beb8ea8bbc4977f5ac1eb45768" args="(Connector &amp;west_to_center, const Connector &amp;center_to_east, const IntVector &amp;connector_width_limit) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::hier::OverlapConnectorAlgorithm::bridge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">Connector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>west_to_center</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">Connector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>center_to_east</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>connector_width_limit</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>A version of bridge without any guarantee of nesting in which an input connector and its transpose are modified to form the resulting bridge connectors. </p>
<p>The east and west BoxLevels are assumed to nest in the center <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html" title="A distributed set of Box objects which reside in the same index space.">BoxLevel</a>. If they do not, the results are not guaranteed to be complete.</p>
<p>The output <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html" title="A container which holds relationship connections between two BoxLevels.">Connector</a> widths are the greater of the widths of <code>center_to_east</code> and west_to_center's transpose (converted into the proper index space, of course).</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>west_to_center</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>center_to_east</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>connector_width_limit</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>west_to_cent.hasTranspose() </dd>
<dd>
cent_to_east.hasTranspose()</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd>bridgeWithNesting( Connector&amp; west_to_east, const Connector&amp; west_to_center, const Connector&amp; center_to_east, const IntVector&amp; center_growth_to_nest_west, const IntVector&amp; center_growth_to_nest_east, const IntVector&amp; connector_width_limit, bool compute_transpose) const; </dd></dl>

<p>References <a class="el" href="SAMRAI__MPI_8C_source.html#l00768">SAMRAI::tbox::SAMRAI_MPI::Barrier()</a>, <a class="el" href="Connector_8h_source.html#l00190">SAMRAI::hier::Connector::clearNeighborhoods()</a>, <a class="el" href="Connector_8h_source.html#l00754">SAMRAI::hier::Connector::getBase()</a>, <a class="el" href="Connector_8h_source.html#l00982">SAMRAI::hier::Connector::getConnectorWidth()</a>, <a class="el" href="IntVector_8h_source.html#l00721">SAMRAI::hier::IntVector::getDim()</a>, <a class="el" href="Connector_8h_source.html#l00781">SAMRAI::hier::Connector::getHead()</a>, <a class="el" href="BoxLevel_8h_source.html#l00398">SAMRAI::hier::BoxLevel::getMPI()</a>, <a class="el" href="Connector_8h_source.html#l01148">SAMRAI::hier::Connector::getTranspose()</a>, <a class="el" href="IntVector_8h_source.html#l00732">SAMRAI::hier::IntVector::getZero()</a>, <a class="el" href="SAMRAI__MPI_8h_source.html#l00296">SAMRAI::tbox::SAMRAI_MPI::hasNullCommunicator()</a>, <a class="el" href="Connector_8h_source.html#l01137">SAMRAI::hier::Connector::hasTranspose()</a>, <a class="el" href="Connector_8C_source.html#l00910">SAMRAI::hier::Connector::setBase()</a>, <a class="el" href="Connector_8C_source.html#l00932">SAMRAI::hier::Connector::setHead()</a>, <a class="el" href="Connector_8C_source.html#l00953">SAMRAI::hier::Connector::setWidth()</a>, and <a class="el" href="Utilities_8h_source.html#l00110">TBOX_ASSERT</a>.</p>

</div>
</div>
<a class="anchor" id="a99bf3a60edd92ad43916c7410c9d5129"></a><!-- doxytag: member="SAMRAI::hier::OverlapConnectorAlgorithm::setBarrierBeforeCommunication" ref="a99bf3a60edd92ad43916c7410c9d5129" args="(bool do_barrier)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::hier::OverlapConnectorAlgorithm::setBarrierBeforeCommunication </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>do_barrier</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set whether to barrier before potential major communication. </p>
<p>This developer feature makes sure all processes start major operations at the same time so that timers do not include the time waiting for slower processes to get to the starting point.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>do_barrier</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a29f448936a23f8dd367ce65c371466a8"></a><!-- doxytag: member="SAMRAI::hier::OverlapConnectorAlgorithm::setSanityCheckMethodPreconditions" ref="a29f448936a23f8dd367ce65c371466a8" args="(bool do_check)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::hier::OverlapConnectorAlgorithm::setSanityCheckMethodPreconditions </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>do_check</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>When <code>do_check</code> is true, turn on sanity checks for input parameters. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>Sanity checks occur at the beginning of certain methods only. The checks are expensive and meant mainly for debugging.</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>do_check</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>

<p>Referenced by <a class="el" href="BoxLevelConnectorUtils_8C_source.html#l01270">SAMRAI::hier::BoxLevelConnectorUtils::addPeriodicImagesAndRelationships()</a>.</p>

</div>
</div>
<a class="anchor" id="a7088a2d599fd1d4c7efca3d078207e98"></a><!-- doxytag: member="SAMRAI::hier::OverlapConnectorAlgorithm::setSanityCheckMethodPostconditions" ref="a7088a2d599fd1d4c7efca3d078207e98" args="(bool do_check)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::hier::OverlapConnectorAlgorithm::setSanityCheckMethodPostconditions </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>do_check</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>When <code>do_check</code> is true, turn on sanity checks for outputs. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>Sanity checks occur at the end of certain methods only. The checks are expensive and meant mainly for debugging.</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>do_check</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2c5d518cee5fba53a393387a4110bb14"></a><!-- doxytag: member="SAMRAI::hier::OverlapConnectorAlgorithm::setSAMRAI_MPI" ref="a2c5d518cee5fba53a393387a4110bb14" args="(const tbox::SAMRAI_MPI &amp;mpi, bool make_duplicate=true)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::hier::OverlapConnectorAlgorithm::setSAMRAI_MPI </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1tbox_1_1SAMRAI__MPI.html">tbox::SAMRAI_MPI</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>mpi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>make_duplicate</em> = <code>true</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set the SAMRAI_MPI to use. </p>
<p>If set, communication will use the specified SAMRAI_MPI instead of the SAMRAI_MPI from BoxLevels. This protects communication operations from accidentally interacting with unrelated communications, but it limits operations to work only with metadata objects with comptatible (congruent) SAMRAI_MPI objects.</p>
<p>If make_duplicate is true, the specified SAMRAI_MPI will be duplicated for exclusise use. The duplicate will be freed upon object destruction. </p>

<p>References <a class="el" href="SAMRAI__MPI_8C_source.html#l01583">SAMRAI::tbox::SAMRAI_MPI::dupCommunicator()</a>, and <a class="el" href="SAMRAI__MPI_8C_source.html#l01608">SAMRAI::tbox::SAMRAI_MPI::freeCommunicator()</a>.</p>

<p>Referenced by <a class="el" href="GriddingAlgorithm_8C_source.html#l00066">SAMRAI::mesh::GriddingAlgorithm::GriddingAlgorithm()</a>.</p>

</div>
</div>
<a class="anchor" id="a2642092f5b583af36c564849ad2df1f7"></a><!-- doxytag: member="SAMRAI::hier::OverlapConnectorAlgorithm::setPrintSteps" ref="a2642092f5b583af36c564849ad2df1f7" args="(bool print_steps)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::hier::OverlapConnectorAlgorithm::setPrintSteps </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>print_steps</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>When <code>print_steps</code> is true, print what the code is doing. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>Step printing may be expensive and and is meant mainly for debugging.</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>print_steps</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8d69f7abe729ec94f3e4ca647116286e"></a><!-- doxytag: member="SAMRAI::hier::OverlapConnectorAlgorithm::setTimerPrefix" ref="a8d69f7abe729ec94f3e4ca647116286e" args="(const std::string &amp;timer_prefix)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::hier::OverlapConnectorAlgorithm::setTimerPrefix </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>timer_prefix</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Setup names of timers. </p>
<p>By default, timers are named "hier::OverlapConnectorAlgorithm::*", where the third field is the specific steps performed by the <a class="el" href="classSAMRAI_1_1hier_1_1MappingConnectorAlgorithm.html" title="Algorithms for using MappingConnectors representing changes to a BoxLevel.">MappingConnectorAlgorithm</a>. You can override the first two fields with this method. Conforming to the timer naming convention, timer_prefix should have the form "*::*". </p>

<p>Referenced by <a class="el" href="GriddingAlgorithm_8C_source.html#l00066">SAMRAI::mesh::GriddingAlgorithm::GriddingAlgorithm()</a>, <a class="el" href="OverlapConnectorAlgorithm_8C_source.html#l00061">OverlapConnectorAlgorithm()</a>, and <a class="el" href="TileClustering_8C_source.html#l00036">SAMRAI::mesh::TileClustering::TileClustering()</a>.</p>

</div>
</div>
<a class="anchor" id="a8bb13003c85cb2ce6fbdc30488b9a6a4"></a><!-- doxytag: member="SAMRAI::hier::OverlapConnectorAlgorithm::getObjectName" ref="a8bb13003c85cb2ce6fbdc30488b9a6a4" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::string SAMRAI::hier::OverlapConnectorAlgorithm::getObjectName </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the name of this object. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>source/SAMRAI/hier/<a class="el" href="OverlapConnectorAlgorithm_8h.html">OverlapConnectorAlgorithm.h</a></li>
<li>source/SAMRAI/hier/<a class="el" href="OverlapConnectorAlgorithm_8C.html">OverlapConnectorAlgorithm.C</a></li>
</ul>
</div>
<hr size="1"/><address style="text-align: right;"><small>Generated on 3 Dec 2014 for SAMRAI by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.1 </small></address>
</body>
</html>
