<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>SAMRAI: SAMRAI::hier::OverlapConnectorAlgorithm Class Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.7 -->
<div class="tabs">
  <ul>
    <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="namespaces.html"><span>Namespaces</span></a></li>
    <li id="current"><a href="annotated.html"><span>Classes</span></a></li>
    <li><a href="files.html"><span>Files</span></a></li>
    <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
  </ul></div>
<div class="tabs">
  <ul>
    <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
    <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
    <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
  </ul></div>
<div class="nav">
<a class="el" href="namespaceSAMRAI.html">SAMRAI</a>::<a class="el" href="namespaceSAMRAI_1_1hier.html">hier</a>::<a class="el" href="classSAMRAI_1_1hier_1_1OverlapConnectorAlgorithm.html">OverlapConnectorAlgorithm</a></div>
<h1>SAMRAI::hier::OverlapConnectorAlgorithm Class Reference</h1><!-- doxytag: class="SAMRAI::hier::OverlapConnectorAlgorithm" --><!-- doxytag: inherits="SAMRAI::hier::BaseConnectorAlgorithm" -->Algorithms for working Connectors whose neighbor data represents overlaps.  
<a href="#_details">More...</a>
<p>
<code>#include &lt;source/SAMRAI/hier/OverlapConnectorAlgorithm.h&gt;</code>
<p>
<p>Inheritance diagram for SAMRAI::hier::OverlapConnectorAlgorithm:
<p><center><img src="classSAMRAI_1_1hier_1_1OverlapConnectorAlgorithm.png" usemap="#SAMRAI::hier::OverlapConnectorAlgorithm_map" border="0" alt=""></center>
<map name="SAMRAI::hier::OverlapConnectorAlgorithm_map">
<area href="classSAMRAI_1_1hier_1_1BaseConnectorAlgorithm.html" alt="SAMRAI::hier::BaseConnectorAlgorithm" shape="rect" coords="0,0,252,24">
</map>
<a href="classSAMRAI_1_1hier_1_1OverlapConnectorAlgorithm-members.html">List of all members.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1OverlapConnectorAlgorithm.html#5035bbebfa166de6e1601a7b6e3907f1">OverlapConnectorAlgorithm</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Constructor.  <a href="#5035bbebfa166de6e1601a7b6e3907f1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1OverlapConnectorAlgorithm.html#50b389f621cf8086641063518662bbcd">~OverlapConnectorAlgorithm</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Destructor.  <a href="#50b389f621cf8086641063518662bbcd"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1OverlapConnectorAlgorithm.html#96125360a070e96de0046f919ec99530">getFromInput</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Read extra debugging flag from input database.  <a href="#96125360a070e96de0046f919ec99530"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1OverlapConnectorAlgorithm.html#e332c260d625389d3d7ce6140fbcf788">findOverlaps</a> (<a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">Connector</a> &amp;connector, const bool ignore_self_overlap=false) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Discover and add overlaps from base to head for an overlap <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">Connector</a>.  <a href="#e332c260d625389d3d7ce6140fbcf788"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1OverlapConnectorAlgorithm.html#5f56d7303025dffaef086edf0185cf4f">findOverlaps</a> (<a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">Connector</a> &amp;connector, const <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a> &amp;globalized_head, const bool ignore_self_overlap=false) const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1OverlapConnectorAlgorithm.html#117ab34c4e5ec7b7e2942dca5bc6460f">extractNeighbors</a> (<a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">Connector::NeighborSet</a> &amp;neighbors, const <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">Connector</a> &amp;connector, const <a class="el" href="classSAMRAI_1_1hier_1_1BoxId.html">BoxId</a> &amp;box_id, const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;gcw) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">For a given <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">Connector</a>, get the subset of overlapping neighbors defined by the given <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">Connector</a> width.  <a href="#117ab34c4e5ec7b7e2942dca5bc6460f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1OverlapConnectorAlgorithm.html#00a49de1613717173249513c0e4a904a">extractNeighbors</a> (<a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">Connector</a> &amp;other, const <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">Connector</a> &amp;connector, const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;gcw) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Like extractNeighbors above except that it computes all neighborhoods of connector placing them into other.  <a href="#00a49de1613717173249513c0e4a904a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1OverlapConnectorAlgorithm.html#36f9a1b95d0481440b4e3e6a0b47ae35">bridgeWithNesting</a> (<a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">Connector</a> &amp;west_to_east, <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">Connector</a> &amp;east_to_west, const <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">Connector</a> &amp;west_to_center, const <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">Connector</a> &amp;center_to_east, const <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">Connector</a> &amp;east_to_center, const <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">Connector</a> &amp;center_to_west, const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;center_growth_to_nest_west, const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;center_growth_to_nest_east, const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;connector_width_limit) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute the overlap Connectors between BoxLevels efficiently by using information from existing overlap Connectors.  <a href="#36f9a1b95d0481440b4e3e6a0b47ae35"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1OverlapConnectorAlgorithm.html#ba9242be7ba1527ce47ea4fe89b48a9e">bridge</a> (<a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">Connector</a> &amp;west_to_east, <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">Connector</a> &amp;east_to_west, const <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">Connector</a> &amp;west_to_center, const <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">Connector</a> &amp;center_to_east, const <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">Connector</a> &amp;east_to_center, const <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">Connector</a> &amp;center_to_west, const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;connector_width_limit) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A version of bridge without any guarantee of nesting.  <a href="#ba9242be7ba1527ce47ea4fe89b48a9e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1OverlapConnectorAlgorithm.html#9b94c1d6cb200300932ae2d6d0fdbd8a">bridge</a> (<a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">Connector</a> &amp;west_to_east, const <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">Connector</a> &amp;west_to_center, const <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">Connector</a> &amp;center_to_east, const <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">Connector</a> &amp;east_to_center, const <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">Connector</a> &amp;center_to_west, const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;connector_width_limit) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A version of bridge without computing the reverse bridge.  <a href="#9b94c1d6cb200300932ae2d6d0fdbd8a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1OverlapConnectorAlgorithm.html#88cdea100b05a06c35094f1d1f634b09">bridge</a> (<a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">Connector</a> &amp;west_to_east, <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">Connector</a> &amp;east_to_west, const <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">Connector</a> &amp;west_to_center, const <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">Connector</a> &amp;center_to_east, const <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">Connector</a> &amp;east_to_center, const <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">Connector</a> &amp;center_to_west) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A version of bridge without limiting the connector_width of the result.  <a href="#88cdea100b05a06c35094f1d1f634b09"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1OverlapConnectorAlgorithm.html#62002e55ddb736796f75faf1363aeb30">bridge</a> (<a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">Connector</a> &amp;west_to_east, const <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">Connector</a> &amp;west_to_center, const <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">Connector</a> &amp;center_to_east, const <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">Connector</a> &amp;east_to_center, const <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">Connector</a> &amp;center_to_west) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A version of bridge without computing the reverse bridge and without limiting the connector_width of the result.  <a href="#62002e55ddb736796f75faf1363aeb30"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1OverlapConnectorAlgorithm.html#6c1f4d3963f7f04460662340b4306dd0">bridge</a> (<a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">Connector</a> &amp;west_to_center, const <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">Connector</a> &amp;center_to_east, const <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">Connector</a> &amp;east_to_center, <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">Connector</a> &amp;center_to_west, const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;connector_width_limit) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A version of bridge without any guarantee of nesting in which one pair of input connectors is modified to form the resulting bridge connectors.  <a href="#6c1f4d3963f7f04460662340b4306dd0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1OverlapConnectorAlgorithm.html#29f448936a23f8dd367ce65c371466a8">setSanityCheckMethodPreconditions</a> (bool do_check)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">When <code>do_check</code> is true, turn on sanity checks for input parameters.  <a href="#29f448936a23f8dd367ce65c371466a8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1OverlapConnectorAlgorithm.html#7088a2d599fd1d4c7efca3d078207e98">setSanityCheckMethodPostconditions</a> (bool do_check)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">When <code>do_check</code> is true, turn on sanity checks for outputs.  <a href="#7088a2d599fd1d4c7efca3d078207e98"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1OverlapConnectorAlgorithm.html#0b02ac3cab3c458913a70a2d55ac707c">checkOverlapCorrectness</a> (const <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">Connector</a> &amp;connector, bool ignore_self_overlap=false, bool assert_completeness=true, bool ignore_periodic_images=false) const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1OverlapConnectorAlgorithm.html#ffbc9d6e16c0cf8515d71012afd275c0">assertOverlapCorrectness</a> (const <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">Connector</a> &amp;connector, bool ignore_self_overlap=false, bool assert_completeness=true, bool ignore_periodic_images=false) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Assert overlap correctness.  <a href="#ffbc9d6e16c0cf8515d71012afd275c0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1OverlapConnectorAlgorithm.html#e93ab6ff1829b5d3b8a3e9d95d40a318">findOverlapErrors</a> (const <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">Connector</a> &amp;connector, <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">Connector</a> &amp;missing, <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">Connector</a> &amp;extra, bool ignore_self_overlap=false) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Find errors in overlap data of an overlap <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">Connector</a>.  <a href="#e93ab6ff1829b5d3b8a3e9d95d40a318"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">const std::string&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1OverlapConnectorAlgorithm.html#8bb13003c85cb2ce6fbdc30488b9a6a4">getObjectName</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the name of this object.  <a href="#8bb13003c85cb2ce6fbdc30488b9a6a4"></a><br></td></tr>
</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
Algorithms for working Connectors whose neighbor data represents overlaps. 
<p>
An overlap <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">Connector</a> is one in which neighbors represent a pair of overlapping Boxes. If a base <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> grown by the <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">Connector</a> width overlaps a head <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a>, the head <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> is a neighbor of the base <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a>. This class implements some functions for working with a overlap Connectors.<p>
<a class="el" href="classSAMRAI_1_1hier_1_1OverlapConnectorAlgorithm.html">OverlapConnectorAlgorithm</a> objects create, check and operate on overlap Connectors. 
<p>
<hr><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" name="5035bbebfa166de6e1601a7b6e3907f1"></a><!-- doxytag: member="SAMRAI::hier::OverlapConnectorAlgorithm::OverlapConnectorAlgorithm" ref="5035bbebfa166de6e1601a7b6e3907f1" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SAMRAI::hier::OverlapConnectorAlgorithm::OverlapConnectorAlgorithm           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Constructor. 
<p>

</div>
</div><p>
<a class="anchor" name="50b389f621cf8086641063518662bbcd"></a><!-- doxytag: member="SAMRAI::hier::OverlapConnectorAlgorithm::~OverlapConnectorAlgorithm" ref="50b389f621cf8086641063518662bbcd" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SAMRAI::hier::OverlapConnectorAlgorithm::~OverlapConnectorAlgorithm           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Destructor. 
<p>

</div>
</div><p>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="96125360a070e96de0046f919ec99530"></a><!-- doxytag: member="SAMRAI::hier::OverlapConnectorAlgorithm::getFromInput" ref="96125360a070e96de0046f919ec99530" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::hier::OverlapConnectorAlgorithm::getFromInput           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Read extra debugging flag from input database. 
<p>

</div>
</div><p>
<a class="anchor" name="e332c260d625389d3d7ce6140fbcf788"></a><!-- doxytag: member="SAMRAI::hier::OverlapConnectorAlgorithm::findOverlaps" ref="e332c260d625389d3d7ce6140fbcf788" args="(Connector &amp;connector, const bool ignore_self_overlap=false) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::hier::OverlapConnectorAlgorithm::findOverlaps           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">Connector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>connector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&nbsp;</td>
          <td class="paramname"> <em>ignore_self_overlap</em> = <code>false</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Discover and add overlaps from base to head for an overlap <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">Connector</a>. 
<p>
The Connector's neighbor information is modified.<p>
If the Connector's head is not GLOBALIZED, a copy is made and globalized. Once a globalized head is obtained, this method simply calls findOverlaps(const BoxLevel &amp;globalized_head).<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>connector</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>ignore_self_overlap</em>&nbsp;</td><td></td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="5f56d7303025dffaef086edf0185cf4f"></a><!-- doxytag: member="SAMRAI::hier::OverlapConnectorAlgorithm::findOverlaps" ref="5f56d7303025dffaef086edf0185cf4f" args="(Connector &amp;connector, const BoxLevel &amp;globalized_head, const bool ignore_self_overlap=false) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::hier::OverlapConnectorAlgorithm::findOverlaps           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">Connector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>connector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>globalized_head</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&nbsp;</td>
          <td class="paramname"> <em>ignore_self_overlap</em> = <code>false</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="117ab34c4e5ec7b7e2942dca5bc6460f"></a><!-- doxytag: member="SAMRAI::hier::OverlapConnectorAlgorithm::extractNeighbors" ref="117ab34c4e5ec7b7e2942dca5bc6460f" args="(Connector::NeighborSet &amp;neighbors, const Connector &amp;connector, const BoxId &amp;box_id, const IntVector &amp;gcw) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::hier::OverlapConnectorAlgorithm::extractNeighbors           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">Connector::NeighborSet</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>neighbors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">Connector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>connector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1BoxId.html">BoxId</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>box_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>gcw</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
For a given <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">Connector</a>, get the subset of overlapping neighbors defined by the given <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">Connector</a> width. 
<p>
The difference between <a class="el" href="classSAMRAI_1_1hier_1_1OverlapConnectorAlgorithm.html#117ab34c4e5ec7b7e2942dca5bc6460f">extractNeighbors()</a> and Connector::getNeighbors() is that <a class="el" href="classSAMRAI_1_1hier_1_1OverlapConnectorAlgorithm.html#117ab34c4e5ec7b7e2942dca5bc6460f">extractNeighbors()</a> extracts the subset of the currently stored neighbors associated with the given <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">Connector</a> width. getNeighbors() returns the entire neighbor set, which corresponds to the Connector's width. The specified <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">Connector</a> width must be less than or equal to the Connector's width.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>neighbors</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>connector</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>box_id</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>gcw</em>&nbsp;</td><td></td></tr>
  </table>
</dl>
<dl compact><dt><b>Precondition:</b></dt><dd>gcw &lt;= connector.getConnectorWidth() <p>
(connector.getParallelState() == <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#02c34699888ab34b06f59a210247bcb42dbf00b87512ae236e2dbde25acb952f">BoxLevel::GLOBALIZED</a>) || (box_id.getOwnerRank() == connector.getMPI().getRank()) <p>
connector.getBase().hasBox(box_id) </dd></dl>

</div>
</div><p>
<a class="anchor" name="00a49de1613717173249513c0e4a904a"></a><!-- doxytag: member="SAMRAI::hier::OverlapConnectorAlgorithm::extractNeighbors" ref="00a49de1613717173249513c0e4a904a" args="(Connector &amp;other, const Connector &amp;connector, const IntVector &amp;gcw) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::hier::OverlapConnectorAlgorithm::extractNeighbors           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">Connector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">Connector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>connector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>gcw</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Like extractNeighbors above except that it computes all neighborhoods of connector placing them into other. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>other</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>connector</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>gcw</em>&nbsp;</td><td></td></tr>
  </table>
</dl>
<dl compact><dt><b>Precondition:</b></dt><dd>gcw &lt;= connector.getConnectorWidth() <p>
for the box_id of each neighborhood base box in connector, (connector.getParallelState() == <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#02c34699888ab34b06f59a210247bcb42dbf00b87512ae236e2dbde25acb952f">BoxLevel::GLOBALIZED</a>) || (box_id.getOwnerRank() == connector.getMPI().getRank()) <p>
for the box_id of each neighborhood base box in connector, connector.getBase().hasBox(box_id) </dd></dl>

</div>
</div><p>
<a class="anchor" name="36f9a1b95d0481440b4e3e6a0b47ae35"></a><!-- doxytag: member="SAMRAI::hier::OverlapConnectorAlgorithm::bridgeWithNesting" ref="36f9a1b95d0481440b4e3e6a0b47ae35" args="(Connector &amp;west_to_east, Connector &amp;east_to_west, const Connector &amp;west_to_center, const Connector &amp;center_to_east, const Connector &amp;east_to_center, const Connector &amp;center_to_west, const IntVector &amp;center_growth_to_nest_west, const IntVector &amp;center_growth_to_nest_east, const IntVector &amp;connector_width_limit) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::hier::OverlapConnectorAlgorithm::bridgeWithNesting           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">Connector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>west_to_east</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">Connector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>east_to_west</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">Connector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>west_to_center</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">Connector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>center_to_east</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">Connector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>east_to_center</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">Connector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>center_to_west</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>center_growth_to_nest_west</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>center_growth_to_nest_east</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>connector_width_limit</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Compute the overlap Connectors between BoxLevels efficiently by using information from existing overlap Connectors. 
<p>
Let east, west and center be BoxLevels. Given overlap Connectors between center and east and between center and west, compute overlap Connectors between east and west.<p>
<div class="fragment"><pre class="fragment">               Input:                            Output:

                                               west to east
      (west)              (east)      (west) ---------------&gt; (east)
        \ ^                ^ /               &lt;---------------
         \ \center  center/ /                  east to west
          \ \ to     to  / /
       west\ \west  east/ /east
        to  \ \        / /  to
       center\ \      / /center
              v \    / v
               (center)
</pre></div><p>
The "bridge" is the Connectors between <code>west</code> and <code>east</code>. Bridging is an algorithm for finding their overlaps using existing overlaps incident from <code>center</code>. This is more efficient than <a class="el" href="classSAMRAI_1_1hier_1_1OverlapConnectorAlgorithm.html#e332c260d625389d3d7ce6140fbcf788">findOverlaps()</a> because it does not require acquiring, storing or searching globalized data.<p>
Preconditions:<p>
<ul>
<li>Four input Connectors refer to the center <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a>, two refer to the west, and two refer to the east. The center, east and west BoxLevels must be the same regardless of what <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">Connector</a> is used to get them. For example, <code> &amp;center_to_west.getHead() == &amp;west_to_center.getBase() </code> must be true.</li></ul>
<p>
<ul>
<li><code>west_to_center</code> and <code>center_to_west</code> must be mutual transposes.</li></ul>
<p>
<ul>
<li><code>east_to_center</code> and <code>center_to_east</code> must be mutual transposes.</li></ul>
<p>
Postconditions:<p>
<ul>
<li><code>west</code> and <code>east</code>, as referenced by the output Connectors are heads of <code>center_to_west</code> and <code>center_to_east</code>.</li>
</ul>
<ul>
<li>Widths of the output Connectors will be either <code>center_to_east's</code> width reduced by <code>center_growth_to_nest_west</code> or <code>center_to_west's</code> width reduced by <code>center_growth_to_nest_east</code>, which ever is greater. Output <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">Connector</a> widths are still limited by the <code>connector_width_limit</code> argument. All comparisons are done after the appropriate index space conversions, of course.</li>
</ul>
<dl compact><dt><b>Note:</b></dt><dd></dd></dl>
<ul>
<li>Although <code>east</code>, <code>west</code> and <code>center</code> are not explicit parameters, they are specified implicitly through the input Connectors.</li>
</ul>
<ul>
<li>The bridge operation works in the degenerate case where <code>east</code> and <code>west</code> are the same object. In that case, <code>west_to_east</code> and <code>east_to_west</code> should also be the same object.</li>
</ul>
<ul>
<li>Bridging finds as many overlaps as it can, given the inputs, but can only guarantee that the output Connectors are complete overlap Connectors if there is nesting as specified by the arguments <code>center_growth_to_nest_west</code> and/or <code>center_growth_to_nest_east</code>. Nesting is not checked, because checking requires an iterative non-scalable computation. Nesting is best determined by the code that created the BoxLevels involved. Bridging is meant to be fast and scalable.</li>
</ul>
<ul>
<li>Periodic relationships are automatically generated if a head <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> in its shifted position overlaps the grown base <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a>. However, because neighbors may be remote, we cannot scalably verify that the periodic neighbors actually exist in the heads of the output Connectors. Spurious periodic relationships may be generated when the periodic image simply has not be added to the head or when parts of east or west lie outside the domain extents. They can be discarded using <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html#a34973973b4d43f6ec68b3ec9c390829">Connector::removePeriodicRelationships</a> and properly regenerated using <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevelConnectorUtils.html">BoxLevelConnectorUtils</a>.</li>
</ul>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>west_to_east</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>east_to_west</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>west_to_center</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>center_to_east</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>east_to_center</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>center_to_west</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>center_growth_to_nest_west</em>&nbsp;</td><td>The amount by which the center <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a> must grow to nest the west <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a>. Bridging guarantees completeness if the width of <b>center_to_east</b> exceeds this amount. If unknown, set to negative value if unknown so it won't be considered when computing the output <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">Connector</a> widths.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>center_growth_to_nest_east</em>&nbsp;</td><td>The amount by which the center <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a> must grow to nest the east <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a>. Bridging guarantees completeness if the width of <b>center_to_west</b> exceeds this amount. If unknown, set to negative value if unknown so it won't be considered when computing the output <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">Connector</a> widths.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>connector_width_limit</em>&nbsp;</td><td>specifies the maximum <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">Connector</a> width to compute overlaps for. The connector_width should be in the coarser of the east and west indices. If connector_width_limit is negative, use the default connector_width, which is the larger of the center_to_west and center_to_east Connectors', coarsened into the coarser of east and west indices. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="ba9242be7ba1527ce47ea4fe89b48a9e"></a><!-- doxytag: member="SAMRAI::hier::OverlapConnectorAlgorithm::bridge" ref="ba9242be7ba1527ce47ea4fe89b48a9e" args="(Connector &amp;west_to_east, Connector &amp;east_to_west, const Connector &amp;west_to_center, const Connector &amp;center_to_east, const Connector &amp;east_to_center, const Connector &amp;center_to_west, const IntVector &amp;connector_width_limit) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::hier::OverlapConnectorAlgorithm::bridge           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">Connector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>west_to_east</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">Connector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>east_to_west</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">Connector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>west_to_center</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">Connector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>center_to_east</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">Connector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>east_to_center</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">Connector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>center_to_west</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>connector_width_limit</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
A version of bridge without any guarantee of nesting. 
<p>
The east and west BoxLevels are assumed to nest in the center <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a>. If they do not, the results are not guaranteed to be complete.<p>
The output <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">Connector</a> widths are the greater of the widths of <code>center_to_east</code> and <code>center_to_west</code> (converted into the proper index space, of course).<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>west_to_east</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>east_to_west</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>west_to_center</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>center_to_east</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>east_to_center</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>center_to_west</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>connector_width_limit</em>&nbsp;</td><td></td></tr>
  </table>
</dl>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classSAMRAI_1_1hier_1_1OverlapConnectorAlgorithm.html#36f9a1b95d0481440b4e3e6a0b47ae35">bridgeWithNesting( Connector&amp; west_to_east, Connector&amp; east_to_west, const Connector&amp; west_to_center, const Connector&amp; center_to_east, const Connector&amp; east_to_center, const Connector&amp; center_to_west, const IntVector&amp; center_growth_to_nest_west, const IntVector&amp; center_growth_to_nest_east, const IntVector&amp; connector_width_limit) const</a>; </dd></dl>

</div>
</div><p>
<a class="anchor" name="9b94c1d6cb200300932ae2d6d0fdbd8a"></a><!-- doxytag: member="SAMRAI::hier::OverlapConnectorAlgorithm::bridge" ref="9b94c1d6cb200300932ae2d6d0fdbd8a" args="(Connector &amp;west_to_east, const Connector &amp;west_to_center, const Connector &amp;center_to_east, const Connector &amp;east_to_center, const Connector &amp;center_to_west, const IntVector &amp;connector_width_limit) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::hier::OverlapConnectorAlgorithm::bridge           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">Connector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>west_to_east</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">Connector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>west_to_center</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">Connector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>center_to_east</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">Connector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>east_to_center</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">Connector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>center_to_west</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>connector_width_limit</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
A version of bridge without computing the reverse bridge. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>west_to_east</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>west_to_center</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>center_to_east</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>east_to_center</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>center_to_west</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>connector_width_limit</em>&nbsp;</td><td></td></tr>
  </table>
</dl>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classSAMRAI_1_1hier_1_1OverlapConnectorAlgorithm.html#ba9242be7ba1527ce47ea4fe89b48a9e">bridge( Connector&amp; west_to_east, Connector&amp; east_to_west, const Connector&amp; west_to_center, const Connector&amp; center_to_east, const Connector&amp; east_to_center, const Connector&amp; center_to_west, const IntVector&amp; connector_width_limit) const</a>; </dd></dl>

</div>
</div><p>
<a class="anchor" name="88cdea100b05a06c35094f1d1f634b09"></a><!-- doxytag: member="SAMRAI::hier::OverlapConnectorAlgorithm::bridge" ref="88cdea100b05a06c35094f1d1f634b09" args="(Connector &amp;west_to_east, Connector &amp;east_to_west, const Connector &amp;west_to_center, const Connector &amp;center_to_east, const Connector &amp;east_to_center, const Connector &amp;center_to_west) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::hier::OverlapConnectorAlgorithm::bridge           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">Connector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>west_to_east</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">Connector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>east_to_west</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">Connector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>west_to_center</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">Connector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>center_to_east</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">Connector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>east_to_center</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">Connector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>center_to_west</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
A version of bridge without limiting the connector_width of the result. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>west_to_east</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>east_to_west</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>west_to_center</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>center_to_east</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>east_to_center</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>center_to_west</em>&nbsp;</td><td></td></tr>
  </table>
</dl>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classSAMRAI_1_1hier_1_1OverlapConnectorAlgorithm.html#ba9242be7ba1527ce47ea4fe89b48a9e">bridge( Connector&amp; west_to_east, Connector&amp; east_to_west, const Connector&amp; west_to_center, const Connector&amp; center_to_east, const Connector&amp; east_to_center, const Connector&amp; center_to_west, const IntVector&amp; connector_width_limit) const</a>; </dd></dl>

</div>
</div><p>
<a class="anchor" name="62002e55ddb736796f75faf1363aeb30"></a><!-- doxytag: member="SAMRAI::hier::OverlapConnectorAlgorithm::bridge" ref="62002e55ddb736796f75faf1363aeb30" args="(Connector &amp;west_to_east, const Connector &amp;west_to_center, const Connector &amp;center_to_east, const Connector &amp;east_to_center, const Connector &amp;center_to_west) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::hier::OverlapConnectorAlgorithm::bridge           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">Connector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>west_to_east</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">Connector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>west_to_center</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">Connector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>center_to_east</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">Connector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>east_to_center</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">Connector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>center_to_west</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
A version of bridge without computing the reverse bridge and without limiting the connector_width of the result. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>west_to_east</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>west_to_center</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>center_to_east</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>east_to_center</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>center_to_west</em>&nbsp;</td><td></td></tr>
  </table>
</dl>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classSAMRAI_1_1hier_1_1OverlapConnectorAlgorithm.html#ba9242be7ba1527ce47ea4fe89b48a9e">bridge( Connector&amp; west_to_east, Connector&amp; east_to_west, const Connector&amp; west_to_center, const Connector&amp; center_to_east, const Connector&amp; east_to_center, const Connector&amp; center_to_west, const IntVector&amp; connector_width_limit) const</a>; </dd></dl>

</div>
</div><p>
<a class="anchor" name="6c1f4d3963f7f04460662340b4306dd0"></a><!-- doxytag: member="SAMRAI::hier::OverlapConnectorAlgorithm::bridge" ref="6c1f4d3963f7f04460662340b4306dd0" args="(Connector &amp;west_to_center, const Connector &amp;center_to_east, const Connector &amp;east_to_center, Connector &amp;center_to_west, const IntVector &amp;connector_width_limit) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::hier::OverlapConnectorAlgorithm::bridge           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">Connector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>west_to_center</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">Connector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>center_to_east</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">Connector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>east_to_center</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">Connector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>center_to_west</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>connector_width_limit</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
A version of bridge without any guarantee of nesting in which one pair of input connectors is modified to form the resulting bridge connectors. 
<p>
The east and west BoxLevels are assumed to nest in the center <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a>. If they do not, the results are not guaranteed to be complete.<p>
The output <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">Connector</a> widths are the greater of the widths of <code>center_to_east</code> and <code>center_to_west</code> (converted into the proper index space, of course).<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>west_to_center</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>center_to_east</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>east_to_center</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>center_to_west</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>connector_width_limit</em>&nbsp;</td><td></td></tr>
  </table>
</dl>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classSAMRAI_1_1hier_1_1OverlapConnectorAlgorithm.html#36f9a1b95d0481440b4e3e6a0b47ae35">bridgeWithNesting( Connector&amp; west_to_east, Connector&amp; east_to_west, const Connector&amp; west_to_center, const Connector&amp; center_to_east, const Connector&amp; east_to_center, const Connector&amp; center_to_west, const IntVector&amp; center_growth_to_nest_west, const IntVector&amp; center_growth_to_nest_east, const IntVector&amp; connector_width_limit) const</a>; </dd></dl>

</div>
</div><p>
<a class="anchor" name="29f448936a23f8dd367ce65c371466a8"></a><!-- doxytag: member="SAMRAI::hier::OverlapConnectorAlgorithm::setSanityCheckMethodPreconditions" ref="29f448936a23f8dd367ce65c371466a8" args="(bool do_check)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::hier::OverlapConnectorAlgorithm::setSanityCheckMethodPreconditions           </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>do_check</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
When <code>do_check</code> is true, turn on sanity checks for input parameters. 
<p>
<dl compact><dt><b>Note:</b></dt><dd>Sanity checks occur at the beginning of certain methods only. The checks are expensive and meant mainly for debugging.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>do_check</em>&nbsp;</td><td></td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="7088a2d599fd1d4c7efca3d078207e98"></a><!-- doxytag: member="SAMRAI::hier::OverlapConnectorAlgorithm::setSanityCheckMethodPostconditions" ref="7088a2d599fd1d4c7efca3d078207e98" args="(bool do_check)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::hier::OverlapConnectorAlgorithm::setSanityCheckMethodPostconditions           </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>do_check</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
When <code>do_check</code> is true, turn on sanity checks for outputs. 
<p>
<dl compact><dt><b>Note:</b></dt><dd>Sanity checks occur at the end of certain methods only. The checks are expensive and meant mainly for debugging.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>do_check</em>&nbsp;</td><td></td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="0b02ac3cab3c458913a70a2d55ac707c"></a><!-- doxytag: member="SAMRAI::hier::OverlapConnectorAlgorithm::checkOverlapCorrectness" ref="0b02ac3cab3c458913a70a2d55ac707c" args="(const Connector &amp;connector, bool ignore_self_overlap=false, bool assert_completeness=true, bool ignore_periodic_images=false) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int SAMRAI::hier::OverlapConnectorAlgorithm::checkOverlapCorrectness           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">Connector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>connector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>ignore_self_overlap</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>assert_completeness</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>ignore_periodic_images</em> = <code>false</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Check that overlap data is correct (represents overlaps) for the given <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">Connector</a>.<p>
Checking is done as follows:<ul>
<li>Find overlap errors using <code><a class="el" href="classSAMRAI_1_1hier_1_1OverlapConnectorAlgorithm.html#e93ab6ff1829b5d3b8a3e9d95d40a318">findOverlapErrors()</a></code>.</li><li>Report overlap errors to <code><a class="el" href="namespaceSAMRAI_1_1tbox.html#d72fd66574b63c87061563d2c66b5475">tbox::perr</a></code>.</li><li>Return number of local errors.</li></ul>
<p>
<dl compact><dt><b>Note:</b></dt><dd>This is an expensive operation (it uses <b><a class="el" href="classSAMRAI_1_1hier_1_1OverlapConnectorAlgorithm.html#e93ab6ff1829b5d3b8a3e9d95d40a318">findOverlapErrors()</a></b>) and should only be used for debugging.</dd></dl>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classSAMRAI_1_1hier_1_1OverlapConnectorAlgorithm.html#e332c260d625389d3d7ce6140fbcf788">findOverlaps()</a></dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>connector</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>ignore_self_overlap</em>&nbsp;</td><td>Ignore a box's overlap with itself </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>assert_completeness</em>&nbsp;</td><td>If false, ignore missing overlaps. This will still look for overlaps that should not be there. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>ignore_periodic_images</em>&nbsp;</td><td>If true, do not require neighbors that are periodic images.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Number of overlap errors found locally.</dd></dl>
<dl compact><dt><b>Precondition:</b></dt><dd>(connector.getBase().isInitialized()) &amp;&amp; (connector.getHead().isInitialized()) <p>
!connector.hasPeriodicLocalNeighborhoodBaseBoxes() </dd></dl>

</div>
</div><p>
<a class="anchor" name="ffbc9d6e16c0cf8515d71012afd275c0"></a><!-- doxytag: member="SAMRAI::hier::OverlapConnectorAlgorithm::assertOverlapCorrectness" ref="ffbc9d6e16c0cf8515d71012afd275c0" args="(const Connector &amp;connector, bool ignore_self_overlap=false, bool assert_completeness=true, bool ignore_periodic_images=false) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::hier::OverlapConnectorAlgorithm::assertOverlapCorrectness           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">Connector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>connector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>ignore_self_overlap</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>assert_completeness</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>ignore_periodic_images</em> = <code>false</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Assert overlap correctness. 
<p>
<dl compact><dt><b>Assertions</b></dt><dd>if an error is found, the method will write out diagnostic information and throw an an error on all processes.</dd></dl>
This is an expensive check.<p>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classSAMRAI_1_1hier_1_1OverlapConnectorAlgorithm.html#0b02ac3cab3c458913a70a2d55ac707c">checkOverlapCorrectness()</a>.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>connector</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>ignore_self_overlap</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>assert_completeness</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>ignore_periodic_images</em>&nbsp;</td><td></td></tr>
  </table>
</dl>
<dl compact><dt><b>Precondition:</b></dt><dd>(connector.getBase().isInitialized()) &amp;&amp; (connector.getHead().isInitialized()) </dd></dl>

</div>
</div><p>
<a class="anchor" name="e93ab6ff1829b5d3b8a3e9d95d40a318"></a><!-- doxytag: member="SAMRAI::hier::OverlapConnectorAlgorithm::findOverlapErrors" ref="e93ab6ff1829b5d3b8a3e9d95d40a318" args="(const Connector &amp;connector, Connector &amp;missing, Connector &amp;extra, bool ignore_self_overlap=false) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::hier::OverlapConnectorAlgorithm::findOverlapErrors           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">Connector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>connector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">Connector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>missing</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">Connector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>extra</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>ignore_self_overlap</em> = <code>false</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Find errors in overlap data of an overlap <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">Connector</a>. 
<p>
An error is either a missing overlap or an extra overlap.<p>
This is an expensive operation and should only be used for debugging.<p>
<dl compact><dt><b>Assertions</b></dt><dd>This version throws an assertion only if it finds inconsistent <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">Connector</a> data. Missing and extra overlaps are returned but do not cause an assertion.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>connector</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>missing</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>extra</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>ignore_self_overlap</em>&nbsp;</td><td></td></tr>
  </table>
</dl>
<dl compact><dt><b>Precondition:</b></dt><dd>(connector.getBase().isInitialized()) &amp;&amp; (connector.getHead().isInitialized()) </dd></dl>

</div>
</div><p>
<a class="anchor" name="8bb13003c85cb2ce6fbdc30488b9a6a4"></a><!-- doxytag: member="SAMRAI::hier::OverlapConnectorAlgorithm::getObjectName" ref="8bb13003c85cb2ce6fbdc30488b9a6a4" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::string SAMRAI::hier::OverlapConnectorAlgorithm::getObjectName           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the name of this object. 
<p>

</div>
</div><p>
<hr>The documentation for this class was generated from the following files:<ul>
<li>source/SAMRAI/hier/<a class="el" href="OverlapConnectorAlgorithm_8h.html">OverlapConnectorAlgorithm.h</a><li>source/SAMRAI/hier/<a class="el" href="OverlapConnectorAlgorithm_8C.html">OverlapConnectorAlgorithm.C</a></ul>
<hr size="1"><address style="align: right;"><small>Generated on 16 Jan 2013 for SAMRAI by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.7 </small></address>
</body>
</html>
