<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>SAMRAI: SAMRAI::hier::OverlapConnectorAlgorithm Class Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.7 -->
<div class="tabs">
  <ul>
    <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="namespaces.html"><span>Namespaces</span></a></li>
    <li id="current"><a href="annotated.html"><span>Classes</span></a></li>
    <li><a href="files.html"><span>Files</span></a></li>
    <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
  </ul></div>
<div class="tabs">
  <ul>
    <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
    <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
    <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
  </ul></div>
<div class="nav">
<a class="el" href="namespaceSAMRAI.html">SAMRAI</a>::<a class="el" href="namespaceSAMRAI_1_1hier.html">hier</a>::<a class="el" href="classSAMRAI_1_1hier_1_1OverlapConnectorAlgorithm.html">OverlapConnectorAlgorithm</a></div>
<h1>SAMRAI::hier::OverlapConnectorAlgorithm Class Reference</h1><!-- doxytag: class="SAMRAI::hier::OverlapConnectorAlgorithm" --><!-- doxytag: inherits="SAMRAI::hier::BaseConnectorAlgorithm" -->Algorithms for working Connectors whose neighbor data represents overlaps.  
<a href="#_details">More...</a>
<p>
<code>#include &lt;source/SAMRAI/hier/OverlapConnectorAlgorithm.h&gt;</code>
<p>
<p>Inheritance diagram for SAMRAI::hier::OverlapConnectorAlgorithm:
<p><center><img src="classSAMRAI_1_1hier_1_1OverlapConnectorAlgorithm.png" usemap="#SAMRAI::hier::OverlapConnectorAlgorithm_map" border="0" alt=""></center>
<map name="SAMRAI::hier::OverlapConnectorAlgorithm_map">
<area href="classSAMRAI_1_1hier_1_1BaseConnectorAlgorithm.html" alt="SAMRAI::hier::BaseConnectorAlgorithm" shape="rect" coords="0,0,252,24">
</map>
<a href="classSAMRAI_1_1hier_1_1OverlapConnectorAlgorithm-members.html">List of all members.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1OverlapConnectorAlgorithm.html#5035bbebfa166de6e1601a7b6e3907f1">OverlapConnectorAlgorithm</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Constructor.  <a href="#5035bbebfa166de6e1601a7b6e3907f1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1OverlapConnectorAlgorithm.html#50b389f621cf8086641063518662bbcd">~OverlapConnectorAlgorithm</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Destructor.  <a href="#50b389f621cf8086641063518662bbcd"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1OverlapConnectorAlgorithm.html#3698546884e96887a1efb39a099701ed">findOverlaps</a> (boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">Connector</a> &gt; &amp;connector, const <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a> &amp;base_box_level, const <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a> &amp;head_box_level, const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;base_width, const <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#02c34699888ab34b06f59a210247bcb4">BoxLevel::ParallelState</a> parallel_state=BoxLevel::DISTRIBUTED, const bool ignore_self_overlap=false) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create overlap <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">Connector</a> then discover and add overlaps from base to head to it.  <a href="#3698546884e96887a1efb39a099701ed"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1OverlapConnectorAlgorithm.html#4e31509736543b0a9ea202fcdbf99de1">findOverlapsWithTranspose</a> (boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">Connector</a> &gt; &amp;connector, const <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a> &amp;base_box_level, const <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a> &amp;head_box_level, const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;base_width, const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;transpose_base_width, const <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#02c34699888ab34b06f59a210247bcb4">BoxLevel::ParallelState</a> parallel_state=BoxLevel::DISTRIBUTED, const bool ignore_self_overlap=false) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create overlap <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">Connector</a> with its transpose then discover and add overlaps from base to head to it and overlaps from head to base to transpose.  <a href="#4e31509736543b0a9ea202fcdbf99de1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1OverlapConnectorAlgorithm.html#e332c260d625389d3d7ce6140fbcf788">findOverlaps</a> (<a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">Connector</a> &amp;connector, const bool ignore_self_overlap=false) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Discover and add overlaps from base to head for an overlap <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">Connector</a>.  <a href="#e332c260d625389d3d7ce6140fbcf788"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1OverlapConnectorAlgorithm.html#5f56d7303025dffaef086edf0185cf4f">findOverlaps</a> (<a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">Connector</a> &amp;connector, const <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a> &amp;globalized_head, const bool ignore_self_overlap=false) const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1OverlapConnectorAlgorithm.html#6b340a8cc4df1d6d7567b9d8da3abe87">findOverlaps_assumedPartition</a> (<a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">Connector</a> &amp;connector) const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1OverlapConnectorAlgorithm.html#117ab34c4e5ec7b7e2942dca5bc6460f">extractNeighbors</a> (<a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">Connector::NeighborSet</a> &amp;neighbors, const <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">Connector</a> &amp;connector, const <a class="el" href="classSAMRAI_1_1hier_1_1BoxId.html">BoxId</a> &amp;box_id, const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;gcw) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">For a given <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">Connector</a>, get the subset of overlapping neighbors defined by the given <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">Connector</a> width.  <a href="#117ab34c4e5ec7b7e2942dca5bc6460f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1OverlapConnectorAlgorithm.html#00a49de1613717173249513c0e4a904a">extractNeighbors</a> (<a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">Connector</a> &amp;other, const <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">Connector</a> &amp;connector, const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;gcw) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Like extractNeighbors above except that it computes all neighborhoods of connector placing them into other.  <a href="#00a49de1613717173249513c0e4a904a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1OverlapConnectorAlgorithm.html#29e80a211de4749ecc033596e4fe5c37">bridgeWithNesting</a> (boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">Connector</a> &gt; &amp;west_to_east, const <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">Connector</a> &amp;west_to_center, const <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">Connector</a> &amp;center_to_east, const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;center_growth_to_nest_west, const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;center_growth_to_nest_east, const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;connector_width_limit, bool compute_transpose) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute the overlap Connectors between BoxLevels efficiently by using information from existing overlap Connectors.  <a href="#29e80a211de4749ecc033596e4fe5c37"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1OverlapConnectorAlgorithm.html#74e426410da5dfd3461c4ae7b268e4da">bridge</a> (boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">Connector</a> &gt; &amp;west_to_east, const <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">Connector</a> &amp;west_to_center, const <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">Connector</a> &amp;center_to_east, const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;connector_width_limit, bool compute_transpose) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A version of bridge without any guarantee of nesting.  <a href="#74e426410da5dfd3461c4ae7b268e4da"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1OverlapConnectorAlgorithm.html#ce6a5dbe88186e63811080f3734826e4">bridge</a> (boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">Connector</a> &gt; &amp;west_to_east, const <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">Connector</a> &amp;west_to_center, const <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">Connector</a> &amp;center_to_east, bool compute_transpose) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A version of bridge without limiting the connector_width of the result.  <a href="#ce6a5dbe88186e63811080f3734826e4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1OverlapConnectorAlgorithm.html#2eee26beb8ea8bbc4977f5ac1eb45768">bridge</a> (<a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">Connector</a> &amp;west_to_center, const <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">Connector</a> &amp;center_to_east, const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;connector_width_limit) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A version of bridge without any guarantee of nesting in which an input connector and its transpose are modified to form the resulting bridge connectors.  <a href="#2eee26beb8ea8bbc4977f5ac1eb45768"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1OverlapConnectorAlgorithm.html#99bf3a60edd92ad43916c7410c9d5129">setBarrierBeforeCommunication</a> (bool do_barrier)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set whether to barrier before potential major communication.  <a href="#99bf3a60edd92ad43916c7410c9d5129"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1OverlapConnectorAlgorithm.html#29f448936a23f8dd367ce65c371466a8">setSanityCheckMethodPreconditions</a> (bool do_check)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">When <code>do_check</code> is true, turn on sanity checks for input parameters.  <a href="#29f448936a23f8dd367ce65c371466a8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1OverlapConnectorAlgorithm.html#7088a2d599fd1d4c7efca3d078207e98">setSanityCheckMethodPostconditions</a> (bool do_check)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">When <code>do_check</code> is true, turn on sanity checks for outputs.  <a href="#7088a2d599fd1d4c7efca3d078207e98"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1OverlapConnectorAlgorithm.html#2c5d518cee5fba53a393387a4110bb14">setSAMRAI_MPI</a> (const <a class="el" href="classSAMRAI_1_1tbox_1_1SAMRAI__MPI.html">tbox::SAMRAI_MPI</a> &amp;mpi, bool make_duplicate=true)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the SAMRAI_MPI to use.  <a href="#2c5d518cee5fba53a393387a4110bb14"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1OverlapConnectorAlgorithm.html#2642092f5b583af36c564849ad2df1f7">setPrintSteps</a> (bool print_steps)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">When <code>print_steps</code> is true, print what the code is doing.  <a href="#2642092f5b583af36c564849ad2df1f7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1OverlapConnectorAlgorithm.html#8d69f7abe729ec94f3e4ca647116286e">setTimerPrefix</a> (const std::string &amp;timer_prefix)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Setup names of timers.  <a href="#8d69f7abe729ec94f3e4ca647116286e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">const std::string&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1OverlapConnectorAlgorithm.html#8bb13003c85cb2ce6fbdc30488b9a6a4">getObjectName</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the name of this object.  <a href="#8bb13003c85cb2ce6fbdc30488b9a6a4"></a><br></td></tr>
</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
Algorithms for working Connectors whose neighbor data represents overlaps. 
<p>
An overlap <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">Connector</a> is one in which neighbors represent a pair of overlapping Boxes. If a base <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> grown by the <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">Connector</a> width overlaps a head <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a>, the head <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> is a neighbor of the base <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a>. This class implements some functions for working with a overlap Connectors.<p>
<a class="el" href="classSAMRAI_1_1hier_1_1OverlapConnectorAlgorithm.html">OverlapConnectorAlgorithm</a> objects create, check and operate on overlap Connectors. 
<p>
<hr><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" name="5035bbebfa166de6e1601a7b6e3907f1"></a><!-- doxytag: member="SAMRAI::hier::OverlapConnectorAlgorithm::OverlapConnectorAlgorithm" ref="5035bbebfa166de6e1601a7b6e3907f1" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SAMRAI::hier::OverlapConnectorAlgorithm::OverlapConnectorAlgorithm           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Constructor. 
<p>

</div>
</div><p>
<a class="anchor" name="50b389f621cf8086641063518662bbcd"></a><!-- doxytag: member="SAMRAI::hier::OverlapConnectorAlgorithm::~OverlapConnectorAlgorithm" ref="50b389f621cf8086641063518662bbcd" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SAMRAI::hier::OverlapConnectorAlgorithm::~OverlapConnectorAlgorithm           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Destructor. 
<p>

</div>
</div><p>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="3698546884e96887a1efb39a099701ed"></a><!-- doxytag: member="SAMRAI::hier::OverlapConnectorAlgorithm::findOverlaps" ref="3698546884e96887a1efb39a099701ed" args="(boost::shared_ptr&lt; Connector &gt; &amp;connector, const BoxLevel &amp;base_box_level, const BoxLevel &amp;head_box_level, const IntVector &amp;base_width, const BoxLevel::ParallelState parallel_state=BoxLevel::DISTRIBUTED, const bool ignore_self_overlap=false) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::hier::OverlapConnectorAlgorithm::findOverlaps           </td>
          <td>(</td>
          <td class="paramtype">boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">Connector</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>connector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>base_box_level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>head_box_level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>base_width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#02c34699888ab34b06f59a210247bcb4">BoxLevel::ParallelState</a>&nbsp;</td>
          <td class="paramname"> <em>parallel_state</em> = <code>BoxLevel::DISTRIBUTED</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&nbsp;</td>
          <td class="paramname"> <em>ignore_self_overlap</em> = <code>false</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Create overlap <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">Connector</a> then discover and add overlaps from base to head to it. 
<p>
The Connector's neighbor information is modified.<p>
If the Connector's head is not GLOBALIZED, a copy is made and globalized. Once a globalized head is obtained, this method simply calls findOverlaps(const BoxLevel &amp;globalized_head).<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>connector</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>base_box_level</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>head_box_level</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>base_width</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>parallel_state</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>ignore_self_overlap</em>&nbsp;</td><td></td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="4e31509736543b0a9ea202fcdbf99de1"></a><!-- doxytag: member="SAMRAI::hier::OverlapConnectorAlgorithm::findOverlapsWithTranspose" ref="4e31509736543b0a9ea202fcdbf99de1" args="(boost::shared_ptr&lt; Connector &gt; &amp;connector, const BoxLevel &amp;base_box_level, const BoxLevel &amp;head_box_level, const IntVector &amp;base_width, const IntVector &amp;transpose_base_width, const BoxLevel::ParallelState parallel_state=BoxLevel::DISTRIBUTED, const bool ignore_self_overlap=false) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::hier::OverlapConnectorAlgorithm::findOverlapsWithTranspose           </td>
          <td>(</td>
          <td class="paramtype">boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">Connector</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>connector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>base_box_level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>head_box_level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>base_width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>transpose_base_width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#02c34699888ab34b06f59a210247bcb4">BoxLevel::ParallelState</a>&nbsp;</td>
          <td class="paramname"> <em>parallel_state</em> = <code>BoxLevel::DISTRIBUTED</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&nbsp;</td>
          <td class="paramname"> <em>ignore_self_overlap</em> = <code>false</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Create overlap <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">Connector</a> with its transpose then discover and add overlaps from base to head to it and overlaps from head to base to transpose. 
<p>
The Connector's neighbor information is modified.<p>
If the Connector's head is not GLOBALIZED, a copy is made and globalized. Once a globalized head is obtained, this method simply calls findOverlaps(const BoxLevel &amp;globalized_head).<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>connector</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>base_box_level</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>head_box_level</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>base_width</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>transpose_base_width</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>parallel_state</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>ignore_self_overlap</em>&nbsp;</td><td></td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="e332c260d625389d3d7ce6140fbcf788"></a><!-- doxytag: member="SAMRAI::hier::OverlapConnectorAlgorithm::findOverlaps" ref="e332c260d625389d3d7ce6140fbcf788" args="(Connector &amp;connector, const bool ignore_self_overlap=false) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::hier::OverlapConnectorAlgorithm::findOverlaps           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">Connector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>connector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&nbsp;</td>
          <td class="paramname"> <em>ignore_self_overlap</em> = <code>false</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Discover and add overlaps from base to head for an overlap <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">Connector</a>. 
<p>
The Connector's neighbor information is modified.<p>
If the Connector's head is not GLOBALIZED, a copy is made and globalized. Once a globalized head is obtained, this method simply calls findOverlaps(const BoxLevel &amp;globalized_head).<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>connector</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>ignore_self_overlap</em>&nbsp;</td><td></td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="5f56d7303025dffaef086edf0185cf4f"></a><!-- doxytag: member="SAMRAI::hier::OverlapConnectorAlgorithm::findOverlaps" ref="5f56d7303025dffaef086edf0185cf4f" args="(Connector &amp;connector, const BoxLevel &amp;globalized_head, const bool ignore_self_overlap=false) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::hier::OverlapConnectorAlgorithm::findOverlaps           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">Connector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>connector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>globalized_head</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&nbsp;</td>
          <td class="paramname"> <em>ignore_self_overlap</em> = <code>false</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="6b340a8cc4df1d6d7567b9d8da3abe87"></a><!-- doxytag: member="SAMRAI::hier::OverlapConnectorAlgorithm::findOverlaps_assumedPartition" ref="6b340a8cc4df1d6d7567b9d8da3abe87" args="(Connector &amp;connector) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::hier::OverlapConnectorAlgorithm::findOverlaps_assumedPartition           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">Connector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>connector</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="117ab34c4e5ec7b7e2942dca5bc6460f"></a><!-- doxytag: member="SAMRAI::hier::OverlapConnectorAlgorithm::extractNeighbors" ref="117ab34c4e5ec7b7e2942dca5bc6460f" args="(Connector::NeighborSet &amp;neighbors, const Connector &amp;connector, const BoxId &amp;box_id, const IntVector &amp;gcw) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::hier::OverlapConnectorAlgorithm::extractNeighbors           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">Connector::NeighborSet</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>neighbors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">Connector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>connector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1BoxId.html">BoxId</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>box_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>gcw</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
For a given <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">Connector</a>, get the subset of overlapping neighbors defined by the given <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">Connector</a> width. 
<p>
The difference between <a class="el" href="classSAMRAI_1_1hier_1_1OverlapConnectorAlgorithm.html#117ab34c4e5ec7b7e2942dca5bc6460f">extractNeighbors()</a> and Connector::getNeighbors() is that <a class="el" href="classSAMRAI_1_1hier_1_1OverlapConnectorAlgorithm.html#117ab34c4e5ec7b7e2942dca5bc6460f">extractNeighbors()</a> extracts the subset of the currently stored neighbors associated with the given <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">Connector</a> width. getNeighbors() returns the entire neighbor set, which corresponds to the Connector's width. The specified <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">Connector</a> width must be less than or equal to the Connector's width.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>neighbors</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>connector</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>box_id</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>gcw</em>&nbsp;</td><td></td></tr>
  </table>
</dl>
<dl compact><dt><b>Precondition:</b></dt><dd>gcw &lt;= connector.getConnectorWidth() <p>
(connector.getParallelState() == <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#02c34699888ab34b06f59a210247bcb42dbf00b87512ae236e2dbde25acb952f">BoxLevel::GLOBALIZED</a>) || (box_id.getOwnerRank() == connector.getMPI().getRank()) <p>
connector.getBase().hasBox(box_id) </dd></dl>

</div>
</div><p>
<a class="anchor" name="00a49de1613717173249513c0e4a904a"></a><!-- doxytag: member="SAMRAI::hier::OverlapConnectorAlgorithm::extractNeighbors" ref="00a49de1613717173249513c0e4a904a" args="(Connector &amp;other, const Connector &amp;connector, const IntVector &amp;gcw) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::hier::OverlapConnectorAlgorithm::extractNeighbors           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">Connector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">Connector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>connector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>gcw</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Like extractNeighbors above except that it computes all neighborhoods of connector placing them into other. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>other</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>connector</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>gcw</em>&nbsp;</td><td></td></tr>
  </table>
</dl>
<dl compact><dt><b>Precondition:</b></dt><dd>gcw &lt;= connector.getConnectorWidth() <p>
for the box_id of each neighborhood base box in connector, (connector.getParallelState() == <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html#02c34699888ab34b06f59a210247bcb42dbf00b87512ae236e2dbde25acb952f">BoxLevel::GLOBALIZED</a>) || (box_id.getOwnerRank() == connector.getMPI().getRank()) <p>
for the box_id of each neighborhood base box in connector, connector.getBase().hasBox(box_id) </dd></dl>

</div>
</div><p>
<a class="anchor" name="29e80a211de4749ecc033596e4fe5c37"></a><!-- doxytag: member="SAMRAI::hier::OverlapConnectorAlgorithm::bridgeWithNesting" ref="29e80a211de4749ecc033596e4fe5c37" args="(boost::shared_ptr&lt; Connector &gt; &amp;west_to_east, const Connector &amp;west_to_center, const Connector &amp;center_to_east, const IntVector &amp;center_growth_to_nest_west, const IntVector &amp;center_growth_to_nest_east, const IntVector &amp;connector_width_limit, bool compute_transpose) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::hier::OverlapConnectorAlgorithm::bridgeWithNesting           </td>
          <td>(</td>
          <td class="paramtype">boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">Connector</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>west_to_east</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">Connector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>west_to_center</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">Connector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>center_to_east</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>center_growth_to_nest_west</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>center_growth_to_nest_east</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>connector_width_limit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>compute_transpose</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Compute the overlap Connectors between BoxLevels efficiently by using information from existing overlap Connectors. 
<p>
Let east, west and center be BoxLevels. Given overlap Connectors between center and east and between center and west, compute overlap Connectors between east and west.<p>
<div class="fragment"><pre class="fragment">               Input:                            Output:

                                               west to east
      (west)              (east)      (west) ---------------&gt; (east)
        \ ^                ^ /               &lt;---------------
         \ \center  center/ /                  east to west
          \ \ to     to  / /
       west\ \west  east/ /east
        to  \ \        / /  to
       center\ \      / /center
              v \    / v
               (center)
</pre></div><p>
The "bridge" is the Connectors between <code>west</code> and <code>east</code>. Bridging is an algorithm for finding their overlaps using existing overlaps incident from <code>center</code>. This is more efficient than <a class="el" href="classSAMRAI_1_1hier_1_1OverlapConnectorAlgorithm.html#3698546884e96887a1efb39a099701ed">findOverlaps()</a> because it does not require acquiring, storing or searching globalized data.<p>
Preconditions:<p>
<ul>
<li>Four input Connectors refer to the center <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a>, two refer to the west, and two refer to the east. The center, east and west BoxLevels must be the same regardless of what <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">Connector</a> is used to get them. For example, <code> &amp;west_to_center.getTranspose().getHead() == &amp;west_to_center.getBase() </code> must be true.</li></ul>
<p>
Postconditions:<p>
<ul>
<li><code>west</code> and <code>east</code>, as referenced by the output Connectors are heads of west_to_center's transpose and <code>center_to_east</code>.</li>
</ul>
<ul>
<li>Widths of the output Connectors will be either <code>center_to_east's</code> width reduced by <code>center_growth_to_nest_west</code> or west_to_center's transpose's width reduced by <code>center_growth_to_nest_east</code>, which ever is greater. Output <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">Connector</a> widths are still limited by the <code>connector_width_limit</code> argument. All comparisons are done after the appropriate index space conversions, of course.</li>
</ul>
<dl compact><dt><b>Note:</b></dt><dd></dd></dl>
<ul>
<li>Although <code>east</code>, <code>west</code> and <code>center</code> are not explicit parameters, they are specified implicitly through the input Connectors.</li>
</ul>
<ul>
<li>The bridge operation works in the degenerate case where <code>east</code> and <code>west</code> are the same object. In that case, <code>west_to_east</code> and its transpose should also be the same object.</li>
</ul>
<ul>
<li>Bridging finds as many overlaps as it can, given the inputs, but can only guarantee that the output Connectors are complete overlap Connectors if there is nesting as specified by the arguments <code>center_growth_to_nest_west</code> and/or <code>center_growth_to_nest_east</code>. Nesting is not checked, because checking requires an iterative non-scalable computation. Nesting is best determined by the code that created the BoxLevels involved. Bridging is meant to be fast and scalable.</li>
</ul>
<ul>
<li>Periodic relationships are automatically generated if a head <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> in its shifted position overlaps the grown base <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a>. However, because neighbors may be remote, we cannot scalably verify that the periodic neighbors actually exist in the heads of the output Connectors. Spurious periodic relationships may be generated when the periodic image simply has not be added to the head or when parts of east or west lie outside the domain extents. They can be discarded using <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html#a34973973b4d43f6ec68b3ec9c390829">Connector::removePeriodicRelationships</a> and properly regenerated using <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevelConnectorUtils.html">BoxLevelConnectorUtils</a>.</li>
</ul>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>west_to_east</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>west_to_center</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>center_to_east</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>center_growth_to_nest_west</em>&nbsp;</td><td>The amount by which the center <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a> must grow to nest the west <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a>. Bridging guarantees completeness if the width of <b>center_to_east</b> exceeds this amount. If unknown, set to negative value if unknown so it won't be considered when computing the output <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">Connector</a> widths.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>center_growth_to_nest_east</em>&nbsp;</td><td>The amount by which the center <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a> must grow to nest the east <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a>. Bridging guarantees completeness if the width of <b>west_to_center's</b> transpose exceeds this amount. If unknown, set to negative value if unknown so it won't be considered when computing the output <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">Connector</a> widths.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>connector_width_limit</em>&nbsp;</td><td>specifies the maximum <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">Connector</a> width to compute overlaps for. The connector_width should be in the coarser of the east and west indices. If connector_width_limit is negative, use the default connector_width, which is the larger of the west_to_center's transpose and center_to_east Connectors', coarsened into the coarser of east and west indices.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>compute_transpose</em>&nbsp;</td><td>true if west_to_east's transpose should be computed</td></tr>
  </table>
</dl>
<dl compact><dt><b>Precondition:</b></dt><dd>west_to_cent.hasTranspose() <p>
cent_to_east.hasTranspose() </dd></dl>

</div>
</div><p>
<a class="anchor" name="74e426410da5dfd3461c4ae7b268e4da"></a><!-- doxytag: member="SAMRAI::hier::OverlapConnectorAlgorithm::bridge" ref="74e426410da5dfd3461c4ae7b268e4da" args="(boost::shared_ptr&lt; Connector &gt; &amp;west_to_east, const Connector &amp;west_to_center, const Connector &amp;center_to_east, const IntVector &amp;connector_width_limit, bool compute_transpose) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::hier::OverlapConnectorAlgorithm::bridge           </td>
          <td>(</td>
          <td class="paramtype">boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">Connector</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>west_to_east</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">Connector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>west_to_center</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">Connector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>center_to_east</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>connector_width_limit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>compute_transpose</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
A version of bridge without any guarantee of nesting. 
<p>
The east and west BoxLevels are assumed to nest in the center <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a>. If they do not, the results are not guaranteed to be complete.<p>
The output <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">Connector</a> widths are the greater of the widths of <code>center_to_east</code> and <code>center_to_west</code> (converted into the proper index space, of course).<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>west_to_east</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>west_to_center</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>center_to_east</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>connector_width_limit</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>compute_transpose</em>&nbsp;</td><td>true if west_to_east's transpose should be computed</td></tr>
  </table>
</dl>
<dl compact><dt><b>Precondition:</b></dt><dd>west_to_cent.hasTranspose() <p>
cent_to_east.hasTranspose()</dd></dl>
<dl compact><dt><b>See also:</b></dt><dd>bridgeWithNesting( Connector&amp; west_to_east, const Connector&amp; west_to_center, const Connector&amp; center_to_east, const IntVector&amp; center_growth_to_nest_west, const IntVector&amp; center_growth_to_nest_east, const IntVector&amp; connector_width_limit, bool compute_transpose) const; </dd></dl>

</div>
</div><p>
<a class="anchor" name="ce6a5dbe88186e63811080f3734826e4"></a><!-- doxytag: member="SAMRAI::hier::OverlapConnectorAlgorithm::bridge" ref="ce6a5dbe88186e63811080f3734826e4" args="(boost::shared_ptr&lt; Connector &gt; &amp;west_to_east, const Connector &amp;west_to_center, const Connector &amp;center_to_east, bool compute_transpose) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::hier::OverlapConnectorAlgorithm::bridge           </td>
          <td>(</td>
          <td class="paramtype">boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">Connector</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>west_to_east</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">Connector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>west_to_center</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">Connector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>center_to_east</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>compute_transpose</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
A version of bridge without limiting the connector_width of the result. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>west_to_east</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>west_to_center</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>center_to_east</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>compute_transpose</em>&nbsp;</td><td>true if west_to_east's transpose should be computed</td></tr>
  </table>
</dl>
<dl compact><dt><b>Precondition:</b></dt><dd>west_to_cent.hasTranspose() <p>
cent_to_east.hasTranspose()</dd></dl>
<dl compact><dt><b>See also:</b></dt><dd>bridge( Connector&amp; west_to_east, const Connector&amp; west_to_center, const Connector&amp; center_to_east, const IntVector&amp; connector_width_limit, bool compute_transpose) const; </dd></dl>

</div>
</div><p>
<a class="anchor" name="2eee26beb8ea8bbc4977f5ac1eb45768"></a><!-- doxytag: member="SAMRAI::hier::OverlapConnectorAlgorithm::bridge" ref="2eee26beb8ea8bbc4977f5ac1eb45768" args="(Connector &amp;west_to_center, const Connector &amp;center_to_east, const IntVector &amp;connector_width_limit) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::hier::OverlapConnectorAlgorithm::bridge           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">Connector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>west_to_center</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">Connector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>center_to_east</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>connector_width_limit</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
A version of bridge without any guarantee of nesting in which an input connector and its transpose are modified to form the resulting bridge connectors. 
<p>
The east and west BoxLevels are assumed to nest in the center <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a>. If they do not, the results are not guaranteed to be complete.<p>
The output <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">Connector</a> widths are the greater of the widths of <code>center_to_east</code> and west_to_center's transpose (converted into the proper index space, of course).<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>west_to_center</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>center_to_east</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>connector_width_limit</em>&nbsp;</td><td></td></tr>
  </table>
</dl>
<dl compact><dt><b>Precondition:</b></dt><dd>west_to_cent.hasTranspose() <p>
cent_to_east.hasTranspose()</dd></dl>
<dl compact><dt><b>See also:</b></dt><dd>bridgeWithNesting( Connector&amp; west_to_east, const Connector&amp; west_to_center, const Connector&amp; center_to_east, const IntVector&amp; center_growth_to_nest_west, const IntVector&amp; center_growth_to_nest_east, const IntVector&amp; connector_width_limit, bool compute_transpose) const; </dd></dl>

</div>
</div><p>
<a class="anchor" name="99bf3a60edd92ad43916c7410c9d5129"></a><!-- doxytag: member="SAMRAI::hier::OverlapConnectorAlgorithm::setBarrierBeforeCommunication" ref="99bf3a60edd92ad43916c7410c9d5129" args="(bool do_barrier)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::hier::OverlapConnectorAlgorithm::setBarrierBeforeCommunication           </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>do_barrier</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set whether to barrier before potential major communication. 
<p>
This developer feature makes sure all processes start major operations at the same time so that timers do not include the time waiting for slower processes to get to the starting point.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>do_barrier</em>&nbsp;</td><td></td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="29f448936a23f8dd367ce65c371466a8"></a><!-- doxytag: member="SAMRAI::hier::OverlapConnectorAlgorithm::setSanityCheckMethodPreconditions" ref="29f448936a23f8dd367ce65c371466a8" args="(bool do_check)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::hier::OverlapConnectorAlgorithm::setSanityCheckMethodPreconditions           </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>do_check</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
When <code>do_check</code> is true, turn on sanity checks for input parameters. 
<p>
<dl compact><dt><b>Note:</b></dt><dd>Sanity checks occur at the beginning of certain methods only. The checks are expensive and meant mainly for debugging.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>do_check</em>&nbsp;</td><td></td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="7088a2d599fd1d4c7efca3d078207e98"></a><!-- doxytag: member="SAMRAI::hier::OverlapConnectorAlgorithm::setSanityCheckMethodPostconditions" ref="7088a2d599fd1d4c7efca3d078207e98" args="(bool do_check)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::hier::OverlapConnectorAlgorithm::setSanityCheckMethodPostconditions           </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>do_check</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
When <code>do_check</code> is true, turn on sanity checks for outputs. 
<p>
<dl compact><dt><b>Note:</b></dt><dd>Sanity checks occur at the end of certain methods only. The checks are expensive and meant mainly for debugging.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>do_check</em>&nbsp;</td><td></td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="2c5d518cee5fba53a393387a4110bb14"></a><!-- doxytag: member="SAMRAI::hier::OverlapConnectorAlgorithm::setSAMRAI_MPI" ref="2c5d518cee5fba53a393387a4110bb14" args="(const tbox::SAMRAI_MPI &amp;mpi, bool make_duplicate=true)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::hier::OverlapConnectorAlgorithm::setSAMRAI_MPI           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1tbox_1_1SAMRAI__MPI.html">tbox::SAMRAI_MPI</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>mpi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>make_duplicate</em> = <code>true</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set the SAMRAI_MPI to use. 
<p>
If set, communication will use the specified SAMRAI_MPI instead of the SAMRAI_MPI from BoxLevels. This protects communication operations from accidentally interacting with unrelated communications, but it limits operations to work only with metadata objects with comptatible (congruent) SAMRAI_MPI objects.<p>
If make_duplicate is true, the specified SAMRAI_MPI will be duplicated for exclusise use. The duplicate will be freed upon object destruction. 
</div>
</div><p>
<a class="anchor" name="2642092f5b583af36c564849ad2df1f7"></a><!-- doxytag: member="SAMRAI::hier::OverlapConnectorAlgorithm::setPrintSteps" ref="2642092f5b583af36c564849ad2df1f7" args="(bool print_steps)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::hier::OverlapConnectorAlgorithm::setPrintSteps           </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>print_steps</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
When <code>print_steps</code> is true, print what the code is doing. 
<p>
<dl compact><dt><b>Note:</b></dt><dd>Step printing may be expensive and and is meant mainly for debugging.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>print_steps</em>&nbsp;</td><td></td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="8d69f7abe729ec94f3e4ca647116286e"></a><!-- doxytag: member="SAMRAI::hier::OverlapConnectorAlgorithm::setTimerPrefix" ref="8d69f7abe729ec94f3e4ca647116286e" args="(const std::string &amp;timer_prefix)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::hier::OverlapConnectorAlgorithm::setTimerPrefix           </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>timer_prefix</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Setup names of timers. 
<p>
By default, timers are named "hier::OverlapConnectorAlgorithm::*", where the third field is the specific steps performed by the <a class="el" href="classSAMRAI_1_1hier_1_1MappingConnectorAlgorithm.html">MappingConnectorAlgorithm</a>. You can override the first two fields with this method. Conforming to the timer naming convention, timer_prefix should have the form "*::*". 
</div>
</div><p>
<a class="anchor" name="8bb13003c85cb2ce6fbdc30488b9a6a4"></a><!-- doxytag: member="SAMRAI::hier::OverlapConnectorAlgorithm::getObjectName" ref="8bb13003c85cb2ce6fbdc30488b9a6a4" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::string SAMRAI::hier::OverlapConnectorAlgorithm::getObjectName           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the name of this object. 
<p>

</div>
</div><p>
<hr>The documentation for this class was generated from the following files:<ul>
<li>source/SAMRAI/hier/<a class="el" href="OverlapConnectorAlgorithm_8h.html">OverlapConnectorAlgorithm.h</a><li>source/SAMRAI/hier/<a class="el" href="OverlapConnectorAlgorithm_8C.html">OverlapConnectorAlgorithm.C</a></ul>
<hr size="1"><address style="align: right;"><small>Generated on 3 Mar 2015 for SAMRAI by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.7 </small></address>
</body>
</html>
