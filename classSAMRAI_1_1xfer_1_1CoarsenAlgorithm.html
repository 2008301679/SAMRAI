<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>SAMRAI: SAMRAI::xfer::CoarsenAlgorithm Class Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.7 -->
<div class="tabs">
  <ul>
    <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="namespaces.html"><span>Namespaces</span></a></li>
    <li id="current"><a href="annotated.html"><span>Classes</span></a></li>
    <li><a href="files.html"><span>Files</span></a></li>
    <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
  </ul></div>
<div class="tabs">
  <ul>
    <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
    <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
    <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
  </ul></div>
<div class="nav">
<a class="el" href="namespaceSAMRAI.html">SAMRAI</a>::<a class="el" href="namespaceSAMRAI_1_1xfer.html">xfer</a>::<a class="el" href="classSAMRAI_1_1xfer_1_1CoarsenAlgorithm.html">CoarsenAlgorithm</a></div>
<h1>SAMRAI::xfer::CoarsenAlgorithm Class Reference</h1><!-- doxytag: class="SAMRAI::xfer::CoarsenAlgorithm" -->Class <a class="el" href="classSAMRAI_1_1xfer_1_1CoarsenAlgorithm.html">CoarsenAlgorithm</a> encapsulates the AMR communication pattern to coarsen data from a finer level to any coarser level.  
<a href="#_details">More...</a>
<p>
<code>#include &lt;source/SAMRAI/xfer/CoarsenAlgorithm.h&gt;</code>
<p>
<a href="classSAMRAI_1_1xfer_1_1CoarsenAlgorithm-members.html">List of all members.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1xfer_1_1CoarsenAlgorithm.html#1f2bf5a8062089078adbc84d71eac28e">CoarsenAlgorithm</a> (const <a class="el" href="classSAMRAI_1_1tbox_1_1Dimension.html">tbox::Dimension</a> &amp;dim, bool fill_coarse_data=false)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Construct a coarsening algorithm and initialize its basic state.  <a href="#1f2bf5a8062089078adbc84d71eac28e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1xfer_1_1CoarsenAlgorithm.html#6b72980eecbc22b9066967080b695753">~CoarsenAlgorithm</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The destructor releases all internal storage.  <a href="#6b72980eecbc22b9066967080b695753"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1xfer_1_1CoarsenAlgorithm.html#cdc98202dce18f2826c2858945d6b8b2">registerCoarsen</a> (const int dst, const int src, const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1hier_1_1CoarsenOperator.html">hier::CoarsenOperator</a> &gt; &amp;opcoarsen, const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a> &amp;gcw_to_coarsen, const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1VariableFillPattern.html">VariableFillPattern</a> &gt; &amp;var_fill_pattern=boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1VariableFillPattern.html">VariableFillPattern</a> &gt;())</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Register a coarsening operation with the coarsening algorithm.  <a href="#cdc98202dce18f2826c2858945d6b8b2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1xfer_1_1CoarsenAlgorithm.html#0a675a0a33d6297fa57ae1041865c453">registerCoarsen</a> (const int dst, const int src, const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1hier_1_1CoarsenOperator.html">hier::CoarsenOperator</a> &gt; &amp;opcoarsen, const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1VariableFillPattern.html">VariableFillPattern</a> &gt; &amp;var_fill_pattern=boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1VariableFillPattern.html">VariableFillPattern</a> &gt;())</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Register a coarsening operation with the coarsening algorithm.  <a href="#0a675a0a33d6297fa57ae1041865c453"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1CoarsenSchedule.html">CoarsenSchedule</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1xfer_1_1CoarsenAlgorithm.html#a21bc9734a4c494be2746bd89b5517a6">createSchedule</a> (const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchLevel.html">hier::PatchLevel</a> &gt; &amp;crse_level, const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchLevel.html">hier::PatchLevel</a> &gt; &amp;fine_level, <a class="el" href="classSAMRAI_1_1xfer_1_1CoarsenPatchStrategy.html">CoarsenPatchStrategy</a> *coarsen_strategy=0, const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1CoarsenTransactionFactory.html">CoarsenTransactionFactory</a> &gt; &amp;transaction_factory=boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1CoarsenTransactionFactory.html">CoarsenTransactionFactory</a> &gt;())</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a communication schedule to coarsen data from the given fine patch level to the given coarse patch level.  <a href="#a21bc9734a4c494be2746bd89b5517a6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1xfer_1_1CoarsenAlgorithm.html#5ebe4533d536ed09da9311d44025e593">checkConsistency</a> (const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1CoarsenSchedule.html">CoarsenSchedule</a> &gt; &amp;schedule) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Given a previously-generated coarsen schedule, check for consistency with this coarsen algorithm object to see whether a call to resetSchedule is a valid operation.  <a href="#5ebe4533d536ed09da9311d44025e593"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1xfer_1_1CoarsenAlgorithm.html#40da07dfe68d058346b8ae0de34ec748">resetSchedule</a> (const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1CoarsenSchedule.html">CoarsenSchedule</a> &gt; &amp;schedule) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Given a previously-generated coarsen schedule, reconfigure it to peform the communication operations registered with this coarsen algorithm object.  <a href="#40da07dfe68d058346b8ae0de34ec748"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1xfer_1_1CoarsenAlgorithm.html#0ed6def085c21285636d8cbb656cfd80">printClassData</a> (std::ostream &amp;stream) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Print the coarsen algorithm state to the specified data stream.  <a href="#0ed6def085c21285636d8cbb656cfd80"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">const <a class="el" href="classSAMRAI_1_1tbox_1_1Dimension.html">tbox::Dimension</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1xfer_1_1CoarsenAlgorithm.html#33af771f305009040d36227754eb80b5">getDim</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the dimension of this object.  <a href="#33af771f305009040d36227754eb80b5"></a><br></td></tr>
</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
Class <a class="el" href="classSAMRAI_1_1xfer_1_1CoarsenAlgorithm.html">CoarsenAlgorithm</a> encapsulates the AMR communication pattern to coarsen data from a finer level to any coarser level. 
<p>
Most often, data is coarsened from the interiors of source patch components on the source patch level into interiors of destination patch components on the destination level. If the coarsening operators require ghost cells on a source component, then sufficient ghost cell storage must be provided by the source patch data component, and those ghost cells must be filled before calling the data coarsening routines.<p>
Communication algorithms generally consist of three parts: an algorithm, a schedule, and a patch strategy. The algorithm describes the communication between patch data items but is independent of the configuration of the AMR hierarchy. PatchData items and their associated coarsening operators are registered with the algorithm. To generate the communication dependencies for a particular hierarchy configuration, the algorithm generates a schedule based on the current hierarchy configuration. This schedule then performs the communication based on the registered data types and their associated operators. User-defined coarsening operations can be written using the interfaces in <a class="el" href="classSAMRAI_1_1xfer_1_1CoarsenPatchStrategy.html">CoarsenPatchStrategy</a> for preprocessCoarsen() and postProcessCoarsen().<p>
The source patch data space is used during processing to store temporary data. Thus, the user-defined coarsening operators should operate on the source space by using the patch data with those indices.<p>
It is the user's responsibility to register valid operations with the coarsen algorithm so that the data communication can occur. In particular, communication operations (e.g., data coarsening, data copy, etc.) are performed in the order that items are registered for coarsening with a coarsen algorithm object. Thus, order of registration must repect any dependencies among patch data communicated. Also, users who use the preprocessCoarsen() and postProcessCoarsen() operations in the patch strategy object must make sure that all data that is needed in those operations are registered with the <a class="el" href="classSAMRAI_1_1xfer_1_1CoarsenAlgorithm.html">CoarsenAlgorithm</a> using <a class="el" href="classSAMRAI_1_1xfer_1_1CoarsenAlgorithm.html#cdc98202dce18f2826c2858945d6b8b2">registerCoarsen()</a> whether or not the data is to be coarsened.<p>
Typical usage of a coarsen algorithm to perform data coarsening on an AMR hierarchy involves four steps:<p>
<ul>
<li>
Construct a coarsen algorithm object. </li>
<li>
Register coarsen operations with the coarsen algorithm. Using the <a class="el" href="classSAMRAI_1_1xfer_1_1CoarsenAlgorithm.html#cdc98202dce18f2826c2858945d6b8b2">registerCoarsen()</a> methods(s), one provides source and destination patch data information, as well as spatial coarsening operators as needed. </li>
<li>
After all operations are registered with the algorithm, one creates a communication schedule using the <a class="el" href="classSAMRAI_1_1xfer_1_1CoarsenAlgorithm.html#a21bc9734a4c494be2746bd89b5517a6">createSchedule()</a> method. This method identifies the source (fine) and destination (coarse) patch levels for data coarsening. Note that when creating a communication schedule, a concrete instance of a <a class="el" href="classSAMRAI_1_1xfer_1_1CoarsenPatchStrategy.html">CoarsenPatchStrategy</a> object may be required to supply user-defined spatial data coarsening operations. </li>
<li>
Invoke the coarsenData() method in the communication schedule to perform the data transfers. </li>
</ul>
<p>
Note that each coarsen schedule created by a coarsen algorithm remains valid as long as the levels involved in the communication process do not change; thus, they can be used for multiple data communication cycles.<p>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classSAMRAI_1_1xfer_1_1CoarsenSchedule.html">xfer::CoarsenSchedule</a> <p>
<a class="el" href="classSAMRAI_1_1xfer_1_1CoarsenPatchStrategy.html">xfer::CoarsenPatchStrategy</a> <p>
<a class="el" href="classSAMRAI_1_1xfer_1_1CoarsenClasses.html">xfer::CoarsenClasses</a> </dd></dl>

<p>
<hr><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" name="1f2bf5a8062089078adbc84d71eac28e"></a><!-- doxytag: member="SAMRAI::xfer::CoarsenAlgorithm::CoarsenAlgorithm" ref="1f2bf5a8062089078adbc84d71eac28e" args="(const tbox::Dimension &amp;dim, bool fill_coarse_data=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SAMRAI::xfer::CoarsenAlgorithm::CoarsenAlgorithm           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1tbox_1_1Dimension.html">tbox::Dimension</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>dim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>fill_coarse_data</em> = <code>false</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Construct a coarsening algorithm and initialize its basic state. 
<p>
Coarsening operations must be registered with this algorithm before it can do anything useful. See the <a class="el" href="classSAMRAI_1_1xfer_1_1CoarsenAlgorithm.html#cdc98202dce18f2826c2858945d6b8b2">registerCoarsen()</a> routine for details<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>dim</em>&nbsp;</td><td>Dimension </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>fill_coarse_data</em>&nbsp;</td><td>boolean flag indicating whether pre-existing coarse level data is needed for the data coarsening operations. By default this argument is false. If a true value is value is provided, then source data will be filled on a temporary coarse patch level (copied from the actual coarse level source data) for use in coarsening operations registered with this algorithm. This option should only be used by those who specifically require this behavior and who know how to properly process the patch data on coarse and fine patch levels during the coarsening process. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="6b72980eecbc22b9066967080b695753"></a><!-- doxytag: member="SAMRAI::xfer::CoarsenAlgorithm::~CoarsenAlgorithm" ref="6b72980eecbc22b9066967080b695753" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SAMRAI::xfer::CoarsenAlgorithm::~CoarsenAlgorithm           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The destructor releases all internal storage. 
<p>

</div>
</div><p>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="cdc98202dce18f2826c2858945d6b8b2"></a><!-- doxytag: member="SAMRAI::xfer::CoarsenAlgorithm::registerCoarsen" ref="cdc98202dce18f2826c2858945d6b8b2" args="(const int dst, const int src, const boost::shared_ptr&lt; hier::CoarsenOperator &gt; &amp;opcoarsen, const hier::IntVector &amp;gcw_to_coarsen, const boost::shared_ptr&lt; VariableFillPattern &gt; &amp;var_fill_pattern=boost::shared_ptr&lt; VariableFillPattern &gt;())" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::xfer::CoarsenAlgorithm::registerCoarsen           </td>
          <td>(</td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1hier_1_1CoarsenOperator.html">hier::CoarsenOperator</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>opcoarsen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>gcw_to_coarsen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1VariableFillPattern.html">VariableFillPattern</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>var_fill_pattern</em> = <code>boost::shared_ptr&lt;&nbsp;<a class="el" href="classSAMRAI_1_1xfer_1_1VariableFillPattern.html">VariableFillPattern</a>&nbsp;&gt;()</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Register a coarsening operation with the coarsening algorithm. 
<p>
Data from the interiors of the source component on a source (fine) patch level will be coarsened into the source component of a temporary (coarse) patch level and then copied into the destination component on the destination (coarse) patch level. If the coarsening operator requires data in ghost cells outside of the patch interiors (i.e., a non-zero stencil width), then those ghost cells must exist in the source patch data component and the ghost cells must be filled with valid data on the source level before a call to invoke the communication schedule. Note that the source and destination components may be the same.<p>
Some special circumstances require that data be coarsened from the ghost cell regions of a finer level and the resulting coarsened data should be copied to the destination patch level. When this is the case, the optional integer vector argument should be set to the cell width, in the destination (coarser) level index space, of the region around the fine level where this coarsening should occur. For example, if the coarser level needs data in a region two (coarse) cells wide around the boundary of the finer level, then the gcw_to_coarsen should be set to a vector with all entries set to two. Moreover, if the ratio between coarse and fine levels is four in this case, then the source patch data is required to have at least eight ghost cells.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>dst</em>&nbsp;</td><td>Patch data index filled on destination level. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>src</em>&nbsp;</td><td>Patch data index coarsened from the source level. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>opcoarsen</em>&nbsp;</td><td>Coarsening operator. This may be a null pointer. If null, coarsening must be handled by the coarsen patch strategy member functions. See the comments for <a class="el" href="classSAMRAI_1_1xfer_1_1CoarsenPatchStrategy.html#659500fc458f4a76c611592fea297e27">CoarsenPatchStrategy::preprocessCoarsen()</a> and <a class="el" href="classSAMRAI_1_1xfer_1_1CoarsenPatchStrategy.html#8cfc7cf51182a3b1f057b347bbe56d80">CoarsenPatchStrategy::postprocessCoarsen()</a>. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>gcw_to_coarsen</em>&nbsp;</td><td>Ghost cell width to be used when data should be coarsened from ghost cell regions of the source (finer) level into the destination (coarser) level. If coarsening from fine ghost cell regions is not desired, then it should be a zero IntVector. If this argument is nonzero, its value should be the cell width, in the destination (coarser) index space, of the region around the fine level where this coarsening should occur. This argument should only be made nonzero by those who specifically require this special behavior and know how to properly process the patch data on coarse and fine patch levels during the coarsening process. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>var_fill_pattern</em>&nbsp;</td><td>boost::shared_ptr to the variable fill pattern, which controls how box overlaps are constructed. If the NULL default is used, then class <a class="el" href="classSAMRAI_1_1xfer_1_1BoxGeometryVariableFillPattern.html">BoxGeometryVariableFillPattern</a> will be used internally.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Precondition:</b></dt><dd>!d_schedule_created </dd></dl>

</div>
</div><p>
<a class="anchor" name="0a675a0a33d6297fa57ae1041865c453"></a><!-- doxytag: member="SAMRAI::xfer::CoarsenAlgorithm::registerCoarsen" ref="0a675a0a33d6297fa57ae1041865c453" args="(const int dst, const int src, const boost::shared_ptr&lt; hier::CoarsenOperator &gt; &amp;opcoarsen, const boost::shared_ptr&lt; VariableFillPattern &gt; &amp;var_fill_pattern=boost::shared_ptr&lt; VariableFillPattern &gt;())" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::xfer::CoarsenAlgorithm::registerCoarsen           </td>
          <td>(</td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1hier_1_1CoarsenOperator.html">hier::CoarsenOperator</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>opcoarsen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1VariableFillPattern.html">VariableFillPattern</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>var_fill_pattern</em> = <code>boost::shared_ptr&lt;<a class="el" href="classSAMRAI_1_1xfer_1_1VariableFillPattern.html">VariableFillPattern</a>&gt;()</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Register a coarsening operation with the coarsening algorithm. 
<p>
This will do all of the same things as the above <a class="el" href="classSAMRAI_1_1xfer_1_1CoarsenAlgorithm.html#cdc98202dce18f2826c2858945d6b8b2">registerCoarsen()</a>, except it does not have the gcw_to_coarsen parameter. 
</div>
</div><p>
<a class="anchor" name="a21bc9734a4c494be2746bd89b5517a6"></a><!-- doxytag: member="SAMRAI::xfer::CoarsenAlgorithm::createSchedule" ref="a21bc9734a4c494be2746bd89b5517a6" args="(const boost::shared_ptr&lt; hier::PatchLevel &gt; &amp;crse_level, const boost::shared_ptr&lt; hier::PatchLevel &gt; &amp;fine_level, CoarsenPatchStrategy *coarsen_strategy=0, const boost::shared_ptr&lt; CoarsenTransactionFactory &gt; &amp;transaction_factory=boost::shared_ptr&lt; CoarsenTransactionFactory &gt;())" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1CoarsenSchedule.html">CoarsenSchedule</a> &gt; SAMRAI::xfer::CoarsenAlgorithm::createSchedule           </td>
          <td>(</td>
          <td class="paramtype">const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchLevel.html">hier::PatchLevel</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>crse_level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchLevel.html">hier::PatchLevel</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>fine_level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1xfer_1_1CoarsenPatchStrategy.html">CoarsenPatchStrategy</a> *&nbsp;</td>
          <td class="paramname"> <em>coarsen_strategy</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1CoarsenTransactionFactory.html">CoarsenTransactionFactory</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>transaction_factory</em> = <code>boost::shared_ptr&lt;&nbsp;<a class="el" href="classSAMRAI_1_1xfer_1_1CoarsenTransactionFactory.html">CoarsenTransactionFactory</a>&nbsp;&gt;()</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Create a communication schedule to coarsen data from the given fine patch level to the given coarse patch level. 
<p>
This communication schedule may then be executed to perform the data transfers. This schedule creation procedure assumes that the coarse level represents a region of coarser index space than the fine level. To avoid potentially erroneous behavior, the coarse level domain should cover the domain of the fine level.<p>
Note that the schedule remains valid as long as the levels do not change; thus, it can be used for multiple data communication cycles.<p>
<dl compact><dt><b>Returns:</b></dt><dd>boost::shared_ptr to coarsen schedule that performs the data transfers.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>crse_level</em>&nbsp;</td><td>boost::shared_ptr to coarse (destination) level. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>fine_level</em>&nbsp;</td><td>boost::shared_ptr to fine (source) level. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>coarsen_strategy</em>&nbsp;</td><td>boost::shared_ptr to a coarsen patch strategy that provides user-defined coarsen operations. If this patch strategy is null (default state), then no user-defined coarsen operations will be performed. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>transaction_factory</em>&nbsp;</td><td>Optional boost::shared_ptr to a coarsen transaction factory that creates data transactions for the schedule. If this pointer is null default state), then a <a class="el" href="classSAMRAI_1_1xfer_1_1StandardCoarsenTransactionFactory.html">StandardCoarsenTransactionFactory</a> object will be used.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Precondition:</b></dt><dd>crse_level &amp;&amp; fine_level <p>
(<a class="el" href="classSAMRAI_1_1xfer_1_1CoarsenAlgorithm.html#33af771f305009040d36227754eb80b5">getDim()</a> == crse_level-&gt;<a class="el" href="classSAMRAI_1_1xfer_1_1CoarsenAlgorithm.html#33af771f305009040d36227754eb80b5">getDim()</a>) &amp;&amp; (<a class="el" href="classSAMRAI_1_1xfer_1_1CoarsenAlgorithm.html#33af771f305009040d36227754eb80b5">getDim()</a> == fine_level-&gt;<a class="el" href="classSAMRAI_1_1xfer_1_1CoarsenAlgorithm.html#33af771f305009040d36227754eb80b5">getDim()</a>) </dd></dl>

</div>
</div><p>
<a class="anchor" name="5ebe4533d536ed09da9311d44025e593"></a><!-- doxytag: member="SAMRAI::xfer::CoarsenAlgorithm::checkConsistency" ref="5ebe4533d536ed09da9311d44025e593" args="(const boost::shared_ptr&lt; CoarsenSchedule &gt; &amp;schedule) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SAMRAI::xfer::CoarsenAlgorithm::checkConsistency           </td>
          <td>(</td>
          <td class="paramtype">const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1CoarsenSchedule.html">CoarsenSchedule</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>schedule</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Given a previously-generated coarsen schedule, check for consistency with this coarsen algorithm object to see whether a call to resetSchedule is a valid operation. 
<p>
Consistency means that the number of operations registered must be the same and the source and destination patch data items and operators must have identical characteristics (i.e., data centering, ghost cell widths, stencil requirements, etc.). However, the specific source, destination patch data ids and operators can be different.<p>
<dl compact><dt><b>Returns:</b></dt><dd>true if schedule reset is valid; false otherwise.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>schedule</em>&nbsp;</td><td>boost::shared_ptr to coarsen schedule, which cannot be null.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Precondition:</b></dt><dd>schedule </dd></dl>

</div>
</div><p>
<a class="anchor" name="40da07dfe68d058346b8ae0de34ec748"></a><!-- doxytag: member="SAMRAI::xfer::CoarsenAlgorithm::resetSchedule" ref="40da07dfe68d058346b8ae0de34ec748" args="(const boost::shared_ptr&lt; CoarsenSchedule &gt; &amp;schedule) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::xfer::CoarsenAlgorithm::resetSchedule           </td>
          <td>(</td>
          <td class="paramtype">const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1CoarsenSchedule.html">CoarsenSchedule</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>schedule</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Given a previously-generated coarsen schedule, reconfigure it to peform the communication operations registered with this coarsen algorithm object. 
<p>
That is, the schedule will be transformed so that it will function as though this coarsen algorithm created it. Note that the set of operations registered with this coarsen algorithm must be essentially the same as those registered with the coarsen algorithm that created the schedule originally, and this is enforced using a call to <a class="el" href="classSAMRAI_1_1xfer_1_1CoarsenAlgorithm.html#5ebe4533d536ed09da9311d44025e593">checkConsistency()</a>.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>schedule</em>&nbsp;</td><td>boost::shared_ptr to coarsen schedule, which cannot be null.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Precondition:</b></dt><dd>schedule <p>
d_coarsen_classes-&gt;classesMatch(schedule-&gt;getEquivalenceClasses()) </dd></dl>

</div>
</div><p>
<a class="anchor" name="0ed6def085c21285636d8cbb656cfd80"></a><!-- doxytag: member="SAMRAI::xfer::CoarsenAlgorithm::printClassData" ref="0ed6def085c21285636d8cbb656cfd80" args="(std::ostream &amp;stream) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::xfer::CoarsenAlgorithm::printClassData           </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&nbsp;</td>
          <td class="paramname"> <em>stream</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Print the coarsen algorithm state to the specified data stream. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>stream</em>&nbsp;</td><td>Output data stream. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="33af771f305009040d36227754eb80b5"></a><!-- doxytag: member="SAMRAI::xfer::CoarsenAlgorithm::getDim" ref="33af771f305009040d36227754eb80b5" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classSAMRAI_1_1tbox_1_1Dimension.html">tbox::Dimension</a>&amp; SAMRAI::xfer::CoarsenAlgorithm::getDim           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return the dimension of this object. 
<p>

</div>
</div><p>
<hr>The documentation for this class was generated from the following files:<ul>
<li>source/SAMRAI/xfer/<a class="el" href="CoarsenAlgorithm_8h.html">CoarsenAlgorithm.h</a><li>source/SAMRAI/xfer/<a class="el" href="CoarsenAlgorithm_8C.html">CoarsenAlgorithm.C</a></ul>
<hr size="1"><address style="align: right;"><small>Generated on 5 Jul 2013 for SAMRAI by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.7 </small></address>
</body>
</html>
