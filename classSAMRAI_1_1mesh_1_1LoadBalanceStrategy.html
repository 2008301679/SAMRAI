<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>SAMRAI: SAMRAI::mesh::LoadBalanceStrategy Class Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.7 -->
<div class="tabs">
  <ul>
    <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="namespaces.html"><span>Namespaces</span></a></li>
    <li id="current"><a href="annotated.html"><span>Classes</span></a></li>
    <li><a href="files.html"><span>Files</span></a></li>
    <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
  </ul></div>
<div class="tabs">
  <ul>
    <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
    <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
    <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
  </ul></div>
<div class="nav">
<a class="el" href="namespaceSAMRAI.html">SAMRAI</a>::<a class="el" href="namespaceSAMRAI_1_1mesh.html">mesh</a>::<a class="el" href="classSAMRAI_1_1mesh_1_1LoadBalanceStrategy.html">LoadBalanceStrategy</a></div>
<h1>SAMRAI::mesh::LoadBalanceStrategy Class Reference</h1><!-- doxytag: class="SAMRAI::mesh::LoadBalanceStrategy" -->Class <a class="el" href="classSAMRAI_1_1mesh_1_1LoadBalanceStrategy.html">LoadBalanceStrategy</a> is an abstract base class that defines a Strategy pattern interface for operations that load balance patches on a single AMR patch hierarchy level. Typically, such operations are invoked after the domain of a new hierarchy level is determined (e.g., via some error estimation procedure) and is applied to the collection of boxes that describe the domain. The load balancing process produces a set of boxes from which patches on the new level are created and a processor mapping describing how the new patches are mapped to processors.  
<a href="#_details">More...</a>
<p>
<code>#include &lt;source/SAMRAI/mesh/LoadBalanceStrategy.h&gt;</code>
<p>
<p>Inheritance diagram for SAMRAI::mesh::LoadBalanceStrategy:
<p><center><img src="classSAMRAI_1_1mesh_1_1LoadBalanceStrategy.png" usemap="#SAMRAI::mesh::LoadBalanceStrategy_map" border="0" alt=""></center>
<map name="SAMRAI::mesh::LoadBalanceStrategy_map">
<area href="classSAMRAI_1_1mesh_1_1ChopAndPackLoadBalancer.html" alt="SAMRAI::mesh::ChopAndPackLoadBalancer" shape="rect" coords="0,56,261,80">
<area href="classSAMRAI_1_1mesh_1_1TreeLoadBalancer.html" alt="SAMRAI::mesh::TreeLoadBalancer" shape="rect" coords="271,56,532,80">
</map>
<a href="classSAMRAI_1_1mesh_1_1LoadBalanceStrategy-members.html">List of all members.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1mesh_1_1LoadBalanceStrategy.html#b783122330df4525d0c913d8019a1d11">~LoadBalanceStrategy</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1mesh_1_1LoadBalanceStrategy.html#1b1525f4eafbf028b8585def7a19541b">getLoadBalanceDependsOnPatchData</a> (int level_number) const =0</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1mesh_1_1LoadBalanceStrategy.html#cb85a8a274e199dd7d10dd7c9288c148">loadBalanceBoxLevel</a> (<a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">hier::BoxLevel</a> &amp;balance_mapped_box_level, <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">hier::Connector</a> &amp;balance_to_anchor, <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">hier::Connector</a> &amp;anchor_to_balance, const <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchHierarchy.html">hier::PatchHierarchy</a> &gt; hierarchy, const int level_number, const <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">hier::Connector</a> &amp;unbalanced_to_attractor, const <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">hier::Connector</a> &amp;attractor_to_unbalanced, const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a> &amp;min_size, const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a> &amp;max_size, const <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">hier::BoxLevel</a> &amp;domain_mapped_box_level, const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a> &amp;bad_interval, const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a> &amp;cut_factor, const <a class="el" href="classSAMRAI_1_1tbox_1_1RankGroup.html">tbox::RankGroup</a> &amp;rank_group=<a class="el" href="classSAMRAI_1_1tbox_1_1RankGroup.html">tbox::RankGroup</a>()) const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Given a BoxLevel, representing the domain of a specified level in the AMR hierarchy, generate a new BoxLevel from which the patches for the level may be formed and update two Connectors incident on the changed BoxLevel.  <a href="#cb85a8a274e199dd7d10dd7c9288c148"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1mesh_1_1LoadBalanceStrategy.html#4a95d5f4b32c9c49ba0427a68e6abd36">gatherAndReportLoadBalance</a> (double local_workload, const <a class="el" href="classSAMRAI_1_1tbox_1_1SAMRAI__MPI.html">tbox::SAMRAI_MPI</a> &amp;mpi, std::ostream &amp;output_stream=<a class="el" href="namespaceSAMRAI_1_1tbox.html#48a363c43ec1479b41d6c9c560ba446d">tbox::plog</a>) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gather workloads in an MPI group and write out a summary of load balance efficiency.  <a href="#4a95d5f4b32c9c49ba0427a68e6abd36"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1mesh_1_1LoadBalanceStrategy.html#cf8c5a7f73a16dd04fa49bc8ef15382d">gatherAndReportLoadBalance</a> (const std::vector&lt; double &gt; &amp;local_loads, const <a class="el" href="classSAMRAI_1_1tbox_1_1SAMRAI__MPI.html">tbox::SAMRAI_MPI</a> &amp;mpi, std::ostream &amp;output_stream=<a class="el" href="namespaceSAMRAI_1_1tbox.html#48a363c43ec1479b41d6c9c560ba446d">tbox::plog</a>) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gather a sequence of workloads in an MPI group and write out a summary of load balance efficiency.  <a href="#cf8c5a7f73a16dd04fa49bc8ef15382d"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1mesh_1_1LoadBalanceStrategy.html#50c18ecf37bb62d993f47824d0e16175">LoadBalanceStrategy</a> ()</td></tr>

<tr><td colspan="2"><br><h2>Static Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1mesh_1_1LoadBalanceStrategy.html#0c199d9c9de1e2bc965b2ed1c1b5be40">markLoadForPostprocessing</a> (int rank, double load, int nbox)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Write load data to log for postprocessing later.  <a href="#0c199d9c9de1e2bc965b2ed1c1b5be40"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1mesh_1_1LoadBalanceStrategy.html#aa6465cb380363534149de11f8346213">reportLoadBalance</a> (const std::vector&lt; double &gt; &amp;workloads, std::ostream &amp;output_stream)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Write out a short report of how well load is balanced.  <a href="#aa6465cb380363534149de11f8346213"></a><br></td></tr>
</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
Class <a class="el" href="classSAMRAI_1_1mesh_1_1LoadBalanceStrategy.html">LoadBalanceStrategy</a> is an abstract base class that defines a Strategy pattern interface for operations that load balance patches on a single AMR patch hierarchy level. Typically, such operations are invoked after the domain of a new hierarchy level is determined (e.g., via some error estimation procedure) and is applied to the collection of boxes that describe the domain. The load balancing process produces a set of boxes from which patches on the new level are created and a processor mapping describing how the new patches are mapped to processors. 
<p>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classSAMRAI_1_1hier_1_1PatchLevel.html">hier::PatchLevel</a> <p>
<a class="el" href="classSAMRAI_1_1hier_1_1ProcessorMapping.html">hier::ProcessorMapping</a> </dd></dl>

<p>
<hr><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" name="b783122330df4525d0c913d8019a1d11"></a><!-- doxytag: member="SAMRAI::mesh::LoadBalanceStrategy::~LoadBalanceStrategy" ref="b783122330df4525d0c913d8019a1d11" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SAMRAI::mesh::LoadBalanceStrategy::~LoadBalanceStrategy           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This virtual destructor does nothing interesting. 
</div>
</div><p>
<a class="anchor" name="50c18ecf37bb62d993f47824d0e16175"></a><!-- doxytag: member="SAMRAI::mesh::LoadBalanceStrategy::LoadBalanceStrategy" ref="50c18ecf37bb62d993f47824d0e16175" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SAMRAI::mesh::LoadBalanceStrategy::LoadBalanceStrategy           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Construct load balance strategy object. 
</div>
</div><p>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="1b1525f4eafbf028b8585def7a19541b"></a><!-- doxytag: member="SAMRAI::mesh::LoadBalanceStrategy::getLoadBalanceDependsOnPatchData" ref="1b1525f4eafbf028b8585def7a19541b" args="(int level_number) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool SAMRAI::mesh::LoadBalanceStrategy::getLoadBalanceDependsOnPatchData           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>level_number</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Indicate whether load balancing procedure for given level depends on patch data on mesh. This can be used to determine whether a level needs to be rebalanced although its box configuration is unchanged.<p>
<dl compact><dt><b>Returns:</b></dt><dd>Boolean value of true if load balance routines for level depend on patch data; false otherwise.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>level_number</em>&nbsp;</td><td>Integer level number. </td></tr>
  </table>
</dl>

<p>
Implemented in <a class="el" href="classSAMRAI_1_1mesh_1_1ChopAndPackLoadBalancer.html#88e41115102265dd474ae40a0c19635a">SAMRAI::mesh::ChopAndPackLoadBalancer</a>, and <a class="el" href="classSAMRAI_1_1mesh_1_1TreeLoadBalancer.html#3784dd2378c8d1f626d2678cfc9a24bf">SAMRAI::mesh::TreeLoadBalancer</a>.
</div>
</div><p>
<a class="anchor" name="cb85a8a274e199dd7d10dd7c9288c148"></a><!-- doxytag: member="SAMRAI::mesh::LoadBalanceStrategy::loadBalanceBoxLevel" ref="cb85a8a274e199dd7d10dd7c9288c148" args="(hier::BoxLevel &amp;balance_mapped_box_level, hier::Connector &amp;balance_to_anchor, hier::Connector &amp;anchor_to_balance, const tbox::Pointer&lt; hier::PatchHierarchy &gt; hierarchy, const int level_number, const hier::Connector &amp;unbalanced_to_attractor, const hier::Connector &amp;attractor_to_unbalanced, const hier::IntVector &amp;min_size, const hier::IntVector &amp;max_size, const hier::BoxLevel &amp;domain_mapped_box_level, const hier::IntVector &amp;bad_interval, const hier::IntVector &amp;cut_factor, const tbox::RankGroup &amp;rank_group=tbox::RankGroup()) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void SAMRAI::mesh::LoadBalanceStrategy::loadBalanceBoxLevel           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">hier::BoxLevel</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>balance_mapped_box_level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">hier::Connector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>balance_to_anchor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">hier::Connector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>anchor_to_balance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchHierarchy.html">hier::PatchHierarchy</a> &gt;&nbsp;</td>
          <td class="paramname"> <em>hierarchy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>level_number</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">hier::Connector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>unbalanced_to_attractor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">hier::Connector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>attractor_to_unbalanced</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>min_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>max_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">hier::BoxLevel</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>domain_mapped_box_level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>bad_interval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>cut_factor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1tbox_1_1RankGroup.html">tbox::RankGroup</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>rank_group</em> = <code><a class="el" href="classSAMRAI_1_1tbox_1_1RankGroup.html">tbox::RankGroup</a>()</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Given a BoxLevel, representing the domain of a specified level in the AMR hierarchy, generate a new BoxLevel from which the patches for the level may be formed and update two Connectors incident on the changed BoxLevel. 
<p>
The union of the boxes in the balance_mapped_box_level is the same before and after the the method call.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>balance_mapped_box_level</em>&nbsp;</td><td>Input BoxLevel. On input, this is the pre-balance BoxLevel. On output, it is the balanced BoxLevel.</td></tr>
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>balance_to_anchor</em>&nbsp;</td><td>Connector between the balance_mapped_box_level and some given "anchor mapped_box_level". This must be accurate on input. On putput, connects the newly balanced balance_mapped_box_level to the anchor mapped_box_level.</td></tr>
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>anchor_to_balance</em>&nbsp;</td><td>Transpose of balance_to_anchor.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>hierarchy</em>&nbsp;</td><td>The hierarchy where the work distribution data lives.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>level_number</em>&nbsp;</td><td>The number of the level where the work distribution data lives.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>unbalanced_to_attractor</em>&nbsp;</td><td>Connector between the balance_mapped_box_level and an "attractor" BoxLevel. This data may be used to indicate preference for data locality. The implementation should try to maximize overlaps between attractor and balance cells owned by the same process.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>attractor_to_unbalanced</em>&nbsp;</td><td>Transpose of unbalanced_to_attractor.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>min_size</em>&nbsp;</td><td><a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a> representing mimimum box size.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>max_size</em>&nbsp;</td><td><a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a> representing maximum box size.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>domain_mapped_box_level</em>&nbsp;</td><td>Description of the domain.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>bad_interval</em>&nbsp;</td><td><a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a> indicating the length of an interval of cells along each side of the box where chopping the box may produce boxes with certain "bad" properties. For example, this is primiarily used to avoid generating ghost regions for patches that intersect the domain boundary in ways that may it difficult for a use to provide boundary values. Thus, it is typically related to the maximum ghost cell width in the problem. See <a class="el" href="structSAMRAI_1_1hier_1_1BoxUtilities.html">hier::BoxUtilities</a> header file for more information.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>cut_factor</em>&nbsp;</td><td><a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a> indicating factor for chopping each side of a box; i.e., after chopping a box, the number of cells along each direction of each piece must be an integer multiple of the corresponding entry in the cut factor vector. For example, the cut factor may be related to the coarsen ratio between levels in the hierarchy in which case it may be used to produce boxes that can be coarsened by a certain factor if needed. See <a class="el" href="structSAMRAI_1_1hier_1_1BoxUtilities.html">hier::BoxUtilities</a> header file for more information.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>rank_group</em>&nbsp;</td><td>Input <a class="el" href="classSAMRAI_1_1tbox_1_1RankGroup.html">tbox::RankGroup</a> indicating a set of ranks on which all boxes in the output balance_mapped_box_level will be restricted. Some child classes may not make use of this argument. </td></tr>
  </table>
</dl>

<p>
Implemented in <a class="el" href="classSAMRAI_1_1mesh_1_1ChopAndPackLoadBalancer.html#940c2313b1ebc0ef9e6c6041274ff341">SAMRAI::mesh::ChopAndPackLoadBalancer</a>, and <a class="el" href="classSAMRAI_1_1mesh_1_1TreeLoadBalancer.html#10011908a919ee5fd03d47bebeb84acc">SAMRAI::mesh::TreeLoadBalancer</a>.
</div>
</div><p>
<a class="anchor" name="4a95d5f4b32c9c49ba0427a68e6abd36"></a><!-- doxytag: member="SAMRAI::mesh::LoadBalanceStrategy::gatherAndReportLoadBalance" ref="4a95d5f4b32c9c49ba0427a68e6abd36" args="(double local_workload, const tbox::SAMRAI_MPI &amp;mpi, std::ostream &amp;output_stream=tbox::plog) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::mesh::LoadBalanceStrategy::gatherAndReportLoadBalance           </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>local_workload</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1tbox_1_1SAMRAI__MPI.html">tbox::SAMRAI_MPI</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>mpi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;&nbsp;</td>
          <td class="paramname"> <em>output_stream</em> = <code><a class="el" href="namespaceSAMRAI_1_1tbox.html#48a363c43ec1479b41d6c9c560ba446d">tbox::plog</a></code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Gather workloads in an MPI group and write out a summary of load balance efficiency. 
<p>
To be used for performance evaluation. Not recommended for general use.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>local_workload</em>&nbsp;</td><td>Workload of the local process</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>mpi</em>&nbsp;</td><td>Represents all processes involved in the load balancing.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>output_stream</em>&nbsp;</td><td>TODO: This method is a utility that doesn't strictly belong in a strategy design pattern. It should be moved elsewhere. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="cf8c5a7f73a16dd04fa49bc8ef15382d"></a><!-- doxytag: member="SAMRAI::mesh::LoadBalanceStrategy::gatherAndReportLoadBalance" ref="cf8c5a7f73a16dd04fa49bc8ef15382d" args="(const std::vector&lt; double &gt; &amp;local_loads, const tbox::SAMRAI_MPI &amp;mpi, std::ostream &amp;output_stream=tbox::plog) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::mesh::LoadBalanceStrategy::gatherAndReportLoadBalance           </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>local_loads</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1tbox_1_1SAMRAI__MPI.html">tbox::SAMRAI_MPI</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>mpi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;&nbsp;</td>
          <td class="paramname"> <em>output_stream</em> = <code><a class="el" href="namespaceSAMRAI_1_1tbox.html#48a363c43ec1479b41d6c9c560ba446d">tbox::plog</a></code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Gather a sequence of workloads in an MPI group and write out a summary of load balance efficiency. 
<p>
Each value in the sequence of workloads represent a certain load the local process had over a sequence of load balancings.<p>
To be used for performance evaluation. Not recommended for general use.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>local_workloads</em>&nbsp;</td><td>Sequence of workloads of the local process. The size of <code>local_loads</code> is the number times load balancing has been used. It must be the same across all processors in <code>mpi</code>.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>mpi</em>&nbsp;</td><td>Represents all processes involved in the load balancing.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>output_stream</em>&nbsp;</td><td>TODO: This method is a utility that doesn't strictly belong in a strategy design pattern. It should be moved elsewhere. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="0c199d9c9de1e2bc965b2ed1c1b5be40"></a><!-- doxytag: member="SAMRAI::mesh::LoadBalanceStrategy::markLoadForPostprocessing" ref="0c199d9c9de1e2bc965b2ed1c1b5be40" args="(int rank, double load, int nbox)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::mesh::LoadBalanceStrategy::markLoadForPostprocessing           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>rank</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>load</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>nbox</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [static, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Write load data to log for postprocessing later. 
<p>
For development only. Not for general use.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>rank</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>load</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>nbox</em>&nbsp;</td><td>TODO: This method does not belong in a strategy base class and should be moved elsewhere. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="aa6465cb380363534149de11f8346213"></a><!-- doxytag: member="SAMRAI::mesh::LoadBalanceStrategy::reportLoadBalance" ref="aa6465cb380363534149de11f8346213" args="(const std::vector&lt; double &gt; &amp;workloads, std::ostream &amp;output_stream)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::mesh::LoadBalanceStrategy::reportLoadBalance           </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>workloads</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;&nbsp;</td>
          <td class="paramname"> <em>output_stream</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [static, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Write out a short report of how well load is balanced. 
<p>
Given the workloads of a number of processes, format and write out a brief report for assessing how well balanced the workloads are.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>workloads</em>&nbsp;</td><td>One value for each process. The number of processes is taken to be the size of this container.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>output_stream</em>&nbsp;</td><td>TODO: This method does not belong in a strategy base class and should be moved elsewhere. </td></tr>
  </table>
</dl>

</div>
</div><p>
<hr>The documentation for this class was generated from the following files:<ul>
<li>source/SAMRAI/mesh/<a class="el" href="LoadBalanceStrategy_8h.html">LoadBalanceStrategy.h</a><li>source/SAMRAI/mesh/<a class="el" href="LoadBalanceStrategy_8C.html">LoadBalanceStrategy.C</a></ul>
<hr size="1"><address style="align: right;"><small>Generated on Fri Mar 16 14:34:19 2012 for SAMRAI by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.7 </small></address>
</body>
</html>
