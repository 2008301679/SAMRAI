<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>SAMRAI: SAMRAI::tbox::AsyncCommPeer&lt; TYPE &gt; Class Template Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.7 -->
<div class="tabs">
  <ul>
    <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="namespaces.html"><span>Namespaces</span></a></li>
    <li id="current"><a href="annotated.html"><span>Classes</span></a></li>
    <li><a href="files.html"><span>Files</span></a></li>
    <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
  </ul></div>
<div class="tabs">
  <ul>
    <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
    <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
    <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
  </ul></div>
<div class="nav">
<a class="el" href="namespaceSAMRAI.html">SAMRAI</a>::<a class="el" href="namespaceSAMRAI_1_1tbox.html">tbox</a>::<a class="el" href="classSAMRAI_1_1tbox_1_1AsyncCommPeer.html">AsyncCommPeer</a></div>
<h1>SAMRAI::tbox::AsyncCommPeer&lt; TYPE &gt; Class Template Reference</h1><!-- doxytag: class="SAMRAI::tbox::AsyncCommPeer" --><!-- doxytag: inherits="SAMRAI::tbox::AsyncCommStage::Member" -->Supports point-to-point asynchronous communication operations that can overlap other communcations using a <a class="el" href="classSAMRAI_1_1tbox_1_1AsyncCommStage.html">AsyncCommStage</a>.  
<a href="#_details">More...</a>
<p>
<code>#include &lt;source/SAMRAI/tbox/AsyncCommPeer.h&gt;</code>
<p>
<p>Inheritance diagram for SAMRAI::tbox::AsyncCommPeer&lt; TYPE &gt;:
<p><center><img src="classSAMRAI_1_1tbox_1_1AsyncCommPeer.png" usemap="#SAMRAI::tbox::AsyncCommPeer< TYPE >_map" border="0" alt=""></center>
<map name="SAMRAI::tbox::AsyncCommPeer< TYPE >_map">
<area href="structSAMRAI_1_1tbox_1_1AsyncCommStage_1_1Member.html" alt="SAMRAI::tbox::AsyncCommStage::Member" shape="rect" coords="0,0,249,24">
</map>
<a href="classSAMRAI_1_1tbox_1_1AsyncCommPeer-members.html">List of all members.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1tbox_1_1AsyncCommPeer.html#2e0e48c61c9524bcf4598d05ae31df16">AsyncCommPeer</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Default constructor does not set up anything. You must <a class="el" href="classSAMRAI_1_1tbox_1_1AsyncCommPeer.html#fcd7e50313fd197dbe9ec1c196d3efff">initialize()</a> the object before using it.  <a href="#2e0e48c61c9524bcf4598d05ae31df16"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1tbox_1_1AsyncCommPeer.html#15c2f56797dab20fb774093842272d4f">AsyncCommPeer</a> (<a class="el" href="classSAMRAI_1_1tbox_1_1AsyncCommStage.html">AsyncCommStage</a> *stage, <a class="el" href="structSAMRAI_1_1tbox_1_1AsyncCommStage_1_1Handler.html">AsyncCommStage::Handler</a> *handler=0)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Construct staged communication object.  <a href="#15c2f56797dab20fb774093842272d4f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1tbox_1_1AsyncCommPeer.html#83b249ee35fbf57c55d57a81ba67bd45">~AsyncCommPeer</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Destructor.  <a href="#83b249ee35fbf57c55d57a81ba67bd45"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1tbox_1_1AsyncCommPeer.html#fcd7e50313fd197dbe9ec1c196d3efff">initialize</a> (<a class="el" href="classSAMRAI_1_1tbox_1_1AsyncCommStage.html">AsyncCommStage</a> *stage, <a class="el" href="structSAMRAI_1_1tbox_1_1AsyncCommStage_1_1Handler.html">AsyncCommStage::Handler</a> *handler=0)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Initialize the object.  <a href="#fcd7e50313fd197dbe9ec1c196d3efff"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1tbox_1_1AsyncCommPeer.html#e40141c7ac5d0ab3234dfafc420303e9">setMPITag</a> (const int primary_tag, const int secondary_tag)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the MPI tags used for communication.  <a href="#e40141c7ac5d0ab3234dfafc420303e9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1tbox_1_1AsyncCommPeer.html#84252d35f93566a843b56ef522b1cb8b">setMPI</a> (const <a class="el" href="classSAMRAI_1_1tbox_1_1SAMRAI__MPI.html">SAMRAI_MPI</a> &amp;mpi)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the MPI object used for communications.  <a href="#84252d35f93566a843b56ef522b1cb8b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">const <a class="el" href="classSAMRAI_1_1tbox_1_1SAMRAI__MPI.html">SAMRAI_MPI</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1tbox_1_1AsyncCommPeer.html#0c418622ec0df435b52f2083614403e8">getMPI</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the MPI object used for communications.  <a href="#0c418622ec0df435b52f2083614403e8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">TaskOp&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1tbox_1_1AsyncCommPeer.html#0677e181d31cd7a67d44ab914b570fab">getNextTaskOp</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Next task in a current communication operation.  <a href="#0677e181d31cd7a67d44ab914b570fab"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">BaseOp&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1tbox_1_1AsyncCommPeer.html#4212ca021d804759d0f3f59a320b8f4c">getBaseOp</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Operation being performed.  <a href="#4212ca021d804759d0f3f59a320b8f4c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1tbox_1_1AsyncCommPeer.html#44e56aba949601b5999e4f9731330995">getPrimaryTag</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Primary tag for the first message.  <a href="#44e56aba949601b5999e4f9731330995"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1tbox_1_1AsyncCommPeer.html#67c964d164ea6b5760d5e5c0df7d73c6">getSecondaryTag</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Secondary tag for the first message.  <a href="#67c964d164ea6b5760d5e5c0df7d73c6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1tbox_1_1AsyncCommPeer.html#8f2771aa544020f7af0286a4fb856618">logCurrentState</a> (std::ostream &amp;co) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">For use in debugging.  <a href="#8f2771aa544020f7af0286a4fb856618"></a><br></td></tr>
<tr><td colspan="2"><div class="groupHeader">Define the peer relationship.</div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1tbox_1_1AsyncCommPeer.html#4f7069eaceb0865e3818d18c6629639f">setPeerRank</a> (int peer_rank)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the peer rank.  <a href="#4f7069eaceb0865e3818d18c6629639f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1tbox_1_1AsyncCommPeer.html#e1f610d20943170965bbd0dcbce33c3a">getPeerRank</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Rank of peer process.  <a href="#e1f610d20943170965bbd0dcbce33c3a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1tbox_1_1AsyncCommPeer.html#463bd320ed59067da7b4abd72988188a">limitFirstDataLength</a> (size_t max_first_data_len)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Limit the data length in first message of a communication.  <a href="#463bd320ed59067da7b4abd72988188a"></a><br></td></tr>
<tr><td colspan="2"><div class="groupHeader">Communication methods</div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1tbox_1_1AsyncCommPeer.html#b6618bb7a746fa89c6ef35d4ee4effab">beginSend</a> (const TYPE *buffer, int size)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Begin a send communication.  <a href="#b6618bb7a746fa89c6ef35d4ee4effab"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1tbox_1_1AsyncCommPeer.html#af125564deb47f54ff8396e7e95d51e2">checkSend</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Check the current broadcast communication and complete the broadcast if all MPI requests are fulfilled.  <a href="#af125564deb47f54ff8396e7e95d51e2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1tbox_1_1AsyncCommPeer.html#824299214e9605879f696f2130a36dd5">beginRecv</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Begin a receive communication.  <a href="#824299214e9605879f696f2130a36dd5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1tbox_1_1AsyncCommPeer.html#f7b8e394ea52df7f198d290dff49e72e">checkRecv</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Check the current receive communication and complete the receive if the MPI request has been fulfilled.  <a href="#f7b8e394ea52df7f198d290dff49e72e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1tbox_1_1AsyncCommPeer.html#87b79fd93bbcfa40bc19e5bc802d5a21">getRecvSize</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the size of received data.  <a href="#87b79fd93bbcfa40bc19e5bc802d5a21"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">const TYPE *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1tbox_1_1AsyncCommPeer.html#b3a5a01c99778d948b30f828d20fdb02">getRecvData</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get access to the received data.  <a href="#b3a5a01c99778d948b30f828d20fdb02"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1tbox_1_1AsyncCommPeer.html#0d6349489f77cff31efbff83ac00039c">clearRecvData</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Clear the receive buffer immediately.  <a href="#0d6349489f77cff31efbff83ac00039c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1tbox_1_1AsyncCommPeer.html#7665d7aba9cd815a6aa18f961ec3e832">proceedToNextWait</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Check the current communication and complete it if all MPI requests are fulfilled.  <a href="#7665d7aba9cd815a6aa18f961ec3e832"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1tbox_1_1AsyncCommPeer.html#1ab7ecd6a416d9506bef86eed1d16e26">isDone</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Whether the last communication operation has finished.  <a href="#1ab7ecd6a416d9506bef86eed1d16e26"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1tbox_1_1AsyncCommPeer.html#b3f9bb2963d317a7cf339887234981a6">completeCurrentOperation</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Wait for the current operation to complete.  <a href="#b3f9bb2963d317a7cf339887234981a6"></a><br></td></tr>
<tr><td colspan="2"><div class="groupHeader">Timers for MPI calls</div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1tbox_1_1AsyncCommPeer.html#ff4f33cd06e0abfed7d658e851e3a829">setSendTimer</a> (const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Timer.html">Timer</a> &gt; &amp;send_timer)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the send-timer.  <a href="#ff4f33cd06e0abfed7d658e851e3a829"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1tbox_1_1AsyncCommPeer.html#2d766c344829bc811166a7e507a83b68">setRecvTimer</a> (const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Timer.html">Timer</a> &gt; &amp;recv_timer)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the receive-timer.  <a href="#2d766c344829bc811166a7e507a83b68"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1tbox_1_1AsyncCommPeer.html#139b1a34ebdf70f1dbef54baf26c7240">setWaitTimer</a> (const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Timer.html">Timer</a> &gt; &amp;wait_timer)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the wait-timer.  <a href="#139b1a34ebdf70f1dbef54baf26c7240"></a><br></td></tr>
</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
<h3>template&lt;class TYPE&gt;<br>
 class SAMRAI::tbox::AsyncCommPeer&lt; TYPE &gt;</h3>

Supports point-to-point asynchronous communication operations that can overlap other communcations using a <a class="el" href="classSAMRAI_1_1tbox_1_1AsyncCommStage.html">AsyncCommStage</a>. 
<p>
To use this class:<p>
<ol type=1>
<li>Construct an object with a stage or <code><a class="el" href="classSAMRAI_1_1tbox_1_1AsyncCommPeer.html#fcd7e50313fd197dbe9ec1c196d3efff">initialize()</a></code> it with a stage.</li></ol>
<p>
<ol type=1>
<li>Set the MPI communicator and tag values for use in the MPI nonblocking message passing functions.</li></ol>
<p>
<ol type=1>
<li>Set the peer rank using <a class="el" href="classSAMRAI_1_1tbox_1_1AsyncCommPeer.html#4f7069eaceb0865e3818d18c6629639f">setPeerRank()</a>.</li></ol>
<p>
<ol type=1>
<li>Call the <a class="el" href="classSAMRAI_1_1tbox_1_1AsyncCommPeer.html#b6618bb7a746fa89c6ef35d4ee4effab">beginSend()</a> and <a class="el" href="classSAMRAI_1_1tbox_1_1AsyncCommPeer.html#824299214e9605879f696f2130a36dd5">beginRecv()</a> functions. Make sure there is a matching call on the peer processor.</li></ol>
<p>
<ol type=1>
<li>Use the stage to advance the message passing operations. The stage tells you which members have completed their operations.</li></ol>
<p>
<ol type=1>
<li>Received data can be accessed using <a class="el" href="classSAMRAI_1_1tbox_1_1AsyncCommPeer.html#87b79fd93bbcfa40bc19e5bc802d5a21">getRecvSize()</a> and <a class="el" href="classSAMRAI_1_1tbox_1_1AsyncCommPeer.html#b3a5a01c99778d948b30f828d20fdb02">getRecvData()</a>.</li></ol>
<p>
It is not neccesary to know how much data is being sent. This class will figure that out (using overhead data attached to the actual user data being communicated).<p>
To check on sends and receives without using the stage, use <a class="el" href="classSAMRAI_1_1tbox_1_1AsyncCommPeer.html#af125564deb47f54ff8396e7e95d51e2">checkSend()</a> and <a class="el" href="classSAMRAI_1_1tbox_1_1AsyncCommPeer.html#f7b8e394ea52df7f198d290dff49e72e">checkRecv()</a> or <a class="el" href="classSAMRAI_1_1tbox_1_1AsyncCommPeer.html#7665d7aba9cd815a6aa18f961ec3e832">proceedToNextWait()</a>. To wait for the current operation to complete, use <a class="el" href="classSAMRAI_1_1tbox_1_1AsyncCommPeer.html#b3f9bb2963d317a7cf339887234981a6">completeCurrentOperation()</a>. 
<p>
<hr><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" name="2e0e48c61c9524bcf4598d05ae31df16"></a><!-- doxytag: member="SAMRAI::tbox::AsyncCommPeer::AsyncCommPeer" ref="2e0e48c61c9524bcf4598d05ae31df16" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSAMRAI_1_1tbox_1_1AsyncCommPeer.html">SAMRAI::tbox::AsyncCommPeer</a>&lt; TYPE &gt;::<a class="el" href="classSAMRAI_1_1tbox_1_1AsyncCommPeer.html">AsyncCommPeer</a>           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Default constructor does not set up anything. You must <a class="el" href="classSAMRAI_1_1tbox_1_1AsyncCommPeer.html#fcd7e50313fd197dbe9ec1c196d3efff">initialize()</a> the object before using it. 
<p>

</div>
</div><p>
<a class="anchor" name="15c2f56797dab20fb774093842272d4f"></a><!-- doxytag: member="SAMRAI::tbox::AsyncCommPeer::AsyncCommPeer" ref="15c2f56797dab20fb774093842272d4f" args="(AsyncCommStage *stage, AsyncCommStage::Handler *handler=0)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSAMRAI_1_1tbox_1_1AsyncCommPeer.html">SAMRAI::tbox::AsyncCommPeer</a>&lt; TYPE &gt;::<a class="el" href="classSAMRAI_1_1tbox_1_1AsyncCommPeer.html">AsyncCommPeer</a>           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1tbox_1_1AsyncCommStage.html">AsyncCommStage</a> *&nbsp;</td>
          <td class="paramname"> <em>stage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSAMRAI_1_1tbox_1_1AsyncCommStage_1_1Handler.html">AsyncCommStage::Handler</a> *&nbsp;</td>
          <td class="paramname"> <em>handler</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Construct staged communication object. 
<p>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classSAMRAI_1_1tbox_1_1AsyncCommPeer.html#fcd7e50313fd197dbe9ec1c196d3efff">initialize()</a>. </dd></dl>

</div>
</div><p>
<a class="anchor" name="83b249ee35fbf57c55d57a81ba67bd45"></a><!-- doxytag: member="SAMRAI::tbox::AsyncCommPeer::~AsyncCommPeer" ref="83b249ee35fbf57c55d57a81ba67bd45" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSAMRAI_1_1tbox_1_1AsyncCommPeer.html">SAMRAI::tbox::AsyncCommPeer</a>&lt; TYPE &gt;::~<a class="el" href="classSAMRAI_1_1tbox_1_1AsyncCommPeer.html">AsyncCommPeer</a>           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Destructor. 
<p>
<dl compact><dt><b>Precondition:</b></dt><dd><a class="el" href="classSAMRAI_1_1tbox_1_1AsyncCommPeer.html#1ab7ecd6a416d9506bef86eed1d16e26">isDone()</a> </dd></dl>

</div>
</div><p>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="fcd7e50313fd197dbe9ec1c196d3efff"></a><!-- doxytag: member="SAMRAI::tbox::AsyncCommPeer::initialize" ref="fcd7e50313fd197dbe9ec1c196d3efff" args="(AsyncCommStage *stage, AsyncCommStage::Handler *handler=0)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSAMRAI_1_1tbox_1_1AsyncCommPeer.html">SAMRAI::tbox::AsyncCommPeer</a>&lt; TYPE &gt;::initialize           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1tbox_1_1AsyncCommStage.html">AsyncCommStage</a> *&nbsp;</td>
          <td class="paramname"> <em>stage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSAMRAI_1_1tbox_1_1AsyncCommStage_1_1Handler.html">AsyncCommStage::Handler</a> *&nbsp;</td>
          <td class="paramname"> <em>handler</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Initialize the object. 
<p>
Attach self to the given stage and set the Handler.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>stage</em>&nbsp;</td><td>The stage handling communicaiton requests for the object. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>handler</em>&nbsp;</td><td>Optional pointer to user-defined data.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Precondition:</b></dt><dd><a class="el" href="classSAMRAI_1_1tbox_1_1AsyncCommPeer.html#1ab7ecd6a416d9506bef86eed1d16e26">isDone()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="4f7069eaceb0865e3818d18c6629639f"></a><!-- doxytag: member="SAMRAI::tbox::AsyncCommPeer::setPeerRank" ref="4f7069eaceb0865e3818d18c6629639f" args="(int peer_rank)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSAMRAI_1_1tbox_1_1AsyncCommPeer.html">SAMRAI::tbox::AsyncCommPeer</a>&lt; TYPE &gt;::setPeerRank           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>peer_rank</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set the peer rank. 
<p>
We assume (without checking) that the peer processor does a complementary call using this processor as its peer. If this assumption is wrong, there will likely be communication errors.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>peer_rank</em>&nbsp;</td><td></td></tr>
  </table>
</dl>
<dl compact><dt><b>Precondition:</b></dt><dd><a class="el" href="classSAMRAI_1_1tbox_1_1AsyncCommPeer.html#1ab7ecd6a416d9506bef86eed1d16e26">isDone()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="e1f610d20943170965bbd0dcbce33c3a"></a><!-- doxytag: member="SAMRAI::tbox::AsyncCommPeer::getPeerRank" ref="e1f610d20943170965bbd0dcbce33c3a" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classSAMRAI_1_1tbox_1_1AsyncCommPeer.html">SAMRAI::tbox::AsyncCommPeer</a>&lt; TYPE &gt;::getPeerRank           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Rank of peer process. 
<p>

</div>
</div><p>
<a class="anchor" name="463bd320ed59067da7b4abd72988188a"></a><!-- doxytag: member="SAMRAI::tbox::AsyncCommPeer::limitFirstDataLength" ref="463bd320ed59067da7b4abd72988188a" args="(size_t max_first_data_len)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSAMRAI_1_1tbox_1_1AsyncCommPeer.html">SAMRAI::tbox::AsyncCommPeer</a>&lt; TYPE &gt;::limitFirstDataLength           </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>max_first_data_len</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Limit the data length in first message of a communication. 
<p>
Sometimes, the receiver does not know how much data is being sent. In such cases, the receiver would assume the data is no more than a size that the sender and receiver have agreed upon before hand, <code>max_first_data_len</code>. If the message is longer, the sender sends it in two parts. The first message contains no more than <code>max_first_data_len</code> items and indicates the true length of the data. A second message is used if needed.<p>
The receiver must set a first data length no less than the sender's or risk a fatal MPI "truncated message" error.<p>
The limit is set to one by default, meaning that any message more than one item long would be sent in two parts. 
</div>
</div><p>
<a class="anchor" name="e40141c7ac5d0ab3234dfafc420303e9"></a><!-- doxytag: member="SAMRAI::tbox::AsyncCommPeer::setMPITag" ref="e40141c7ac5d0ab3234dfafc420303e9" args="(const int primary_tag, const int secondary_tag)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSAMRAI_1_1tbox_1_1AsyncCommPeer.html">SAMRAI::tbox::AsyncCommPeer</a>&lt; TYPE &gt;::setMPITag           </td>
          <td>(</td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>primary_tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>secondary_tag</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set the MPI tags used for communication. 
<p>
The <code>primary_tag</code> is used for every message. If a message must be sent in two parts (see <a class="el" href="classSAMRAI_1_1tbox_1_1AsyncCommPeer.html#463bd320ed59067da7b4abd72988188a">limitFirstDataLength()</a>), the secondary tag is used for the follow-up message. It is advisable to use different values for the two tags to ensure that the second message is not mistaken for the first.<p>
<dl compact><dt><b>Attention:</b></dt><dd>This class is NOT (and cannot be) responsible for ensuring that the MPI communicator and tag are sufficient to select the correct messages. Please specify appropriate values for the MPI communicator and tag. Very elusive bugs can occur if incorrect messages are received.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>primary_tag</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>secondary_tag</em>&nbsp;</td><td></td></tr>
  </table>
</dl>
<dl compact><dt><b>Precondition:</b></dt><dd><a class="el" href="classSAMRAI_1_1tbox_1_1AsyncCommPeer.html#1ab7ecd6a416d9506bef86eed1d16e26">isDone()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="84252d35f93566a843b56ef522b1cb8b"></a><!-- doxytag: member="SAMRAI::tbox::AsyncCommPeer::setMPI" ref="84252d35f93566a843b56ef522b1cb8b" args="(const SAMRAI_MPI &amp;mpi)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSAMRAI_1_1tbox_1_1AsyncCommPeer.html">SAMRAI::tbox::AsyncCommPeer</a>&lt; TYPE &gt;::setMPI           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1tbox_1_1SAMRAI__MPI.html">SAMRAI_MPI</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>mpi</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set the MPI object used for communications. 
<p>
<dl compact><dt><b>Attention:</b></dt><dd>This class is NOT (and cannot be) responsible for ensuring that the MPI object and tag are sufficient to select the correct messages. Please specify appropriate values for the MPI object and tag. Very elusive bugs can occur if incorrect messages are received. To be safe, it is best to create a new communicator to avoid interference with other communications within <a class="el" href="namespaceSAMRAI.html">SAMRAI</a>.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>mpi</em>&nbsp;</td><td></td></tr>
  </table>
</dl>
<dl compact><dt><b>Precondition:</b></dt><dd><a class="el" href="classSAMRAI_1_1tbox_1_1AsyncCommPeer.html#1ab7ecd6a416d9506bef86eed1d16e26">isDone()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="0c418622ec0df435b52f2083614403e8"></a><!-- doxytag: member="SAMRAI::tbox::AsyncCommPeer::getMPI" ref="0c418622ec0df435b52f2083614403e8" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classSAMRAI_1_1tbox_1_1SAMRAI__MPI.html">SAMRAI_MPI</a>&amp; <a class="el" href="classSAMRAI_1_1tbox_1_1AsyncCommPeer.html">SAMRAI::tbox::AsyncCommPeer</a>&lt; TYPE &gt;::getMPI           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Gets the MPI object used for communications. 
<p>

</div>
</div><p>
<a class="anchor" name="0677e181d31cd7a67d44ab914b570fab"></a><!-- doxytag: member="SAMRAI::tbox::AsyncCommPeer::getNextTaskOp" ref="0677e181d31cd7a67d44ab914b570fab" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">TaskOp <a class="el" href="classSAMRAI_1_1tbox_1_1AsyncCommPeer.html">SAMRAI::tbox::AsyncCommPeer</a>&lt; TYPE &gt;::getNextTaskOp           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Next task in a current communication operation. 
<p>

</div>
</div><p>
<a class="anchor" name="4212ca021d804759d0f3f59a320b8f4c"></a><!-- doxytag: member="SAMRAI::tbox::AsyncCommPeer::getBaseOp" ref="4212ca021d804759d0f3f59a320b8f4c" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">BaseOp <a class="el" href="classSAMRAI_1_1tbox_1_1AsyncCommPeer.html">SAMRAI::tbox::AsyncCommPeer</a>&lt; TYPE &gt;::getBaseOp           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Operation being performed. 
<p>

</div>
</div><p>
<a class="anchor" name="44e56aba949601b5999e4f9731330995"></a><!-- doxytag: member="SAMRAI::tbox::AsyncCommPeer::getPrimaryTag" ref="44e56aba949601b5999e4f9731330995" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classSAMRAI_1_1tbox_1_1AsyncCommPeer.html">SAMRAI::tbox::AsyncCommPeer</a>&lt; TYPE &gt;::getPrimaryTag           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Primary tag for the first message. 
<p>

</div>
</div><p>
<a class="anchor" name="67c964d164ea6b5760d5e5c0df7d73c6"></a><!-- doxytag: member="SAMRAI::tbox::AsyncCommPeer::getSecondaryTag" ref="67c964d164ea6b5760d5e5c0df7d73c6" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classSAMRAI_1_1tbox_1_1AsyncCommPeer.html">SAMRAI::tbox::AsyncCommPeer</a>&lt; TYPE &gt;::getSecondaryTag           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Secondary tag for the first message. 
<p>

</div>
</div><p>
<a class="anchor" name="b6618bb7a746fa89c6ef35d4ee4effab"></a><!-- doxytag: member="SAMRAI::tbox::AsyncCommPeer::beginSend" ref="b6618bb7a746fa89c6ef35d4ee4effab" args="(const TYPE *buffer, int size)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classSAMRAI_1_1tbox_1_1AsyncCommPeer.html">SAMRAI::tbox::AsyncCommPeer</a>&lt; TYPE &gt;::beginSend           </td>
          <td>(</td>
          <td class="paramtype">const TYPE *&nbsp;</td>
          <td class="paramname"> <em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>size</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Begin a send communication. 
<p>
This must be paired with a <a class="el" href="classSAMRAI_1_1tbox_1_1AsyncCommPeer.html#824299214e9605879f696f2130a36dd5">beginRecv()</a> by the peer processor.<p>
On return, the data in <b>buffer</b> would have been copied so it is safe to deallocate or modify <code>buffer</code>.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>buffer</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>size</em>&nbsp;</td><td></td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Whether operation is completed.</dd></dl>
<dl compact><dt><b>Precondition:</b></dt><dd><a class="el" href="classSAMRAI_1_1tbox_1_1AsyncCommPeer.html#0677e181d31cd7a67d44ab914b570fab">getNextTaskOp()</a> == none </dd></dl>

</div>
</div><p>
<a class="anchor" name="af125564deb47f54ff8396e7e95d51e2"></a><!-- doxytag: member="SAMRAI::tbox::AsyncCommPeer::checkSend" ref="af125564deb47f54ff8396e7e95d51e2" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classSAMRAI_1_1tbox_1_1AsyncCommPeer.html">SAMRAI::tbox::AsyncCommPeer</a>&lt; TYPE &gt;::checkSend           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Check the current broadcast communication and complete the broadcast if all MPI requests are fulfilled. 
<p>
If no communication is in progress, this call does nothing.<p>
<dl compact><dt><b>Returns:</b></dt><dd>Whether operation is completed.</dd></dl>
<dl compact><dt><b>Precondition:</b></dt><dd><a class="el" href="classSAMRAI_1_1tbox_1_1AsyncCommPeer.html#4212ca021d804759d0f3f59a320b8f4c">getBaseOp()</a> == send </dd></dl>

</div>
</div><p>
<a class="anchor" name="824299214e9605879f696f2130a36dd5"></a><!-- doxytag: member="SAMRAI::tbox::AsyncCommPeer::beginRecv" ref="824299214e9605879f696f2130a36dd5" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classSAMRAI_1_1tbox_1_1AsyncCommPeer.html">SAMRAI::tbox::AsyncCommPeer</a>&lt; TYPE &gt;::beginRecv           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Begin a receive communication. 
<p>
This must be paired with a <a class="el" href="classSAMRAI_1_1tbox_1_1AsyncCommPeer.html#b6618bb7a746fa89c6ef35d4ee4effab">beginSend()</a> by the peer processor.<p>
The received data is stored in an internal buffer accessible through <a class="el" href="classSAMRAI_1_1tbox_1_1AsyncCommPeer.html#b3a5a01c99778d948b30f828d20fdb02">getRecvData()</a>. After receiving, the internal buffer is available until the object goes out of scope, another communication operation is initiated or deallocateInternalRecvBuffer() is called.<p>
The actual length of data received by the last receive operation is returned by <a class="el" href="classSAMRAI_1_1tbox_1_1AsyncCommPeer.html#87b79fd93bbcfa40bc19e5bc802d5a21">getRecvSize()</a>.<p>
<dl compact><dt><b>Returns:</b></dt><dd>Whether operation is completed. </dd></dl>

</div>
</div><p>
<a class="anchor" name="f7b8e394ea52df7f198d290dff49e72e"></a><!-- doxytag: member="SAMRAI::tbox::AsyncCommPeer::checkRecv" ref="f7b8e394ea52df7f198d290dff49e72e" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classSAMRAI_1_1tbox_1_1AsyncCommPeer.html">SAMRAI::tbox::AsyncCommPeer</a>&lt; TYPE &gt;::checkRecv           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Check the current receive communication and complete the receive if the MPI request has been fulfilled. 
<p>
<dl compact><dt><b>Returns:</b></dt><dd>Whether operation is completed.</dd></dl>
<dl compact><dt><b>Precondition:</b></dt><dd><a class="el" href="classSAMRAI_1_1tbox_1_1AsyncCommPeer.html#4212ca021d804759d0f3f59a320b8f4c">getBaseOp()</a> == recv </dd></dl>

</div>
</div><p>
<a class="anchor" name="87b79fd93bbcfa40bc19e5bc802d5a21"></a><!-- doxytag: member="SAMRAI::tbox::AsyncCommPeer::getRecvSize" ref="87b79fd93bbcfa40bc19e5bc802d5a21" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classSAMRAI_1_1tbox_1_1AsyncCommPeer.html">SAMRAI::tbox::AsyncCommPeer</a>&lt; TYPE &gt;::getRecvSize           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return the size of received data. 
<p>
<dl compact><dt><b>Precondition:</b></dt><dd><a class="el" href="classSAMRAI_1_1tbox_1_1AsyncCommPeer.html#4212ca021d804759d0f3f59a320b8f4c">getBaseOp()</a> == recv </dd></dl>

</div>
</div><p>
<a class="anchor" name="b3a5a01c99778d948b30f828d20fdb02"></a><!-- doxytag: member="SAMRAI::tbox::AsyncCommPeer::getRecvData" ref="b3a5a01c99778d948b30f828d20fdb02" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const TYPE * <a class="el" href="classSAMRAI_1_1tbox_1_1AsyncCommPeer.html">SAMRAI::tbox::AsyncCommPeer</a>&lt; TYPE &gt;::getRecvData           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get access to the received data. 
<p>
<dl compact><dt><b>Precondition:</b></dt><dd><a class="el" href="classSAMRAI_1_1tbox_1_1AsyncCommPeer.html#4212ca021d804759d0f3f59a320b8f4c">getBaseOp()</a> == recv </dd></dl>

</div>
</div><p>
<a class="anchor" name="0d6349489f77cff31efbff83ac00039c"></a><!-- doxytag: member="SAMRAI::tbox::AsyncCommPeer::clearRecvData" ref="0d6349489f77cff31efbff83ac00039c" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSAMRAI_1_1tbox_1_1AsyncCommPeer.html">SAMRAI::tbox::AsyncCommPeer</a>&lt; TYPE &gt;::clearRecvData           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Clear the receive buffer immediately. 
<p>
This is optional. The received data remains inside the object the next communicaiton operation starts, or until it is explicitly freed.<p>
It is an error to clear the receive buffer in the middle of a communication operation.<p>
<dl compact><dt><b>Precondition:</b></dt><dd>getNextTaksOp() == none </dd></dl>

</div>
</div><p>
<a class="anchor" name="7665d7aba9cd815a6aa18f961ec3e832"></a><!-- doxytag: member="SAMRAI::tbox::AsyncCommPeer::proceedToNextWait" ref="7665d7aba9cd815a6aa18f961ec3e832" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classSAMRAI_1_1tbox_1_1AsyncCommPeer.html">SAMRAI::tbox::AsyncCommPeer</a>&lt; TYPE &gt;::proceedToNextWait           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Check the current communication and complete it if all MPI requests are fulfilled. 
<p>

<p>
Implements <a class="el" href="structSAMRAI_1_1tbox_1_1AsyncCommStage_1_1Member.html#fb9f55fd72f7f9713b0138e8cad7c87e">SAMRAI::tbox::AsyncCommStage::Member</a>.
</div>
</div><p>
<a class="anchor" name="1ab7ecd6a416d9506bef86eed1d16e26"></a><!-- doxytag: member="SAMRAI::tbox::AsyncCommPeer::isDone" ref="1ab7ecd6a416d9506bef86eed1d16e26" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classSAMRAI_1_1tbox_1_1AsyncCommPeer.html">SAMRAI::tbox::AsyncCommPeer</a>&lt; TYPE &gt;::isDone           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Whether the last communication operation has finished. 
<p>
This means more than just whether there is outstanding MPI requests such as that returned by hasOutstandingRequests(). The communication is more complex, requiring up to two messages and copying of the received message into the correct buffer. When <a class="el" href="classSAMRAI_1_1tbox_1_1AsyncCommPeer.html#1ab7ecd6a416d9506bef86eed1d16e26">isDone()</a> returns true, the operation is truly finished. 
<p>
Implements <a class="el" href="structSAMRAI_1_1tbox_1_1AsyncCommStage_1_1Member.html#377ac960e58fbaa8c5d528c86c2d6100">SAMRAI::tbox::AsyncCommStage::Member</a>.
</div>
</div><p>
<a class="anchor" name="b3f9bb2963d317a7cf339887234981a6"></a><!-- doxytag: member="SAMRAI::tbox::AsyncCommPeer::completeCurrentOperation" ref="b3f9bb2963d317a7cf339887234981a6" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSAMRAI_1_1tbox_1_1AsyncCommPeer.html">SAMRAI::tbox::AsyncCommPeer</a>&lt; TYPE &gt;::completeCurrentOperation           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Wait for the current operation to complete. 
<p>

<p>
Implements <a class="el" href="structSAMRAI_1_1tbox_1_1AsyncCommStage_1_1Member.html#276cadf660e7cc5f1d302e2ac347bfd1">SAMRAI::tbox::AsyncCommStage::Member</a>.
</div>
</div><p>
<a class="anchor" name="ff4f33cd06e0abfed7d658e851e3a829"></a><!-- doxytag: member="SAMRAI::tbox::AsyncCommPeer::setSendTimer" ref="ff4f33cd06e0abfed7d658e851e3a829" args="(const boost::shared_ptr&lt; Timer &gt; &amp;send_timer)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSAMRAI_1_1tbox_1_1AsyncCommPeer.html">SAMRAI::tbox::AsyncCommPeer</a>&lt; TYPE &gt;::setSendTimer           </td>
          <td>(</td>
          <td class="paramtype">const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Timer.html">Timer</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>send_timer</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set the send-timer. 
<p>
Set the timer for non-blocking sends. If the timer is null, revert to the default timer named ""tboxAsyncCommPeer::MPI_ISend".<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>send_timer</em>&nbsp;</td><td></td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="2d766c344829bc811166a7e507a83b68"></a><!-- doxytag: member="SAMRAI::tbox::AsyncCommPeer::setRecvTimer" ref="2d766c344829bc811166a7e507a83b68" args="(const boost::shared_ptr&lt; Timer &gt; &amp;recv_timer)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSAMRAI_1_1tbox_1_1AsyncCommPeer.html">SAMRAI::tbox::AsyncCommPeer</a>&lt; TYPE &gt;::setRecvTimer           </td>
          <td>(</td>
          <td class="paramtype">const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Timer.html">Timer</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>recv_timer</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set the receive-timer. 
<p>
Set the timer for non-blocking receives. If the timer is null, revert to the default timer named ""tboxAsyncCommPeer::MPI_IRecv".<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>recv_timer</em>&nbsp;</td><td></td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="139b1a34ebdf70f1dbef54baf26c7240"></a><!-- doxytag: member="SAMRAI::tbox::AsyncCommPeer::setWaitTimer" ref="139b1a34ebdf70f1dbef54baf26c7240" args="(const boost::shared_ptr&lt; Timer &gt; &amp;wait_timer)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSAMRAI_1_1tbox_1_1AsyncCommPeer.html">SAMRAI::tbox::AsyncCommPeer</a>&lt; TYPE &gt;::setWaitTimer           </td>
          <td>(</td>
          <td class="paramtype">const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Timer.html">Timer</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>wait_timer</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set the wait-timer. 
<p>
Set the timer for blocking waits. If the timer is null, revert to the default timer named ""tboxAsyncCommPeer::wait_all()".<p>
This timer is used when in this class and is not the same as the timer given to <a class="el" href="classSAMRAI_1_1tbox_1_1AsyncCommStage.html">AsyncCommStage</a> (unless the user sets it up that way explicitly).<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>wait_timer</em>&nbsp;</td><td></td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="8f2771aa544020f7af0286a4fb856618"></a><!-- doxytag: member="SAMRAI::tbox::AsyncCommPeer::logCurrentState" ref="8f2771aa544020f7af0286a4fb856618" args="(std::ostream &amp;co) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSAMRAI_1_1tbox_1_1AsyncCommPeer.html">SAMRAI::tbox::AsyncCommPeer</a>&lt; TYPE &gt;::logCurrentState           </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&nbsp;</td>
          <td class="paramname"> <em>co</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
For use in debugging. 
<p>

</div>
</div><p>
<hr>The documentation for this class was generated from the following files:<ul>
<li>source/SAMRAI/tbox/<a class="el" href="AsyncCommPeer_8h.html">AsyncCommPeer.h</a><li>source/SAMRAI/tbox/<a class="el" href="AsyncCommPeer_8C.html">AsyncCommPeer.C</a></ul>
<hr size="1"><address style="align: right;"><small>Generated on 16 Jan 2013 for SAMRAI by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.7 </small></address>
</body>
</html>
