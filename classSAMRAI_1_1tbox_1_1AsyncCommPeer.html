<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>SAMRAI: SAMRAI::tbox::AsyncCommPeer&lt; TYPE &gt; Class Template Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.7 -->
<div class="tabs">
  <ul>
    <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="namespaces.html"><span>Namespaces</span></a></li>
    <li id="current"><a href="annotated.html"><span>Classes</span></a></li>
    <li><a href="files.html"><span>Files</span></a></li>
    <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
  </ul></div>
<div class="tabs">
  <ul>
    <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
    <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
    <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
  </ul></div>
<div class="nav">
<a class="el" href="namespaceSAMRAI.html">SAMRAI</a>::<a class="el" href="namespaceSAMRAI_1_1tbox.html">tbox</a>::<a class="el" href="classSAMRAI_1_1tbox_1_1AsyncCommPeer.html">AsyncCommPeer</a></div>
<h1>SAMRAI::tbox::AsyncCommPeer&lt; TYPE &gt; Class Template Reference</h1><!-- doxytag: class="SAMRAI::tbox::AsyncCommPeer" --><!-- doxytag: inherits="SAMRAI::tbox::AsyncCommStage::Member" -->Supports point-to-point asynchronous communication operations that can overlap other communcations using a <a class="el" href="classSAMRAI_1_1tbox_1_1AsyncCommStage.html">AsyncCommStage</a>.  
<a href="#_details">More...</a>
<p>
<code>#include &lt;source/SAMRAI/tbox/AsyncCommPeer.h&gt;</code>
<p>
<p>Inheritance diagram for SAMRAI::tbox::AsyncCommPeer&lt; TYPE &gt;:
<p><center><img src="classSAMRAI_1_1tbox_1_1AsyncCommPeer.png" usemap="#SAMRAI::tbox::AsyncCommPeer< TYPE >_map" border="0" alt=""></center>
<map name="SAMRAI::tbox::AsyncCommPeer< TYPE >_map">
<area href="structSAMRAI_1_1tbox_1_1AsyncCommStage_1_1Member.html" alt="SAMRAI::tbox::AsyncCommStage::Member" shape="rect" coords="0,0,249,24">
</map>
<a href="classSAMRAI_1_1tbox_1_1AsyncCommPeer-members.html">List of all members.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1tbox_1_1AsyncCommPeer.html#93da7c17ff733e193cc9c696e5ba7a37">AsyncCommPeer</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Default constructor does not set up anything. You must initialize() the object before using it.  <a href="#93da7c17ff733e193cc9c696e5ba7a37"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1tbox_1_1AsyncCommPeer.html#271df18485a0a27910542d948a1bf326">AsyncCommPeer</a> (<a class="el" href="classSAMRAI_1_1tbox_1_1AsyncCommStage.html">AsyncCommStage</a> *stage, <a class="el" href="structSAMRAI_1_1tbox_1_1AsyncCommStage_1_1Handler.html">AsyncCommStage::Handler</a> *handler=NULL)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Construct staged communication object.  <a href="#271df18485a0a27910542d948a1bf326"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1tbox_1_1AsyncCommPeer.html#e2f5f2fb6993a2dae7f24ca64d21d712">~AsyncCommPeer</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Destructor.  <a href="#e2f5f2fb6993a2dae7f24ca64d21d712"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1tbox_1_1AsyncCommPeer.html#1aa02afffe89beaf152ba865dd197085">initialize</a> (<a class="el" href="classSAMRAI_1_1tbox_1_1AsyncCommStage.html">AsyncCommStage</a> *stage, <a class="el" href="structSAMRAI_1_1tbox_1_1AsyncCommStage_1_1Handler.html">AsyncCommStage::Handler</a> *handler=NULL)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Initialize the object.  <a href="#1aa02afffe89beaf152ba865dd197085"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1tbox_1_1AsyncCommPeer.html#6b0ab44b0dfc199bbaadc34f69203b5f">setMPITag</a> (const int primary_tag, const int secondary_tag)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the MPI tags used for communication.  <a href="#6b0ab44b0dfc199bbaadc34f69203b5f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1tbox_1_1AsyncCommPeer.html#9e52583d61b081b82e5cce6597f4b5ff">setMPI</a> (const <a class="el" href="classSAMRAI_1_1tbox_1_1SAMRAI__MPI.html">SAMRAI_MPI</a> &amp;mpi)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the MPI object used for communications.  <a href="#9e52583d61b081b82e5cce6597f4b5ff"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1tbox_1_1AsyncCommPeer.html#d0e5031b5995196e29852128ef04cff0">logCurrentState</a> (std::ostream &amp;co) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">For use in debugging.  <a href="#d0e5031b5995196e29852128ef04cff0"></a><br></td></tr>
<tr><td colspan="2"><div class="groupHeader">Define the peer relationship.</div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1tbox_1_1AsyncCommPeer.html#65889c93f5ad6b1075fec1e246ba3b1f">setPeerRank</a> (int peer_rank)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the peer rank.  <a href="#65889c93f5ad6b1075fec1e246ba3b1f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1tbox_1_1AsyncCommPeer.html#841a2601b5aa7164b3c0e697dc7ec2ff">getPeerRank</a> () const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1tbox_1_1AsyncCommPeer.html#0f669fcb5dbe3bac17dee7e2a12151e8">limitFirstDataLength</a> (size_t max_first_data_len)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Limit the data length in first message of a communication.  <a href="#0f669fcb5dbe3bac17dee7e2a12151e8"></a><br></td></tr>
<tr><td colspan="2"><div class="groupHeader">Communication methods</div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1tbox_1_1AsyncCommPeer.html#88f4b0c82a271e24ab32a8ef43222aad">beginSend</a> (const TYPE *buffer, int size)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Begin a send communication.  <a href="#88f4b0c82a271e24ab32a8ef43222aad"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1tbox_1_1AsyncCommPeer.html#337da0c7f4df7b0492e6b7374ff13e1b">checkSend</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Check the current broadcast communication and complete the broadcast if all MPI requests are fulfilled.  <a href="#337da0c7f4df7b0492e6b7374ff13e1b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1tbox_1_1AsyncCommPeer.html#abd8d8831deb941b104bd0a44e9029b5">beginRecv</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Begin a receive communication.  <a href="#abd8d8831deb941b104bd0a44e9029b5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1tbox_1_1AsyncCommPeer.html#ff724572a00324529e9169fd35d2c705">checkRecv</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Check the current receive communication and complete the receive if the MPI request has been fulfilled.  <a href="#ff724572a00324529e9169fd35d2c705"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1tbox_1_1AsyncCommPeer.html#816b916c7ef815fcb4c05a06f0547686">getRecvSize</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the size of received data.  <a href="#816b916c7ef815fcb4c05a06f0547686"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">const TYPE *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1tbox_1_1AsyncCommPeer.html#3d577f52648bf7c8a3cb2c8b5722bc1c">getRecvData</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get access to the received data.  <a href="#3d577f52648bf7c8a3cb2c8b5722bc1c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1tbox_1_1AsyncCommPeer.html#dffeacbbbac30e62582e081e741b51d6">clearRecvData</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Clear the receive buffer immediately.  <a href="#dffeacbbbac30e62582e081e741b51d6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1tbox_1_1AsyncCommPeer.html#5ba5df74dc2da6b8f30cf58789949371">proceedToNextWait</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Check the current communication and complete it if all MPI requests are fulfilled.  <a href="#5ba5df74dc2da6b8f30cf58789949371"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1tbox_1_1AsyncCommPeer.html#d27bc3d378d2253c9bc370158e0809db">isDone</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Whether the last communication operation has finished.  <a href="#d27bc3d378d2253c9bc370158e0809db"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1tbox_1_1AsyncCommPeer.html#29b4a58cec656d3b80463cf692412aa8">completeCurrentOperation</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Wait for the current operation to complete.  <a href="#29b4a58cec656d3b80463cf692412aa8"></a><br></td></tr>
</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
<h3>template&lt;class TYPE&gt;<br>
 class SAMRAI::tbox::AsyncCommPeer&lt; TYPE &gt;</h3>

Supports point-to-point asynchronous communication operations that can overlap other communcations using a <a class="el" href="classSAMRAI_1_1tbox_1_1AsyncCommStage.html">AsyncCommStage</a>. 
<p>
To use this class:<p>
<ol type=1>
<li>Construct an object with a stage or <code>initialize()</code> it with a stage.</li></ol>
<p>
<ol type=1>
<li>Set the MPI communicator and tag values for use in the MPI nonblocking message passing functions.</li></ol>
<p>
<ol type=1>
<li>Set the peer rank using <a class="el" href="classSAMRAI_1_1tbox_1_1AsyncCommPeer.html#65889c93f5ad6b1075fec1e246ba3b1f">setPeerRank()</a>.</li></ol>
<p>
<ol type=1>
<li>Call the <a class="el" href="classSAMRAI_1_1tbox_1_1AsyncCommPeer.html#88f4b0c82a271e24ab32a8ef43222aad">beginSend()</a> and <a class="el" href="classSAMRAI_1_1tbox_1_1AsyncCommPeer.html#abd8d8831deb941b104bd0a44e9029b5">beginRecv()</a> functions. Make sure there is a matching call on the peer processor.</li></ol>
<p>
<ol type=1>
<li>Use the stage to advance the message passing operations. The stage tells you which members have completed their operations.</li></ol>
<p>
<ol type=1>
<li>Received data can be accessed using <a class="el" href="classSAMRAI_1_1tbox_1_1AsyncCommPeer.html#816b916c7ef815fcb4c05a06f0547686">getRecvSize()</a> and <a class="el" href="classSAMRAI_1_1tbox_1_1AsyncCommPeer.html#3d577f52648bf7c8a3cb2c8b5722bc1c">getRecvData()</a>.</li></ol>
<p>
It is not neccesary to know how much data is being sent. This class will figure that out (using overhead data attached to the actual user data being communicated).<p>
To check on sends and receives without using the stage, use <a class="el" href="classSAMRAI_1_1tbox_1_1AsyncCommPeer.html#337da0c7f4df7b0492e6b7374ff13e1b">checkSend()</a> and <a class="el" href="classSAMRAI_1_1tbox_1_1AsyncCommPeer.html#ff724572a00324529e9169fd35d2c705">checkRecv()</a> or <a class="el" href="classSAMRAI_1_1tbox_1_1AsyncCommPeer.html#5ba5df74dc2da6b8f30cf58789949371">proceedToNextWait()</a>. To wait for the current operation to complete, use <a class="el" href="classSAMRAI_1_1tbox_1_1AsyncCommPeer.html#29b4a58cec656d3b80463cf692412aa8">completeCurrentOperation()</a>. 
<p>
<hr><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" name="93da7c17ff733e193cc9c696e5ba7a37"></a><!-- doxytag: member="SAMRAI::tbox::AsyncCommPeer::AsyncCommPeer" ref="93da7c17ff733e193cc9c696e5ba7a37" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSAMRAI_1_1tbox_1_1AsyncCommPeer.html">SAMRAI::tbox::AsyncCommPeer</a>&lt; TYPE &gt;::<a class="el" href="classSAMRAI_1_1tbox_1_1AsyncCommPeer.html">AsyncCommPeer</a>           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Default constructor does not set up anything. You must initialize() the object before using it. 
<p>

</div>
</div><p>
<a class="anchor" name="271df18485a0a27910542d948a1bf326"></a><!-- doxytag: member="SAMRAI::tbox::AsyncCommPeer::AsyncCommPeer" ref="271df18485a0a27910542d948a1bf326" args="(AsyncCommStage *stage, AsyncCommStage::Handler *handler=NULL)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSAMRAI_1_1tbox_1_1AsyncCommPeer.html">SAMRAI::tbox::AsyncCommPeer</a>&lt; TYPE &gt;::<a class="el" href="classSAMRAI_1_1tbox_1_1AsyncCommPeer.html">AsyncCommPeer</a>           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1tbox_1_1AsyncCommStage.html">AsyncCommStage</a> *&nbsp;</td>
          <td class="paramname"> <em>stage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSAMRAI_1_1tbox_1_1AsyncCommStage_1_1Handler.html">AsyncCommStage::Handler</a> *&nbsp;</td>
          <td class="paramname"> <em>handler</em> = <code>NULL</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Construct staged communication object. 
<p>
<dl compact><dt><b>See also:</b></dt><dd>initialize(). </dd></dl>

</div>
</div><p>
<a class="anchor" name="e2f5f2fb6993a2dae7f24ca64d21d712"></a><!-- doxytag: member="SAMRAI::tbox::AsyncCommPeer::~AsyncCommPeer" ref="e2f5f2fb6993a2dae7f24ca64d21d712" args="(void)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSAMRAI_1_1tbox_1_1AsyncCommPeer.html">SAMRAI::tbox::AsyncCommPeer</a>&lt; TYPE &gt;::~<a class="el" href="classSAMRAI_1_1tbox_1_1AsyncCommPeer.html">AsyncCommPeer</a>           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Destructor. 
<p>

</div>
</div><p>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="1aa02afffe89beaf152ba865dd197085"></a><!-- doxytag: member="SAMRAI::tbox::AsyncCommPeer::initialize" ref="1aa02afffe89beaf152ba865dd197085" args="(AsyncCommStage *stage, AsyncCommStage::Handler *handler=NULL)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSAMRAI_1_1tbox_1_1AsyncCommPeer.html">SAMRAI::tbox::AsyncCommPeer</a>&lt; TYPE &gt;::initialize           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1tbox_1_1AsyncCommStage.html">AsyncCommStage</a> *&nbsp;</td>
          <td class="paramname"> <em>stage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSAMRAI_1_1tbox_1_1AsyncCommStage_1_1Handler.html">AsyncCommStage::Handler</a> *&nbsp;</td>
          <td class="paramname"> <em>handler</em> = <code>NULL</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Initialize the object. 
<p>
Attach self to the given stage and set the Handler.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>state</em>&nbsp;</td><td>The stage handling communicaiton requests for the object. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>hander</em>&nbsp;</td><td>Optional pointer to user-defined data. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="65889c93f5ad6b1075fec1e246ba3b1f"></a><!-- doxytag: member="SAMRAI::tbox::AsyncCommPeer::setPeerRank" ref="65889c93f5ad6b1075fec1e246ba3b1f" args="(int peer_rank)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">SAMRAI_INLINE_KEYWORD void <a class="el" href="classSAMRAI_1_1tbox_1_1AsyncCommPeer.html">SAMRAI::tbox::AsyncCommPeer</a>&lt; TYPE &gt;::setPeerRank           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>peer_rank</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set the peer rank. 
<p>
We assume (without checking) that the peer processor does a complementary call using this processor as its peer. If this assumption is wrong, there will likely be communication errors. 
</div>
</div><p>
<a class="anchor" name="841a2601b5aa7164b3c0e697dc7ec2ff"></a><!-- doxytag: member="SAMRAI::tbox::AsyncCommPeer::getPeerRank" ref="841a2601b5aa7164b3c0e697dc7ec2ff" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">SAMRAI_INLINE_KEYWORD int <a class="el" href="classSAMRAI_1_1tbox_1_1AsyncCommPeer.html">SAMRAI::tbox::AsyncCommPeer</a>&lt; TYPE &gt;::getPeerRank           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="0f669fcb5dbe3bac17dee7e2a12151e8"></a><!-- doxytag: member="SAMRAI::tbox::AsyncCommPeer::limitFirstDataLength" ref="0f669fcb5dbe3bac17dee7e2a12151e8" args="(size_t max_first_data_len)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">SAMRAI_INLINE_KEYWORD void <a class="el" href="classSAMRAI_1_1tbox_1_1AsyncCommPeer.html">SAMRAI::tbox::AsyncCommPeer</a>&lt; TYPE &gt;::limitFirstDataLength           </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>max_first_data_len</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Limit the data length in first message of a communication. 
<p>
Sometimes, the receiver does not know how much data is being sent. In such cases, the receiver would assume the data is no more than a size that the sender and receiver have agreed upon before hand, <code>max_first_data_len</code>. If the message is longer, the sender sends it in two parts. The first message contains no more than <code>max_first_data_len</code> items and indicates the true length of the data. A second message is used if needed.<p>
The receiver must set a first data length no less than the sender's or risk a fatal MPI "truncated message" error.<p>
The limit is set to one by default, meaning that any message more than one item long would be sent in two parts. 
</div>
</div><p>
<a class="anchor" name="6b0ab44b0dfc199bbaadc34f69203b5f"></a><!-- doxytag: member="SAMRAI::tbox::AsyncCommPeer::setMPITag" ref="6b0ab44b0dfc199bbaadc34f69203b5f" args="(const int primary_tag, const int secondary_tag)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">SAMRAI_INLINE_KEYWORD void <a class="el" href="classSAMRAI_1_1tbox_1_1AsyncCommPeer.html">SAMRAI::tbox::AsyncCommPeer</a>&lt; TYPE &gt;::setMPITag           </td>
          <td>(</td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>primary_tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>secondary_tag</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set the MPI tags used for communication. 
<p>
The <code>primary_tag</code> is used for every message. If a message must be sent in two parts (see <a class="el" href="classSAMRAI_1_1tbox_1_1AsyncCommPeer.html#0f669fcb5dbe3bac17dee7e2a12151e8">limitFirstDataLength()</a>), the secondary tag is used for the follow-up message. It is advisable to use different values for the two tags to ensure that the second message is not mistaken for the first.<p>
<dl compact><dt><b>Attention:</b></dt><dd>This class is NOT (and cannot be) responsible for ensuring that the MPI communicator and tag are sufficient to select the correct messages. Please specify appropriate values for the MPI communicator and tag. Very elusive bugs can occur if incorrect messages are received. </dd></dl>

</div>
</div><p>
<a class="anchor" name="9e52583d61b081b82e5cce6597f4b5ff"></a><!-- doxytag: member="SAMRAI::tbox::AsyncCommPeer::setMPI" ref="9e52583d61b081b82e5cce6597f4b5ff" args="(const SAMRAI_MPI &amp;mpi)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">SAMRAI_INLINE_KEYWORD void <a class="el" href="classSAMRAI_1_1tbox_1_1AsyncCommPeer.html">SAMRAI::tbox::AsyncCommPeer</a>&lt; TYPE &gt;::setMPI           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1tbox_1_1SAMRAI__MPI.html">SAMRAI_MPI</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>mpi</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set the MPI object used for communications. 
<p>
<dl compact><dt><b>Attention:</b></dt><dd>This class is NOT (and cannot be) responsible for ensuring that the MPI object and tag are sufficient to select the correct messages. Please specify appropriate values for the MPI object and tag. Very elusive bugs can occur if incorrect messages are received. To be safe, it is best to create a new communicator to avoid interference with other communications within <a class="el" href="namespaceSAMRAI.html">SAMRAI</a>. </dd></dl>

</div>
</div><p>
<a class="anchor" name="88f4b0c82a271e24ab32a8ef43222aad"></a><!-- doxytag: member="SAMRAI::tbox::AsyncCommPeer::beginSend" ref="88f4b0c82a271e24ab32a8ef43222aad" args="(const TYPE *buffer, int size)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classSAMRAI_1_1tbox_1_1AsyncCommPeer.html">SAMRAI::tbox::AsyncCommPeer</a>&lt; TYPE &gt;::beginSend           </td>
          <td>(</td>
          <td class="paramtype">const TYPE *&nbsp;</td>
          <td class="paramname"> <em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>size</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Begin a send communication. 
<p>
This must be paired with a <a class="el" href="classSAMRAI_1_1tbox_1_1AsyncCommPeer.html#abd8d8831deb941b104bd0a44e9029b5">beginRecv()</a> by the peer processor.<p>
On return, the data in <b>buffer</b> would have been copied so it is safe to deallocate or modify <code>buffer</code>.<p>
<dl compact><dt><b>Returns:</b></dt><dd>Whether operation is completed. </dd></dl>

</div>
</div><p>
<a class="anchor" name="337da0c7f4df7b0492e6b7374ff13e1b"></a><!-- doxytag: member="SAMRAI::tbox::AsyncCommPeer::checkSend" ref="337da0c7f4df7b0492e6b7374ff13e1b" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classSAMRAI_1_1tbox_1_1AsyncCommPeer.html">SAMRAI::tbox::AsyncCommPeer</a>&lt; TYPE &gt;::checkSend           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Check the current broadcast communication and complete the broadcast if all MPI requests are fulfilled. 
<p>
If no communication is in progress, this call does nothing.<p>
<dl compact><dt><b>Returns:</b></dt><dd>Whether operation is completed. </dd></dl>

</div>
</div><p>
<a class="anchor" name="abd8d8831deb941b104bd0a44e9029b5"></a><!-- doxytag: member="SAMRAI::tbox::AsyncCommPeer::beginRecv" ref="abd8d8831deb941b104bd0a44e9029b5" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classSAMRAI_1_1tbox_1_1AsyncCommPeer.html">SAMRAI::tbox::AsyncCommPeer</a>&lt; TYPE &gt;::beginRecv           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Begin a receive communication. 
<p>
This must be paired with a <a class="el" href="classSAMRAI_1_1tbox_1_1AsyncCommPeer.html#88f4b0c82a271e24ab32a8ef43222aad">beginSend()</a> by the peer processor.<p>
The received data is stored in an internal buffer accessible through <a class="el" href="classSAMRAI_1_1tbox_1_1AsyncCommPeer.html#3d577f52648bf7c8a3cb2c8b5722bc1c">getRecvData()</a>. After receiving, the internal buffer is available until the object goes out of scope, another communication operation is initiated or deallocateInternalRecvBuffer() is called.<p>
The actual length of data received by the last receive operation is returned by <a class="el" href="classSAMRAI_1_1tbox_1_1AsyncCommPeer.html#816b916c7ef815fcb4c05a06f0547686">getRecvSize()</a>.<p>
<dl compact><dt><b>Returns:</b></dt><dd>Whether operation is completed. </dd></dl>

</div>
</div><p>
<a class="anchor" name="ff724572a00324529e9169fd35d2c705"></a><!-- doxytag: member="SAMRAI::tbox::AsyncCommPeer::checkRecv" ref="ff724572a00324529e9169fd35d2c705" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classSAMRAI_1_1tbox_1_1AsyncCommPeer.html">SAMRAI::tbox::AsyncCommPeer</a>&lt; TYPE &gt;::checkRecv           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Check the current receive communication and complete the receive if the MPI request has been fulfilled. 
<p>
<dl compact><dt><b>Returns:</b></dt><dd>Whether operation is completed. </dd></dl>

</div>
</div><p>
<a class="anchor" name="816b916c7ef815fcb4c05a06f0547686"></a><!-- doxytag: member="SAMRAI::tbox::AsyncCommPeer::getRecvSize" ref="816b916c7ef815fcb4c05a06f0547686" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classSAMRAI_1_1tbox_1_1AsyncCommPeer.html">SAMRAI::tbox::AsyncCommPeer</a>&lt; TYPE &gt;::getRecvSize           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return the size of received data. 
<p>

</div>
</div><p>
<a class="anchor" name="3d577f52648bf7c8a3cb2c8b5722bc1c"></a><!-- doxytag: member="SAMRAI::tbox::AsyncCommPeer::getRecvData" ref="3d577f52648bf7c8a3cb2c8b5722bc1c" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const TYPE * <a class="el" href="classSAMRAI_1_1tbox_1_1AsyncCommPeer.html">SAMRAI::tbox::AsyncCommPeer</a>&lt; TYPE &gt;::getRecvData           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get access to the received data. 
<p>

</div>
</div><p>
<a class="anchor" name="dffeacbbbac30e62582e081e741b51d6"></a><!-- doxytag: member="SAMRAI::tbox::AsyncCommPeer::clearRecvData" ref="dffeacbbbac30e62582e081e741b51d6" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSAMRAI_1_1tbox_1_1AsyncCommPeer.html">SAMRAI::tbox::AsyncCommPeer</a>&lt; TYPE &gt;::clearRecvData           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Clear the receive buffer immediately. 
<p>
This is optional. The received data remains inside the object the next communicaiton operation starts, or until it is explicitly freed.<p>
It is an error to clear the receive buffer in the middle of a communication operation. 
</div>
</div><p>
<a class="anchor" name="5ba5df74dc2da6b8f30cf58789949371"></a><!-- doxytag: member="SAMRAI::tbox::AsyncCommPeer::proceedToNextWait" ref="5ba5df74dc2da6b8f30cf58789949371" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classSAMRAI_1_1tbox_1_1AsyncCommPeer.html">SAMRAI::tbox::AsyncCommPeer</a>&lt; TYPE &gt;::proceedToNextWait           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Check the current communication and complete it if all MPI requests are fulfilled. 
<p>

<p>
Implements <a class="el" href="structSAMRAI_1_1tbox_1_1AsyncCommStage_1_1Member.html#cfd165b72b53fc4c7dd206bfd5490049">SAMRAI::tbox::AsyncCommStage::Member</a>.
</div>
</div><p>
<a class="anchor" name="d27bc3d378d2253c9bc370158e0809db"></a><!-- doxytag: member="SAMRAI::tbox::AsyncCommPeer::isDone" ref="d27bc3d378d2253c9bc370158e0809db" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">SAMRAI_INLINE_KEYWORD bool <a class="el" href="classSAMRAI_1_1tbox_1_1AsyncCommPeer.html">SAMRAI::tbox::AsyncCommPeer</a>&lt; TYPE &gt;::isDone           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Whether the last communication operation has finished. 
<p>
This means more than just whether there is outstanding MPI requests such as that returned by hasOutstandingRequests(). The communication is more complex, requiring up to two messages and copying of the received message into the correct buffer. When <a class="el" href="classSAMRAI_1_1tbox_1_1AsyncCommPeer.html#d27bc3d378d2253c9bc370158e0809db">isDone()</a> returns true, the operation is truly finished. 
<p>
Implements <a class="el" href="structSAMRAI_1_1tbox_1_1AsyncCommStage_1_1Member.html#89d4ecc764d1b91a1082caaf08f008da">SAMRAI::tbox::AsyncCommStage::Member</a>.
</div>
</div><p>
<a class="anchor" name="29b4a58cec656d3b80463cf692412aa8"></a><!-- doxytag: member="SAMRAI::tbox::AsyncCommPeer::completeCurrentOperation" ref="29b4a58cec656d3b80463cf692412aa8" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSAMRAI_1_1tbox_1_1AsyncCommPeer.html">SAMRAI::tbox::AsyncCommPeer</a>&lt; TYPE &gt;::completeCurrentOperation           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Wait for the current operation to complete. 
<p>

<p>
Implements <a class="el" href="structSAMRAI_1_1tbox_1_1AsyncCommStage_1_1Member.html#656fcd6b8b0ac508d5b0134acc92b7b7">SAMRAI::tbox::AsyncCommStage::Member</a>.
</div>
</div><p>
<a class="anchor" name="d0e5031b5995196e29852128ef04cff0"></a><!-- doxytag: member="SAMRAI::tbox::AsyncCommPeer::logCurrentState" ref="d0e5031b5995196e29852128ef04cff0" args="(std::ostream &amp;co) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSAMRAI_1_1tbox_1_1AsyncCommPeer.html">SAMRAI::tbox::AsyncCommPeer</a>&lt; TYPE &gt;::logCurrentState           </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&nbsp;</td>
          <td class="paramname"> <em>co</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
For use in debugging. 
<p>

</div>
</div><p>
<hr>The documentation for this class was generated from the following files:<ul>
<li>source/SAMRAI/tbox/<a class="el" href="AsyncCommPeer_8h.html">AsyncCommPeer.h</a><li>source/SAMRAI/tbox/<a class="el" href="AsyncCommPeer_8C.html">AsyncCommPeer.C</a><li>source/SAMRAI/tbox/<a class="el" href="AsyncCommPeer_8I.html">AsyncCommPeer.I</a></ul>
<hr size="1"><address style="align: right;"><small>Generated on Fri Mar 16 14:34:21 2012 for SAMRAI by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.7 </small></address>
</body>
</html>
