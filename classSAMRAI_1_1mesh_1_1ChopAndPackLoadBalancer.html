<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>SAMRAI: SAMRAI::mesh::ChopAndPackLoadBalancer Class Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.7 -->
<div class="tabs">
  <ul>
    <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="namespaces.html"><span>Namespaces</span></a></li>
    <li id="current"><a href="annotated.html"><span>Classes</span></a></li>
    <li><a href="files.html"><span>Files</span></a></li>
    <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
  </ul></div>
<div class="tabs">
  <ul>
    <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
    <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
    <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
  </ul></div>
<div class="nav">
<a class="el" href="namespaceSAMRAI.html">SAMRAI</a>::<a class="el" href="namespaceSAMRAI_1_1mesh.html">mesh</a>::<a class="el" href="classSAMRAI_1_1mesh_1_1ChopAndPackLoadBalancer.html">ChopAndPackLoadBalancer</a></div>
<h1>SAMRAI::mesh::ChopAndPackLoadBalancer Class Reference</h1><!-- doxytag: class="SAMRAI::mesh::ChopAndPackLoadBalancer" --><!-- doxytag: inherits="SAMRAI::mesh::LoadBalanceStrategy" -->Class <a class="el" href="classSAMRAI_1_1mesh_1_1ChopAndPackLoadBalancer.html">ChopAndPackLoadBalancer</a> provides load balancing routines for AMR hierarchy levels based on either uniform or non-uniform workload estimates.  
<a href="#_details">More...</a>
<p>
<code>#include &lt;source/SAMRAI/mesh/ChopAndPackLoadBalancer.h&gt;</code>
<p>
<p>Inheritance diagram for SAMRAI::mesh::ChopAndPackLoadBalancer:
<p><center><img src="classSAMRAI_1_1mesh_1_1ChopAndPackLoadBalancer.png" usemap="#SAMRAI::mesh::ChopAndPackLoadBalancer_map" border="0" alt=""></center>
<map name="SAMRAI::mesh::ChopAndPackLoadBalancer_map">
<area href="classSAMRAI_1_1mesh_1_1LoadBalanceStrategy.html" alt="SAMRAI::mesh::LoadBalanceStrategy" shape="rect" coords="0,0,261,24">
</map>
<a href="classSAMRAI_1_1mesh_1_1ChopAndPackLoadBalancer-members.html">List of all members.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1mesh_1_1ChopAndPackLoadBalancer.html#6db69c687ed9baa903d80f197e7f6fea">ChopAndPackLoadBalancer</a> (const <a class="el" href="classSAMRAI_1_1tbox_1_1Dimension.html">tbox::Dimension</a> &amp;dim, const std::string &amp;name, const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Database.html">tbox::Database</a> &gt; &amp;input_db=boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Database.html">tbox::Database</a> &gt;())</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1mesh_1_1ChopAndPackLoadBalancer.html#aa24ea7743cbc21e29f765155bcb07de">ChopAndPackLoadBalancer</a> (const <a class="el" href="classSAMRAI_1_1tbox_1_1Dimension.html">tbox::Dimension</a> &amp;dim, const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Database.html">tbox::Database</a> &gt; &amp;input_db=boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Database.html">tbox::Database</a> &gt;())</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1mesh_1_1ChopAndPackLoadBalancer.html#cd41326c1c4d12e357dc650d157fb5ff">~ChopAndPackLoadBalancer</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1mesh_1_1ChopAndPackLoadBalancer.html#ab2e2831967c3e4482ed2eaef2ef8999">setMaxWorkloadFactor</a> (double factor, int level_number=-1)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1mesh_1_1ChopAndPackLoadBalancer.html#deec05d7ac32c2468e3963192a87551e">setWorkloadTolerance</a> (double tolerance, int level_number=-1)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1mesh_1_1ChopAndPackLoadBalancer.html#9524bc66b85f61dbd26c479196c10158">setWorkloadPatchDataIndex</a> (int data_id, int level_number=-1)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1mesh_1_1ChopAndPackLoadBalancer.html#f503a774c77b183266a33e6652cc266d">setUniformWorkload</a> (int level_number=-1)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1mesh_1_1ChopAndPackLoadBalancer.html#50508f23058665b53d34f29415f23865">setBinPackMethod</a> (const std::string &amp;method, int level_number=-1)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1mesh_1_1ChopAndPackLoadBalancer.html#8452f55919adee2a7465e590e7b0a05b">setIgnoreLevelDomainIsSingleBox</a> (bool flag)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1mesh_1_1ChopAndPackLoadBalancer.html#2156edcd6cccc24337965fddf91d69b1">getLoadBalanceDependsOnPatchData</a> (int level_number) const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1mesh_1_1ChopAndPackLoadBalancer.html#bc7bae6426d7934de9794bdfce19d0b8">loadBalanceBoxLevel</a> (<a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">hier::BoxLevel</a> &amp;balance_box_level, <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">hier::Connector</a> *balance_to_anchor, const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchHierarchy.html">hier::PatchHierarchy</a> &gt; &amp;hierarchy, const int level_number, const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a> &amp;min_size, const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a> &amp;max_size, const <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">hier::BoxLevel</a> &amp;domain_box_level, const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a> &amp;bad_interval, const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a> &amp;cut_factor, const <a class="el" href="classSAMRAI_1_1tbox_1_1RankGroup.html">tbox::RankGroup</a> &amp;rank_group=<a class="el" href="classSAMRAI_1_1tbox_1_1RankGroup.html">tbox::RankGroup</a>()) const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1mesh_1_1ChopAndPackLoadBalancer.html#da9d5dcc91582715f5a3b9d5390240ee">printClassData</a> (std::ostream &amp;os) const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">const std::string &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1mesh_1_1ChopAndPackLoadBalancer.html#1f7831930b73ba20d8345e7e1289d4a8">getObjectName</a> () const </td></tr>

</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
Class <a class="el" href="classSAMRAI_1_1mesh_1_1ChopAndPackLoadBalancer.html">ChopAndPackLoadBalancer</a> provides load balancing routines for AMR hierarchy levels based on either uniform or non-uniform workload estimates. 
<p>
This class is derived from the abstract base class <a class="el" href="classSAMRAI_1_1mesh_1_1LoadBalanceStrategy.html">LoadBalanceStrategy</a>; thus, it is a concrete implementation of the load balance Strategy pattern interface.<p>
Load balancing operations, whether based on uniform or non-uniform workloads, can be specified for each level in the hierarchy individually or for the entire hierarchy. Basic load balance parameters can be set from an input file, while more complex behavior can be set at run-time via member functions, including dynamic reconfiguration of balance operations.<p>
<b> Input Parameters </b><p>
<b> Definitions: </b><ul>
<li><b>bin_pack_method</b> String value indicating the type of bin packing to use to map patches to processors. Currently, two options are supported: "GREEDY" and "SPATIAL". The "GREEDY" method simply maps each patch (box) to the first processor (bin), in ascending tbox::MPI process number, whose difference between the average workload and its current workload is less than the workload of the patch in question. The "SPATIAL" method first constructs an ordering of the patches (boxes) by passing a Morton-type curve through the center of each box. Then, it attempts to map the patches to processors by assigning patches that are near each other on the curve to the same processor. If no input value is specified, a default value of "SPATIAL" is used. The input value will be used for all levels and will below.</li></ul>
<p>
<ul>
<li><b>max_workload_factor</b> Double array (length = number of levels) used during the box-splitting phase to determine which boxes to split. Specifically, boxes will be chopped if their estimated workload is greater than max_workload_factor * A, where A is the average workload (i.e., A = (total work)/(num processors)). The default value for this parameter is 1.0. It can be set to any value greater than zero, either in the input file or via the <a class="el" href="classSAMRAI_1_1mesh_1_1ChopAndPackLoadBalancer.html#ab2e2831967c3e4482ed2eaef2ef8999">setMaxWorkloadFactor()</a> member function below.</li></ul>
<p>
<ul>
<li><b>workload_tolerance</b> Double array (length = number of levels) used during the box-splitting phase to determine which boxes to split. The tolerance value can be use to prevent splitting of boxes when the computed box workload is close to the computed ideal workload. A box is split if:<br>
 ( box_workload &lt;= ( (1. + workload_tolerance) * ideal_workload ) )<br>
 Tolerance values should be greater than or equal to 0.0 and less then 1.0. Large values will probably have undesirable results. It can be set either in the input file or via the <a class="el" href="classSAMRAI_1_1mesh_1_1ChopAndPackLoadBalancer.html#deec05d7ac32c2468e3963192a87551e">setWorkloadTolerance()</a> member function below.<br>
 NOTE: If a length is less than max levels then finest value specified is use for finer levels. If length is greater than max levels, the values are ignored.</li></ul>
<p>
<ul>
<li><b>ignore_level_box_union_is_single_box</b> Boolean flag to control chopping of level boxes when the union of the input boxes passed to the loadBalanceBoxes() routine is a single box. The default value is false, which means that the domain will be chopped to make patch boxes based on the (single box) union of the boxes describing the level regardless of the input boxes. When the value is set to true, either via the <a class="el" href="classSAMRAI_1_1mesh_1_1ChopAndPackLoadBalancer.html#8452f55919adee2a7465e590e7b0a05b">setIgnoreLevelDomainIsSingleBox()</a> function or an input file, the domain will be chopped by chopping each of the input boxes.</li></ul>
<p>
<ul>
<li><b>processor_layout</b> Integer array (length = DIM) indicating the way in which the domain should be chopped when a level can be described as a single parallelepiped region (i.e., a box). If no input value is provided, or if the product of these entries does not equal the number of processors, then the processor layout computed will be computed from the size of the domain box and the number of processors in use if necessary.<br>
 NOTE: The largest patch size constraint specified in the input for the <a class="el" href="classSAMRAI_1_1mesh_1_1GriddingAlgorithm.html">GriddingAlgorithm</a> object takes precedence over the processor layout specification. That is, if the processor layout indicates that the resulting level patches would be larger than the largest patch size, the layout will be ignored and boxes obeying the patch size constrint will result.</li></ul>
<p>
<ul>
<li><b>tile_size</b> Tile size when using tile mode. Tile mode restricts box cuts to tile boundaries.</li></ul>
<p>
<b> Details: </b> <br>
 <table border="1" cellspacing="3" cellpadding="3">
<tr>
<th>parameter </th><th>type </th><th>default </th><th>range </th><th>opt/req </th><th>behavior on restart  </th></tr>
<tr>
<td>bin_pack_method </td><td>string </td><td>"SPATIAL" </td><td>"SPATIAL", "GREEDY" </td><td>opt </td><td>Not written to restart. Value in input db used.  </td></tr>
<tr>
<td>max_workload_factor </td><td>array of doubles </td><td>none </td><td>0.0 &lt;= all values </td><td>opt </td><td>Not written to restart. Value in input db used.  </td></tr>
<tr>
<td>workload_tolerance </td><td>array of doubles </td><td>none </td><td>0.0 &lt;= all values &lt; 1.0 </td><td>opt </td><td>Not written to restart. Value in input db used.  </td></tr>
<tr>
<td>ignore_level_box_union_is_single_box </td><td>bool </td><td>FALSE </td><td>TRUE, FALSE </td><td>opt </td><td>Not written to restart. Value in input db used.  </td></tr>
<tr>
<td>processor_layout </td><td>int[] </td><td>N/A </td><td>N/A </td><td>opt </td><td>Not written to restart. Value in input db used.  </td></tr>
<tr>
<td>tile_size </td><td>IntVector </td><td>1 </td><td>1- </td><td>opt </td><td>Not written to restart. Value in input db used.  </td></tr>
</table>
<p>
A sample input file entry might look like:<p>
<div class="fragment"><pre class="fragment">    processor_layout = 4 , 4 , 4    <span class="comment">// number of processors is 64</span>
    bin_pack = <span class="stringliteral">"GREEDY"</span>
    max_workload_factor = 0.9
    ignore_level_box_union_is_single_box = TRUE
</pre></div><p>
Performance warning: This class implements a sequential algorithm. The time it takes to this balancer increases with processor count. However, you can probably use this load balancer on up to 1K processors before its performance degrades noticably.<p>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classSAMRAI_1_1mesh_1_1LoadBalanceStrategy.html">mesh::LoadBalanceStrategy</a> </dd></dl>

<p>
<hr><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" name="6db69c687ed9baa903d80f197e7f6fea"></a><!-- doxytag: member="SAMRAI::mesh::ChopAndPackLoadBalancer::ChopAndPackLoadBalancer" ref="6db69c687ed9baa903d80f197e7f6fea" args="(const tbox::Dimension &amp;dim, const std::string &amp;name, const boost::shared_ptr&lt; tbox::Database &gt; &amp;input_db=boost::shared_ptr&lt; tbox::Database &gt;())" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SAMRAI::mesh::ChopAndPackLoadBalancer::ChopAndPackLoadBalancer           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1tbox_1_1Dimension.html">tbox::Dimension</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>dim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Database.html">tbox::Database</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>input_db</em> = <code>boost::shared_ptr&lt;&nbsp;<a class="el" href="classSAMRAI_1_1tbox_1_1Database.html">tbox::Database</a>&nbsp;&gt;()</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Construct load balancer object, including setting default object state and reading input data from the input data base, if required.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>dim</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>name</em>&nbsp;</td><td>User-defined string identifier used for error reporting. This string must be non-empty. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>input_db</em>&nbsp;</td><td>(optional) database pointer providing parameters from input file. This pointer may be null indicating no input will be read.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Precondition:</b></dt><dd>!name.empty() </dd></dl>

</div>
</div><p>
<a class="anchor" name="aa24ea7743cbc21e29f765155bcb07de"></a><!-- doxytag: member="SAMRAI::mesh::ChopAndPackLoadBalancer::ChopAndPackLoadBalancer" ref="aa24ea7743cbc21e29f765155bcb07de" args="(const tbox::Dimension &amp;dim, const boost::shared_ptr&lt; tbox::Database &gt; &amp;input_db=boost::shared_ptr&lt; tbox::Database &gt;())" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SAMRAI::mesh::ChopAndPackLoadBalancer::ChopAndPackLoadBalancer           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1tbox_1_1Dimension.html">tbox::Dimension</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>dim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Database.html">tbox::Database</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>input_db</em> = <code>boost::shared_ptr&lt;&nbsp;<a class="el" href="classSAMRAI_1_1tbox_1_1Database.html">tbox::Database</a>&nbsp;&gt;()</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Construct load balancer object, including setting default object state and reading input data from the input data base, if required. The only difference between this constructor and the previous one is the string identifier input. If this constructor is used, the default object name "ChopAndPackLoadBalancer" applies.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>dim</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>input_db</em>&nbsp;</td><td>(optional) database pointer providing parameters from input file. This pointer may be null indicating no input will be read. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="cd41326c1c4d12e357dc650d157fb5ff"></a><!-- doxytag: member="SAMRAI::mesh::ChopAndPackLoadBalancer::~ChopAndPackLoadBalancer" ref="cd41326c1c4d12e357dc650d157fb5ff" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SAMRAI::mesh::ChopAndPackLoadBalancer::~ChopAndPackLoadBalancer           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The virtual destructor releases all internal storage. 
</div>
</div><p>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="ab2e2831967c3e4482ed2eaef2ef8999"></a><!-- doxytag: member="SAMRAI::mesh::ChopAndPackLoadBalancer::setMaxWorkloadFactor" ref="ab2e2831967c3e4482ed2eaef2ef8999" args="(double factor, int level_number=-1)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::mesh::ChopAndPackLoadBalancer::setMaxWorkloadFactor           </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>factor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>level_number</em> = <code>-1</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set the max workload factor for either the specified level or all hierarchy levels. See discussion about inputs above for information on how this value is used during load balancing operations.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>factor</em>&nbsp;</td><td>Double value of multiplier for average workload used in box chopping. The default value is 1.0. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>level_number</em>&nbsp;</td><td>Optional integer number for level to which factor is applied. If no value is given, the factor will be used for all levels.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Precondition:</b></dt><dd>factor &gt; 0.0 </dd></dl>

</div>
</div><p>
<a class="anchor" name="deec05d7ac32c2468e3963192a87551e"></a><!-- doxytag: member="SAMRAI::mesh::ChopAndPackLoadBalancer::setWorkloadTolerance" ref="deec05d7ac32c2468e3963192a87551e" args="(double tolerance, int level_number=-1)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::mesh::ChopAndPackLoadBalancer::setWorkloadTolerance           </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>tolerance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>level_number</em> = <code>-1</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set the workload tolerance for either the specified level or all hierarchy levels. See discussion about inputs above for information on how this value is used during load balancing operations.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>tolerance</em>&nbsp;</td><td>Double value of tolerance. The default value is 0.0;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>level_number</em>&nbsp;</td><td>Optional integer number for level to which factor is applied. If no value is given, the value will be used for all levels.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Precondition:</b></dt><dd>tolerance &gt; 0.0 </dd></dl>

</div>
</div><p>
<a class="anchor" name="9524bc66b85f61dbd26c479196c10158"></a><!-- doxytag: member="SAMRAI::mesh::ChopAndPackLoadBalancer::setWorkloadPatchDataIndex" ref="9524bc66b85f61dbd26c479196c10158" args="(int data_id, int level_number=-1)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::mesh::ChopAndPackLoadBalancer::setWorkloadPatchDataIndex           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>data_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>level_number</em> = <code>-1</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Configure the load balancer to use the data stored in the hierarchy at the specified descriptor index for estimating the workload on each cell.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>data_id</em>&nbsp;</td><td>Integer value of patch data identifier for workload estimate on each cell. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>level_number</em>&nbsp;</td><td>Optional integer number for level on which data id is used. If no value is given, the data will be used for all levels.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Precondition:</b></dt><dd><a class="el" href="classSAMRAI_1_1hier_1_1VariableDatabase.html#9a9b3b6122833db2716a3a600dfa12e3">hier::VariableDatabase::getDatabase()</a>-&gt;getPatchDescriptor()-&gt;getPatchDataFactory(data_id) is actually a boost::shared_ptr&lt;pdat::CellDataFactory&lt;double&gt; &gt; </dd></dl>

</div>
</div><p>
<a class="anchor" name="f503a774c77b183266a33e6652cc266d"></a><!-- doxytag: member="SAMRAI::mesh::ChopAndPackLoadBalancer::setUniformWorkload" ref="f503a774c77b183266a33e6652cc266d" args="(int level_number=-1)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::mesh::ChopAndPackLoadBalancer::setUniformWorkload           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>level_number</em> = <code>-1</code>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Configure the load balancer to load balance boxes by assuming all cells on the specified level or all hierarchy levels are weighted equally.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>level_number</em>&nbsp;</td><td>Optional integer number for level on which uniform workload estimate will be used. If the level number is not specified, a uniform workload estimate will be used on all levels. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="50508f23058665b53d34f29415f23865"></a><!-- doxytag: member="SAMRAI::mesh::ChopAndPackLoadBalancer::setBinPackMethod" ref="50508f23058665b53d34f29415f23865" args="(const std::string &amp;method, int level_number=-1)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::mesh::ChopAndPackLoadBalancer::setBinPackMethod           </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>method</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>level_number</em> = <code>-1</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Configure the load balancer to use the bin-packing procedure for mapping patches to processors indicated by the string.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>method</em>&nbsp;</td><td>String value indicating bin-packing method to use. See input file description above for valid options. The default value is "GREEDY". </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>level_number</em>&nbsp;</td><td>Optional integer number for level on which bin-packing method will be used. If no value is given, the prescribed methods will be used on all levels.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Precondition:</b></dt><dd>(method == "GREEDY") || (method == "SPATIAL") </dd></dl>

</div>
</div><p>
<a class="anchor" name="8452f55919adee2a7465e590e7b0a05b"></a><!-- doxytag: member="SAMRAI::mesh::ChopAndPackLoadBalancer::setIgnoreLevelDomainIsSingleBox" ref="8452f55919adee2a7465e590e7b0a05b" args="(bool flag)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::mesh::ChopAndPackLoadBalancer::setIgnoreLevelDomainIsSingleBox           </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>flag</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set the boolean flag to control chopping of level boxes when the union of the input boxes passed to the loadBalanceBoxes() routine is a single box. The default value is false, which means that the domain will be chopped to make patch boxes based on the (single box) union of the boxes describing the level regardless of the input boxes. When the value is set to true, the domain will be chopped by chopping each of the input boxes.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>flag</em>&nbsp;</td><td>Boolean value indicating whether to ignore the set of input boxes to the loadBalanceBoxes() routine when the union of those boxes is a single box. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="2156edcd6cccc24337965fddf91d69b1"></a><!-- doxytag: member="SAMRAI::mesh::ChopAndPackLoadBalancer::getLoadBalanceDependsOnPatchData" ref="2156edcd6cccc24337965fddf91d69b1" args="(int level_number) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SAMRAI::mesh::ChopAndPackLoadBalancer::getLoadBalanceDependsOnPatchData           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>level_number</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return true if load balancing procedure for given level depends on patch data on mesh; otherwise return false. This can be used to determine whether a level needs to be rebalanced although its box configuration is unchanged. This function is pure virtual in the <a class="el" href="classSAMRAI_1_1mesh_1_1LoadBalanceStrategy.html">LoadBalanceStrategy</a> base class.<p>
<dl compact><dt><b>Returns:</b></dt><dd>Boolean value indicating whether load balance depends on patch data.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>level_number</em>&nbsp;</td><td>Integer patch level number. </td></tr>
  </table>
</dl>

<p>
Implements <a class="el" href="classSAMRAI_1_1mesh_1_1LoadBalanceStrategy.html#26cddcc6d628372374dd30549800bfc5">SAMRAI::mesh::LoadBalanceStrategy</a>.
</div>
</div><p>
<a class="anchor" name="bc7bae6426d7934de9794bdfce19d0b8"></a><!-- doxytag: member="SAMRAI::mesh::ChopAndPackLoadBalancer::loadBalanceBoxLevel" ref="bc7bae6426d7934de9794bdfce19d0b8" args="(hier::BoxLevel &amp;balance_box_level, hier::Connector *balance_to_anchor, const boost::shared_ptr&lt; hier::PatchHierarchy &gt; &amp;hierarchy, const int level_number, const hier::IntVector &amp;min_size, const hier::IntVector &amp;max_size, const hier::BoxLevel &amp;domain_box_level, const hier::IntVector &amp;bad_interval, const hier::IntVector &amp;cut_factor, const tbox::RankGroup &amp;rank_group=tbox::RankGroup()) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::mesh::ChopAndPackLoadBalancer::loadBalanceBoxLevel           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">hier::BoxLevel</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>balance_box_level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">hier::Connector</a> *&nbsp;</td>
          <td class="paramname"> <em>balance_to_anchor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchHierarchy.html">hier::PatchHierarchy</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>hierarchy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>level_number</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>min_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>max_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">hier::BoxLevel</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>domain_box_level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>bad_interval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>cut_factor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1tbox_1_1RankGroup.html">tbox::RankGroup</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>rank_group</em> = <code><a class="el" href="classSAMRAI_1_1tbox_1_1RankGroup.html">tbox::RankGroup</a>()</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Given a list of boxes, representing the domain of a level in the AMR hierarchy, generate an array of boxes and an associated processor mapping from which the patches for the level will be generated and assigned. The resulting boxes and processor mapping will be determined based on parameters set via input or member functions above. This function is pure virtual in the <a class="el" href="classSAMRAI_1_1mesh_1_1LoadBalanceStrategy.html">LoadBalanceStrategy</a> base class.<p>
The load balancing algorithm should ignore any periodic image Boxes in the input balance_box_level.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>balance_box_level</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>balance_to_anchor</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>hierarchy</em>&nbsp;</td><td>Input patch hierarchy in which level will reside. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>level_number</em>&nbsp;</td><td>Input integer number of level in patch hierarchy. This value must be &gt;= 0. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>min_size</em>&nbsp;</td><td>Input integer vector of minimum sizes for output boxes. All entries must be &gt; 0. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>max_size</em>&nbsp;</td><td>Input integer vector of maximum sizes for output boxes. All entries must be &gt;= min_size. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>domain_box_level</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>bad_interval</em>&nbsp;</td><td>Input integer vector used to create boxes near physical domain boundary with sufficient number of cells. No box face will be closer to the boundary than the corresponding interval of cells to the boundary (the corresponding value is given by the normal direction of the box face) unless the face coincides with the boundary itself. The point of this argument is to have no patch live within a certain ghost cell width of the boundary if its boundary does not coincide with that boundary . That is, all ghost cells along a face will be either in the domain interior or outside the domain. All entries must be &gt;= 0. See <a class="el" href="structSAMRAI_1_1hier_1_1BoxUtilities.html">hier::BoxUtilities</a> documentation for more details. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>cut_factor</em>&nbsp;</td><td>Input integer vector used to create boxes with correct sizes. The length of each box direction will be an integer multiple of the corresponding cut factor vector entry. All vector entries must be &gt; 0. See <a class="el" href="structSAMRAI_1_1hier_1_1BoxUtilities.html">hier::BoxUtilities</a> documentation for more details. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>rank_group</em>&nbsp;</td><td>Needed for compatibility with parent class. This argument is ignored.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Precondition:</b></dt><dd>!balance_to_anchor || balance_to_anchor-&gt;hasTranspose() <p>
(d_dim == balance_box_level.getDim()) &amp;&amp; (d_dim == min_size.getDim()) &amp;&amp; (d_dim == max_size.getDim()) &amp;&amp; (d_dim == domain_box_level.getDim()) &amp;&amp; (d_dim == bad_interval.getDim()) &amp;&amp; (d_dim == cut_factor.getDim()) </dd></dl>

<p>
Implements <a class="el" href="classSAMRAI_1_1mesh_1_1LoadBalanceStrategy.html#2a6934691d740a0930f1644d5271d6b2">SAMRAI::mesh::LoadBalanceStrategy</a>.
</div>
</div><p>
<a class="anchor" name="da9d5dcc91582715f5a3b9d5390240ee"></a><!-- doxytag: member="SAMRAI::mesh::ChopAndPackLoadBalancer::printClassData" ref="da9d5dcc91582715f5a3b9d5390240ee" args="(std::ostream &amp;os) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::mesh::ChopAndPackLoadBalancer::printClassData           </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&nbsp;</td>
          <td class="paramname"> <em>os</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Print out all members of the class instance to given output stream. 
</div>
</div><p>
<a class="anchor" name="1f7831930b73ba20d8345e7e1289d4a8"></a><!-- doxytag: member="SAMRAI::mesh::ChopAndPackLoadBalancer::getObjectName" ref="1f7831930b73ba20d8345e7e1289d4a8" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::string&amp; SAMRAI::mesh::ChopAndPackLoadBalancer::getObjectName           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the name of this object.<p>
<dl compact><dt><b>Returns:</b></dt><dd>The name of this object. </dd></dl>

</div>
</div><p>
<hr>The documentation for this class was generated from the following files:<ul>
<li>source/SAMRAI/mesh/<a class="el" href="ChopAndPackLoadBalancer_8h.html">ChopAndPackLoadBalancer.h</a><li>source/SAMRAI/mesh/<a class="el" href="ChopAndPackLoadBalancer_8C.html">ChopAndPackLoadBalancer.C</a></ul>
<hr size="1"><address style="align: right;"><small>Generated on 3 Mar 2015 for SAMRAI by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.7 </small></address>
</body>
</html>
