<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>SAMRAI: SAMRAI::hier::MultiblockBoxTree Class Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.7 -->
<div class="tabs">
  <ul>
    <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="namespaces.html"><span>Namespaces</span></a></li>
    <li id="current"><a href="annotated.html"><span>Classes</span></a></li>
    <li><a href="files.html"><span>Files</span></a></li>
    <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
  </ul></div>
<div class="tabs">
  <ul>
    <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
    <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
    <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
  </ul></div>
<div class="nav">
<a class="el" href="namespaceSAMRAI.html">SAMRAI</a>::<a class="el" href="namespaceSAMRAI_1_1hier.html">hier</a>::<a class="el" href="classSAMRAI_1_1hier_1_1MultiblockBoxTree.html">MultiblockBoxTree</a></div>
<h1>SAMRAI::hier::MultiblockBoxTree Class Reference</h1><!-- doxytag: class="SAMRAI::hier::MultiblockBoxTree" -->Utility sorting Boxes into tree-like form for finding box overlaps. All boxes must be specified in the transformation specified by their <a class="el" href="classSAMRAI_1_1hier_1_1BlockId.html">BlockId</a>.  
<a href="#_details">More...</a>
<p>
<code>#include &lt;source/SAMRAI/hier/MultiblockBoxTree.h&gt;</code>
<p>
<a href="classSAMRAI_1_1hier_1_1MultiblockBoxTree-members.html">List of all members.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1MultiblockBoxTree.html#e7f8584568a14cf4d8394b26b0c16a60">MultiblockBoxTree</a> (const <a class="el" href="classSAMRAI_1_1hier_1_1GridGeometry.html">GridGeometry</a> &amp;grid_geometry, const <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a> &amp;boxes, size_t min_number=10)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Constructs a <a class="el" href="classSAMRAI_1_1hier_1_1MultiblockBoxTree.html">MultiblockBoxTree</a> from set of Boxes.  <a href="#e7f8584568a14cf4d8394b26b0c16a60"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1MultiblockBoxTree.html#11b540babc8ad0bc9688f14e2d398017">MultiblockBoxTree</a> (const <a class="el" href="classSAMRAI_1_1hier_1_1GridGeometry.html">GridGeometry</a> &amp;grid_geometry, const std::vector&lt; <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> &gt; &amp;boxes, size_t min_number=10)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Constructs a <a class="el" href="classSAMRAI_1_1hier_1_1MultiblockBoxTree.html">MultiblockBoxTree</a> from vector of Boxes.  <a href="#11b540babc8ad0bc9688f14e2d398017"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1MultiblockBoxTree.html#cb3f9c78df338759dab3ae64e60e9413">MultiblockBoxTree</a> (const <a class="el" href="classSAMRAI_1_1hier_1_1GridGeometry.html">GridGeometry</a> &amp;grid_geometry, const std::map&lt; <a class="el" href="classSAMRAI_1_1hier_1_1BlockId.html">BlockId</a>, <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a> &gt; &amp;boxes, size_t min_number=10)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Constructs a <a class="el" href="classSAMRAI_1_1hier_1_1MultiblockBoxTree.html">MultiblockBoxTree</a> from a collection of BoxContainers each of which is associated with a specific <a class="el" href="classSAMRAI_1_1hier_1_1BlockId.html">BlockId</a>.  <a href="#cb3f9c78df338759dab3ae64e60e9413"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1MultiblockBoxTree.html#341f8d1cadcc6ab62da394283f671121">MultiblockBoxTree</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Default constructor constructs an uninitialized <a class="el" href="classSAMRAI_1_1hier_1_1MultiblockBoxTree.html">MultiblockBoxTree</a>.  <a href="#341f8d1cadcc6ab62da394283f671121"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1MultiblockBoxTree.html#10448246be1d50eed7260b3cfbe0c343">~MultiblockBoxTree</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Destructor.  <a href="#10448246be1d50eed7260b3cfbe0c343"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1MultiblockBoxTree.html#477bd3dafacab150bcce5369a2a6a235">generateTree</a> (const <a class="el" href="classSAMRAI_1_1hier_1_1GridGeometry.html">GridGeometry</a> &amp;grid_geometry, const <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a> &amp;boxes, size_t min_number=10)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Generates the tree from a <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a>.  <a href="#477bd3dafacab150bcce5369a2a6a235"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1MultiblockBoxTree.html#3e6a59b88567d97f85d0aaa4d3271a36">generateTree</a> (const <a class="el" href="classSAMRAI_1_1hier_1_1GridGeometry.html">GridGeometry</a> &amp;grid_geometry, const std::map&lt; <a class="el" href="classSAMRAI_1_1hier_1_1BlockId.html">BlockId</a>, <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a> &gt; &amp;boxes, size_t min_number=10)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Generates the tree from lists of Boxes.  <a href="#3e6a59b88567d97f85d0aaa4d3271a36"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1MultiblockBoxTree.html#06a55cc29f672d074c1660c5d94e3d0a">generateNonPeriodicTree</a> (const <a class="el" href="classSAMRAI_1_1hier_1_1GridGeometry.html">GridGeometry</a> &amp;grid_geometry, const <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a> &amp;boxes, size_t min_number=10)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Generates the tree of non-periodic Boxes from a <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a>.  <a href="#06a55cc29f672d074c1660c5d94e3d0a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1MultiblockBoxTree.html#25fd9390864ddf5f1b9f4d1aa7d530b9">hasBoxInBlock</a> (const <a class="el" href="classSAMRAI_1_1hier_1_1BlockId.html">BlockId</a> &amp;block_id) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return whether the tree contains any Boxes with the given <a class="el" href="classSAMRAI_1_1hier_1_1BlockId.html">BlockId</a>.  <a href="#25fd9390864ddf5f1b9f4d1aa7d530b9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">const <a class="el" href="classSAMRAI_1_1hier_1_1BoxTree.html">BoxTree</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1MultiblockBoxTree.html#b5fd0eaba7a07c0adb62dae9a4fdb5e2">getSingleBlockBoxTree</a> (const <a class="el" href="classSAMRAI_1_1hier_1_1BlockId.html">BlockId</a> &amp;block_id) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the tree for a single block.  <a href="#b5fd0eaba7a07c0adb62dae9a4fdb5e2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1MultiblockBoxTree.html#3302e4ee7186eba88169dd1e98e9bc17">clear</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Reset to uninitialized state.  <a href="#3302e4ee7186eba88169dd1e98e9bc17"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1MultiblockBoxTree.html#5a1218a3bd6a1a4fbd3209ca151e414a">isInitialized</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Check whether the tree has been initialized.  <a href="#5a1218a3bd6a1a4fbd3209ca151e414a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">const <a class="el" href="classSAMRAI_1_1hier_1_1GridGeometry.html">GridGeometry</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1MultiblockBoxTree.html#643857469cc397e3e3a0c30eb2cf2cb0">getGridGeometry</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the <a class="el" href="classSAMRAI_1_1hier_1_1GridGeometry.html">GridGeometry</a> object for the multiblock environment.  <a href="#643857469cc397e3e3a0c30eb2cf2cb0"></a><br></td></tr>
<tr><td colspan="2"><div class="groupHeader">Overlap checks</div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1MultiblockBoxTree.html#97b0b05c1e5f60927f4575db20a38dc5">hasOverlap</a> (const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> &amp;box, bool include_singularity_block_neighbors=false) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Whether the given <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> has an overlap with Boxes in the tree.  <a href="#97b0b05c1e5f60927f4575db20a38dc5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1MultiblockBoxTree.html#c3c69cafd801dfc3669de8d3f1bac919">findOverlapBoxes</a> (<a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">Connector</a> &amp;overlap_connector, const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> &amp;box, const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;refinement_ratio, bool include_singularity_block_neighbors=false) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Find all boxes that overlap the given <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> and insert as neighbors of that box in overlap_connector.  <a href="#c3c69cafd801dfc3669de8d3f1bac919"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1MultiblockBoxTree.html#1d17457839ef8b25d17fe744c2030141">findOverlapBoxes</a> (std::vector&lt; <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> &gt; &amp;overlap_boxes, const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> &amp;box, const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;refinement_ratio, bool include_singularity_block_neighbors=false) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Find all boxes that overlap the given <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a>.  <a href="#1d17457839ef8b25d17fe744c2030141"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1MultiblockBoxTree.html#a599bfb5e60afe00be62b0a4951510b5">findOverlapBoxes</a> (std::vector&lt; const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> * &gt; &amp;overlap_boxes, const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> &amp;box, const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;refinement_ratio, bool include_singularity_block_neighbors=false) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Find all boxes that overlap the given <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a>.  <a href="#a599bfb5e60afe00be62b0a4951510b5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1MultiblockBoxTree.html#b66ce08f60094c82cab0bdbf385986d2">findOverlapBoxes</a> (<a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a> &amp;overlap_boxes, const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> &amp;box, const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;refinement_ratio, bool include_singularity_block_neighbors=false) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Find all boxes that overlap the given <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a>.  <a href="#b66ce08f60094c82cab0bdbf385986d2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1MultiblockBoxTree.html#bb222597c3504d8d5eff7bba9f27063e">getBoxes</a> (std::vector&lt; <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> &gt; &amp;boxes) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the Boxes in the tree.  <a href="#bb222597c3504d8d5eff7bba9f27063e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1MultiblockBoxTree.html">MultiblockBoxTree</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1MultiblockBoxTree.html#71d06d4d3d22c41799eacb321fcc9c94">createRefinedTree</a> (const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;ratio) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a similar tree with the boxes refined by a given ratio.  <a href="#71d06d4d3d22c41799eacb321fcc9c94"></a><br></td></tr>
</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
Utility sorting Boxes into tree-like form for finding box overlaps. All boxes must be specified in the transformation specified by their <a class="el" href="classSAMRAI_1_1hier_1_1BlockId.html">BlockId</a>. 
<p>
Overlap searches are done by<ul>
<li><a class="el" href="classSAMRAI_1_1hier_1_1MultiblockBoxTree.html#97b0b05c1e5f60927f4575db20a38dc5">hasOverlap()</a></li><li><a class="el" href="classSAMRAI_1_1hier_1_1MultiblockBoxTree.html#c3c69cafd801dfc3669de8d3f1bac919">findOverlapBoxes()</a></li></ul>
<p>
Significant changes since design review:<ul>
<li>findOverlapBoxes requires refinement_ratio. </li></ul>

<p>
<hr><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" name="e7f8584568a14cf4d8394b26b0c16a60"></a><!-- doxytag: member="SAMRAI::hier::MultiblockBoxTree::MultiblockBoxTree" ref="e7f8584568a14cf4d8394b26b0c16a60" args="(const GridGeometry &amp;grid_geometry, const BoxContainer &amp;boxes, size_t min_number=10)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SAMRAI::hier::MultiblockBoxTree::MultiblockBoxTree           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1GridGeometry.html">GridGeometry</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>grid_geometry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>boxes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>min_number</em> = <code>10</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Constructs a <a class="el" href="classSAMRAI_1_1hier_1_1MultiblockBoxTree.html">MultiblockBoxTree</a> from set of Boxes. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>grid_geometry</em>&nbsp;</td><td><a class="el" href="classSAMRAI_1_1hier_1_1GridGeometry.html">GridGeometry</a> desribing the multiblock environment.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>boxes.</em>&nbsp;</td><td>No empty boxes are allowed.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>min_number</em>&nbsp;</td><td>Split up sets of boxes while the number of boxes in a subset is greater than this value. Setting to a larger value tends to make tree building faster but tree searching slower, and vice versa. <b>Default:</b> 10 </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="11b540babc8ad0bc9688f14e2d398017"></a><!-- doxytag: member="SAMRAI::hier::MultiblockBoxTree::MultiblockBoxTree" ref="11b540babc8ad0bc9688f14e2d398017" args="(const GridGeometry &amp;grid_geometry, const std::vector&lt; Box &gt; &amp;boxes, size_t min_number=10)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SAMRAI::hier::MultiblockBoxTree::MultiblockBoxTree           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1GridGeometry.html">GridGeometry</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>grid_geometry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>boxes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>min_number</em> = <code>10</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Constructs a <a class="el" href="classSAMRAI_1_1hier_1_1MultiblockBoxTree.html">MultiblockBoxTree</a> from vector of Boxes. 
<p>
See MultiblockBoxTree( const tbox::Dimension&amp; , const BoxContainer&amp; , size_t min_number );<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>grid_geometry</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>boxes.</em>&nbsp;</td><td>No empty boxes are allowed.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>min_number.</em>&nbsp;</td><td><b>Default:</b> 10 </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="cb3f9c78df338759dab3ae64e60e9413"></a><!-- doxytag: member="SAMRAI::hier::MultiblockBoxTree::MultiblockBoxTree" ref="cb3f9c78df338759dab3ae64e60e9413" args="(const GridGeometry &amp;grid_geometry, const std::map&lt; BlockId, BoxContainer &gt; &amp;boxes, size_t min_number=10)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SAMRAI::hier::MultiblockBoxTree::MultiblockBoxTree           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1GridGeometry.html">GridGeometry</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>grid_geometry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; <a class="el" href="classSAMRAI_1_1hier_1_1BlockId.html">BlockId</a>, <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>boxes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>min_number</em> = <code>10</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Constructs a <a class="el" href="classSAMRAI_1_1hier_1_1MultiblockBoxTree.html">MultiblockBoxTree</a> from a collection of BoxContainers each of which is associated with a specific <a class="el" href="classSAMRAI_1_1hier_1_1BlockId.html">BlockId</a>. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>grid_geometry</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>boxes.</em>&nbsp;</td><td>No empty boxes are allowed.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>min_number.</em>&nbsp;</td><td><b>Default:</b> 10 </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="341f8d1cadcc6ab62da394283f671121"></a><!-- doxytag: member="SAMRAI::hier::MultiblockBoxTree::MultiblockBoxTree" ref="341f8d1cadcc6ab62da394283f671121" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SAMRAI::hier::MultiblockBoxTree::MultiblockBoxTree           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Default constructor constructs an uninitialized <a class="el" href="classSAMRAI_1_1hier_1_1MultiblockBoxTree.html">MultiblockBoxTree</a>. 
<p>

</div>
</div><p>
<a class="anchor" name="10448246be1d50eed7260b3cfbe0c343"></a><!-- doxytag: member="SAMRAI::hier::MultiblockBoxTree::~MultiblockBoxTree" ref="10448246be1d50eed7260b3cfbe0c343" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SAMRAI::hier::MultiblockBoxTree::~MultiblockBoxTree           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Destructor. 
<p>

</div>
</div><p>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="477bd3dafacab150bcce5369a2a6a235"></a><!-- doxytag: member="SAMRAI::hier::MultiblockBoxTree::generateTree" ref="477bd3dafacab150bcce5369a2a6a235" args="(const GridGeometry &amp;grid_geometry, const BoxContainer &amp;boxes, size_t min_number=10)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::hier::MultiblockBoxTree::generateTree           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1GridGeometry.html">GridGeometry</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>grid_geometry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>boxes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>min_number</em> = <code>10</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Generates the tree from a <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a>. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>grid_geometry</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>boxes.</em>&nbsp;</td><td>No empty boxes are allowed.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>min_number</em>&nbsp;</td><td></td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="3e6a59b88567d97f85d0aaa4d3271a36"></a><!-- doxytag: member="SAMRAI::hier::MultiblockBoxTree::generateTree" ref="3e6a59b88567d97f85d0aaa4d3271a36" args="(const GridGeometry &amp;grid_geometry, const std::map&lt; BlockId, BoxContainer &gt; &amp;boxes, size_t min_number=10)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::hier::MultiblockBoxTree::generateTree           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1GridGeometry.html">GridGeometry</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>grid_geometry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; <a class="el" href="classSAMRAI_1_1hier_1_1BlockId.html">BlockId</a>, <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>boxes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>min_number</em> = <code>10</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Generates the tree from lists of Boxes. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>grid_geometry</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>boxes.</em>&nbsp;</td><td>No empty boxes are allowed.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>min_number</em>&nbsp;</td><td></td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="06a55cc29f672d074c1660c5d94e3d0a"></a><!-- doxytag: member="SAMRAI::hier::MultiblockBoxTree::generateNonPeriodicTree" ref="06a55cc29f672d074c1660c5d94e3d0a" args="(const GridGeometry &amp;grid_geometry, const BoxContainer &amp;boxes, size_t min_number=10)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::hier::MultiblockBoxTree::generateNonPeriodicTree           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1GridGeometry.html">GridGeometry</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>grid_geometry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>boxes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>min_number</em> = <code>10</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Generates the tree of non-periodic Boxes from a <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a>. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>grid_geometry</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>boxes.</em>&nbsp;</td><td>No empty boxes are allowed.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>min_number</em>&nbsp;</td><td></td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="25fd9390864ddf5f1b9f4d1aa7d530b9"></a><!-- doxytag: member="SAMRAI::hier::MultiblockBoxTree::hasBoxInBlock" ref="25fd9390864ddf5f1b9f4d1aa7d530b9" args="(const BlockId &amp;block_id) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SAMRAI::hier::MultiblockBoxTree::hasBoxInBlock           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1BlockId.html">BlockId</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>block_id</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return whether the tree contains any Boxes with the given <a class="el" href="classSAMRAI_1_1hier_1_1BlockId.html">BlockId</a>. 
<p>
If the method getSingleBlockBoxTree(const BlockId&amp;) method will throw an unrecoverable error if this method returns false for the given <a class="el" href="classSAMRAI_1_1hier_1_1BlockId.html">BlockId</a>. 
</div>
</div><p>
<a class="anchor" name="b5fd0eaba7a07c0adb62dae9a4fdb5e2"></a><!-- doxytag: member="SAMRAI::hier::MultiblockBoxTree::getSingleBlockBoxTree" ref="b5fd0eaba7a07c0adb62dae9a4fdb5e2" args="(const BlockId &amp;block_id) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classSAMRAI_1_1hier_1_1BoxTree.html">BoxTree</a> &amp; SAMRAI::hier::MultiblockBoxTree::getSingleBlockBoxTree           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1BlockId.html">BlockId</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>block_id</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return the tree for a single block. 
<p>
If the Boxes initializing the tree did not contain at least one <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> with the given <a class="el" href="classSAMRAI_1_1hier_1_1BlockId.html">BlockId</a>, the corresponding single-block tree does not exist, and this method throws an unrecoverable error. To check for the existance of the tree, use <a class="el" href="classSAMRAI_1_1hier_1_1MultiblockBoxTree.html#25fd9390864ddf5f1b9f4d1aa7d530b9">hasBoxInBlock()</a>. 
</div>
</div><p>
<a class="anchor" name="3302e4ee7186eba88169dd1e98e9bc17"></a><!-- doxytag: member="SAMRAI::hier::MultiblockBoxTree::clear" ref="3302e4ee7186eba88169dd1e98e9bc17" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::hier::MultiblockBoxTree::clear           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Reset to uninitialized state. 
<p>
Uninitialized trees can be initialized using <a class="el" href="classSAMRAI_1_1hier_1_1MultiblockBoxTree.html#477bd3dafacab150bcce5369a2a6a235">generateTree()</a>. 
</div>
</div><p>
<a class="anchor" name="5a1218a3bd6a1a4fbd3209ca151e414a"></a><!-- doxytag: member="SAMRAI::hier::MultiblockBoxTree::isInitialized" ref="5a1218a3bd6a1a4fbd3209ca151e414a" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SAMRAI::hier::MultiblockBoxTree::isInitialized           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Check whether the tree has been initialized. 
<p>
Uninitialized trees can be initialized using <a class="el" href="classSAMRAI_1_1hier_1_1MultiblockBoxTree.html#477bd3dafacab150bcce5369a2a6a235">generateTree()</a>. 
</div>
</div><p>
<a class="anchor" name="643857469cc397e3e3a0c30eb2cf2cb0"></a><!-- doxytag: member="SAMRAI::hier::MultiblockBoxTree::getGridGeometry" ref="643857469cc397e3e3a0c30eb2cf2cb0" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classSAMRAI_1_1hier_1_1GridGeometry.html">GridGeometry</a> &amp; SAMRAI::hier::MultiblockBoxTree::getGridGeometry           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return the <a class="el" href="classSAMRAI_1_1hier_1_1GridGeometry.html">GridGeometry</a> object for the multiblock environment. 
<p>
Do not deallocate the returned <a class="el" href="classSAMRAI_1_1hier_1_1GridGeometry.html">GridGeometry</a>. 
</div>
</div><p>
<a class="anchor" name="97b0b05c1e5f60927f4575db20a38dc5"></a><!-- doxytag: member="SAMRAI::hier::MultiblockBoxTree::hasOverlap" ref="97b0b05c1e5f60927f4575db20a38dc5" args="(const Box &amp;box, bool include_singularity_block_neighbors=false) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SAMRAI::hier::MultiblockBoxTree::hasOverlap           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>box</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>include_singularity_block_neighbors</em> = <code>false</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Whether the given <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> has an overlap with Boxes in the tree. 
<p>
We also check for overlap with Boxes in blocks adjacent to box's block.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>box</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>include_singularity_block_neighbors</em>&nbsp;</td><td>Whether to include intersections with boxes in blocks that are neighbors of box's block across a multiblock singularity. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="c3c69cafd801dfc3669de8d3f1bac919"></a><!-- doxytag: member="SAMRAI::hier::MultiblockBoxTree::findOverlapBoxes" ref="c3c69cafd801dfc3669de8d3f1bac919" args="(Connector &amp;overlap_connector, const Box &amp;box, const IntVector &amp;refinement_ratio, bool include_singularity_block_neighbors=false) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::hier::MultiblockBoxTree::findOverlapBoxes           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">Connector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>overlap_connector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>box</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>refinement_ratio</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>include_singularity_block_neighbors</em> = <code>false</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Find all boxes that overlap the given <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> and insert as neighbors of that box in overlap_connector. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>overlap_connector</em>&nbsp;</td><td>Overlap connector with box in its base <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a>.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>box</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>refinement_ratio</em>&nbsp;</td><td>Refinement ratio of box's index space.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>include_singularity_block_neighbors</em>&nbsp;</td><td>Whether to include intersections with boxes in blocks that are neighbors of box's block across a multiblock singularity. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="1d17457839ef8b25d17fe744c2030141"></a><!-- doxytag: member="SAMRAI::hier::MultiblockBoxTree::findOverlapBoxes" ref="1d17457839ef8b25d17fe744c2030141" args="(std::vector&lt; Box &gt; &amp;overlap_boxes, const Box &amp;box, const IntVector &amp;refinement_ratio, bool include_singularity_block_neighbors=false) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::hier::MultiblockBoxTree::findOverlapBoxes           </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>overlap_boxes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>box</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>refinement_ratio</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>include_singularity_block_neighbors</em> = <code>false</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Find all boxes that overlap the given <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a>. 
<p>
To avoid unneeded work, the output <b>overlap_boxes</b> container is not emptied. Overlapping Boxes are simply added.<p>
Output is unsorted.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>overlap_boxes</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>box</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>refinement_ratio</em>&nbsp;</td><td>Refinement ratio of box's index space.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>include_singularity_block_neighbors</em>&nbsp;</td><td>Whether to include intersections with boxes in blocks that are neighbors of box's block across a multiblock singularity. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="a599bfb5e60afe00be62b0a4951510b5"></a><!-- doxytag: member="SAMRAI::hier::MultiblockBoxTree::findOverlapBoxes" ref="a599bfb5e60afe00be62b0a4951510b5" args="(std::vector&lt; const Box * &gt; &amp;overlap_boxes, const Box &amp;box, const IntVector &amp;refinement_ratio, bool include_singularity_block_neighbors=false) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::hier::MultiblockBoxTree::findOverlapBoxes           </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> * &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>overlap_boxes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>box</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>refinement_ratio</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>include_singularity_block_neighbors</em> = <code>false</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Find all boxes that overlap the given <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a>. 
<p>
Analogous to findOverlapBoxes returning a vector of Boxes but avoids the copies. If the returned overlapped boxes are used in a context in which the <a class="el" href="classSAMRAI_1_1hier_1_1MultiblockBoxTree.html">MultiblockBoxTree</a> is constant there is no point in incurring the cost of copying the tree's Boxes. Just return a vector of their addresses.<p>
Output is unsorted.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>overlap_boxes</em>&nbsp;</td><td>Pointers to Boxes that overlap with box.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>box</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>refinement_ratio</em>&nbsp;</td><td>Refinement ratio of box's index space.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>include_singularity_block_neighbors</em>&nbsp;</td><td>Whether to include intersections with boxes in blocks that are neighbors of box's block across a multiblock singularity. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="b66ce08f60094c82cab0bdbf385986d2"></a><!-- doxytag: member="SAMRAI::hier::MultiblockBoxTree::findOverlapBoxes" ref="b66ce08f60094c82cab0bdbf385986d2" args="(BoxContainer &amp;overlap_boxes, const Box &amp;box, const IntVector &amp;refinement_ratio, bool include_singularity_block_neighbors=false) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::hier::MultiblockBoxTree::findOverlapBoxes           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>overlap_boxes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>box</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>refinement_ratio</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>include_singularity_block_neighbors</em> = <code>false</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Find all boxes that overlap the given <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a>. 
<p>
To avoid unneeded work, the output <b>overlap_boxes</b> container is not emptied. Overlapping Boxes are simply added.<p>
Output is unsorted.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>box</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>refinement_ratio</em>&nbsp;</td><td>Refinement ratio of box's index space.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>include_singularity_block_neighbors</em>&nbsp;</td><td>Whether to include intersections with boxes in blocks that are neighbors of box's block across a multiblock singularity. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="bb222597c3504d8d5eff7bba9f27063e"></a><!-- doxytag: member="SAMRAI::hier::MultiblockBoxTree::getBoxes" ref="bb222597c3504d8d5eff7bba9f27063e" args="(std::vector&lt; Box &gt; &amp;boxes) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::hier::MultiblockBoxTree::getBoxes           </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>boxes</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the Boxes in the tree. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>boxes</em>&nbsp;</td><td></td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="71d06d4d3d22c41799eacb321fcc9c94"></a><!-- doxytag: member="SAMRAI::hier::MultiblockBoxTree::createRefinedTree" ref="71d06d4d3d22c41799eacb321fcc9c94" args="(const IntVector &amp;ratio) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1MultiblockBoxTree.html">MultiblockBoxTree</a> &gt; SAMRAI::hier::MultiblockBoxTree::createRefinedTree           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>ratio</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Create a similar tree with the boxes refined by a given ratio. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>ratio</em>&nbsp;</td><td>The boxes are refined by this ratio.</td></tr>
  </table>
</dl>
Note that there is no coresponding version to create a coarsened tree. Coarsened trees cannot be trivially generated like refined trees can. To create a coarsened tree, you must manually get the boxes, coarsen them and use them to build a new tree. 
</div>
</div><p>
<hr>The documentation for this class was generated from the following files:<ul>
<li>source/SAMRAI/hier/<a class="el" href="MultiblockBoxTree_8h.html">MultiblockBoxTree.h</a><li>source/SAMRAI/hier/<a class="el" href="MultiblockBoxTree_8C.html">MultiblockBoxTree.C</a></ul>
<hr size="1"><address style="align: right;"><small>Generated on Wed Jan 18 16:05:15 2012 for SAMRAI by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.7 </small></address>
</body>
</html>
