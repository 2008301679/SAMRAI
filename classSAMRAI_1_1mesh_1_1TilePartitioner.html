<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>SAMRAI: SAMRAI::mesh::TilePartitioner Class Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.7 -->
<div class="tabs">
  <ul>
    <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="namespaces.html"><span>Namespaces</span></a></li>
    <li id="current"><a href="annotated.html"><span>Classes</span></a></li>
    <li><a href="files.html"><span>Files</span></a></li>
    <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
  </ul></div>
<div class="tabs">
  <ul>
    <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
    <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
    <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
  </ul></div>
<div class="nav">
<a class="el" href="namespaceSAMRAI.html">SAMRAI</a>::<a class="el" href="namespaceSAMRAI_1_1mesh.html">mesh</a>::<a class="el" href="classSAMRAI_1_1mesh_1_1TilePartitioner.html">TilePartitioner</a></div>
<h1>SAMRAI::mesh::TilePartitioner Class Reference</h1><!-- doxytag: class="SAMRAI::mesh::TilePartitioner" --><!-- doxytag: inherits="SAMRAI::mesh::LoadBalanceStrategy" -->Load balance by cutting boxes along designated mesh lines defining a tile box grid. Implemementing the LoadBalancerStrategy. This is UNSUPPORTED, EXPERIMENTAL code not for general use.  
<a href="#_details">More...</a>
<p>
<code>#include &lt;source/SAMRAI/mesh/TilePartitioner.h&gt;</code>
<p>
<p>Inheritance diagram for SAMRAI::mesh::TilePartitioner:
<p><center><img src="classSAMRAI_1_1mesh_1_1TilePartitioner.png" usemap="#SAMRAI::mesh::TilePartitioner_map" border="0" alt=""></center>
<map name="SAMRAI::mesh::TilePartitioner_map">
<area href="classSAMRAI_1_1mesh_1_1LoadBalanceStrategy.html" alt="SAMRAI::mesh::LoadBalanceStrategy" shape="rect" coords="0,0,222,24">
</map>
<a href="classSAMRAI_1_1mesh_1_1TilePartitioner-members.html">List of all members.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1mesh_1_1TilePartitioner.html#7a462508173c6deaf56ded1a58009a34">TilePartitioner</a> (const <a class="el" href="classSAMRAI_1_1tbox_1_1Dimension.html">tbox::Dimension</a> &amp;dim, const std::string &amp;name, const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Database.html">tbox::Database</a> &gt; &amp;input_db=boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Database.html">tbox::Database</a> &gt;())</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Initializing constructor sets object state to default or, if database provided, to parameters in database.  <a href="#7a462508173c6deaf56ded1a58009a34"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1mesh_1_1TilePartitioner.html#bfef402380a8d55cec109e12de915c56">~TilePartitioner</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Virtual destructor releases all internal storage.  <a href="#bfef402380a8d55cec109e12de915c56"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1mesh_1_1TilePartitioner.html#650c67e3173a8af25375b46e87c8b634">getLoadBalanceDependsOnPatchData</a> (int level_number) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return true if load balancing procedure for given level depends on patch data on mesh; otherwise return false.  <a href="#650c67e3173a8af25375b46e87c8b634"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1mesh_1_1TilePartitioner.html#4546be77107453eef7f824d7ecf8b252">loadBalanceBoxLevel</a> (<a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">hier::BoxLevel</a> &amp;balance_box_level, <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">hier::Connector</a> *balance_to_anchor, const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchHierarchy.html">hier::PatchHierarchy</a> &gt; &amp;hierarchy, const int level_number, const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a> &amp;min_size, const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a> &amp;max_size, const <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">hier::BoxLevel</a> &amp;domain_box_level, const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a> &amp;bad_interval, const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a> &amp;cut_factor, const <a class="el" href="classSAMRAI_1_1tbox_1_1RankGroup.html">tbox::RankGroup</a> &amp;rank_group=<a class="el" href="classSAMRAI_1_1tbox_1_1RankGroup.html">tbox::RankGroup</a>()) const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1mesh_1_1TilePartitioner.html#6ff885abb9c89c006d32b8a643cd6aee">printStatistics</a> (std::ostream &amp;output_stream=<a class="el" href="namespaceSAMRAI_1_1tbox.html#b84041705493761fb17a8127e3a2dca2">tbox::plog</a>) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Write out statistics recorded for the most recent load balancing result.  <a href="#6ff885abb9c89c006d32b8a643cd6aee"></a><br></td></tr>
</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
Load balance by cutting boxes along designated mesh lines defining a tile box grid. Implemementing the LoadBalancerStrategy. This is UNSUPPORTED, EXPERIMENTAL code not for general use. 
<p>
This class delegates its partitioning to the <a class="el" href="classSAMRAI_1_1mesh_1_1TreeLoadBalancer.html">TreeLoadBalancer</a> but overrides the cut_factor parameter in <a class="el" href="classSAMRAI_1_1mesh_1_1TilePartitioner.html#4546be77107453eef7f824d7ecf8b252">loadBalanceBoxLevel()</a> to control the patch size.<p>
<b> Input Parameters </b><p>
<b> Definitions: </b><p>
<ul>
<li><b>box_size</b> Box size in the index space of the tag level.</li></ul>
<p>
<ul>
<li><b>internal_load_balancer</b> Which internal load balancer to use.</li></ul>
<p>
<ul>
<li><b><a class="el" href="classSAMRAI_1_1mesh_1_1TreeLoadBalancer.html">TreeLoadBalancer</a></b> { ... } Input for internal <a class="el" href="classSAMRAI_1_1mesh_1_1TreeLoadBalancer.html">TreeLoadBalancer</a>, required if internal_load_balancer = "TreeLoadBalancer".</li></ul>
<p>
<ul>
<li><b><a class="el" href="classSAMRAI_1_1mesh_1_1ChopAndPackLoadBalancer.html">ChopAndPackLoadBalancer</a></b> { ... } Input for internal <a class="el" href="classSAMRAI_1_1mesh_1_1ChopAndPackLoadBalancer.html">ChopAndPackLoadBalancer</a>, required if internal_load_balancer = "ChopAndPackLoadBalancer".</li></ul>
<p>
<b> Details: </b> <br>
 <table border="1" cellspacing="3" cellpadding="3">
<tr>
<th>parameter </th><th>type </th><th>default </th><th>range </th><th>opt/req </th><th>behavior on restart  </th></tr>
<tr>
<td>box_size </td><td>int[] </td><td>none </td><td>???????? </td><td>req </td><td>Not written to restart. Value in input db used.  </td></tr>
<tr>
<td>internal_load_balancer </td><td>string </td><td>"TreeLoadBalancer" </td><td>"TreeLoadBalancer", "ChopAndPackLoadBalancer" </td><td>opt </td><td>Not written to restart. Value in input db used.  </td></tr>
<tr>
<td><a class="el" href="classSAMRAI_1_1mesh_1_1TreeLoadBalancer.html">TreeLoadBalancer</a> </td><td>database </td><td>NULL </td><td></td><td>conditionally req </td><td>Not written to restart. Value in input db used.  </td></tr>
<tr>
<td><a class="el" href="classSAMRAI_1_1mesh_1_1ChopAndPackLoadBalancer.html">ChopAndPackLoadBalancer</a> </td><td>database </td><td>NULL </td><td></td><td>conditionally req </td><td>Not written to restart. Value in input db used.  </td></tr>
</table>

<p>
<hr><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" name="7a462508173c6deaf56ded1a58009a34"></a><!-- doxytag: member="SAMRAI::mesh::TilePartitioner::TilePartitioner" ref="7a462508173c6deaf56ded1a58009a34" args="(const tbox::Dimension &amp;dim, const std::string &amp;name, const boost::shared_ptr&lt; tbox::Database &gt; &amp;input_db=boost::shared_ptr&lt; tbox::Database &gt;())" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SAMRAI::mesh::TilePartitioner::TilePartitioner           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1tbox_1_1Dimension.html">tbox::Dimension</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>dim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Database.html">tbox::Database</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>input_db</em> = <code>boost::shared_ptr&lt;&nbsp;<a class="el" href="classSAMRAI_1_1tbox_1_1Database.html">tbox::Database</a>&nbsp;&gt;()</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Initializing constructor sets object state to default or, if database provided, to parameters in database. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>dim</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>name</em>&nbsp;</td><td>User-defined std::string identifier used for error reporting and timer names. If omitted, "TilePartitioner" is used.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>input_db</em>&nbsp;</td><td>(optional) database pointer providing parameters from input file. This pointer may be null indicating no input is used. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="bfef402380a8d55cec109e12de915c56"></a><!-- doxytag: member="SAMRAI::mesh::TilePartitioner::~TilePartitioner" ref="bfef402380a8d55cec109e12de915c56" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SAMRAI::mesh::TilePartitioner::~TilePartitioner           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Virtual destructor releases all internal storage. 
<p>

</div>
</div><p>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="650c67e3173a8af25375b46e87c8b634"></a><!-- doxytag: member="SAMRAI::mesh::TilePartitioner::getLoadBalanceDependsOnPatchData" ref="650c67e3173a8af25375b46e87c8b634" args="(int level_number) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SAMRAI::mesh::TilePartitioner::getLoadBalanceDependsOnPatchData           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>level_number</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return true if load balancing procedure for given level depends on patch data on mesh; otherwise return false. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>level_number</em>&nbsp;</td><td>Integer patch level number. </td></tr>
  </table>
</dl>

<p>
Implements <a class="el" href="classSAMRAI_1_1mesh_1_1LoadBalanceStrategy.html#26cddcc6d628372374dd30549800bfc5">SAMRAI::mesh::LoadBalanceStrategy</a>.
</div>
</div><p>
<a class="anchor" name="4546be77107453eef7f824d7ecf8b252"></a><!-- doxytag: member="SAMRAI::mesh::TilePartitioner::loadBalanceBoxLevel" ref="4546be77107453eef7f824d7ecf8b252" args="(hier::BoxLevel &amp;balance_box_level, hier::Connector *balance_to_anchor, const boost::shared_ptr&lt; hier::PatchHierarchy &gt; &amp;hierarchy, const int level_number, const hier::IntVector &amp;min_size, const hier::IntVector &amp;max_size, const hier::BoxLevel &amp;domain_box_level, const hier::IntVector &amp;bad_interval, const hier::IntVector &amp;cut_factor, const tbox::RankGroup &amp;rank_group=tbox::RankGroup()) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::mesh::TilePartitioner::loadBalanceBoxLevel           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">hier::BoxLevel</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>balance_box_level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">hier::Connector</a> *&nbsp;</td>
          <td class="paramname"> <em>balance_to_anchor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchHierarchy.html">hier::PatchHierarchy</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>hierarchy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>level_number</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>min_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>max_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">hier::BoxLevel</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>domain_box_level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>bad_interval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>cut_factor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1tbox_1_1RankGroup.html">tbox::RankGroup</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>rank_group</em> = <code><a class="el" href="classSAMRAI_1_1tbox_1_1RankGroup.html">tbox::RankGroup</a>()</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Given a BoxLevel, representing the domain of a specified level in the AMR hierarchy, generate a new BoxLevel from which the patches for the level may be formed and update two Connectors incident on the changed BoxLevel.<p>
The union of the boxes in the balance_box_level is the same before and after the the method call.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>balance_box_level</em>&nbsp;</td><td>Input BoxLevel. On input, this is the pre-balance BoxLevel. On output, it is the balanced BoxLevel.</td></tr>
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>balance_to_anchor</em>&nbsp;</td><td>Connector between the balance_box_level and some given "anchor box_level". This must be accurate on input. On putput, connects the newly balanced balance_box_level to the anchor box_level.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>hierarchy</em>&nbsp;</td><td>The hierarchy where the work distribution data lives.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>level_number</em>&nbsp;</td><td>The number of the level where the work distribution data lives.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>min_size</em>&nbsp;</td><td><a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a> representing mimimum box size.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>max_size</em>&nbsp;</td><td><a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a> representing maximum box size.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>domain_box_level</em>&nbsp;</td><td>Description of the domain.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>bad_interval</em>&nbsp;</td><td><a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a> indicating the length of an interval of cells along each side of the box where chopping the box may produce boxes with certain "bad" properties. For example, this is primiarily used to avoid generating ghost regions for patches that intersect the domain boundary in ways that may it difficult for a use to provide boundary values. Thus, it is typically related to the maximum ghost cell width in the problem. See <a class="el" href="structSAMRAI_1_1hier_1_1BoxUtilities.html">hier::BoxUtilities</a> header file for more information.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>cut_factor</em>&nbsp;</td><td><a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a> indicating factor for chopping each side of a box; i.e., after chopping a box, the number of cells along each direction of each piece must be an integer multiple of the corresponding entry in the cut factor vector. For example, the cut factor may be related to the coarsen ratio between levels in the hierarchy in which case it may be used to produce boxes that can be coarsened by a certain factor if needed. See <a class="el" href="structSAMRAI_1_1hier_1_1BoxUtilities.html">hier::BoxUtilities</a> header file for more information.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>rank_group</em>&nbsp;</td><td>Input <a class="el" href="classSAMRAI_1_1tbox_1_1RankGroup.html">tbox::RankGroup</a> indicating a set of ranks on which all boxes in the output balance_box_level will be restricted. Some child classes may not make use of this argument.</td></tr>
  </table>
</dl>
<p>
Note: This implementation does not yet support non-uniform load balancing. 
<p>
Implements <a class="el" href="classSAMRAI_1_1mesh_1_1LoadBalanceStrategy.html#2a6934691d740a0930f1644d5271d6b2">SAMRAI::mesh::LoadBalanceStrategy</a>.
</div>
</div><p>
<a class="anchor" name="6ff885abb9c89c006d32b8a643cd6aee"></a><!-- doxytag: member="SAMRAI::mesh::TilePartitioner::printStatistics" ref="6ff885abb9c89c006d32b8a643cd6aee" args="(std::ostream &amp;output_stream=tbox::plog) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::mesh::TilePartitioner::printStatistics           </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&nbsp;</td>
          <td class="paramname"> <em>output_stream</em> = <code><a class="el" href="namespaceSAMRAI_1_1tbox.html#b84041705493761fb17a8127e3a2dca2">tbox::plog</a></code>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Write out statistics recorded for the most recent load balancing result. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>output_stream</em>&nbsp;</td><td></td></tr>
  </table>
</dl>

</div>
</div><p>
<hr>The documentation for this class was generated from the following files:<ul>
<li>source/SAMRAI/mesh/<a class="el" href="TilePartitioner_8h.html">TilePartitioner.h</a><li>source/SAMRAI/mesh/<a class="el" href="TilePartitioner_8C.html">TilePartitioner.C</a></ul>
<hr size="1"><address style="align: right;"><small>Generated on 10 Jan 2014 for SAMRAI by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.7 </small></address>
</body>
</html>
