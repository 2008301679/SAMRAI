<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>SAMRAI: SAMRAI::tbox::AsyncCommGroup Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath"><a class="el" href="namespaceSAMRAI.html">SAMRAI</a>::<a class="el" href="namespaceSAMRAI_1_1tbox.html">tbox</a>::<a class="el" href="classSAMRAI_1_1tbox_1_1AsyncCommGroup.html">AsyncCommGroup</a>
  </div>
</div>
<div class="contents">
<h1>SAMRAI::tbox::AsyncCommGroup Class Reference</h1><!-- doxytag: class="SAMRAI::tbox::AsyncCommGroup" --><!-- doxytag: inherits="SAMRAI::tbox::AsyncCommStage::Member" -->
<p>Supports all-to-one and one-to-all asynchronous communication operations within a given group of processes by sending messages along the branches of a conceptual tree.  
<a href="#_details">More...</a></p>

<p><code>#include &lt;source/SAMRAI/tbox/AsyncCommGroup.h&gt;</code></p>
<div class="dynheader">
Inheritance diagram for SAMRAI::tbox::AsyncCommGroup:</div>
<div class="dynsection">
 <div class="center">
  <img src="classSAMRAI_1_1tbox_1_1AsyncCommGroup.gif" usemap="#SAMRAI::tbox::AsyncCommGroup_map" alt=""/>
  <map id="SAMRAI::tbox::AsyncCommGroup_map" name="SAMRAI::tbox::AsyncCommGroup_map">
<area href="structSAMRAI_1_1tbox_1_1AsyncCommStage_1_1Member.html" alt="SAMRAI::tbox::AsyncCommStage::Member" shape="rect" coords="0,0,249,24"/>
</map>
 </div>
</div>

<p><a href="classSAMRAI_1_1tbox_1_1AsyncCommGroup-members.html">List of all members.</a></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1tbox_1_1AsyncCommGroup.html#a610c526c5c212b9ba4d5df712b52a239">AsyncCommGroup</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Default constructor does not set up anything. You must <a class="el" href="classSAMRAI_1_1tbox_1_1AsyncCommGroup.html#a530c097142fa3b07df1b2ec228644d90" title="Initialize the object.">initialize()</a> the object before using it.  <a href="#a610c526c5c212b9ba4d5df712b52a239"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1tbox_1_1AsyncCommGroup.html#a6d99f4f383c3c4d79b0e6a933e19a48f">AsyncCommGroup</a> (const size_t nchild, <a class="el" href="classSAMRAI_1_1tbox_1_1AsyncCommStage.html">AsyncCommStage</a> *stage, <a class="el" href="structSAMRAI_1_1tbox_1_1AsyncCommStage_1_1Handler.html">AsyncCommStage::Handler</a> *handler=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Construct communication group.  <a href="#a6d99f4f383c3c4d79b0e6a933e19a48f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1tbox_1_1AsyncCommGroup.html#a74b163a0fb8e5194a7622ed825c67925">~AsyncCommGroup</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Destructor.  <a href="#a74b163a0fb8e5194a7622ed825c67925"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1tbox_1_1AsyncCommGroup.html#a530c097142fa3b07df1b2ec228644d90">initialize</a> (const int nchild, <a class="el" href="classSAMRAI_1_1tbox_1_1AsyncCommStage.html">AsyncCommStage</a> *stage, <a class="el" href="structSAMRAI_1_1tbox_1_1AsyncCommStage_1_1Handler.html">AsyncCommStage::Handler</a> *handler=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Initialize the object.  <a href="#a530c097142fa3b07df1b2ec228644d90"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1tbox_1_1AsyncCommGroup.html#af2aa4253bd569d04b31bb5b35a39142e">setMPITag</a> (const int mpi_tag)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the MPI tag used for communication within the group.  <a href="#af2aa4253bd569d04b31bb5b35a39142e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1tbox_1_1AsyncCommGroup.html#ad8b5f632b4069b0a430526a91c795193">getMPITag</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the MPI tag used for communication within the group.  <a href="#ad8b5f632b4069b0a430526a91c795193"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1tbox_1_1AsyncCommGroup.html#a45e5077b79079c08b6833bd1bddc78fc">getGroupSize</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the size of the group.  <a href="#a45e5077b79079c08b6833bd1bddc78fc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">TaskOp&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1tbox_1_1AsyncCommGroup.html#aaef1113ae55e6000c33197401fa7db62">getNextTaskOp</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns next task in a current communication operation.  <a href="#aaef1113ae55e6000c33197401fa7db62"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">BaseOp&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1tbox_1_1AsyncCommGroup.html#af933f3b999fd68a44db1fe0e7e3c1117">getBaseOp</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns operation being performed.  <a href="#af933f3b999fd68a44db1fe0e7e3c1117"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1tbox_1_1AsyncCommGroup.html#a61b12b80ec4a33e37608629ecc6c4fb4">getParentRank</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Rank of parent process in the group.  <a href="#a61b12b80ec4a33e37608629ecc6c4fb4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1tbox_1_1AsyncCommGroup.html#aef41816db86e9504615c5b0f9582cfaa">setUseMPICollectiveForFullGroups</a> (bool use_mpi_collective=true)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set whether to use native MPI collective function calls when group includes all ranks in the MPI communicator.  <a href="#aef41816db86e9504615c5b0f9582cfaa"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1tbox_1_1AsyncCommGroup.html#ac909116403ea9b4e86a194669224dbf7">setUseBlockingSendToParent</a> (const bool flag)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set whether sends to parents should be blocking.  <a href="#ac909116403ea9b4e86a194669224dbf7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1tbox_1_1AsyncCommGroup.html#af090fddfaa48c7eb91a860a9c4cc2c08">setUseBlockingSendToChildren</a> (const bool flag)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set whether sends to children should be blocking.  <a href="#af090fddfaa48c7eb91a860a9c4cc2c08"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1tbox_1_1AsyncCommGroup.html#a9ee3d6de2d490eb50fe9db359d5f8341">getNumberOfChildren</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1tbox_1_1AsyncCommGroup.html#ad2596b98ef718fecd5f8891f6a4c9201">logCurrentState</a> (std::ostream &amp;co) const </td></tr>
<tr><td colspan="2"><div class="groupHeader">Define the communication group</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrp83f31ff7f0e3b2f2b0b15c2c85cf40f8"></a> </p>
<br/><br/></div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1tbox_1_1AsyncCommGroup.html#af359b65deb16aa633a5f8a9e65d69ea5">setGroupAndRootIndex</a> (const <a class="el" href="classSAMRAI_1_1tbox_1_1SAMRAI__MPI.html">SAMRAI_MPI</a> &amp;mpi, const int *group_ranks, const int group_size, const int root_index)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Setup the tree for the given group of processes. The root process is specified by its index in the group array.  <a href="#af359b65deb16aa633a5f8a9e65d69ea5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1tbox_1_1AsyncCommGroup.html#a3b959dbd42462bb2fe52c458626a2ad9">setGroupAndRootRank</a> (const <a class="el" href="classSAMRAI_1_1tbox_1_1SAMRAI__MPI.html">SAMRAI_MPI</a> &amp;mpi, const int *group_ranks, const int group_size, const int root_rank)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Setup the group for the given group. The root process is specified by its rank.  <a href="#a3b959dbd42462bb2fe52c458626a2ad9"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Communication methods</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrpf1210f404c74e62c227e69e226c481b4"></a> </p>
<br/><br/></div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1tbox_1_1AsyncCommGroup.html#a520f3cec0caea74a731b9102276eb83c">beginBcast</a> (int *buffer, int size)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Begin a broadcast communication.  <a href="#a520f3cec0caea74a731b9102276eb83c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1tbox_1_1AsyncCommGroup.html#a69fd7c96bf69ca79b76a0ebf8c133fd9">checkBcast</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Check the current broadcast communication and complete the broadcast if all MPI requests are fulfilled.  <a href="#a69fd7c96bf69ca79b76a0ebf8c133fd9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1tbox_1_1AsyncCommGroup.html#a2179371efe6288654029b5796ac10fa2">beginGather</a> (int *buffer, int size)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Begin a gather communication.  <a href="#a2179371efe6288654029b5796ac10fa2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1tbox_1_1AsyncCommGroup.html#a14b1c40af08d5be853ef33ccdde46489">checkGather</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Check the current gather communication and complete the gather if all MPI requests are fulfilled.  <a href="#a14b1c40af08d5be853ef33ccdde46489"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1tbox_1_1AsyncCommGroup.html#a8c793a5e0abe994ceb89d186dd21ff6c">beginSumReduce</a> (int *buffer, int size)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Begin a sum reduce communication.  <a href="#a8c793a5e0abe994ceb89d186dd21ff6c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1tbox_1_1AsyncCommGroup.html#a724bbf61b605419c2ac4d43748cdabbe">checkSumReduce</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Check the current sum reduce communication and complete the sum reduce if all MPI requests are fulfilled.  <a href="#a724bbf61b605419c2ac4d43748cdabbe"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1tbox_1_1AsyncCommGroup.html#a85e2402d111fc0e5a15c2a23f3d63f96">proceedToNextWait</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Check the current communication and complete it if all MPI requests are fulfilled.  <a href="#a85e2402d111fc0e5a15c2a23f3d63f96"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1tbox_1_1AsyncCommGroup.html#a1bcf15f48abd8abdc052496fb76a1c25">isDone</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Whether the last communication operation has finished.  <a href="#a1bcf15f48abd8abdc052496fb76a1c25"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1tbox_1_1AsyncCommGroup.html#aeeb67c2ae16d7518bc700d4d9b0e20c5">completeCurrentOperation</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Wait for the current operation to complete.  <a href="#aeeb67c2ae16d7518bc700d4d9b0e20c5"></a><br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>Supports all-to-one and one-to-all asynchronous communication operations within a given group of processes by sending messages along the branches of a conceptual tree. </p>
<p>This class was created to perform certain group communications without using MPI global communications, which require creating new MPI communicators (can be expensive) and does not support asynchronous operations (until MPI-2).</p>
<p>The supported communications are asynchronous in that you can start one and wait for it or check back on it occassionally until it completes. Simultaneous Asynchronous operations of many groups can be done by using a <a class="el" href="classSAMRAI_1_1tbox_1_1AsyncCommStage.html" title="Stage multiple non-blocking MPI communications so that codes waiting for them to...">AsyncCommStage</a> to allocate the groups and to check for completed communications.</p>
<p>Supported operations are currently broadcast, gather and sum reduce. Only integer data is supported.</p>
<p>A tree is an acyclic graph in which a node at position pos has nchild children, and the following positions for its</p>
<ul>
<li>parent: (pos-1)/nchild</li>
<li>first (oldest) child: pos*nchild+1</li>
<li>last (youngest) child: (pos+1)*nchild</li>
</ul>
<p>For example, nchild=2 corresponds to a binary tree.</p>
<p>Communication is done by sending messages toward the root (for all-to-one operations) or leaves (for one-to-all operations). For the former, we receive data from the children and send to the parent. For the latter, we receive from the parent and send to the children. Thus every communication involves a receive and a send (except at the root and leaf nodes of the tree).</p>
<p>Using a tree generally gives better performance than having all processes in the the tree communicate directly with the root process. Using MPI communicators corresponding to the groups may faster than using this class, but the cost of creating MPI communicators MAY be expensive.</p>
<p>This class supports communication and uses MPI for message passing. If MPI is disabled, the job of this class disappears and the class is effectively empty. The public interfaces still remain so the class can compile, but the implementations are trivial. </p>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a610c526c5c212b9ba4d5df712b52a239"></a><!-- doxytag: member="SAMRAI::tbox::AsyncCommGroup::AsyncCommGroup" ref="a610c526c5c212b9ba4d5df712b52a239" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SAMRAI::tbox::AsyncCommGroup::AsyncCommGroup </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Default constructor does not set up anything. You must <a class="el" href="classSAMRAI_1_1tbox_1_1AsyncCommGroup.html#a530c097142fa3b07df1b2ec228644d90" title="Initialize the object.">initialize()</a> the object before using it. </p>

</div>
</div>
<a class="anchor" id="a6d99f4f383c3c4d79b0e6a933e19a48f"></a><!-- doxytag: member="SAMRAI::tbox::AsyncCommGroup::AsyncCommGroup" ref="a6d99f4f383c3c4d79b0e6a933e19a48f" args="(const size_t nchild, AsyncCommStage *stage, AsyncCommStage::Handler *handler=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SAMRAI::tbox::AsyncCommGroup::AsyncCommGroup </td>
          <td>(</td>
          <td class="paramtype">const size_t&nbsp;</td>
          <td class="paramname"> <em>nchild</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1tbox_1_1AsyncCommStage.html">AsyncCommStage</a> *&nbsp;</td>
          <td class="paramname"> <em>stage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSAMRAI_1_1tbox_1_1AsyncCommStage_1_1Handler.html">AsyncCommStage::Handler</a> *&nbsp;</td>
          <td class="paramname"> <em>handler</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Construct communication group. </p>
<p>The number of children per node is flexible.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>nchild</em>&nbsp;</td><td>Number of children per tree node in the group, i.e., nchild=2 is a binary tree. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>stage</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>handler</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="post"><dt><b>Postcondition:</b></dt><dd>nchild == <a class="el" href="structSAMRAI_1_1tbox_1_1AsyncCommStage_1_1Member.html#ac549fac8a64d230d5c7d0d5b2b6947c7" title="Get the number of requests for the stage Member.">numberOfRequests()</a> </dd></dl>

<p>References <a class="el" href="AsyncCommStage_8h_source.html#l00134">SAMRAI::tbox::AsyncCommStage::Member::numberOfRequests()</a>, and <a class="el" href="Utilities_8h_source.html#l00110">TBOX_ASSERT</a>.</p>

</div>
</div>
<a class="anchor" id="a74b163a0fb8e5194a7622ed825c67925"></a><!-- doxytag: member="SAMRAI::tbox::AsyncCommGroup::~AsyncCommGroup" ref="a74b163a0fb8e5194a7622ed825c67925" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SAMRAI::tbox::AsyncCommGroup::~AsyncCommGroup </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Destructor. </p>
<dl class="pre"><dt><b>Precondition:</b></dt><dd><a class="el" href="classSAMRAI_1_1tbox_1_1AsyncCommGroup.html#a1bcf15f48abd8abdc052496fb76a1c25" title="Whether the last communication operation has finished.">isDone()</a> </dd></dl>

<p>References <a class="el" href="SAMRAI__MPI_8h_source.html#l00233">SAMRAI::tbox::SAMRAI_MPI::getCommunicator()</a>, <a class="el" href="AsyncCommGroup_8C_source.html#l00236">isDone()</a>, and <a class="el" href="Utilities_8h_source.html#l00060">TBOX_ERROR</a>.</p>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a530c097142fa3b07df1b2ec228644d90"></a><!-- doxytag: member="SAMRAI::tbox::AsyncCommGroup::initialize" ref="a530c097142fa3b07df1b2ec228644d90" args="(const int nchild, AsyncCommStage *stage, AsyncCommStage::Handler *handler=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::tbox::AsyncCommGroup::initialize </td>
          <td>(</td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>nchild</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1tbox_1_1AsyncCommStage.html">AsyncCommStage</a> *&nbsp;</td>
          <td class="paramname"> <em>stage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSAMRAI_1_1tbox_1_1AsyncCommStage_1_1Handler.html">AsyncCommStage::Handler</a> *&nbsp;</td>
          <td class="paramname"> <em>handler</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Initialize the object. </p>
<p>Attach self to the given stage and set the Handler.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>nchild</em>&nbsp;</td><td>Number of children per tree node in the group, i.e., nchild=2 is a binary tree.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>stage</em>&nbsp;</td><td>The required stage used for completing non-blocking message passing calls.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>handler</em>&nbsp;</td><td>Optional handler (see <a class="el" href="structSAMRAI_1_1tbox_1_1AsyncCommStage_1_1Member.html" title="Something on a stage, using MPI requests and statuses provided by the stage.">AsyncCommStage::Member</a>).</td></tr>
  </table>
  </dd>
</dl>
<dl class="pre"><dt><b>Precondition:</b></dt><dd><a class="el" href="classSAMRAI_1_1tbox_1_1AsyncCommGroup.html#a1bcf15f48abd8abdc052496fb76a1c25" title="Whether the last communication operation has finished.">isDone()</a> </dd></dl>

<p>References <a class="el" href="AsyncCommStage_8C_source.html#l00744">SAMRAI::tbox::AsyncCommStage::Member::attachStage()</a>, <a class="el" href="AsyncCommGroup_8C_source.html#l00236">isDone()</a>, <a class="el" href="AsyncCommStage_8h_source.html#l00205">SAMRAI::tbox::AsyncCommStage::Member::setHandler()</a>, and <a class="el" href="Utilities_8h_source.html#l00060">TBOX_ERROR</a>.</p>

</div>
</div>
<a class="anchor" id="af359b65deb16aa633a5f8a9e65d69ea5"></a><!-- doxytag: member="SAMRAI::tbox::AsyncCommGroup::setGroupAndRootIndex" ref="af359b65deb16aa633a5f8a9e65d69ea5" args="(const SAMRAI_MPI &amp;mpi, const int *group_ranks, const int group_size, const int root_index)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::tbox::AsyncCommGroup::setGroupAndRootIndex </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1tbox_1_1SAMRAI__MPI.html">SAMRAI_MPI</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>mpi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&nbsp;</td>
          <td class="paramname"> <em>group_ranks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>group_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>root_index</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Setup the tree for the given group of processes. The root process is specified by its index in the group array. </p>
<p>The root rank is specified by dereferencing <code>group</code> array with <code>root_index</code>.</p>
<dl class="pre"><dt><b>Precondition:</b></dt><dd><a class="el" href="classSAMRAI_1_1tbox_1_1AsyncCommGroup.html#aaef1113ae55e6000c33197401fa7db62" title="Returns next task in a current communication operation.">getNextTaskOp()</a> == none </dd></dl>

<p>References <a class="el" href="SAMRAI__MPI_8h_source.html#l00233">SAMRAI::tbox::SAMRAI_MPI::getCommunicator()</a>, <a class="el" href="AsyncCommGroup_8h_source.html#l00215">getNextTaskOp()</a>, <a class="el" href="SAMRAI__MPI_8h_source.html#l00214">SAMRAI::tbox::SAMRAI_MPI::getRank()</a>, <a class="el" href="SAMRAI__MPI_8h_source.html#l00224">SAMRAI::tbox::SAMRAI_MPI::getSize()</a>, <a class="el" href="Utilities_8h_source.html#l00110">TBOX_ASSERT</a>, and <a class="el" href="Utilities_8h_source.html#l00060">TBOX_ERROR</a>.</p>

<p>Referenced by <a class="el" href="AsyncCommGroup_8C_source.html#l01124">setGroupAndRootRank()</a>.</p>

</div>
</div>
<a class="anchor" id="a3b959dbd42462bb2fe52c458626a2ad9"></a><!-- doxytag: member="SAMRAI::tbox::AsyncCommGroup::setGroupAndRootRank" ref="a3b959dbd42462bb2fe52c458626a2ad9" args="(const SAMRAI_MPI &amp;mpi, const int *group_ranks, const int group_size, const int root_rank)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::tbox::AsyncCommGroup::setGroupAndRootRank </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1tbox_1_1SAMRAI__MPI.html">SAMRAI_MPI</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>mpi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&nbsp;</td>
          <td class="paramname"> <em>group_ranks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>group_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>root_rank</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Setup the group for the given group. The root process is specified by its rank. </p>
<p>The rank of the root is root_rank, which must be one of the ranks given in the group. </p>

<p>References <a class="el" href="SAMRAI__MPI_8h_source.html#l00233">SAMRAI::tbox::SAMRAI_MPI::getCommunicator()</a>, <a class="el" href="AsyncCommGroup_8C_source.html#l01151">setGroupAndRootIndex()</a>, and <a class="el" href="Utilities_8h_source.html#l00060">TBOX_ERROR</a>.</p>

</div>
</div>
<a class="anchor" id="af2aa4253bd569d04b31bb5b35a39142e"></a><!-- doxytag: member="SAMRAI::tbox::AsyncCommGroup::setMPITag" ref="af2aa4253bd569d04b31bb5b35a39142e" args="(const int mpi_tag)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::tbox::AsyncCommGroup::setMPITag </td>
          <td>(</td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>mpi_tag</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set the MPI tag used for communication within the group. </p>
<dl class="attention"><dt><b>Attention:</b></dt><dd>This class is NOT (and cannot be) responsible for ensuring that the MPI communicator and tag are sufficient to select the correct messages. Please specify appropriate values for the MPI communicator and tag. Very elusive bugs can occur if incorrect messages are received. To be safe, it is best to create a new communicator to avoid interference with other communications within <a class="el" href="namespaceSAMRAI.html">SAMRAI</a>.</dd></dl>
<dl class="pre"><dt><b>Precondition:</b></dt><dd><a class="el" href="classSAMRAI_1_1tbox_1_1AsyncCommGroup.html#a1bcf15f48abd8abdc052496fb76a1c25" title="Whether the last communication operation has finished.">isDone()</a> </dd></dl>

<p>References <a class="el" href="AsyncCommGroup_8C_source.html#l00236">isDone()</a>, and <a class="el" href="Utilities_8h_source.html#l00060">TBOX_ERROR</a>.</p>

</div>
</div>
<a class="anchor" id="ad8b5f632b4069b0a430526a91c795193"></a><!-- doxytag: member="SAMRAI::tbox::AsyncCommGroup::getMPITag" ref="ad8b5f632b4069b0a430526a91c795193" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int SAMRAI::tbox::AsyncCommGroup::getMPITag </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the MPI tag used for communication within the group. </p>

</div>
</div>
<a class="anchor" id="a45e5077b79079c08b6833bd1bddc78fc"></a><!-- doxytag: member="SAMRAI::tbox::AsyncCommGroup::getGroupSize" ref="a45e5077b79079c08b6833bd1bddc78fc" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int SAMRAI::tbox::AsyncCommGroup::getGroupSize </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the size of the group. </p>

</div>
</div>
<a class="anchor" id="aaef1113ae55e6000c33197401fa7db62"></a><!-- doxytag: member="SAMRAI::tbox::AsyncCommGroup::getNextTaskOp" ref="aaef1113ae55e6000c33197401fa7db62" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TaskOp SAMRAI::tbox::AsyncCommGroup::getNextTaskOp </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns next task in a current communication operation. </p>

<p>Referenced by <a class="el" href="AsyncCommGroup_8C_source.html#l00291">beginBcast()</a>, <a class="el" href="AsyncCommGroup_8C_source.html#l00521">beginGather()</a>, <a class="el" href="AsyncCommGroup_8C_source.html#l00799">beginSumReduce()</a>, <a class="el" href="AsyncCommGroup_8C_source.html#l00322">checkBcast()</a>, <a class="el" href="AsyncCommGroup_8C_source.html#l00236">isDone()</a>, and <a class="el" href="AsyncCommGroup_8C_source.html#l01151">setGroupAndRootIndex()</a>.</p>

</div>
</div>
<a class="anchor" id="af933f3b999fd68a44db1fe0e7e3c1117"></a><!-- doxytag: member="SAMRAI::tbox::AsyncCommGroup::getBaseOp" ref="af933f3b999fd68a44db1fe0e7e3c1117" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BaseOp SAMRAI::tbox::AsyncCommGroup::getBaseOp </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns operation being performed. </p>

<p>Referenced by <a class="el" href="AsyncCommGroup_8C_source.html#l00322">checkBcast()</a>, and <a class="el" href="AsyncCommGroup_8C_source.html#l00595">checkGather()</a>.</p>

</div>
</div>
<a class="anchor" id="a61b12b80ec4a33e37608629ecc6c4fb4"></a><!-- doxytag: member="SAMRAI::tbox::AsyncCommGroup::getParentRank" ref="a61b12b80ec4a33e37608629ecc6c4fb4" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int SAMRAI::tbox::AsyncCommGroup::getParentRank </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Rank of parent process in the group. </p>

</div>
</div>
<a class="anchor" id="aef41816db86e9504615c5b0f9582cfaa"></a><!-- doxytag: member="SAMRAI::tbox::AsyncCommGroup::setUseMPICollectiveForFullGroups" ref="aef41816db86e9504615c5b0f9582cfaa" args="(bool use_mpi_collective=true)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::tbox::AsyncCommGroup::setUseMPICollectiveForFullGroups </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>use_mpi_collective</em> = <code>true</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set whether to use native MPI collective function calls when group includes all ranks in the MPI communicator. </p>
<p>This option is off by default to avoid MPI lock-ups. If you use it, make sure all processors can get to the collective operation to avoid lock-ups.</p>
<dl class="pre"><dt><b>Precondition:</b></dt><dd><a class="el" href="classSAMRAI_1_1tbox_1_1AsyncCommGroup.html#a1bcf15f48abd8abdc052496fb76a1c25" title="Whether the last communication operation has finished.">isDone()</a> </dd></dl>

<p>References <a class="el" href="AsyncCommGroup_8C_source.html#l00236">isDone()</a>, and <a class="el" href="Utilities_8h_source.html#l00060">TBOX_ERROR</a>.</p>

</div>
</div>
<a class="anchor" id="ac909116403ea9b4e86a194669224dbf7"></a><!-- doxytag: member="SAMRAI::tbox::AsyncCommGroup::setUseBlockingSendToParent" ref="ac909116403ea9b4e86a194669224dbf7" args="(const bool flag)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::tbox::AsyncCommGroup::setUseBlockingSendToParent </td>
          <td>(</td>
          <td class="paramtype">const bool&nbsp;</td>
          <td class="paramname"> <em>flag</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set whether sends to parents should be blocking. </p>
<p>The default is to use blocking send to parent. Because there is just one parent, short messages can be buffered by MPI to improve the performance of blocking sends. Blocking sends need not be checked for completion. </p>

</div>
</div>
<a class="anchor" id="af090fddfaa48c7eb91a860a9c4cc2c08"></a><!-- doxytag: member="SAMRAI::tbox::AsyncCommGroup::setUseBlockingSendToChildren" ref="af090fddfaa48c7eb91a860a9c4cc2c08" args="(const bool flag)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::tbox::AsyncCommGroup::setUseBlockingSendToChildren </td>
          <td>(</td>
          <td class="paramtype">const bool&nbsp;</td>
          <td class="paramname"> <em>flag</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set whether sends to children should be blocking. </p>
<p>The default is to use nonblocking send to children. Nonblocking sends to children are generally appropriate as there are multiple children. </p>

</div>
</div>
<a class="anchor" id="a520f3cec0caea74a731b9102276eb83c"></a><!-- doxytag: member="SAMRAI::tbox::AsyncCommGroup::beginBcast" ref="a520f3cec0caea74a731b9102276eb83c" args="(int *buffer, int size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SAMRAI::tbox::AsyncCommGroup::beginBcast </td>
          <td>(</td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>size</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Begin a broadcast communication. </p>
<p>Root process of broadcast may send less data (smaller size) than receivers of broadcast, in which case the missing data is considered irrelevant by the root.</p>
<p>If this method returns false, <a class="el" href="classSAMRAI_1_1tbox_1_1AsyncCommGroup.html#a69fd7c96bf69ca79b76a0ebf8c133fd9" title="Check the current broadcast communication and complete the broadcast if all MPI requests...">checkBcast()</a> must be called until it returns true before any change in object state is allowed.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Whether operation is completed.</dd></dl>
<dl class="pre"><dt><b>Precondition:</b></dt><dd><a class="el" href="classSAMRAI_1_1tbox_1_1AsyncCommGroup.html#aaef1113ae55e6000c33197401fa7db62" title="Returns next task in a current communication operation.">getNextTaskOp()</a> == none </dd></dl>

<p>References <a class="el" href="AsyncCommGroup_8C_source.html#l00322">checkBcast()</a>, <a class="el" href="SAMRAI__MPI_8h_source.html#l00233">SAMRAI::tbox::SAMRAI_MPI::getCommunicator()</a>, <a class="el" href="AsyncCommGroup_8h_source.html#l00215">getNextTaskOp()</a>, <a class="el" href="SAMRAI__MPI_8h_source.html#l00224">SAMRAI::tbox::SAMRAI_MPI::getSize()</a>, and <a class="el" href="Utilities_8h_source.html#l00060">TBOX_ERROR</a>.</p>

</div>
</div>
<a class="anchor" id="a69fd7c96bf69ca79b76a0ebf8c133fd9"></a><!-- doxytag: member="SAMRAI::tbox::AsyncCommGroup::checkBcast" ref="a69fd7c96bf69ca79b76a0ebf8c133fd9" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SAMRAI::tbox::AsyncCommGroup::checkBcast </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Check the current broadcast communication and complete the broadcast if all MPI requests are fulfilled. </p>
<p>If no communication is in progress, this call does nothing.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Whether operation is completed.</dd></dl>
<dl class="pre"><dt><b>Precondition:</b></dt><dd><a class="el" href="classSAMRAI_1_1tbox_1_1AsyncCommGroup.html#af933f3b999fd68a44db1fe0e7e3c1117" title="Returns operation being performed.">getBaseOp()</a> == bcast</dd></dl>
<dl class="post"><dt><b>Postcondition:</b></dt><dd>(<a class="el" href="classSAMRAI_1_1tbox_1_1AsyncCommGroup.html#a61b12b80ec4a33e37608629ecc6c4fb4" title="Rank of parent process in the group.">getParentRank()</a> != -1) || (<a class="el" href="classSAMRAI_1_1tbox_1_1AsyncCommGroup.html#aaef1113ae55e6000c33197401fa7db62" title="Returns next task in a current communication operation.">getNextTaskOp()</a> != recv_check) </dd></dl>

<p>References <a class="el" href="SAMRAI__MPI_8C_source.html#l00385">SAMRAI::tbox::SAMRAI_MPI::Get_count()</a>, <a class="el" href="AsyncCommGroup_8h_source.html#l00224">getBaseOp()</a>, <a class="el" href="SAMRAI__MPI_8h_source.html#l00233">SAMRAI::tbox::SAMRAI_MPI::getCommunicator()</a>, <a class="el" href="AsyncCommGroup_8h_source.html#l00215">getNextTaskOp()</a>, <a class="el" href="AsyncCommStage_8C_source.html#l00813">SAMRAI::tbox::AsyncCommStage::Member::getRequestPointer()</a>, <a class="el" href="SAMRAI__MPI_8C_source.html#l01028">SAMRAI::tbox::SAMRAI_MPI::Irecv()</a>, <a class="el" href="SAMRAI__MPI_8C_source.html#l00995">SAMRAI::tbox::SAMRAI_MPI::Isend()</a>, <a class="el" href="SAMRAI__MPI_8h_source.html#l00043">MPI_ERR_IN_STATUS</a>, <a class="el" href="SAMRAI__MPI_8h_source.html#l00138">SAMRAI::tbox::SAMRAI_MPI::Status::MPI_ERROR</a>, <a class="el" href="SAMRAI__MPI_8h_source.html#l00052">MPI_INT</a>, <a class="el" href="SAMRAI__MPI_8h_source.html#l00042">MPI_REQUEST_NULL</a>, <a class="el" href="SAMRAI__MPI_8h_source.html#l00136">SAMRAI::tbox::SAMRAI_MPI::Status::MPI_SOURCE</a>, <a class="el" href="SAMRAI__MPI_8h_source.html#l00039">MPI_SUCCESS</a>, <a class="el" href="SAMRAI__MPI_8h_source.html#l00137">SAMRAI::tbox::SAMRAI_MPI::Status::MPI_TAG</a>, <a class="el" href="namespaceSAMRAI_1_1tbox.html#ab84041705493761fb17a8127e3a2dca2">SAMRAI::tbox::plog</a>, <a class="el" href="SAMRAI__MPI_8C_source.html#l01154">SAMRAI::tbox::SAMRAI_MPI::Send()</a>, <a class="el" href="Utilities_8h_source.html#l00110">TBOX_ASSERT</a>, <a class="el" href="Utilities_8h_source.html#l00060">TBOX_ERROR</a>, and <a class="el" href="SAMRAI__MPI_8C_source.html#l00435">SAMRAI::tbox::SAMRAI_MPI::Test()</a>.</p>

<p>Referenced by <a class="el" href="AsyncCommGroup_8C_source.html#l00291">beginBcast()</a>, and <a class="el" href="AsyncCommGroup_8C_source.html#l00206">proceedToNextWait()</a>.</p>

</div>
</div>
<a class="anchor" id="a2179371efe6288654029b5796ac10fa2"></a><!-- doxytag: member="SAMRAI::tbox::AsyncCommGroup::beginGather" ref="a2179371efe6288654029b5796ac10fa2" args="(int *buffer, int size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SAMRAI::tbox::AsyncCommGroup::beginGather </td>
          <td>(</td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>size</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Begin a gather communication. </p>
<p>The gather operation mimics the results of MPI_Gather.</p>
<p>Sending processes of gather may send less data (smaller size) than receivers, in which case the missing data is considered irrelevant by the sender.</p>
<p>If this method returns false, <a class="el" href="classSAMRAI_1_1tbox_1_1AsyncCommGroup.html#a14b1c40af08d5be853ef33ccdde46489" title="Check the current gather communication and complete the gather if all MPI requests...">checkGather()</a> must be called until it returns true before any change in object state is allowed.</p>
<p>On non-root processes, buffer should contain the data to be gathered. On the root process, it should have enough space for all the data from all the processes in the group.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>buffer</em>&nbsp;</td><td>Data to gather.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>size</em>&nbsp;</td><td>Number of items contributed by each process. This must be the same across processes. However, the root's actual usable buffer must be big enough to hold the gathered data (size times the number of processes in the group).</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Whether operation is completed.</dd></dl>
<dl class="pre"><dt><b>Precondition:</b></dt><dd><a class="el" href="classSAMRAI_1_1tbox_1_1AsyncCommGroup.html#aaef1113ae55e6000c33197401fa7db62" title="Returns next task in a current communication operation.">getNextTaskOp()</a> == none </dd></dl>

<p>References <a class="el" href="AsyncCommGroup_8C_source.html#l00595">checkGather()</a>, <a class="el" href="SAMRAI__MPI_8h_source.html#l00233">SAMRAI::tbox::SAMRAI_MPI::getCommunicator()</a>, <a class="el" href="AsyncCommGroup_8h_source.html#l00215">getNextTaskOp()</a>, <a class="el" href="SAMRAI__MPI_8h_source.html#l00224">SAMRAI::tbox::SAMRAI_MPI::getSize()</a>, and <a class="el" href="Utilities_8h_source.html#l00060">TBOX_ERROR</a>.</p>

</div>
</div>
<a class="anchor" id="a14b1c40af08d5be853ef33ccdde46489"></a><!-- doxytag: member="SAMRAI::tbox::AsyncCommGroup::checkGather" ref="a14b1c40af08d5be853ef33ccdde46489" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SAMRAI::tbox::AsyncCommGroup::checkGather </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Check the current gather communication and complete the gather if all MPI requests are fulfilled. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Whether operation is completed.</dd></dl>
<dl class="pre"><dt><b>Precondition:</b></dt><dd><a class="el" href="classSAMRAI_1_1tbox_1_1AsyncCommGroup.html#af933f3b999fd68a44db1fe0e7e3c1117" title="Returns operation being performed.">getBaseOp()</a> == gather </dd></dl>

<p>References <a class="el" href="SAMRAI__MPI_8C_source.html#l00385">SAMRAI::tbox::SAMRAI_MPI::Get_count()</a>, <a class="el" href="AsyncCommGroup_8h_source.html#l00224">getBaseOp()</a>, <a class="el" href="SAMRAI__MPI_8h_source.html#l00233">SAMRAI::tbox::SAMRAI_MPI::getCommunicator()</a>, <a class="el" href="AsyncCommStage_8C_source.html#l00813">SAMRAI::tbox::AsyncCommStage::Member::getRequestPointer()</a>, <a class="el" href="SAMRAI__MPI_8C_source.html#l01028">SAMRAI::tbox::SAMRAI_MPI::Irecv()</a>, <a class="el" href="SAMRAI__MPI_8C_source.html#l00995">SAMRAI::tbox::SAMRAI_MPI::Isend()</a>, <a class="el" href="SAMRAI__MPI_8h_source.html#l00043">MPI_ERR_IN_STATUS</a>, <a class="el" href="SAMRAI__MPI_8h_source.html#l00138">SAMRAI::tbox::SAMRAI_MPI::Status::MPI_ERROR</a>, <a class="el" href="SAMRAI__MPI_8h_source.html#l00052">MPI_INT</a>, <a class="el" href="SAMRAI__MPI_8h_source.html#l00042">MPI_REQUEST_NULL</a>, <a class="el" href="SAMRAI__MPI_8h_source.html#l00136">SAMRAI::tbox::SAMRAI_MPI::Status::MPI_SOURCE</a>, <a class="el" href="SAMRAI__MPI_8h_source.html#l00039">MPI_SUCCESS</a>, <a class="el" href="SAMRAI__MPI_8h_source.html#l00137">SAMRAI::tbox::SAMRAI_MPI::Status::MPI_TAG</a>, <a class="el" href="namespaceSAMRAI_1_1tbox.html#ab84041705493761fb17a8127e3a2dca2">SAMRAI::tbox::plog</a>, <a class="el" href="SAMRAI__MPI_8C_source.html#l01154">SAMRAI::tbox::SAMRAI_MPI::Send()</a>, <a class="el" href="Utilities_8h_source.html#l00110">TBOX_ASSERT</a>, <a class="el" href="Utilities_8h_source.html#l00060">TBOX_ERROR</a>, and <a class="el" href="SAMRAI__MPI_8C_source.html#l00435">SAMRAI::tbox::SAMRAI_MPI::Test()</a>.</p>

<p>Referenced by <a class="el" href="AsyncCommGroup_8C_source.html#l00521">beginGather()</a>, and <a class="el" href="AsyncCommGroup_8C_source.html#l00206">proceedToNextWait()</a>.</p>

</div>
</div>
<a class="anchor" id="a8c793a5e0abe994ceb89d186dd21ff6c"></a><!-- doxytag: member="SAMRAI::tbox::AsyncCommGroup::beginSumReduce" ref="a8c793a5e0abe994ceb89d186dd21ff6c" args="(int *buffer, int size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SAMRAI::tbox::AsyncCommGroup::beginSumReduce </td>
          <td>(</td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>size</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Begin a sum reduce communication. </p>
<p>Assume all messages are the same size.</p>
<p>If this method returns false, <a class="el" href="classSAMRAI_1_1tbox_1_1AsyncCommGroup.html#a724bbf61b605419c2ac4d43748cdabbe" title="Check the current sum reduce communication and complete the sum reduce if all MPI...">checkSumReduce()</a> must be called until it returns true before any change in object state is allowed.</p>
<p>Buffer should contain the data to be gathered.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Whether operation is completed.</dd></dl>
<dl class="pre"><dt><b>Precondition:</b></dt><dd><a class="el" href="classSAMRAI_1_1tbox_1_1AsyncCommGroup.html#aaef1113ae55e6000c33197401fa7db62" title="Returns next task in a current communication operation.">getNextTaskOp()</a> == none </dd></dl>

<p>References <a class="el" href="SAMRAI__MPI_8h_source.html#l00233">SAMRAI::tbox::SAMRAI_MPI::getCommunicator()</a>, <a class="el" href="AsyncCommGroup_8h_source.html#l00215">getNextTaskOp()</a>, and <a class="el" href="Utilities_8h_source.html#l00060">TBOX_ERROR</a>.</p>

</div>
</div>
<a class="anchor" id="a724bbf61b605419c2ac4d43748cdabbe"></a><!-- doxytag: member="SAMRAI::tbox::AsyncCommGroup::checkSumReduce" ref="a724bbf61b605419c2ac4d43748cdabbe" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SAMRAI::tbox::AsyncCommGroup::checkSumReduce </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Check the current sum reduce communication and complete the sum reduce if all MPI requests are fulfilled. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Whether operation is completed. </dd></dl>

</div>
</div>
<a class="anchor" id="a85e2402d111fc0e5a15c2a23f3d63f96"></a><!-- doxytag: member="SAMRAI::tbox::AsyncCommGroup::proceedToNextWait" ref="a85e2402d111fc0e5a15c2a23f3d63f96" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SAMRAI::tbox::AsyncCommGroup::proceedToNextWait </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Check the current communication and complete it if all MPI requests are fulfilled. </p>

<p>Implements <a class="el" href="structSAMRAI_1_1tbox_1_1AsyncCommStage_1_1Member.html#afb9f55fd72f7f9713b0138e8cad7c87e">SAMRAI::tbox::AsyncCommStage::Member</a>.</p>

<p>References <a class="el" href="AsyncCommGroup_8C_source.html#l00322">checkBcast()</a>, <a class="el" href="AsyncCommGroup_8C_source.html#l00595">checkGather()</a>, <a class="el" href="SAMRAI__MPI_8h_source.html#l00233">SAMRAI::tbox::SAMRAI_MPI::getCommunicator()</a>, and <a class="el" href="Utilities_8h_source.html#l00060">TBOX_ERROR</a>.</p>

<p>Referenced by <a class="el" href="AsyncCommGroup_8C_source.html#l00255">completeCurrentOperation()</a>.</p>

</div>
</div>
<a class="anchor" id="a1bcf15f48abd8abdc052496fb76a1c25"></a><!-- doxytag: member="SAMRAI::tbox::AsyncCommGroup::isDone" ref="a1bcf15f48abd8abdc052496fb76a1c25" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SAMRAI::tbox::AsyncCommGroup::isDone </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Whether the last communication operation has finished. </p>
<p>This means more than just whether there is pending MPI requests such as that returned by <a class="el" href="structSAMRAI_1_1tbox_1_1AsyncCommStage_1_1Member.html#ae5ff4bfb5ee958425e2e8b35afe45f8e" title="Return whether the Member has some pending communication requests.">hasPendingRequests()</a>. The communication may be more complex, requiring several messages and copying of the received message into the correct buffer.</p>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>(<a class="el" href="classSAMRAI_1_1tbox_1_1AsyncCommGroup.html#aaef1113ae55e6000c33197401fa7db62" title="Returns next task in a current communication operation.">getNextTaskOp()</a> != none) || !hasPendingRequests() </dd></dl>

<p>Implements <a class="el" href="structSAMRAI_1_1tbox_1_1AsyncCommStage_1_1Member.html#a377ac960e58fbaa8c5d528c86c2d6100">SAMRAI::tbox::AsyncCommStage::Member</a>.</p>

<p>References <a class="el" href="AsyncCommGroup_8h_source.html#l00215">getNextTaskOp()</a>, <a class="el" href="AsyncCommStage_8C_source.html#l00778">SAMRAI::tbox::AsyncCommStage::Member::hasPendingRequests()</a>, and <a class="el" href="Utilities_8h_source.html#l00110">TBOX_ASSERT</a>.</p>

<p>Referenced by <a class="el" href="AsyncCommGroup_8C_source.html#l00175">initialize()</a>, <a class="el" href="AsyncCommGroup_8C_source.html#l01342">setMPITag()</a>, <a class="el" href="AsyncCommGroup_8C_source.html#l01357">setUseMPICollectiveForFullGroups()</a>, <a class="el" href="AsyncCommGroup_8C_source.html#l00157">~AsyncCommGroup()</a>, and <a class="el" href="BergerRigoutsosNode_8C_source.html#l00163">SAMRAI::mesh::BergerRigoutsosNode::~BergerRigoutsosNode()</a>.</p>

</div>
</div>
<a class="anchor" id="aeeb67c2ae16d7518bc700d4d9b0e20c5"></a><!-- doxytag: member="SAMRAI::tbox::AsyncCommGroup::completeCurrentOperation" ref="aeeb67c2ae16d7518bc700d4d9b0e20c5" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::tbox::AsyncCommGroup::completeCurrentOperation </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Wait for the current operation to complete. </p>

<p>Implements <a class="el" href="structSAMRAI_1_1tbox_1_1AsyncCommStage_1_1Member.html#a276cadf660e7cc5f1d302e2ac347bfd1">SAMRAI::tbox::AsyncCommStage::Member</a>.</p>

<p>References <a class="el" href="SAMRAI__MPI_8h_source.html#l00233">SAMRAI::tbox::SAMRAI_MPI::getCommunicator()</a>, <a class="el" href="AsyncCommStage_8C_source.html#l00813">SAMRAI::tbox::AsyncCommStage::Member::getRequestPointer()</a>, <a class="el" href="SAMRAI__MPI_8h_source.html#l00039">MPI_SUCCESS</a>, <a class="el" href="AsyncCommGroup_8C_source.html#l00206">proceedToNextWait()</a>, <a class="el" href="Utilities_8h_source.html#l00060">TBOX_ERROR</a>, and <a class="el" href="SAMRAI__MPI_8C_source.html#l00512">SAMRAI::tbox::SAMRAI_MPI::Waitall()</a>.</p>

</div>
</div>
<a class="anchor" id="a9ee3d6de2d490eb50fe9db359d5f8341"></a><!-- doxytag: member="SAMRAI::tbox::AsyncCommGroup::getNumberOfChildren" ref="a9ee3d6de2d490eb50fe9db359d5f8341" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int SAMRAI::tbox::AsyncCommGroup::getNumberOfChildren </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ad2596b98ef718fecd5f8891f6a4c9201"></a><!-- doxytag: member="SAMRAI::tbox::AsyncCommGroup::logCurrentState" ref="ad2596b98ef718fecd5f8891f6a4c9201" args="(std::ostream &amp;co) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::tbox::AsyncCommGroup::logCurrentState </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&nbsp;</td>
          <td class="paramname"> <em>co</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>References <a class="el" href="SAMRAI__MPI_8h_source.html#l00233">SAMRAI::tbox::SAMRAI_MPI::getCommunicator()</a>, and <a class="el" href="AsyncCommStage_8C_source.html#l00813">SAMRAI::tbox::AsyncCommStage::Member::getRequestPointer()</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>source/SAMRAI/tbox/<a class="el" href="AsyncCommGroup_8h.html">AsyncCommGroup.h</a></li>
<li>source/SAMRAI/tbox/<a class="el" href="AsyncCommGroup_8C.html">AsyncCommGroup.C</a></li>
</ul>
</div>
<hr size="1"/><address style="text-align: right;"><small>Generated on 3 Dec 2014 for SAMRAI by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.1 </small></address>
</body>
</html>
