<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>SAMRAI: SAMRAI::tbox::AsyncCommGroup Class Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.7 -->
<div class="tabs">
  <ul>
    <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="namespaces.html"><span>Namespaces</span></a></li>
    <li id="current"><a href="annotated.html"><span>Classes</span></a></li>
    <li><a href="files.html"><span>Files</span></a></li>
    <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
  </ul></div>
<div class="tabs">
  <ul>
    <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
    <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
    <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
  </ul></div>
<div class="nav">
<a class="el" href="namespaceSAMRAI.html">SAMRAI</a>::<a class="el" href="namespaceSAMRAI_1_1tbox.html">tbox</a>::<a class="el" href="classSAMRAI_1_1tbox_1_1AsyncCommGroup.html">AsyncCommGroup</a></div>
<h1>SAMRAI::tbox::AsyncCommGroup Class Reference</h1><!-- doxytag: class="SAMRAI::tbox::AsyncCommGroup" --><!-- doxytag: inherits="SAMRAI::tbox::AsyncCommStage::Member" -->Supports all-to-one and one-to-all asynchronous communication operations within a given group of processes by sending messages along the branches of a conceptual tree.  
<a href="#_details">More...</a>
<p>
<code>#include &lt;source/SAMRAI/tbox/AsyncCommGroup.h&gt;</code>
<p>
<p>Inheritance diagram for SAMRAI::tbox::AsyncCommGroup:
<p><center><img src="classSAMRAI_1_1tbox_1_1AsyncCommGroup.png" usemap="#SAMRAI::tbox::AsyncCommGroup_map" border="0" alt=""></center>
<map name="SAMRAI::tbox::AsyncCommGroup_map">
<area href="structSAMRAI_1_1tbox_1_1AsyncCommStage_1_1Member.html" alt="SAMRAI::tbox::AsyncCommStage::Member" shape="rect" coords="0,0,249,24">
</map>
<a href="classSAMRAI_1_1tbox_1_1AsyncCommGroup-members.html">List of all members.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1tbox_1_1AsyncCommGroup.html#d8a630b5a845c3858b6d8fb7049edb35">AsyncCommGroup</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Default constructor does not set up anything. You must <a class="el" href="classSAMRAI_1_1tbox_1_1AsyncCommGroup.html#92054b7a0619bf59eafef7e6d7fc9614">initialize()</a> the object before using it.  <a href="#d8a630b5a845c3858b6d8fb7049edb35"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1tbox_1_1AsyncCommGroup.html#8891057496e99d949ed6633096a3dcf4">AsyncCommGroup</a> (const size_t nchild, <a class="el" href="classSAMRAI_1_1tbox_1_1AsyncCommStage.html">AsyncCommStage</a> *stage, <a class="el" href="structSAMRAI_1_1tbox_1_1AsyncCommStage_1_1Handler.html">AsyncCommStage::Handler</a> *handler=NULL)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Construct communication group.  <a href="#8891057496e99d949ed6633096a3dcf4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1tbox_1_1AsyncCommGroup.html#ea4758e70c3ee13257cb04fe262291f7">~AsyncCommGroup</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Destructor.  <a href="#ea4758e70c3ee13257cb04fe262291f7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1tbox_1_1AsyncCommGroup.html#92054b7a0619bf59eafef7e6d7fc9614">initialize</a> (const int nchild, <a class="el" href="classSAMRAI_1_1tbox_1_1AsyncCommStage.html">AsyncCommStage</a> *stage, <a class="el" href="structSAMRAI_1_1tbox_1_1AsyncCommStage_1_1Handler.html">AsyncCommStage::Handler</a> *handler=NULL)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Initialize the object.  <a href="#92054b7a0619bf59eafef7e6d7fc9614"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1tbox_1_1AsyncCommGroup.html#4bf0558cac92526b0e000e72efbfcf8c">setMPITag</a> (const int mpi_tag)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the MPI tag used for communication within the group.  <a href="#4bf0558cac92526b0e000e72efbfcf8c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1tbox_1_1AsyncCommGroup.html#1106977ff3c89b06484449e784691fe8">setUseMPICollectiveForFullGroups</a> (bool use_mpi_collective=true)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set whether to use native MPI collective function calls when group includes all ranks in the MPI communicator.  <a href="#1106977ff3c89b06484449e784691fe8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1tbox_1_1AsyncCommGroup.html#62ec7934413b27f55cef1a7351577ca8">setUseBlockingSendToParent</a> (const bool flag)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set whether sends to parents should be blocking.  <a href="#62ec7934413b27f55cef1a7351577ca8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1tbox_1_1AsyncCommGroup.html#13fc47f58f61fdb68fcb963039a5b88f">setUseBlockingSendToChildren</a> (const bool flag)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set whether sends to children should be blocking.  <a href="#13fc47f58f61fdb68fcb963039a5b88f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1tbox_1_1AsyncCommGroup.html#0e14f541574e79e0003c17442ae9139e">getNumberOfChildren</a> () const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1tbox_1_1AsyncCommGroup.html#324e958f59593e4068af89b1642f14d6">logCurrentState</a> (std::ostream &amp;co) const </td></tr>

<tr><td colspan="2"><div class="groupHeader">Define the communication group</div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1tbox_1_1AsyncCommGroup.html#6d39465076a5c671dd975df4bf636aeb">setGroupAndRootIndex</a> (const <a class="el" href="classSAMRAI_1_1tbox_1_1SAMRAI__MPI.html">SAMRAI_MPI</a> &amp;mpi, const int *group_ranks, const int group_size, const int root_index)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Setup the tree for the given group of processes. The root process is specified by its index in the group array.  <a href="#6d39465076a5c671dd975df4bf636aeb"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1tbox_1_1AsyncCommGroup.html#c4340f04af16680af5f4ef720dea1990">setGroupAndRootRank</a> (const <a class="el" href="classSAMRAI_1_1tbox_1_1SAMRAI__MPI.html">SAMRAI_MPI</a> &amp;mpi, const int *group_ranks, const int group_size, const int root_rank)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Setup the group for the given group. The root process is specified by its rank.  <a href="#c4340f04af16680af5f4ef720dea1990"></a><br></td></tr>
<tr><td colspan="2"><div class="groupHeader">Communication methods</div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1tbox_1_1AsyncCommGroup.html#06b00398abb81df2b560aedf732ab2ff">beginBcast</a> (int *buffer, int size)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Begin a broadcast communication.  <a href="#06b00398abb81df2b560aedf732ab2ff"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1tbox_1_1AsyncCommGroup.html#2325f8028785df0a216026cab2d514a1">checkBcast</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Check the current broadcast communication and complete the broadcast if all MPI requests are fulfilled.  <a href="#2325f8028785df0a216026cab2d514a1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1tbox_1_1AsyncCommGroup.html#9c7d56cfca635e0bf22c60f90c9c19f3">beginGather</a> (int *buffer, int size)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Begin a gather communication.  <a href="#9c7d56cfca635e0bf22c60f90c9c19f3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1tbox_1_1AsyncCommGroup.html#6fa975a2c7d16210e87f81c1c6747b4a">checkGather</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Check the current gather communication and complete the gather if all MPI requests are fulfilled.  <a href="#6fa975a2c7d16210e87f81c1c6747b4a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1tbox_1_1AsyncCommGroup.html#b313138a5c769ea770c61d61ffbc3960">beginSumReduce</a> (int *buffer, int size)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Begin a sum reduce communication.  <a href="#b313138a5c769ea770c61d61ffbc3960"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1tbox_1_1AsyncCommGroup.html#a061fd02aa491ebfa92146d7f12e584f">checkSumReduce</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Check the current sum reduce communication and complete the sum reduce if all MPI requests are fulfilled.  <a href="#a061fd02aa491ebfa92146d7f12e584f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1tbox_1_1AsyncCommGroup.html#defc051a154c31e28cb0709552a5250f">proceedToNextWait</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Check the current communication and complete it if all MPI requests are fulfilled.  <a href="#defc051a154c31e28cb0709552a5250f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1tbox_1_1AsyncCommGroup.html#693ccf3a0b648a27baebba6263129746">isDone</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Whether the last communication operation has finished.  <a href="#693ccf3a0b648a27baebba6263129746"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1tbox_1_1AsyncCommGroup.html#a2e47f7dd4a2b518723664ebef6796a1">completeCurrentOperation</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Wait for the current operation to complete.  <a href="#a2e47f7dd4a2b518723664ebef6796a1"></a><br></td></tr>
</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
Supports all-to-one and one-to-all asynchronous communication operations within a given group of processes by sending messages along the branches of a conceptual tree. 
<p>
This class was created to perform certain group communications without using MPI global communications, which require creating new MPI communicators (can be expensive) and does not support asynchronous operations (until MPI-2).<p>
The supported communications are asynchronous in that you can start one and wait for it or check back on it occassionally until it completes. Simultaneous Asynchronous operations of many groups can be done by using a <a class="el" href="classSAMRAI_1_1tbox_1_1AsyncCommStage.html">AsyncCommStage</a> to allocate the groups and to check for completed communications.<p>
Supported operations are currently broadcast, gather and sum reduce. Only integer data is supported.<p>
A tree is an acyclic graph in which a node at position pos has nchild children, and the following positions for its<p>
<ul>
<li>parent: (pos-1)/nchild</li><li>first (oldest) child: pos*nchild+1</li><li>last (youngest) child: (pos+1)*nchild</li></ul>
<p>
For example, nchild=2 corresponds to a binary tree.<p>
Communication is done by sending messages toward the root (for all-to-one operations) or leaves (for one-to-all operations). For the former, we receive data from the children and send to the parent. For the latter, we receive from the parent and send to the children. Thus every communication involves a receive and a send (except at the root and leaf nodes of the tree).<p>
Using a tree generally gives better performance than having all processes in the the tree communicate directly with the root process. Using MPI communicators corresponding to the groups may faster than using this class, but the cost of creating MPI communicators MAY be expensive.<p>
This class supports communication and uses MPI for message passing. If MPI is disabled, the job of this class disappears and the class is effectively empty. The public interfaces still remain so the class can compile, but the implementations are trivial. 
<p>
<hr><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" name="d8a630b5a845c3858b6d8fb7049edb35"></a><!-- doxytag: member="SAMRAI::tbox::AsyncCommGroup::AsyncCommGroup" ref="d8a630b5a845c3858b6d8fb7049edb35" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SAMRAI::tbox::AsyncCommGroup::AsyncCommGroup           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Default constructor does not set up anything. You must <a class="el" href="classSAMRAI_1_1tbox_1_1AsyncCommGroup.html#92054b7a0619bf59eafef7e6d7fc9614">initialize()</a> the object before using it. 
<p>

</div>
</div><p>
<a class="anchor" name="8891057496e99d949ed6633096a3dcf4"></a><!-- doxytag: member="SAMRAI::tbox::AsyncCommGroup::AsyncCommGroup" ref="8891057496e99d949ed6633096a3dcf4" args="(const size_t nchild, AsyncCommStage *stage, AsyncCommStage::Handler *handler=NULL)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SAMRAI::tbox::AsyncCommGroup::AsyncCommGroup           </td>
          <td>(</td>
          <td class="paramtype">const size_t&nbsp;</td>
          <td class="paramname"> <em>nchild</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1tbox_1_1AsyncCommStage.html">AsyncCommStage</a> *&nbsp;</td>
          <td class="paramname"> <em>stage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSAMRAI_1_1tbox_1_1AsyncCommStage_1_1Handler.html">AsyncCommStage::Handler</a> *&nbsp;</td>
          <td class="paramname"> <em>handler</em> = <code>NULL</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Construct communication group. 
<p>
The number of children per node is flexible.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>nchild</em>&nbsp;</td><td>Number of children per tree node in the group, i.e., nchild=2 is a binary tree. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="ea4758e70c3ee13257cb04fe262291f7"></a><!-- doxytag: member="SAMRAI::tbox::AsyncCommGroup::~AsyncCommGroup" ref="ea4758e70c3ee13257cb04fe262291f7" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SAMRAI::tbox::AsyncCommGroup::~AsyncCommGroup           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Destructor. 
<p>

</div>
</div><p>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="92054b7a0619bf59eafef7e6d7fc9614"></a><!-- doxytag: member="SAMRAI::tbox::AsyncCommGroup::initialize" ref="92054b7a0619bf59eafef7e6d7fc9614" args="(const int nchild, AsyncCommStage *stage, AsyncCommStage::Handler *handler=NULL)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::tbox::AsyncCommGroup::initialize           </td>
          <td>(</td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>nchild</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1tbox_1_1AsyncCommStage.html">AsyncCommStage</a> *&nbsp;</td>
          <td class="paramname"> <em>stage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSAMRAI_1_1tbox_1_1AsyncCommStage_1_1Handler.html">AsyncCommStage::Handler</a> *&nbsp;</td>
          <td class="paramname"> <em>handler</em> = <code>NULL</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Initialize the object. 
<p>
Attach self to the given stage and set the Handler.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>nchild</em>&nbsp;</td><td>Number of children per tree node in the group, i.e., nchild=2 is a binary tree.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>stage</em>&nbsp;</td><td>The required stage used for completing non-blocking message passing calls.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>handler</em>&nbsp;</td><td>Optional handler (see <a class="el" href="structSAMRAI_1_1tbox_1_1AsyncCommStage_1_1Member.html">AsyncCommStage::Member</a>). </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="6d39465076a5c671dd975df4bf636aeb"></a><!-- doxytag: member="SAMRAI::tbox::AsyncCommGroup::setGroupAndRootIndex" ref="6d39465076a5c671dd975df4bf636aeb" args="(const SAMRAI_MPI &amp;mpi, const int *group_ranks, const int group_size, const int root_index)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::tbox::AsyncCommGroup::setGroupAndRootIndex           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1tbox_1_1SAMRAI__MPI.html">SAMRAI_MPI</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>mpi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&nbsp;</td>
          <td class="paramname"> <em>group_ranks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>group_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>root_index</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Setup the tree for the given group of processes. The root process is specified by its index in the group array. 
<p>
The root rank is specified by dereferencing <code>group</code> array with <code>root_index</code>. 
</div>
</div><p>
<a class="anchor" name="c4340f04af16680af5f4ef720dea1990"></a><!-- doxytag: member="SAMRAI::tbox::AsyncCommGroup::setGroupAndRootRank" ref="c4340f04af16680af5f4ef720dea1990" args="(const SAMRAI_MPI &amp;mpi, const int *group_ranks, const int group_size, const int root_rank)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::tbox::AsyncCommGroup::setGroupAndRootRank           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1tbox_1_1SAMRAI__MPI.html">SAMRAI_MPI</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>mpi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&nbsp;</td>
          <td class="paramname"> <em>group_ranks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>group_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>root_rank</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Setup the group for the given group. The root process is specified by its rank. 
<p>
The rank of the root is root_rank, which must be one of the ranks given in the group. 
</div>
</div><p>
<a class="anchor" name="4bf0558cac92526b0e000e72efbfcf8c"></a><!-- doxytag: member="SAMRAI::tbox::AsyncCommGroup::setMPITag" ref="4bf0558cac92526b0e000e72efbfcf8c" args="(const int mpi_tag)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SAMRAI_INLINE_KEYWORD void SAMRAI::tbox::AsyncCommGroup::setMPITag           </td>
          <td>(</td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>mpi_tag</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set the MPI tag used for communication within the group. 
<p>
<dl compact><dt><b>Attention:</b></dt><dd>This class is NOT (and cannot be) responsible for ensuring that the MPI communicator and tag are sufficient to select the correct messages. Please specify appropriate values for the MPI communicator and tag. Very elusive bugs can occur if incorrect messages are received. To be safe, it is best to create a new communicator to avoid interference with other communications within <a class="el" href="namespaceSAMRAI.html">SAMRAI</a>. </dd></dl>

</div>
</div><p>
<a class="anchor" name="1106977ff3c89b06484449e784691fe8"></a><!-- doxytag: member="SAMRAI::tbox::AsyncCommGroup::setUseMPICollectiveForFullGroups" ref="1106977ff3c89b06484449e784691fe8" args="(bool use_mpi_collective=true)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SAMRAI_INLINE_KEYWORD void SAMRAI::tbox::AsyncCommGroup::setUseMPICollectiveForFullGroups           </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>use_mpi_collective</em> = <code>true</code>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set whether to use native MPI collective function calls when group includes all ranks in the MPI communicator. 
<p>
This option is off by default to avoid MPI lock-ups. If you use it, make sure all processors can get to the collective operation to avoid lock-ups. 
</div>
</div><p>
<a class="anchor" name="62ec7934413b27f55cef1a7351577ca8"></a><!-- doxytag: member="SAMRAI::tbox::AsyncCommGroup::setUseBlockingSendToParent" ref="62ec7934413b27f55cef1a7351577ca8" args="(const bool flag)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SAMRAI_INLINE_KEYWORD void SAMRAI::tbox::AsyncCommGroup::setUseBlockingSendToParent           </td>
          <td>(</td>
          <td class="paramtype">const bool&nbsp;</td>
          <td class="paramname"> <em>flag</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set whether sends to parents should be blocking. 
<p>
The default is to use blocking send to parent. Because there is just one parent, short messages can be buffered by MPI to improve the performance of blocking sends. Blocking sends need not be checked for completion. 
</div>
</div><p>
<a class="anchor" name="13fc47f58f61fdb68fcb963039a5b88f"></a><!-- doxytag: member="SAMRAI::tbox::AsyncCommGroup::setUseBlockingSendToChildren" ref="13fc47f58f61fdb68fcb963039a5b88f" args="(const bool flag)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SAMRAI_INLINE_KEYWORD void SAMRAI::tbox::AsyncCommGroup::setUseBlockingSendToChildren           </td>
          <td>(</td>
          <td class="paramtype">const bool&nbsp;</td>
          <td class="paramname"> <em>flag</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set whether sends to children should be blocking. 
<p>
The default is to use nonblocking send to children. Nonblocking sends to children are generally appropriate as there are multiple children. 
</div>
</div><p>
<a class="anchor" name="06b00398abb81df2b560aedf732ab2ff"></a><!-- doxytag: member="SAMRAI::tbox::AsyncCommGroup::beginBcast" ref="06b00398abb81df2b560aedf732ab2ff" args="(int *buffer, int size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SAMRAI::tbox::AsyncCommGroup::beginBcast           </td>
          <td>(</td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>size</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Begin a broadcast communication. 
<p>
Root process of broadcast may send less data (smaller size) than receivers of broadcast, in which case the missing data is considered irrelevant by the root.<p>
If this method returns false, <a class="el" href="classSAMRAI_1_1tbox_1_1AsyncCommGroup.html#2325f8028785df0a216026cab2d514a1">checkBcast()</a> must be called until it returns true before any change in object state is allowed.<p>
<dl compact><dt><b>Returns:</b></dt><dd>Whether operation is completed. </dd></dl>

</div>
</div><p>
<a class="anchor" name="2325f8028785df0a216026cab2d514a1"></a><!-- doxytag: member="SAMRAI::tbox::AsyncCommGroup::checkBcast" ref="2325f8028785df0a216026cab2d514a1" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SAMRAI::tbox::AsyncCommGroup::checkBcast           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Check the current broadcast communication and complete the broadcast if all MPI requests are fulfilled. 
<p>
If no communication is in progress, this call does nothing.<p>
<dl compact><dt><b>Returns:</b></dt><dd>Whether operation is completed. </dd></dl>

</div>
</div><p>
<a class="anchor" name="9c7d56cfca635e0bf22c60f90c9c19f3"></a><!-- doxytag: member="SAMRAI::tbox::AsyncCommGroup::beginGather" ref="9c7d56cfca635e0bf22c60f90c9c19f3" args="(int *buffer, int size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SAMRAI::tbox::AsyncCommGroup::beginGather           </td>
          <td>(</td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>size</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Begin a gather communication. 
<p>
The gather operation mimics the results of MPI_Gather.<p>
Sending processes of gather may send less data (smaller size) than receivers, in which case the missing data is considered irrelevant by the sender.<p>
If this method returns false, <a class="el" href="classSAMRAI_1_1tbox_1_1AsyncCommGroup.html#6fa975a2c7d16210e87f81c1c6747b4a">checkGather()</a> must be called until it returns true before any change in object state is allowed.<p>
On non-root processes, buffer should contain the data to be gathered. On the root process, it should have enough space for all the data from all the processes in the group.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>buffer</em>&nbsp;</td><td>Data to gather.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>size</em>&nbsp;</td><td>Number of items contributed by each process. This must be the same across processes. However, the root's actual usable buffer must be big enough to hold the gathered data (size times the number of processes in the group).</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Whether operation is completed. </dd></dl>

</div>
</div><p>
<a class="anchor" name="6fa975a2c7d16210e87f81c1c6747b4a"></a><!-- doxytag: member="SAMRAI::tbox::AsyncCommGroup::checkGather" ref="6fa975a2c7d16210e87f81c1c6747b4a" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SAMRAI::tbox::AsyncCommGroup::checkGather           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Check the current gather communication and complete the gather if all MPI requests are fulfilled. 
<p>
<dl compact><dt><b>Returns:</b></dt><dd>Whether operation is completed. </dd></dl>

</div>
</div><p>
<a class="anchor" name="b313138a5c769ea770c61d61ffbc3960"></a><!-- doxytag: member="SAMRAI::tbox::AsyncCommGroup::beginSumReduce" ref="b313138a5c769ea770c61d61ffbc3960" args="(int *buffer, int size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SAMRAI::tbox::AsyncCommGroup::beginSumReduce           </td>
          <td>(</td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>size</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Begin a sum reduce communication. 
<p>
Assume all messages are the same size.<p>
If this method returns false, <a class="el" href="classSAMRAI_1_1tbox_1_1AsyncCommGroup.html#a061fd02aa491ebfa92146d7f12e584f">checkSumReduce()</a> must be called until it returns true before any change in object state is allowed.<p>
Buffer should contain the data to be gathered.<p>
<dl compact><dt><b>Returns:</b></dt><dd>Whether operation is completed. </dd></dl>

</div>
</div><p>
<a class="anchor" name="a061fd02aa491ebfa92146d7f12e584f"></a><!-- doxytag: member="SAMRAI::tbox::AsyncCommGroup::checkSumReduce" ref="a061fd02aa491ebfa92146d7f12e584f" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SAMRAI::tbox::AsyncCommGroup::checkSumReduce           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Check the current sum reduce communication and complete the sum reduce if all MPI requests are fulfilled. 
<p>
<dl compact><dt><b>Returns:</b></dt><dd>Whether operation is completed. </dd></dl>

</div>
</div><p>
<a class="anchor" name="defc051a154c31e28cb0709552a5250f"></a><!-- doxytag: member="SAMRAI::tbox::AsyncCommGroup::proceedToNextWait" ref="defc051a154c31e28cb0709552a5250f" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SAMRAI::tbox::AsyncCommGroup::proceedToNextWait           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Check the current communication and complete it if all MPI requests are fulfilled. 
<p>

<p>
Implements <a class="el" href="structSAMRAI_1_1tbox_1_1AsyncCommStage_1_1Member.html#cfd165b72b53fc4c7dd206bfd5490049">SAMRAI::tbox::AsyncCommStage::Member</a>.
</div>
</div><p>
<a class="anchor" name="693ccf3a0b648a27baebba6263129746"></a><!-- doxytag: member="SAMRAI::tbox::AsyncCommGroup::isDone" ref="693ccf3a0b648a27baebba6263129746" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SAMRAI_INLINE_KEYWORD bool SAMRAI::tbox::AsyncCommGroup::isDone           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Whether the last communication operation has finished. 
<p>
This means more than just whether there is pending MPI requests such as that returned by <a class="el" href="structSAMRAI_1_1tbox_1_1AsyncCommStage_1_1Member.html#c0a4ce0d28f253c9b3c909178c8e889a">hasPendingRequests()</a>. The communication may be more complex, requiring several messages and copying of the received message into the correct buffer. 
<p>
Implements <a class="el" href="structSAMRAI_1_1tbox_1_1AsyncCommStage_1_1Member.html#89d4ecc764d1b91a1082caaf08f008da">SAMRAI::tbox::AsyncCommStage::Member</a>.
</div>
</div><p>
<a class="anchor" name="a2e47f7dd4a2b518723664ebef6796a1"></a><!-- doxytag: member="SAMRAI::tbox::AsyncCommGroup::completeCurrentOperation" ref="a2e47f7dd4a2b518723664ebef6796a1" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::tbox::AsyncCommGroup::completeCurrentOperation           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Wait for the current operation to complete. 
<p>

<p>
Implements <a class="el" href="structSAMRAI_1_1tbox_1_1AsyncCommStage_1_1Member.html#656fcd6b8b0ac508d5b0134acc92b7b7">SAMRAI::tbox::AsyncCommStage::Member</a>.
</div>
</div><p>
<a class="anchor" name="0e14f541574e79e0003c17442ae9139e"></a><!-- doxytag: member="SAMRAI::tbox::AsyncCommGroup::getNumberOfChildren" ref="0e14f541574e79e0003c17442ae9139e" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SAMRAI_INLINE_KEYWORD int SAMRAI::tbox::AsyncCommGroup::getNumberOfChildren           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="324e958f59593e4068af89b1642f14d6"></a><!-- doxytag: member="SAMRAI::tbox::AsyncCommGroup::logCurrentState" ref="324e958f59593e4068af89b1642f14d6" args="(std::ostream &amp;co) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::tbox::AsyncCommGroup::logCurrentState           </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&nbsp;</td>
          <td class="paramname"> <em>co</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<hr>The documentation for this class was generated from the following files:<ul>
<li>source/SAMRAI/tbox/<a class="el" href="AsyncCommGroup_8h.html">AsyncCommGroup.h</a><li>source/SAMRAI/tbox/<a class="el" href="AsyncCommGroup_8C.html">AsyncCommGroup.C</a><li>source/SAMRAI/tbox/<a class="el" href="AsyncCommGroup_8I.html">AsyncCommGroup.I</a></ul>
<hr size="1"><address style="align: right;"><small>Generated on Wed Jan 18 16:05:19 2012 for SAMRAI by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.7 </small></address>
</body>
</html>
