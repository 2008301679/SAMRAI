<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>SAMRAI: SAMRAI::mesh::BaseGriddingAlgorithm&lt; DIM &gt; Class Template Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.2 -->
<div class="qindex"><a class="qindex" href="main.html">Main&nbsp;Page</a> | <a class="qindex" href="namespaces.html">Namespace List</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="namespacemembers.html">Namespace&nbsp;Members</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a> | <a class="qindex" href="globals.html">File&nbsp;Members</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a></div>
<div class="nav">
<a class="el" href="namespaceSAMRAI.html">SAMRAI</a>::<a class="el" href="namespaceSAMRAI_1_1mesh.html">mesh</a>::<a class="el" href="classSAMRAI_1_1mesh_1_1BaseGriddingAlgorithm.html">BaseGriddingAlgorithm</a></div>
<h1>SAMRAI::mesh::BaseGriddingAlgorithm&lt; DIM &gt; Class Template Reference</h1>Virtual base class providing interface for gridding algorithm.  
<a href="#_details">More...</a>
<p>
<code>#include &lt;source/mesh/gridding/BaseGriddingAlgorithm.h&gt;</code>
<p>
Inheritance diagram for SAMRAI::mesh::BaseGriddingAlgorithm&lt; DIM &gt;:<p><center><img src="classSAMRAI_1_1mesh_1_1BaseGriddingAlgorithm__inherit__graph.png" border="0" usemap="#SAMRAI_1_1mesh_1_1BaseGriddingAlgorithm_3_01DIM_01_4__inherit__map" alt="Inheritance graph"></center>
<map name="SAMRAI_1_1mesh_1_1BaseGriddingAlgorithm_3_01DIM_01_4__inherit__map">
<area href="classSAMRAI_1_1mblk_1_1MultiblockGriddingAlgorithm.html" shape="rect" coords="7,233,338,257" alt="">
<area href="classSAMRAI_1_1mesh_1_1GriddingAlgorithm.html" shape="rect" coords="362,233,637,257" alt="">
<area href="classSAMRAI_1_1tbox_1_1Serializable.html" shape="rect" coords="245,84,426,108" alt="">
<area href="classtbox_1_1DescribedClass.html" shape="rect" coords="278,9,393,33" alt="">
</map>
<center><font size="2">[<a target="top" href="graph_legend.html">legend</a>]</font></center><a href="classSAMRAI_1_1mesh_1_1BaseGriddingAlgorithm-members.html">List of all members.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1mesh_1_1BaseGriddingAlgorithm.html#a0">BaseGriddingAlgorithm</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Default constructor.  <a href="#a0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1mesh_1_1BaseGriddingAlgorithm.html#a1">~BaseGriddingAlgorithm</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Virtual destructor for BaseGriddingAlgorithm&lt;DIM&gt;.  <a href="#a1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1mesh_1_1BaseGriddingAlgorithm.html#a2">makeCoarsestLevel</a> (<a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1BasePatchHierarchy.html">hier::BasePatchHierarchy</a>&lt; DIM &gt; &gt; hierarchy, const double level_time)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Construct the coarsest level in a hierarchy (i.e., level 0).  <a href="#a2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1mesh_1_1BaseGriddingAlgorithm.html#a3">makeFinerLevel</a> (<a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1BasePatchHierarchy.html">hier::BasePatchHierarchy</a>&lt; DIM &gt; &gt; hierarchy, const double level_time, const bool initial_time, const int tag_buffer, const double regrid_start_time=0.)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This routine attempts to create a new level in a hierarchy finer than the finest level currently residing in the hierarchy.  <a href="#a3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1mesh_1_1BaseGriddingAlgorithm.html#a4">regridAllFinerLevels</a> (<a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1BasePatchHierarchy.html">hier::BasePatchHierarchy</a>&lt; DIM &gt; &gt; hierarchy, const int level_number, const double regrid_time, const <a class="el" href="classSAMRAI_1_1tbox_1_1Array.html">tbox::Array</a>&lt; int &gt; &amp;tag_buffer, <a class="el" href="classSAMRAI_1_1tbox_1_1Array.html">tbox::Array</a>&lt; double &gt; regrid_start_time=<a class="el" href="classSAMRAI_1_1tbox_1_1Array.html">tbox::Array</a>&lt; double &gt;(), const bool level_is_coarsest_to_sync=true)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This routine attempts to reconfigure the patches on each level in an AMR patch hierarchy which is finer than the specified level.  <a href="#a4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1mesh_1_1BaseGriddingAlgorithm.html#a5">errorEstimationUsesTimeIntegration</a> () const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return true if error estimation process uses time integration; otherwise, return false.  <a href="#a5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1mesh_1_1BaseGriddingAlgorithm.html#a6">getErrorCoarsenRatio</a> () const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the error coarsen ratio.  <a href="#a6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1mesh_1_1BaseGriddingAlgorithm.html#a7">levelCanBeRefined</a> (const int level_number) const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return true if level associated with the specified level number can be refined; i.e., the level number is less than that of the finest level allowed in the hierarchy. Otherwise, false is returned.  <a href="#a7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1mesh_1_1TagAndInitializeStrategy.html">TagAndInitializeStrategy</a>&lt;<br>
 DIM &gt; &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1mesh_1_1BaseGriddingAlgorithm.html#a8">getTagAndInitializeStrategy</a> () const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return pointer to level gridding strategy data member.  <a href="#a8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1mesh_1_1BaseGriddingAlgorithm.html#a9">getMaxLevels</a> () const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return maximum number of levels allowed in hierarchy.  <a href="#a9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a>&lt;<br>
 DIM &gt; &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1mesh_1_1BaseGriddingAlgorithm.html#a10">getRatioToCoarserLevel</a> (const int level_number) const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return const reference to ratio between specified level and next coarser.  <a href="#a10"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1mesh_1_1BaseGriddingAlgorithm.html#a11">getEfficiencyTolerance</a> (const int level_number) const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return efficiency tolerance for clustering tags on level.  <a href="#a11"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1mesh_1_1BaseGriddingAlgorithm.html#a12">getCombineEfficiency</a> (const int level_number) const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return combine efficiency for clustering tags on level.  <a href="#a12"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1mesh_1_1BaseGriddingAlgorithm.html#a13">getProperNestingBuffer</a> (const int level_number) const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return proper nesting buffer width for level.  <a href="#a13"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1mesh_1_1BaseGriddingAlgorithm.html#a14">putToDatabase</a> (<a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Database.html">tbox::Database</a> &gt; db)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Write object state out to the given database.  <a href="#a14"></a><br></td></tr>
</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
<h3>template&lt;int DIM&gt;<br>
 class SAMRAI::mesh::BaseGriddingAlgorithm&lt; DIM &gt;</h3>

Virtual base class providing interface for gridding algorithm. 
<p>
Class <a class="el" href="classSAMRAI_1_1mesh_1_1BaseGriddingAlgorithm.html">BaseGriddingAlgorithm</a> in a virtual base class that provides an abstract interface for a gridding algorithm. This allows higher-level classes in <a class="el" href="namespaceSAMRAI.html">SAMRAI</a> and in applications that use <a class="el" href="namespaceSAMRAI.html">SAMRAI</a> to interface with a gridding algorithm in an abstract manner without knowing whether it is a <a class="el" href="classSAMRAI_1_1mesh_1_1GriddingAlgorithm.html">mesh::GriddingAlgorithm</a> that handles gridding operations on a rectangular domain or if it is an algorithm for gridding on, for example, a multiblock domain.<p>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classSAMRAI_1_1mesh_1_1GriddingAlgorithm.html">mesh::GriddingAlgorithm</a> </dd></dl>

<p>
<hr><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" name="a0" doxytag="SAMRAI::mesh::BaseGriddingAlgorithm::BaseGriddingAlgorithm"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="mdPrefix" colspan="4">
template&lt;int DIM&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="classSAMRAI_1_1mesh_1_1BaseGriddingAlgorithm.html">SAMRAI::mesh::BaseGriddingAlgorithm</a>&lt; DIM &gt;::<a class="el" href="classSAMRAI_1_1mesh_1_1BaseGriddingAlgorithm.html">BaseGriddingAlgorithm</a>           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Default constructor. 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="a1" doxytag="SAMRAI::mesh::BaseGriddingAlgorithm::~BaseGriddingAlgorithm"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="mdPrefix" colspan="4">
template&lt;int DIM&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="classSAMRAI_1_1mesh_1_1BaseGriddingAlgorithm.html">SAMRAI::mesh::BaseGriddingAlgorithm</a>&lt; DIM &gt;::~<a class="el" href="classSAMRAI_1_1mesh_1_1BaseGriddingAlgorithm.html">BaseGriddingAlgorithm</a>           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Virtual destructor for BaseGriddingAlgorithm&lt;DIM&gt;. 
<p>
    </td>
  </tr>
</table>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="a2" doxytag="SAMRAI::mesh::BaseGriddingAlgorithm::makeCoarsestLevel"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="mdPrefix" colspan="4">
template&lt;int DIM&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top">virtual void <a class="el" href="classSAMRAI_1_1mesh_1_1BaseGriddingAlgorithm.html">SAMRAI::mesh::BaseGriddingAlgorithm</a>&lt; DIM &gt;::makeCoarsestLevel           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1BasePatchHierarchy.html">hier::BasePatchHierarchy</a>&lt; DIM &gt; &gt;&nbsp;</td>
          <td class="mdname" nowrap> <em>hierarchy</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const double&nbsp;</td>
          <td class="mdname" nowrap> <em>level_time</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Construct the coarsest level in a hierarchy (i.e., level 0). 
<p>
If level 0 does not already exist, then the domain specification is checked against the constraints of the grid generation procedures. The level gridding strategy data member defines these constraints. Recall that the domain specification is maintained by the grid geometry associated with the hierarchy. Generally, an unrecoverable exception will result if the constraints are not satisfied.<p>
If level 0 already exists in the hierarchy, then the routine will generate a new level by re-applying the load balancing procedure to the existing level. Data will be moved from the old level to the new level and the pre-existing level 0 will be discarded. Note that this routine is different than the routine <a class="el" href="classSAMRAI_1_1mesh_1_1BaseGriddingAlgorithm.html#a3">makeFinerLevel()</a> below, which is used to construct levels 1 and finer. In particular, this routine does not select cells for refinement, whereas the other routine does.<p>
Important note: If assertion checking is turned on, then an unrecoverable assertion will result if either the patch hierarchy or its grid geometry is NULL.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hierarchy</em>&nbsp;</td><td>The hierarchy on which coarse level is constructed. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>level_time</em>&nbsp;</td><td>Simulation time when level is constructed </td></tr>
  </table>
</dl>

<p>
Implemented in <a class="el" href="classSAMRAI_1_1mesh_1_1GriddingAlgorithm.html#a2">SAMRAI::mesh::GriddingAlgorithm&lt; DIM &gt;</a>, and <a class="el" href="classSAMRAI_1_1mblk_1_1MultiblockGriddingAlgorithm.html#a2">SAMRAI::mblk::MultiblockGriddingAlgorithm&lt; DIM &gt;</a>.    </td>
  </tr>
</table>
<a class="anchor" name="a3" doxytag="SAMRAI::mesh::BaseGriddingAlgorithm::makeFinerLevel"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="mdPrefix" colspan="4">
template&lt;int DIM&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top">virtual void <a class="el" href="classSAMRAI_1_1mesh_1_1BaseGriddingAlgorithm.html">SAMRAI::mesh::BaseGriddingAlgorithm</a>&lt; DIM &gt;::makeFinerLevel           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1BasePatchHierarchy.html">hier::BasePatchHierarchy</a>&lt; DIM &gt; &gt;&nbsp;</td>
          <td class="mdname" nowrap> <em>hierarchy</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const double&nbsp;</td>
          <td class="mdname" nowrap> <em>level_time</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const bool&nbsp;</td>
          <td class="mdname" nowrap> <em>initial_time</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const int&nbsp;</td>
          <td class="mdname" nowrap> <em>tag_buffer</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const double&nbsp;</td>
          <td class="mdname" nowrap> <em>regrid_start_time</em> = <code>0.</code></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This routine attempts to create a new level in a hierarchy finer than the finest level currently residing in the hierarchy. 
<p>
It will select cells for refinement on the finest level and construct a new finest level, if necessary. If no cells are selected for refinement, no new level will be added to the hierarchy. The boolean argument initial_time indicates whether the routine is called at the initial simulation time. If true, this routine is used to build individual levels during the construction of the AMR hierarchy at the initial simulation time. If false, the routine is being used to add new levels to the hierarchy at some later point. In either case, the time value is the current simulation time. Note that this routine cannot be used to construct the coarsest level in the hierarchy (i.e., level 0). The routine <a class="el" href="classSAMRAI_1_1mesh_1_1BaseGriddingAlgorithm.html#a2">makeCoarsestLevel()</a> above must be used for that purpose.<p>
The tag buffer indicates the number of cells by which cells selected for refinement will be buffered before new finer level boxes are constructed. The buffer is important to keep phenomena of interest on refined regions of the mesh until adaptive regridding occurs next. Thus, the buffer size should take into account how the simulation may evolve before regridding occurs (<a class="el" href="solv__cartesianrobinbchelper3d_8f.html#a8">e.g</a>., number of timesteps taken).<p>
Important note: If assertion checking is activated, several checks are applied to the functions arguments. If any check is violated, an unrecoverable assertion will result. In particular, the hierarchy pointer must be non-NULL and the given level number must match that of the finest level currently residing in the hierarchy. Also, the the tag buffer must be positive.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hierarchy</em>&nbsp;</td><td>The hierarchy on which coarse level is constructed. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>level_time</em>&nbsp;</td><td>Simulation time when level is constructed </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>initial_time</em>&nbsp;</td><td>Must be true if level_time is the initial time of the simulation, false otherwise </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>tag_buffer</em>&nbsp;</td><td>Size of buffer around tagged cells that will be covered by the fine level </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>regrid_start_time</em>&nbsp;</td><td>The simulation time when the regridding operation began (this parameter is ignored except when using Richardson extrapolation) </td></tr>
  </table>
</dl>

<p>
Implemented in <a class="el" href="classSAMRAI_1_1mesh_1_1GriddingAlgorithm.html#a3">SAMRAI::mesh::GriddingAlgorithm&lt; DIM &gt;</a>, and <a class="el" href="classSAMRAI_1_1mblk_1_1MultiblockGriddingAlgorithm.html#a3">SAMRAI::mblk::MultiblockGriddingAlgorithm&lt; DIM &gt;</a>.    </td>
  </tr>
</table>
<a class="anchor" name="a4" doxytag="SAMRAI::mesh::BaseGriddingAlgorithm::regridAllFinerLevels"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="mdPrefix" colspan="4">
template&lt;int DIM&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top">virtual void <a class="el" href="classSAMRAI_1_1mesh_1_1BaseGriddingAlgorithm.html">SAMRAI::mesh::BaseGriddingAlgorithm</a>&lt; DIM &gt;::regridAllFinerLevels           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1BasePatchHierarchy.html">hier::BasePatchHierarchy</a>&lt; DIM &gt; &gt;&nbsp;</td>
          <td class="mdname" nowrap> <em>hierarchy</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const int&nbsp;</td>
          <td class="mdname" nowrap> <em>level_number</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const double&nbsp;</td>
          <td class="mdname" nowrap> <em>regrid_time</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const <a class="el" href="classSAMRAI_1_1tbox_1_1Array.html">tbox::Array</a>&lt; int &gt; &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>tag_buffer</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="classSAMRAI_1_1tbox_1_1Array.html">tbox::Array</a>&lt; double &gt;&nbsp;</td>
          <td class="mdname" nowrap> <em>regrid_start_time</em> = <code><a class="el" href="classSAMRAI_1_1tbox_1_1Array.html">tbox::Array</a>&lt;&nbsp;double&nbsp;&gt;()</code>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const bool&nbsp;</td>
          <td class="mdname" nowrap> <em>level_is_coarsest_to_sync</em> = <code>true</code></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This routine attempts to reconfigure the patches on each level in an AMR patch hierarchy which is finer than the specified level. 
<p>
The given level number is that of the coarsest level on which cells will be selected for refinement. In other words, that level is the finest level that will not be subject to a change in its patch configuration during the regridding process. Generally, this routine should be used to alter a pre-existing AMR patch hierarchy based on the need to adapt the computational mesh around some phenomenon of interest. The routine <a class="el" href="classSAMRAI_1_1mesh_1_1BaseGriddingAlgorithm.html#a3">makeFinerLevel()</a> above should be used to construct an initial hierarchy configuration or to add more than one new level into the hierarchy. Also, this routine will not reconfigure the patches on level 0 (i.e., the coarsest in any hierarchy). The routine <a class="el" href="classSAMRAI_1_1mesh_1_1BaseGriddingAlgorithm.html#a2">makeCoarsestLevel()</a> above is provided for that purpose.<p>
Note that the current algorithm permits at most one new finest level to be added to the hierarchy with each invocation of the regridding process. This constraint, though seemingly restrictive makes the process of maintaining properly nested levels much easier.<p>
The tag buffer array indicates the number of cells by which cells selected for refinement on a level will be buffered before new finer level boxes are constructed. The buffer is important to keep phenomena of interest on refined regions of the mesh until adaptive regridding occurs next. Thus, the buffer size should take into account how the simulation may evolve before regridding occurs (<a class="el" href="solv__cartesianrobinbchelper3d_8f.html#a8">e.g</a>., number of timesteps taken on each level).<p>
The boolean argument is used for regridding in time-dependent problems. When true, it indicates that the specified level is the coarsest level to synchronize at the current regrid time before this regridding method is called. This is a pretty idiosyncratic argument but allows some flexibility in the way memory is managed during time-dependent regridding operations.<p>
Important note: If assertion checking is activated, several checks are applied to the functions arguments. If any check is violated, an unrecoverable assertion will result. In particular, the hierarchy pointer must be non-NULL and the given level number must match that of of some level in the hierarchy. Also, the tag buffer array must contain a positive value for each level in the hierarchy.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hierarchy</em>&nbsp;</td><td>The hierarchy on which coarse level is constructed. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>level_number</em>&nbsp;</td><td>Coarsest level on which cells will be tagged for refinement </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>regrid_time</em>&nbsp;</td><td>Simulaition time when regridding occurs </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>tag_buffer</em>&nbsp;</td><td>Size of buffer on each level around tagged cells that will be covered by the next finer level </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>regrid_start_time</em>&nbsp;</td><td>The simulation time when the regridding operation began on each level (this parameter is ignored except when using Richardson extrapolation) </td></tr>
  </table>
</dl>

<p>
Implemented in <a class="el" href="classSAMRAI_1_1mesh_1_1GriddingAlgorithm.html#a4">SAMRAI::mesh::GriddingAlgorithm&lt; DIM &gt;</a>, and <a class="el" href="classSAMRAI_1_1mblk_1_1MultiblockGriddingAlgorithm.html#a4">SAMRAI::mblk::MultiblockGriddingAlgorithm&lt; DIM &gt;</a>.    </td>
  </tr>
</table>
<a class="anchor" name="a5" doxytag="SAMRAI::mesh::BaseGriddingAlgorithm::errorEstimationUsesTimeIntegration"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="mdPrefix" colspan="4">
template&lt;int DIM&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top">virtual bool <a class="el" href="classSAMRAI_1_1mesh_1_1BaseGriddingAlgorithm.html">SAMRAI::mesh::BaseGriddingAlgorithm</a>&lt; DIM &gt;::errorEstimationUsesTimeIntegration           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const<code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Return true if error estimation process uses time integration; otherwise, return false. 
<p>

<p>
Implemented in <a class="el" href="classSAMRAI_1_1mesh_1_1GriddingAlgorithm.html#a5">SAMRAI::mesh::GriddingAlgorithm&lt; DIM &gt;</a>, and <a class="el" href="classSAMRAI_1_1mblk_1_1MultiblockGriddingAlgorithm.html#a5">SAMRAI::mblk::MultiblockGriddingAlgorithm&lt; DIM &gt;</a>.    </td>
  </tr>
</table>
<a class="anchor" name="a6" doxytag="SAMRAI::mesh::BaseGriddingAlgorithm::getErrorCoarsenRatio"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="mdPrefix" colspan="4">
template&lt;int DIM&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top">virtual int <a class="el" href="classSAMRAI_1_1mesh_1_1BaseGriddingAlgorithm.html">SAMRAI::mesh::BaseGriddingAlgorithm</a>&lt; DIM &gt;::getErrorCoarsenRatio           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const<code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Return the error coarsen ratio. 
<p>
This is needed for cases where an error estimation scheme uses time integration (<a class="el" href="solv__cartesianrobinbchelper3d_8f.html#a8">e.g</a>. Richardson extrapolation) to determine how many time levels to maintain to properly apply the estimtion scheme. In general, an even refine ratio (<a class="el" href="solv__cartesianrobinbchelper3d_8f.html#a8">e.g</a>. 2, 4, 8) will maintain two time levels, while while an odd refine ratio (<a class="el" href="solv__cartesianrobinbchelper3d_8f.html#a8">e.g</a>. 3) will maintain three. 
<p>
Implemented in <a class="el" href="classSAMRAI_1_1mesh_1_1GriddingAlgorithm.html#a6">SAMRAI::mesh::GriddingAlgorithm&lt; DIM &gt;</a>, and <a class="el" href="classSAMRAI_1_1mblk_1_1MultiblockGriddingAlgorithm.html#a6">SAMRAI::mblk::MultiblockGriddingAlgorithm&lt; DIM &gt;</a>.    </td>
  </tr>
</table>
<a class="anchor" name="a7" doxytag="SAMRAI::mesh::BaseGriddingAlgorithm::levelCanBeRefined"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="mdPrefix" colspan="4">
template&lt;int DIM&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top">virtual bool <a class="el" href="classSAMRAI_1_1mesh_1_1BaseGriddingAlgorithm.html">SAMRAI::mesh::BaseGriddingAlgorithm</a>&lt; DIM &gt;::levelCanBeRefined           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const int&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>level_number</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const<code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Return true if level associated with the specified level number can be refined; i.e., the level number is less than that of the finest level allowed in the hierarchy. Otherwise, false is returned. 
<p>

<p>
Implemented in <a class="el" href="classSAMRAI_1_1mesh_1_1GriddingAlgorithm.html#a7">SAMRAI::mesh::GriddingAlgorithm&lt; DIM &gt;</a>, and <a class="el" href="classSAMRAI_1_1mblk_1_1MultiblockGriddingAlgorithm.html#a7">SAMRAI::mblk::MultiblockGriddingAlgorithm&lt; DIM &gt;</a>.    </td>
  </tr>
</table>
<a class="anchor" name="a8" doxytag="SAMRAI::mesh::BaseGriddingAlgorithm::getTagAndInitializeStrategy"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="mdPrefix" colspan="4">
template&lt;int DIM&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top">virtual <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1mesh_1_1TagAndInitializeStrategy.html">TagAndInitializeStrategy</a>&lt;DIM&gt; &gt; <a class="el" href="classSAMRAI_1_1mesh_1_1BaseGriddingAlgorithm.html">SAMRAI::mesh::BaseGriddingAlgorithm</a>&lt; DIM &gt;::getTagAndInitializeStrategy           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const<code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Return pointer to level gridding strategy data member. 
<p>

<p>
Implemented in <a class="el" href="classSAMRAI_1_1mesh_1_1GriddingAlgorithm.html#a8">SAMRAI::mesh::GriddingAlgorithm&lt; DIM &gt;</a>, and <a class="el" href="classSAMRAI_1_1mblk_1_1MultiblockGriddingAlgorithm.html#a8">SAMRAI::mblk::MultiblockGriddingAlgorithm&lt; DIM &gt;</a>.    </td>
  </tr>
</table>
<a class="anchor" name="a9" doxytag="SAMRAI::mesh::BaseGriddingAlgorithm::getMaxLevels"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="mdPrefix" colspan="4">
template&lt;int DIM&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top">virtual int <a class="el" href="classSAMRAI_1_1mesh_1_1BaseGriddingAlgorithm.html">SAMRAI::mesh::BaseGriddingAlgorithm</a>&lt; DIM &gt;::getMaxLevels           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const<code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Return maximum number of levels allowed in hierarchy. 
<p>

<p>
Implemented in <a class="el" href="classSAMRAI_1_1mesh_1_1GriddingAlgorithm.html#a10">SAMRAI::mesh::GriddingAlgorithm&lt; DIM &gt;</a>, and <a class="el" href="classSAMRAI_1_1mblk_1_1MultiblockGriddingAlgorithm.html#a9">SAMRAI::mblk::MultiblockGriddingAlgorithm&lt; DIM &gt;</a>.    </td>
  </tr>
</table>
<a class="anchor" name="a10" doxytag="SAMRAI::mesh::BaseGriddingAlgorithm::getRatioToCoarserLevel"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="mdPrefix" colspan="4">
template&lt;int DIM&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top">virtual const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a>&lt;DIM&gt;&amp; <a class="el" href="classSAMRAI_1_1mesh_1_1BaseGriddingAlgorithm.html">SAMRAI::mesh::BaseGriddingAlgorithm</a>&lt; DIM &gt;::getRatioToCoarserLevel           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const int&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>level_number</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const<code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Return const reference to ratio between specified level and next coarser. 
<p>

<p>
Implemented in <a class="el" href="classSAMRAI_1_1mesh_1_1GriddingAlgorithm.html#a11">SAMRAI::mesh::GriddingAlgorithm&lt; DIM &gt;</a>, and <a class="el" href="classSAMRAI_1_1mblk_1_1MultiblockGriddingAlgorithm.html#a10">SAMRAI::mblk::MultiblockGriddingAlgorithm&lt; DIM &gt;</a>.    </td>
  </tr>
</table>
<a class="anchor" name="a11" doxytag="SAMRAI::mesh::BaseGriddingAlgorithm::getEfficiencyTolerance"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="mdPrefix" colspan="4">
template&lt;int DIM&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top">virtual double <a class="el" href="classSAMRAI_1_1mesh_1_1BaseGriddingAlgorithm.html">SAMRAI::mesh::BaseGriddingAlgorithm</a>&lt; DIM &gt;::getEfficiencyTolerance           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const int&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>level_number</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const<code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Return efficiency tolerance for clustering tags on level. 
<p>

<p>
Implemented in <a class="el" href="classSAMRAI_1_1mesh_1_1GriddingAlgorithm.html#a12">SAMRAI::mesh::GriddingAlgorithm&lt; DIM &gt;</a>, and <a class="el" href="classSAMRAI_1_1mblk_1_1MultiblockGriddingAlgorithm.html#a11">SAMRAI::mblk::MultiblockGriddingAlgorithm&lt; DIM &gt;</a>.    </td>
  </tr>
</table>
<a class="anchor" name="a12" doxytag="SAMRAI::mesh::BaseGriddingAlgorithm::getCombineEfficiency"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="mdPrefix" colspan="4">
template&lt;int DIM&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top">virtual double <a class="el" href="classSAMRAI_1_1mesh_1_1BaseGriddingAlgorithm.html">SAMRAI::mesh::BaseGriddingAlgorithm</a>&lt; DIM &gt;::getCombineEfficiency           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const int&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>level_number</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const<code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Return combine efficiency for clustering tags on level. 
<p>

<p>
Implemented in <a class="el" href="classSAMRAI_1_1mesh_1_1GriddingAlgorithm.html#a13">SAMRAI::mesh::GriddingAlgorithm&lt; DIM &gt;</a>, and <a class="el" href="classSAMRAI_1_1mblk_1_1MultiblockGriddingAlgorithm.html#a12">SAMRAI::mblk::MultiblockGriddingAlgorithm&lt; DIM &gt;</a>.    </td>
  </tr>
</table>
<a class="anchor" name="a13" doxytag="SAMRAI::mesh::BaseGriddingAlgorithm::getProperNestingBuffer"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="mdPrefix" colspan="4">
template&lt;int DIM&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top">virtual int <a class="el" href="classSAMRAI_1_1mesh_1_1BaseGriddingAlgorithm.html">SAMRAI::mesh::BaseGriddingAlgorithm</a>&lt; DIM &gt;::getProperNestingBuffer           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const int&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>level_number</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const<code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Return proper nesting buffer width for level. 
<p>

<p>
Implemented in <a class="el" href="classSAMRAI_1_1mesh_1_1GriddingAlgorithm.html#a14">SAMRAI::mesh::GriddingAlgorithm&lt; DIM &gt;</a>, and <a class="el" href="classSAMRAI_1_1mblk_1_1MultiblockGriddingAlgorithm.html#a13">SAMRAI::mblk::MultiblockGriddingAlgorithm&lt; DIM &gt;</a>.    </td>
  </tr>
</table>
<a class="anchor" name="a14" doxytag="SAMRAI::mesh::BaseGriddingAlgorithm::putToDatabase"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="mdPrefix" colspan="4">
template&lt;int DIM&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top">virtual void <a class="el" href="classSAMRAI_1_1mesh_1_1BaseGriddingAlgorithm.html">SAMRAI::mesh::BaseGriddingAlgorithm</a>&lt; DIM &gt;::putToDatabase           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Database.html">tbox::Database</a> &gt;&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>db</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Write object state out to the given database. 
<p>
When assertion checking is active, the database pointer must be non-null. 
<p>
Implemented in <a class="el" href="classSAMRAI_1_1mesh_1_1GriddingAlgorithm.html#a18">SAMRAI::mesh::GriddingAlgorithm&lt; DIM &gt;</a>, and <a class="el" href="classSAMRAI_1_1mblk_1_1MultiblockGriddingAlgorithm.html#a16">SAMRAI::mblk::MultiblockGriddingAlgorithm&lt; DIM &gt;</a>.    </td>
  </tr>
</table>
<hr>The documentation for this class was generated from the following files:<ul>
<li>source/mesh/gridding/<a class="el" href="BaseGriddingAlgorithm_8h.html">BaseGriddingAlgorithm.h</a><li>source/mesh/gridding/<a class="el" href="BaseGriddingAlgorithm_8C.html">BaseGriddingAlgorithm.C</a></ul>
<hr size="1"><address style="align: right;"><small>Generated on Fri Dec 2 11:28:39 2005 for SAMRAI by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.2 </small></address>
</body>
</html>
