<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>SAMRAI: SAMRAI::hier::BaseGridGeometry Class Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.7 -->
<div class="tabs">
  <ul>
    <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="namespaces.html"><span>Namespaces</span></a></li>
    <li id="current"><a href="annotated.html"><span>Classes</span></a></li>
    <li><a href="files.html"><span>Files</span></a></li>
    <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
  </ul></div>
<div class="tabs">
  <ul>
    <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
    <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
    <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
  </ul></div>
<div class="nav">
<a class="el" href="namespaceSAMRAI.html">SAMRAI</a>::<a class="el" href="namespaceSAMRAI_1_1hier.html">hier</a>::<a class="el" href="classSAMRAI_1_1hier_1_1BaseGridGeometry.html">BaseGridGeometry</a></div>
<h1>SAMRAI::hier::BaseGridGeometry Class Reference</h1><!-- doxytag: class="SAMRAI::hier::BaseGridGeometry" --><!-- doxytag: inherits="SAMRAI::tbox::Serializable" -->Class <a class="el" href="classSAMRAI_1_1hier_1_1BaseGridGeometry.html">BaseGridGeometry</a> manages the index space that determines the extent of the coarse-level domain of a <a class="el" href="namespaceSAMRAI.html">SAMRAI</a> hierarchy.  
<a href="#_details">More...</a>
<p>
<code>#include &lt;source/SAMRAI/hier/BaseGridGeometry.h&gt;</code>
<p>
<p>Inheritance diagram for SAMRAI::hier::BaseGridGeometry:
<p><center><img src="classSAMRAI_1_1hier_1_1BaseGridGeometry.png" usemap="#SAMRAI::hier::BaseGridGeometry_map" border="0" alt=""></center>
<map name="SAMRAI::hier::BaseGridGeometry_map">
<area href="classSAMRAI_1_1tbox_1_1Serializable.html" alt="SAMRAI::tbox::Serializable" shape="rect" coords="0,0,234,24">
<area href="classSAMRAI_1_1geom_1_1GridGeometry.html" alt="SAMRAI::geom::GridGeometry" shape="rect" coords="0,112,234,136">
<area href="classSAMRAI_1_1geom_1_1CartesianGridGeometry.html" alt="SAMRAI::geom::CartesianGridGeometry" shape="rect" coords="0,168,234,192">
</map>
<a href="classSAMRAI_1_1hier_1_1BaseGridGeometry-members.html">List of all members.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Types</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef <a class="el" href="classSAMRAI_1_1hier_1_1PatchGeometry_1_1TwoDimBool.html">PatchGeometry::TwoDimBool</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BaseGridGeometry.html#2c84daec71e1e05ec3bad88279b1ee71">TwoDimBool</a></td></tr>

<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BaseGridGeometry.html#cb35341c85c992e92c7be494cc0f10b6">BaseGridGeometry</a> (const <a class="el" href="classSAMRAI_1_1tbox_1_1Dimension.html">tbox::Dimension</a> &amp;dim, const std::string &amp;object_name, const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Database.html">tbox::Database</a> &gt; &amp;input_db, bool allow_multiblock=true)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Construct a new BaseBaseGridGeometry object and initialize from input.  <a href="#cb35341c85c992e92c7be494cc0f10b6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BaseGridGeometry.html#6b1645ff250edd7083c2b56bc5a8b739">BaseGridGeometry</a> (const std::string &amp;object_name, <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a> &amp;domain)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Construct a new <a class="el" href="classSAMRAI_1_1hier_1_1BaseGridGeometry.html">BaseGridGeometry</a> object based on arguments.  <a href="#6b1645ff250edd7083c2b56bc5a8b739"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BaseGridGeometry.html#14e2ff30289470d8ecce5867b2635112">~BaseGridGeometry</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Virtual destructor.  <a href="#14e2ff30289470d8ecce5867b2635112"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BaseGridGeometry.html#3121e566f814c8b69d62b6ba760df106">computePhysicalDomain</a> (<a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a> &amp;domain, const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;ratio_to_level_zero, const <a class="el" href="classSAMRAI_1_1hier_1_1BlockId.html">BlockId</a> &amp;block_id) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute the box array describing the index space for a given block of the physical domain.  <a href="#3121e566f814c8b69d62b6ba760df106"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BaseGridGeometry.html#fea4db9c9b049f2a2c4c74e3f37be625">computePhysicalDomainWithPeriodicImages</a> (<a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a> &amp;domain, const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;ratio_to_level_zero, const <a class="el" href="classSAMRAI_1_1hier_1_1BlockId.html">BlockId</a> &amp;block_id) const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BaseGridGeometry.html#30799197a6a455cc0cb1c8d19ef15475">computePhysicalDomain</a> (<a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a> &amp;box_level, const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;ratio_to_level_zero, const <a class="el" href="classSAMRAI_1_1hier_1_1BlockId.html">BlockId</a> &amp;block_id) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute the <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a> describing the index space for a given block of the physical domain.  <a href="#30799197a6a455cc0cb1c8d19ef15475"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BaseGridGeometry.html#a3b218ddfb045d81f760ac135c977dc5">computePhysicalDomain</a> (<a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a> &amp;domain_boxes, const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;ratio_to_level_zero) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute the <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a> describing the complete physical domain for all blocks.  <a href="#a3b218ddfb045d81f760ac135c977dc5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BaseGridGeometry.html#c4500caa1f578f624325d73eaf4f51ed">computePhysicalDomain</a> (<a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a> &amp;box_level, const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;ratio_to_level_zero) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute the <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a> describing the complete physical domain for all blocks.  <a href="#c4500caa1f578f624325d73eaf4f51ed"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BaseGridGeometry.html#78e3fdfffe544d11ae09ade40a5c2692">setPhysicalDomain</a> (const <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a> &amp;domain, const int number_blocks)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the physical domain (for level zero).  <a href="#78e3fdfffe544d11ae09ade40a5c2692"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">const <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BaseGridGeometry.html#e87a623d8a09007e0ab7fcd1c4975448">getPhysicalDomain</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the physical domain description on level zero.  <a href="#e87a623d8a09007e0ab7fcd1c4975448"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">const <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BaseGridGeometry.html#e9d9dff79f597adaa4c609889d0cb0fa">getDomainSearchTree</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Access the multiblock domain description as a tree without periodic images.  <a href="#e9d9dff79f597adaa4c609889d0cb0fa"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">const <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BaseGridGeometry.html#e52702ba3b9888e727829fcf7979c40d">getPeriodicDomainSearchTree</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Access the multiblock domain description with periodic images (if any).  <a href="#e52702ba3b9888e727829fcf7979c40d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BaseGridGeometry.html#025e5bdc7c515abbedb32418692c89e3">getDomainIsSingleBox</a> (const <a class="el" href="classSAMRAI_1_1hier_1_1BlockId.html">BlockId</a> &amp;block_id) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">returns whether the physical domain for a block managed by this geometry object can be represented as a single box.  <a href="#025e5bdc7c515abbedb32418692c89e3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BaseGridGeometry.html#a3acf8fcafae0e42c7ddef695902d612">initializePeriodicShift</a> (const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;directions)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Initialize the periodic shift on the coarsest level.  <a href="#a3acf8fcafae0e42c7ddef695902d612"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BaseGridGeometry.html#0cb5a20a07c1ef2444d73b938f3e2508">getPeriodicShift</a> (const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;ratio_to_level_zero) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the periodic shift in each direction for the physical domain managed by this geometry object.  <a href="#0cb5a20a07c1ef2444d73b938f3e2508"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BaseGridGeometry.html#b232ac0f62df4ddf63640075c9809593">getNumberBlocks</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the number of blocks in the geometry.  <a href="#b232ac0f62df4ddf63640075c9809593"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BaseGridGeometry.html#4fa66503a18aa7e4bf7f3ed80e196605">getMaxTransferOpStencilWidth</a> (const <a class="el" href="classSAMRAI_1_1tbox_1_1Dimension.html">tbox::Dimension</a> &amp;dim)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the max stencil width of all transfer operators.  <a href="#4fa66503a18aa7e4bf7f3ed80e196605"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual boost::shared_ptr&lt;<br>
 <a class="el" href="classSAMRAI_1_1hier_1_1BaseGridGeometry.html">BaseGridGeometry</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BaseGridGeometry.html#968532340aeb78d7d001077c7670bc3b">makeRefinedGridGeometry</a> (const std::string &amp;fine_geom_name, const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;refine_ratio) const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a pointer to a refined version of this grid geometry object.  <a href="#968532340aeb78d7d001077c7670bc3b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual boost::shared_ptr&lt;<br>
 <a class="el" href="classSAMRAI_1_1hier_1_1BaseGridGeometry.html">BaseGridGeometry</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BaseGridGeometry.html#af8de212bb28d3b179a8b72919a665d5">makeCoarsenedGridGeometry</a> (const std::string &amp;coarse_geom_name, const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;coarsen_ratio) const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a pointer to a coarsened version of this grid geometry object.  <a href="#af8de212bb28d3b179a8b72919a665d5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BaseGridGeometry.html#19a471295763d5f72cdf8af12f6ec00b">setGeometryDataOnPatch</a> (<a class="el" href="classSAMRAI_1_1hier_1_1Patch.html">Patch</a> &amp;patch, const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;ratio_to_level_zero, const <a class="el" href="classSAMRAI_1_1hier_1_1PatchGeometry_1_1TwoDimBool.html">TwoDimBool</a> &amp;touches_regular_bdry, const <a class="el" href="classSAMRAI_1_1hier_1_1PatchGeometry_1_1TwoDimBool.html">TwoDimBool</a> &amp;touches_periodic_bdry) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute and set grid data for patch.  <a href="#19a471295763d5f72cdf8af12f6ec00b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BaseGridGeometry.html#c86bd5b30025e7dab88524fecdc9b5a1">computeBoundaryBoxesOnLevel</a> (std::map&lt; <a class="el" href="classSAMRAI_1_1hier_1_1BoxId.html">BoxId</a>, <a class="el" href="classSAMRAI_1_1hier_1_1PatchBoundaries.html">PatchBoundaries</a> &gt; &amp;boundaries, const <a class="el" href="classSAMRAI_1_1hier_1_1PatchLevel.html">PatchLevel</a> &amp;level, const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;periodic_shift, const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;ghost_width, const <a class="el" href="classSAMRAI_1_1tbox_1_1Array.html">tbox::Array</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a> &gt; &amp;domain, bool do_all_patches=false) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute boundary boxes for each patch in patch level.  <a href="#c86bd5b30025e7dab88524fecdc9b5a1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BaseGridGeometry.html#0d85bbb9457dd891d2cf79d9ac1b8528">getBoundaryBoxes</a> (<a class="el" href="classSAMRAI_1_1hier_1_1PatchBoundaries.html">PatchBoundaries</a> &amp;patch_boundaries, const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> &amp;box, const <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a> &amp;domain_boxes, const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;ghosts, const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;periodic_shift) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute boundary boxes for patch.  <a href="#0d85bbb9457dd891d2cf79d9ac1b8528"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BaseGridGeometry.html#8e6feb712b0d3f62061a13e34008f3a0">adjustMultiblockPatchLevelBoundaries</a> (<a class="el" href="classSAMRAI_1_1hier_1_1PatchLevel.html">PatchLevel</a> &amp;patch_level)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adjust boundary data of a level to be consistent with the multiblock nature of the domain.  <a href="#8e6feb712b0d3f62061a13e34008f3a0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BaseGridGeometry.html#bcf69f3e15104c7360e0b5e54125faeb">addCoarsenOperator</a> (const char *var_type_name, const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1hier_1_1CoarsenOperator.html">CoarsenOperator</a> &gt; &amp;coarsen_op)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Add a concrete spatial coarsening operator.  <a href="#bcf69f3e15104c7360e0b5e54125faeb"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BaseGridGeometry.html#ecef292efb8f956281623e8c1be436bf">addRefineOperator</a> (const char *var_type_name, const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1hier_1_1RefineOperator.html">RefineOperator</a> &gt; &amp;refine_op)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Add a concrete spatial refinement operator.  <a href="#ecef292efb8f956281623e8c1be436bf"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BaseGridGeometry.html#4a2393fa2136747608df8a6bd3e8a942">addTimeInterpolateOperator</a> (const char *var_type_name, const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1hier_1_1TimeInterpolateOperator.html">TimeInterpolateOperator</a> &gt; &amp;time_op)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Add a concrete time interpolation operator.  <a href="#4a2393fa2136747608df8a6bd3e8a942"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1hier_1_1CoarsenOperator.html">CoarsenOperator</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BaseGridGeometry.html#9caec604d95019574c60247c97c75822">lookupCoarsenOperator</a> (const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1hier_1_1Variable.html">Variable</a> &gt; &amp;var, const std::string &amp;op_name)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Lookup function for coarsening operator.  <a href="#9caec604d95019574c60247c97c75822"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1hier_1_1RefineOperator.html">RefineOperator</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BaseGridGeometry.html#24ae5de0cee5397bfec289abbba31715">lookupRefineOperator</a> (const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1hier_1_1Variable.html">Variable</a> &gt; &amp;var, const std::string &amp;op_name)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Lookup function for refinement operator.  <a href="#24ae5de0cee5397bfec289abbba31715"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1hier_1_1TimeInterpolateOperator.html">TimeInterpolateOperator</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BaseGridGeometry.html#203c33a511662e9c72fcddb9bc3b871b">lookupTimeInterpolateOperator</a> (const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1hier_1_1Variable.html">Variable</a> &gt; &amp;var, const std::string &amp;op_name=&quot;STD_LINEAR_TIME_INTERPOLATE&quot;)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Lookup function for time interpolation operator.  <a href="#203c33a511662e9c72fcddb9bc3b871b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BaseGridGeometry.html#571bd04ea6ef3851ff969cfce86aa1e5">setMinTransferOpStencilWidth</a> (const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;min_value)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set a minimum value on the value returned by <a class="el" href="classSAMRAI_1_1hier_1_1BaseGridGeometry.html#4fa66503a18aa7e4bf7f3ed80e196605">getMaxTransferOpStencilWidth()</a>.  <a href="#571bd04ea6ef3851ff969cfce86aa1e5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">const <a class="el" href="classSAMRAI_1_1tbox_1_1Dimension.html">tbox::Dimension</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BaseGridGeometry.html#9d11d3bc88025b781369ec0868c7c1c3">getDim</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the dimension of this object.  <a href="#9d11d3bc88025b781369ec0868c7c1c3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">const std::string &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BaseGridGeometry.html#e59b99b58fc078db1c36922ee5e851de">getObjectName</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the name of this object.  <a href="#e59b99b58fc078db1c36922ee5e851de"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BaseGridGeometry.html#87e73fcb379aeb33143d75dc9d028167">registerNeighbors</a> (const <a class="el" href="classSAMRAI_1_1hier_1_1BlockId.html">BlockId</a> &amp;block_a, const <a class="el" href="classSAMRAI_1_1hier_1_1BlockId.html">BlockId</a> &amp;block_b, const <a class="el" href="classSAMRAI_1_1hier_1_1Transformation.html#2dd7d97a19db7c8e97402e8518c0af8d">Transformation::RotationIdentifier</a> rotation_b_to_a, const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;shift_b_to_a, const int neighbor_type)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Register a relationship between two neighboring blocks of a multiblock domain.  <a href="#87e73fcb379aeb33143d75dc9d028167"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BaseGridGeometry.html#b2ccb71f6163ba0f739f8fca2c5109f1">getDomainOutsideBlock</a> (<a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a> &amp;domain_outside_block, const <a class="el" href="classSAMRAI_1_1hier_1_1BlockId.html">BlockId</a> &amp;block_id) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get a <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a> that contains all of the index space of all other blocks in the multiblock domain.  <a href="#b2ccb71f6163ba0f739f8fca2c5109f1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BaseGridGeometry.html#8e8bfc592ce1ce3632c2ce548782d35b">getNumberOfBlockSingularities</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the number of block singularities in the block configuration.  <a href="#8e8bfc592ce1ce3632c2ce548782d35b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">const <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BaseGridGeometry.html#fc696ada5b9f9a5d84544a801dfbb5bb">getSingularityBoxContainer</a> (const <a class="el" href="classSAMRAI_1_1hier_1_1BlockId.html">BlockId</a> &amp;block_id) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return a <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a> that describes all of the singularities touched by the block indicated by block_id.  <a href="#fc696ada5b9f9a5d84544a801dfbb5bb"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">const std::vector&lt; int &gt; &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BaseGridGeometry.html#aec0483604beb9036172bd05f69d6587">getSingularityIndices</a> (const <a class="el" href="classSAMRAI_1_1hier_1_1BlockId.html">BlockId</a> &amp;block_id) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return a list of integers indicating all of the singularities touched by the block indicated by block_id.  <a href="#aec0483604beb9036172bd05f69d6587"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BaseGridGeometry.html#710cc9937538b7fa12880a1b3457b0b2">reducedConnectivityExists</a> (const <a class="el" href="classSAMRAI_1_1hier_1_1BlockId.html">BlockId</a> &amp;block_id) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Tell if block represented by block_id touches a reduced-connectivity singularity.  <a href="#710cc9937538b7fa12880a1b3457b0b2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BaseGridGeometry.html#54d295355deb36e3ff8507bcce711691">transformBox</a> (<a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> &amp;box, const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;ratio, const <a class="el" href="classSAMRAI_1_1hier_1_1BlockId.html">BlockId</a> &amp;output_block, const <a class="el" href="classSAMRAI_1_1hier_1_1BlockId.html">BlockId</a> &amp;input_block) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Modify a box by rotating and shifting from the index space of the transformed_block to the index space of the base_block at the resolution level defined by ratio_to_level_zero.  <a href="#54d295355deb36e3ff8507bcce711691"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BaseGridGeometry.html#6a1defea91aa9a819792130ac87cafb9">transformBoxContainer</a> (<a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a> &amp;boxes, const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;ratio, const <a class="el" href="classSAMRAI_1_1hier_1_1BlockId.html">BlockId</a> &amp;output_block, const <a class="el" href="classSAMRAI_1_1hier_1_1BlockId.html">BlockId</a> &amp;input_block) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Modify boxes by rotating and shifting from the index space of the input_block to the index space of the output_block at the resolution level defined by ratio_to_level_zero.  <a href="#6a1defea91aa9a819792130ac87cafb9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BaseGridGeometry.html#f7d5a8c2276d52a38e2c335fa168f109">getTransformedBlock</a> (<a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a> &amp;block_boxes, const <a class="el" href="classSAMRAI_1_1hier_1_1BlockId.html">BlockId</a> &amp;base_block, const <a class="el" href="classSAMRAI_1_1hier_1_1BlockId.html">BlockId</a> &amp;transformed_block)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get a box array that describes the coarse-level domain of the transformed_block in terms of the index space of base_block.  <a href="#f7d5a8c2276d52a38e2c335fa168f109"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">const std::list&lt; <a class="el" href="classSAMRAI_1_1hier_1_1BaseGridGeometry_1_1Neighbor.html">Neighbor</a> &gt; &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BaseGridGeometry.html#63e07df4bba597491e27b317b018e7cc">getNeighbors</a> (const <a class="el" href="classSAMRAI_1_1hier_1_1BlockId.html">BlockId</a> &amp;block_id) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return a list of <a class="el" href="classSAMRAI_1_1hier_1_1BaseGridGeometry_1_1Neighbor.html">Neighbor</a> objects describing all of the neighbors of the block indicated by the block_id.  <a href="#63e07df4bba597491e27b317b018e7cc"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BaseGridGeometry.html#8f7b5ea584e4bcb325fcc59bc2c0e654">getNumberOfNeighbors</a> (const <a class="el" href="classSAMRAI_1_1hier_1_1BlockId.html">BlockId</a> &amp;block_id) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the number of neighbors a specific block of the Multiblock domain has.  <a href="#8f7b5ea584e4bcb325fcc59bc2c0e654"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BaseGridGeometry.html#b6f08d17ed3d3108f575d44620c66b1d">areNeighbors</a> (const <a class="el" href="classSAMRAI_1_1hier_1_1BlockId.html">BlockId</a> &amp;block_a, const <a class="el" href="classSAMRAI_1_1hier_1_1BlockId.html">BlockId</a> &amp;block_b) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Tell if the given BlockIds represent neighboring blocks.  <a href="#b6f08d17ed3d3108f575d44620c66b1d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BaseGridGeometry.html#bea2a02283882c0f1b7e2bbeaccd0962">areSingularityNeighbors</a> (const <a class="el" href="classSAMRAI_1_1hier_1_1BlockId.html">BlockId</a> &amp;block_a, const <a class="el" href="classSAMRAI_1_1hier_1_1BlockId.html">BlockId</a> &amp;block_b) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Tell if the given BlockIds represent neighboring blocks.  <a href="#bea2a02283882c0f1b7e2bbeaccd0962"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classSAMRAI_1_1hier_1_1Transformation.html#2dd7d97a19db7c8e97402e8518c0af8d">Transformation::RotationIdentifier</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BaseGridGeometry.html#e42b72e7ac995e307de1ce3a6a03fc1d">getRotationIdentifier</a> (const <a class="el" href="classSAMRAI_1_1hier_1_1BlockId.html">BlockId</a> &amp;dst, const <a class="el" href="classSAMRAI_1_1hier_1_1BlockId.html">BlockId</a> &amp;src) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the rotation identifier to rotate from src to dst.\.  <a href="#e42b72e7ac995e307de1ce3a6a03fc1d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BaseGridGeometry.html#507de6c39e6ad6f40bbafe70ea9f6b9d">getOffset</a> (const <a class="el" href="classSAMRAI_1_1hier_1_1BlockId.html">BlockId</a> &amp;dst, const <a class="el" href="classSAMRAI_1_1hier_1_1BlockId.html">BlockId</a> &amp;src) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the offset to shift from src to dst after rotation.  <a href="#507de6c39e6ad6f40bbafe70ea9f6b9d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BaseGridGeometry.html#5bc0d426345a277583c1a8689efb5f85">hasEnhancedConnectivity</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Query if the geometry has enhanced connectivity.  <a href="#5bc0d426345a277583c1a8689efb5f85"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BaseGridGeometry.html#2a44cc9f46a022c854e761a8cef83e92">printClassData</a> (std::ostream &amp;stream) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Print object data to the specified output stream.  <a href="#2a44cc9f46a022c854e761a8cef83e92"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BaseGridGeometry.html#48bbb36fc2179d989b6a148f79c3b977">putToRestart</a> (const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Database.html">tbox::Database</a> &gt; &amp;restart_db) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Writes the state of the <a class="el" href="classSAMRAI_1_1hier_1_1BaseGridGeometry.html">BaseGridGeometry</a> object to the restart database.  <a href="#48bbb36fc2179d989b6a148f79c3b977"></a><br></td></tr>
<tr><td colspan="2"><div class="groupHeader">Functions for computing boundary boxes</div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BaseGridGeometry.html#6c114d583c0eea623e24d751207f6eaf">findPatchesTouchingBoundaries</a> (std::map&lt; <a class="el" href="classSAMRAI_1_1hier_1_1BoxId.html">BoxId</a>, <a class="el" href="classSAMRAI_1_1hier_1_1PatchGeometry_1_1TwoDimBool.html">TwoDimBool</a> &gt; &amp;touches_regular_boundary, std::map&lt; <a class="el" href="classSAMRAI_1_1hier_1_1BoxId.html">BoxId</a>, <a class="el" href="classSAMRAI_1_1hier_1_1PatchGeometry_1_1TwoDimBool.html">TwoDimBool</a> &gt; &amp;touches_periodic_boundary, const <a class="el" href="classSAMRAI_1_1hier_1_1PatchLevel.html">PatchLevel</a> &amp;level) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">For every patch on a level, find all ways a patch touches a physical or periodic boundary.  <a href="#6c114d583c0eea623e24d751207f6eaf"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BaseGridGeometry.html#88a0aa57ec9c97888964904e3d087891">computeBoxTouchingBoundaries</a> (<a class="el" href="classSAMRAI_1_1hier_1_1PatchGeometry_1_1TwoDimBool.html">TwoDimBool</a> &amp;touches_regular_bdry, <a class="el" href="classSAMRAI_1_1hier_1_1PatchGeometry_1_1TwoDimBool.html">TwoDimBool</a> &amp;touches_periodic_bdry, const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> &amp;box, const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;refinement_ratio, const <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a> &amp;refined_periodic_domain_tree) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Version of findPatchTouchingBoundaries for a single box.  <a href="#88a0aa57ec9c97888964904e3d087891"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BaseGridGeometry.html#0d0c3fb929943deb1e14964ce52c1063">setGeometryOnPatches</a> (<a class="el" href="classSAMRAI_1_1hier_1_1PatchLevel.html">PatchLevel</a> &amp;level, const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;ratio_to_level_zero, const std::map&lt; <a class="el" href="classSAMRAI_1_1hier_1_1BoxId.html">BoxId</a>, <a class="el" href="classSAMRAI_1_1hier_1_1PatchGeometry_1_1TwoDimBool.html">TwoDimBool</a> &gt; &amp;touches_regular_bdry, const std::map&lt; <a class="el" href="classSAMRAI_1_1hier_1_1BoxId.html">BoxId</a>, <a class="el" href="classSAMRAI_1_1hier_1_1PatchGeometry_1_1TwoDimBool.html">TwoDimBool</a> &gt; &amp;touches_periodic_bdry, const bool defer_boundary_box_creation)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets geometry data for patches on a level.  <a href="#0d0c3fb929943deb1e14964ce52c1063"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BaseGridGeometry.html#8c325429f40644934b6403aa62596ef6">setBoundaryBoxes</a> (<a class="el" href="classSAMRAI_1_1hier_1_1PatchLevel.html">PatchLevel</a> &amp;level)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Construct and set the boundary boxes for each patch.  <a href="#8c325429f40644934b6403aa62596ef6"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BaseGridGeometry.html#3364f17623cfe4d36347b741499dab85">BaseGridGeometry</a> (const std::string &amp;object_name, <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a> &amp;domain, const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1hier_1_1TransferOperatorRegistry.html">TransferOperatorRegistry</a> &gt; &amp;op_reg)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Construct a new <a class="el" href="classSAMRAI_1_1hier_1_1BaseGridGeometry.html">BaseGridGeometry</a> object based on arguments.  <a href="#3364f17623cfe4d36347b741499dab85"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BaseGridGeometry.html#b2d5cbd3201d19708fda5320b94b6402">readBlockDataFromInput</a> (const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Database.html">tbox::Database</a> &gt; &amp;input_db)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Read multiblock metadata input from the input database.  <a href="#b2d5cbd3201d19708fda5320b94b6402"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Protected Attributes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1hier_1_1TransferOperatorRegistry.html">TransferOperatorRegistry</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BaseGridGeometry.html#3f77f497366bc01a1f1082995cb27fd3">d_transfer_operator_registry</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classSAMRAI_1_1tbox_1_1Dimension.html">tbox::Dimension</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BaseGridGeometry.html#3db460feb609c2e0619cc971dfe5cc94">d_dim</a></td></tr>

<tr><td colspan="2"><br><h2>Friends</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BaseGridGeometry.html#fd278c6c8ecae0cdc8c275f95d1eadcb">TransferOperatorRegistry</a></td></tr>

<tr><td colspan="2"><br><h2>Classes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1BaseGridGeometry_1_1Neighbor.html">Neighbor</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Class to represent the neighbor of a given block.  <a href="classSAMRAI_1_1hier_1_1BaseGridGeometry_1_1Neighbor.html#_details">More...</a><br></td></tr>
</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
Class <a class="el" href="classSAMRAI_1_1hier_1_1BaseGridGeometry.html">BaseGridGeometry</a> manages the index space that determines the extent of the coarse-level domain of a <a class="el" href="namespaceSAMRAI.html">SAMRAI</a> hierarchy. 
<p>
A <a class="el" href="classSAMRAI_1_1hier_1_1BaseGridGeometry.html">BaseGridGeometry</a> object may be used as a base class to derive child classes that manage particular grid types (e.g., Cartesian, cylindrical, etc.).<p>
The grid geometry class is responsible for maintaining information about the index space describing the physical domain and computing this information for patches in an AMR hierarchy.<p>
<dl compact><dt><b>Additional Functionality</b></dt><dd>Operations performed by this class include determining which patches are adjacent to the physical domain boundary and computing boundary boxes for patches which describe how the patch touches the domain boundary (useful for filling ghost cell data for physical boundary conditions).</dd></dl>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classSAMRAI_1_1hier_1_1BoundaryBox.html">hier::BoundaryBox</a> </dd></dl>

<p>
<hr><h2>Member Typedef Documentation</h2>
<a class="anchor" name="2c84daec71e1e05ec3bad88279b1ee71"></a><!-- doxytag: member="SAMRAI::hier::BaseGridGeometry::TwoDimBool" ref="2c84daec71e1e05ec3bad88279b1ee71" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classSAMRAI_1_1hier_1_1PatchGeometry_1_1TwoDimBool.html">PatchGeometry::TwoDimBool</a> <a class="el" href="classSAMRAI_1_1hier_1_1PatchGeometry_1_1TwoDimBool.html">SAMRAI::hier::BaseGridGeometry::TwoDimBool</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<hr><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" name="cb35341c85c992e92c7be494cc0f10b6"></a><!-- doxytag: member="SAMRAI::hier::BaseGridGeometry::BaseGridGeometry" ref="cb35341c85c992e92c7be494cc0f10b6" args="(const tbox::Dimension &amp;dim, const std::string &amp;object_name, const boost::shared_ptr&lt; tbox::Database &gt; &amp;input_db, bool allow_multiblock=true)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SAMRAI::hier::BaseGridGeometry::BaseGridGeometry           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1tbox_1_1Dimension.html">tbox::Dimension</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>dim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>object_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Database.html">tbox::Database</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>input_db</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>allow_multiblock</em> = <code>true</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Construct a new BaseBaseGridGeometry object and initialize from input. 
<p>
This constructor for <a class="el" href="classSAMRAI_1_1hier_1_1BaseGridGeometry.html">BaseGridGeometry</a> initializes data members based on parameters read from the specified input database.<p>
This constructor is intended for use when directly constructing a <a class="el" href="classSAMRAI_1_1hier_1_1BaseGridGeometry.html">BaseGridGeometry</a> without using a derived child class. The object will contain all index space grid information for a mesh, but nothing about the physical coordinates of the mesh.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>dim</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>object_name</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>input_db</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>allow_multiblock</em>&nbsp;</td><td>set to false if called by inherently single block derived class such as CartesianGridGeometry</td></tr>
  </table>
</dl>
<dl compact><dt><b>Precondition:</b></dt><dd>!object_name.empty() <p>
input_db </dd></dl>

</div>
</div><p>
<a class="anchor" name="6b1645ff250edd7083c2b56bc5a8b739"></a><!-- doxytag: member="SAMRAI::hier::BaseGridGeometry::BaseGridGeometry" ref="6b1645ff250edd7083c2b56bc5a8b739" args="(const std::string &amp;object_name, BoxContainer &amp;domain)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SAMRAI::hier::BaseGridGeometry::BaseGridGeometry           </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>object_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>domain</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Construct a new <a class="el" href="classSAMRAI_1_1hier_1_1BaseGridGeometry.html">BaseGridGeometry</a> object based on arguments. 
<p>
This constructor creates a new <a class="el" href="classSAMRAI_1_1hier_1_1BaseGridGeometry.html">BaseGridGeometry</a> object based on the arguments, rather than relying on input or restart data.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>object_name</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>domain</em>&nbsp;</td><td>Each element of the array describes the index space for a block.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Precondition:</b></dt><dd>!object_name.empty() <p>
!domain.isEmpty() </dd></dl>

</div>
</div><p>
<a class="anchor" name="14e2ff30289470d8ecce5867b2635112"></a><!-- doxytag: member="SAMRAI::hier::BaseGridGeometry::~BaseGridGeometry" ref="14e2ff30289470d8ecce5867b2635112" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SAMRAI::hier::BaseGridGeometry::~BaseGridGeometry           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Virtual destructor. 
<p>

</div>
</div><p>
<a class="anchor" name="3364f17623cfe4d36347b741499dab85"></a><!-- doxytag: member="SAMRAI::hier::BaseGridGeometry::BaseGridGeometry" ref="3364f17623cfe4d36347b741499dab85" args="(const std::string &amp;object_name, BoxContainer &amp;domain, const boost::shared_ptr&lt; TransferOperatorRegistry &gt; &amp;op_reg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SAMRAI::hier::BaseGridGeometry::BaseGridGeometry           </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>object_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>domain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1hier_1_1TransferOperatorRegistry.html">TransferOperatorRegistry</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>op_reg</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Construct a new <a class="el" href="classSAMRAI_1_1hier_1_1BaseGridGeometry.html">BaseGridGeometry</a> object based on arguments. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>object_name</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>domain</em>&nbsp;</td><td>Each element of the array describes the index space for a block. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>op_reg</em>&nbsp;</td><td></td></tr>
  </table>
</dl>
<dl compact><dt><b>Precondition:</b></dt><dd>!object_name.empty() <p>
!domain.isEmpty() </dd></dl>

</div>
</div><p>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="6c114d583c0eea623e24d751207f6eaf"></a><!-- doxytag: member="SAMRAI::hier::BaseGridGeometry::findPatchesTouchingBoundaries" ref="6c114d583c0eea623e24d751207f6eaf" args="(std::map&lt; BoxId, TwoDimBool &gt; &amp;touches_regular_boundary, std::map&lt; BoxId, TwoDimBool &gt; &amp;touches_periodic_boundary, const PatchLevel &amp;level) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::hier::BaseGridGeometry::findPatchesTouchingBoundaries           </td>
          <td>(</td>
          <td class="paramtype">std::map&lt; <a class="el" href="classSAMRAI_1_1hier_1_1BoxId.html">BoxId</a>, <a class="el" href="classSAMRAI_1_1hier_1_1PatchGeometry_1_1TwoDimBool.html">TwoDimBool</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>touches_regular_boundary</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::map&lt; <a class="el" href="classSAMRAI_1_1hier_1_1BoxId.html">BoxId</a>, <a class="el" href="classSAMRAI_1_1hier_1_1PatchGeometry_1_1TwoDimBool.html">TwoDimBool</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>touches_periodic_boundary</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1PatchLevel.html">PatchLevel</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>level</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
For every patch on a level, find all ways a patch touches a physical or periodic boundary. 
<p>
For every patch on the given <a class="el" href="classSAMRAI_1_1hier_1_1PatchLevel.html">PatchLevel</a>, this routine determines which kinds of boundaries are touched (regular, periodic, both, or neither).<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>touches_regular_boundary</em>&nbsp;</td><td>map to store which patches touch non-periodic boundaries. </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>touches_periodic_boundary</em>&nbsp;</td><td>map to store which patches touch periodic boundaries. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>level</em>&nbsp;</td><td>containing the patches to be checked </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="88a0aa57ec9c97888964904e3d087891"></a><!-- doxytag: member="SAMRAI::hier::BaseGridGeometry::computeBoxTouchingBoundaries" ref="88a0aa57ec9c97888964904e3d087891" args="(TwoDimBool &amp;touches_regular_bdry, TwoDimBool &amp;touches_periodic_bdry, const Box &amp;box, const IntVector &amp;refinement_ratio, const BoxContainer &amp;refined_periodic_domain_tree) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::hier::BaseGridGeometry::computeBoxTouchingBoundaries           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1hier_1_1PatchGeometry_1_1TwoDimBool.html">TwoDimBool</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>touches_regular_bdry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1hier_1_1PatchGeometry_1_1TwoDimBool.html">TwoDimBool</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>touches_periodic_bdry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>box</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>refinement_ratio</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>refined_periodic_domain_tree</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Version of findPatchTouchingBoundaries for a single box. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>touches_regular_bdry</em>&nbsp;</td><td>TwoDimBool to store which patches touch non-periodic boundaries. </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>touches_periodic_bdry</em>&nbsp;</td><td>TwoDimBool to store which patches touch periodic boundaries. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>box</em>&nbsp;</td><td>to be checked</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>refinement_ratio</em>&nbsp;</td><td>Refinement ratio of given box</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>refined_periodic_domain_tree</em>&nbsp;</td><td></td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="0d0c3fb929943deb1e14964ce52c1063"></a><!-- doxytag: member="SAMRAI::hier::BaseGridGeometry::setGeometryOnPatches" ref="0d0c3fb929943deb1e14964ce52c1063" args="(PatchLevel &amp;level, const IntVector &amp;ratio_to_level_zero, const std::map&lt; BoxId, TwoDimBool &gt; &amp;touches_regular_bdry, const std::map&lt; BoxId, TwoDimBool &gt; &amp;touches_periodic_bdry, const bool defer_boundary_box_creation)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::hier::BaseGridGeometry::setGeometryOnPatches           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1hier_1_1PatchLevel.html">PatchLevel</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>ratio_to_level_zero</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; <a class="el" href="classSAMRAI_1_1hier_1_1BoxId.html">BoxId</a>, <a class="el" href="classSAMRAI_1_1hier_1_1PatchGeometry_1_1TwoDimBool.html">TwoDimBool</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>touches_regular_bdry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; <a class="el" href="classSAMRAI_1_1hier_1_1BoxId.html">BoxId</a>, <a class="el" href="classSAMRAI_1_1hier_1_1PatchGeometry_1_1TwoDimBool.html">TwoDimBool</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>touches_periodic_bdry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&nbsp;</td>
          <td class="paramname"> <em>defer_boundary_box_creation</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets geometry data for patches on a level. 
<p>
Using the boundary information previously computed, this method will pass the information to the concrete implementation of the geometry class, and construct boundary boxes if required.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>level</em>&nbsp;</td><td>containing the patches to be checked. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>ratio_to_level_zero</em>&nbsp;</td><td>ratio to the coarsest level. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>touches_regular_bdry</em>&nbsp;</td><td>Array storing which patches touch non-periodic boundaries. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>touches_periodic_bdry</em>&nbsp;</td><td>Array storing which patches touch periodic boundaries. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>defer_boundary_box_creation</em>&nbsp;</td><td>Flag to indicate if boundary boxes should be created</td></tr>
  </table>
</dl>
<dl compact><dt><b>Precondition:</b></dt><dd>(<a class="el" href="classSAMRAI_1_1hier_1_1BaseGridGeometry.html#9d11d3bc88025b781369ec0868c7c1c3">getDim()</a> == level.getDim()) &amp;&amp; (<a class="el" href="classSAMRAI_1_1hier_1_1BaseGridGeometry.html#9d11d3bc88025b781369ec0868c7c1c3">getDim()</a> == ratio_to_level_zero.getDim()) <p>
ratio_to_level_zero != <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html#178dc4477a52ff09e80a2c3e86944e7f">IntVector::getZero</a>(<a class="el" href="classSAMRAI_1_1hier_1_1BaseGridGeometry.html#9d11d3bc88025b781369ec0868c7c1c3">getDim()</a>) </dd></dl>

</div>
</div><p>
<a class="anchor" name="8c325429f40644934b6403aa62596ef6"></a><!-- doxytag: member="SAMRAI::hier::BaseGridGeometry::setBoundaryBoxes" ref="8c325429f40644934b6403aa62596ef6" args="(PatchLevel &amp;level)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::hier::BaseGridGeometry::setBoundaryBoxes           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1hier_1_1PatchLevel.html">PatchLevel</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>level</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Construct and set the boundary boxes for each patch. 
<p>
Construct the boundary boxes for every patch in the level. Once constructed, the boundary boxes are set on each patch's <a class="el" href="classSAMRAI_1_1hier_1_1PatchGeometry.html">PatchGeometry</a> object.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>level</em>&nbsp;</td><td>The level for which boundary boxes are constructed.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Precondition:</b></dt><dd><a class="el" href="classSAMRAI_1_1hier_1_1BaseGridGeometry.html#9d11d3bc88025b781369ec0868c7c1c3">getDim()</a> == level.getDim() </dd></dl>

</div>
</div><p>
<a class="anchor" name="3121e566f814c8b69d62b6ba760df106"></a><!-- doxytag: member="SAMRAI::hier::BaseGridGeometry::computePhysicalDomain" ref="3121e566f814c8b69d62b6ba760df106" args="(BoxContainer &amp;domain, const IntVector &amp;ratio_to_level_zero, const BlockId &amp;block_id) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::hier::BaseGridGeometry::computePhysicalDomain           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>domain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>ratio_to_level_zero</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1BlockId.html">BlockId</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>block_id</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Compute the box array describing the index space for a given block of the physical domain. 
<p>
The domain description does not include periodic images.<p>
If any entry of the ratio vector is negative, the index space is coarsened with respect to the physical domain description. Otherwise, the index space is refined.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>domain</em>&nbsp;</td><td>The <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a> to be computed </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>ratio_to_level_zero</em>&nbsp;</td><td>ratio to the coarsest level </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>block_id</em>&nbsp;</td><td></td></tr>
  </table>
</dl>
<dl compact><dt><b>Precondition:</b></dt><dd><a class="el" href="classSAMRAI_1_1hier_1_1BaseGridGeometry.html#9d11d3bc88025b781369ec0868c7c1c3">getDim()</a> == ratio_to_level_zero.getDim() </dd></dl>

</div>
</div><p>
<a class="anchor" name="fea4db9c9b049f2a2c4c74e3f37be625"></a><!-- doxytag: member="SAMRAI::hier::BaseGridGeometry::computePhysicalDomainWithPeriodicImages" ref="fea4db9c9b049f2a2c4c74e3f37be625" args="(BoxContainer &amp;domain, const IntVector &amp;ratio_to_level_zero, const BlockId &amp;block_id) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::hier::BaseGridGeometry::computePhysicalDomainWithPeriodicImages           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>domain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>ratio_to_level_zero</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1BlockId.html">BlockId</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>block_id</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="30799197a6a455cc0cb1c8d19ef15475"></a><!-- doxytag: member="SAMRAI::hier::BaseGridGeometry::computePhysicalDomain" ref="30799197a6a455cc0cb1c8d19ef15475" args="(BoxLevel &amp;box_level, const IntVector &amp;ratio_to_level_zero, const BlockId &amp;block_id) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::hier::BaseGridGeometry::computePhysicalDomain           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>box_level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>ratio_to_level_zero</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1BlockId.html">BlockId</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>block_id</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Compute the <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a> describing the index space for a given block of the physical domain. 
<p>
The domain description includes periodic images, if any exist.<p>
Unlike the <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a> version of this function, the domain computed contains periodic image boxes. If any entry of ratio vector is negative, the index space is coarsened with respect to the physical domain description. Otherwise, the index space is refined.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>box_level</em>&nbsp;</td><td>The <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a> containing all Boxes describing the index space </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>ratio_to_level_zero</em>&nbsp;</td><td>ratio to the coarsest level </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>block_id</em>&nbsp;</td><td></td></tr>
  </table>
</dl>
<dl compact><dt><b>Precondition:</b></dt><dd><a class="el" href="classSAMRAI_1_1hier_1_1BaseGridGeometry.html#9d11d3bc88025b781369ec0868c7c1c3">getDim()</a> == ratio_to_level_zero.getDim() </dd></dl>

</div>
</div><p>
<a class="anchor" name="a3b218ddfb045d81f760ac135c977dc5"></a><!-- doxytag: member="SAMRAI::hier::BaseGridGeometry::computePhysicalDomain" ref="a3b218ddfb045d81f760ac135c977dc5" args="(BoxContainer &amp;domain_boxes, const IntVector &amp;ratio_to_level_zero) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::hier::BaseGridGeometry::computePhysicalDomain           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>domain_boxes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>ratio_to_level_zero</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Compute the <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a> describing the complete physical domain for all blocks. 
<p>
The domain description includes periodic images, if any exist.<p>
If any entry of the ratio vector is negative, the index space is coarsened with respect to the physical domain description. Otherwise, the index space is refined.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>domain_boxes</em>&nbsp;</td><td>The <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a> containing all Boxes describing the physical domain </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>ratio_to_level_zero</em>&nbsp;</td><td>ratio to the coarsest level</td></tr>
  </table>
</dl>
<dl compact><dt><b>Precondition:</b></dt><dd><a class="el" href="classSAMRAI_1_1hier_1_1BaseGridGeometry.html#9d11d3bc88025b781369ec0868c7c1c3">getDim()</a> == ratio_to_level_zero.getDim() </dd></dl>

</div>
</div><p>
<a class="anchor" name="c4500caa1f578f624325d73eaf4f51ed"></a><!-- doxytag: member="SAMRAI::hier::BaseGridGeometry::computePhysicalDomain" ref="c4500caa1f578f624325d73eaf4f51ed" args="(BoxLevel &amp;box_level, const IntVector &amp;ratio_to_level_zero) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::hier::BaseGridGeometry::computePhysicalDomain           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>box_level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>ratio_to_level_zero</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Compute the <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a> describing the complete physical domain for all blocks. 
<p>
The domain description includes periodic images, if any exist.<p>
If any entry of the ratio vector is negative, the index space is coarsened with respect to the physical domain description. Otherwise, the index space is refined.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>box_level</em>&nbsp;</td><td>The <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a> containing all Boxes describing the physical domain </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>ratio_to_level_zero</em>&nbsp;</td><td>ratio to the coarsest level</td></tr>
  </table>
</dl>
<dl compact><dt><b>Precondition:</b></dt><dd><a class="el" href="classSAMRAI_1_1hier_1_1BaseGridGeometry.html#9d11d3bc88025b781369ec0868c7c1c3">getDim()</a> == ratio_to_level_zero.getDim() </dd></dl>

</div>
</div><p>
<a class="anchor" name="78e3fdfffe544d11ae09ade40a5c2692"></a><!-- doxytag: member="SAMRAI::hier::BaseGridGeometry::setPhysicalDomain" ref="78e3fdfffe544d11ae09ade40a5c2692" args="(const BoxContainer &amp;domain, const int number_blocks)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::hier::BaseGridGeometry::setPhysicalDomain           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>domain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>number_blocks</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set the physical domain (for level zero). 
<p>
Each entry in the array of box arrays represents the physical domain for a single block<p>
The extents of the input domain boxes are used, but their LocalId's are disregarded. <a class="el" href="classSAMRAI_1_1hier_1_1BaseGridGeometry.html">BaseGridGeometry</a> will assign new and unique LocalId's to the domain box description. Subsequent calls to <a class="el" href="classSAMRAI_1_1hier_1_1BaseGridGeometry.html#e87a623d8a09007e0ab7fcd1c4975448">getPhysicalDomain()</a> will return boxes with the new LocalId's.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>domain</em>&nbsp;</td><td>The input array of <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a> </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>number_blocks</em>&nbsp;</td><td></td></tr>
  </table>
</dl>
<dl compact><dt><b>Precondition:</b></dt><dd>!domain.isEmpty() <p>
for each box in domain: box.getBlockId().isValid() &amp;&amp; (box.getBlockId().getBlockValue() &lt; number_blocks) </dd></dl>

</div>
</div><p>
<a class="anchor" name="e87a623d8a09007e0ab7fcd1c4975448"></a><!-- doxytag: member="SAMRAI::hier::BaseGridGeometry::getPhysicalDomain" ref="e87a623d8a09007e0ab7fcd1c4975448" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a>&amp; SAMRAI::hier::BaseGridGeometry::getPhysicalDomain           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the physical domain description on level zero. 
<p>
<dl compact><dt><b>Returns:</b></dt><dd>const reference to physical domain description for level 0. </dd></dl>

</div>
</div><p>
<a class="anchor" name="e9d9dff79f597adaa4c609889d0cb0fa"></a><!-- doxytag: member="SAMRAI::hier::BaseGridGeometry::getDomainSearchTree" ref="e9d9dff79f597adaa4c609889d0cb0fa" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a>&amp; SAMRAI::hier::BaseGridGeometry::getDomainSearchTree           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Access the multiblock domain description as a tree without periodic images. 
<p>
This tree does not contain periodic images, even if there is only one block and the domain is periodic.<p>
<dl compact><dt><b>Returns:</b></dt><dd>The multiblock domain description as a search tree. </dd></dl>

</div>
</div><p>
<a class="anchor" name="e52702ba3b9888e727829fcf7979c40d"></a><!-- doxytag: member="SAMRAI::hier::BaseGridGeometry::getPeriodicDomainSearchTree" ref="e52702ba3b9888e727829fcf7979c40d" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a>&amp; SAMRAI::hier::BaseGridGeometry::getPeriodicDomainSearchTree           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Access the multiblock domain description with periodic images (if any). 
<p>
<dl compact><dt><b>Returns:</b></dt><dd>The domain description as a search tree with periodic images (if any). </dd></dl>

</div>
</div><p>
<a class="anchor" name="025e5bdc7c515abbedb32418692c89e3"></a><!-- doxytag: member="SAMRAI::hier::BaseGridGeometry::getDomainIsSingleBox" ref="025e5bdc7c515abbedb32418692c89e3" args="(const BlockId &amp;block_id) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SAMRAI::hier::BaseGridGeometry::getDomainIsSingleBox           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1BlockId.html">BlockId</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>block_id</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
returns whether the physical domain for a block managed by this geometry object can be represented as a single box. 
<p>
<dl compact><dt><b>Returns:</b></dt><dd>true if the physical domain can be represented as a single box, otherwise false.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>block_id</em>&nbsp;</td><td></td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="a3acf8fcafae0e42c7ddef695902d612"></a><!-- doxytag: member="SAMRAI::hier::BaseGridGeometry::initializePeriodicShift" ref="a3acf8fcafae0e42c7ddef695902d612" args="(const IntVector &amp;directions)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::hier::BaseGridGeometry::initializePeriodicShift           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>directions</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Initialize the periodic shift on the coarsest level. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>directions</em>&nbsp;</td><td>an array indicating periodic directions(1) or all others (0).</td></tr>
  </table>
</dl>
<dl compact><dt><b>Precondition:</b></dt><dd><a class="el" href="classSAMRAI_1_1hier_1_1BaseGridGeometry.html#9d11d3bc88025b781369ec0868c7c1c3">getDim()</a> == directions.getDim()</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>The <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> argument should be set to 1 for periodic directions and 0 for all other directions. The shift will be calculated to the number of cells in the periodic direction and zero in all other directions. </dd></dl>

</div>
</div><p>
<a class="anchor" name="0cb5a20a07c1ef2444d73b938f3e2508"></a><!-- doxytag: member="SAMRAI::hier::BaseGridGeometry::getPeriodicShift" ref="0cb5a20a07c1ef2444d73b938f3e2508" args="(const IntVector &amp;ratio_to_level_zero) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> SAMRAI::hier::BaseGridGeometry::getPeriodicShift           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>ratio_to_level_zero</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the periodic shift in each direction for the physical domain managed by this geometry object. 
<p>
The returned <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> contains the periodic shift in each direction for a domain represented by a refinement of the reference physical domain (i.e. level zero) by the given ratio vector. Entries will be zero for non-periodic directions.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>ratio_to_level_zero</em>&nbsp;</td><td>ratio to the coarsest level.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The periodic shift in each direction for a domain represented by a refinement of the reference physical domain.</dd></dl>
<dl compact><dt><b>Precondition:</b></dt><dd><a class="el" href="classSAMRAI_1_1hier_1_1BaseGridGeometry.html#9d11d3bc88025b781369ec0868c7c1c3">getDim()</a> == ratio_to_level_zero.getDim() </dd></dl>

</div>
</div><p>
<a class="anchor" name="b232ac0f62df4ddf63640075c9809593"></a><!-- doxytag: member="SAMRAI::hier::BaseGridGeometry::getNumberBlocks" ref="b232ac0f62df4ddf63640075c9809593" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int SAMRAI::hier::BaseGridGeometry::getNumberBlocks           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the number of blocks in the geometry. 
<p>

</div>
</div><p>
<a class="anchor" name="4fa66503a18aa7e4bf7f3ed80e196605"></a><!-- doxytag: member="SAMRAI::hier::BaseGridGeometry::getMaxTransferOpStencilWidth" ref="4fa66503a18aa7e4bf7f3ed80e196605" args="(const tbox::Dimension &amp;dim)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> SAMRAI::hier::BaseGridGeometry::getMaxTransferOpStencilWidth           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1tbox_1_1Dimension.html">tbox::Dimension</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>dim</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the max stencil width of all transfer operators. 
<p>
The max stencil width is required by the DLBG to determine when two nearby boxes are defined as neighbors. The DLBG in turn provides the neighbor information for various operations such as schedule construction.<p>
<dl compact><dt><b>Returns:</b></dt><dd>The max stencil width of all transfer operators. </dd></dl>

</div>
</div><p>
<a class="anchor" name="968532340aeb78d7d001077c7670bc3b"></a><!-- doxytag: member="SAMRAI::hier::BaseGridGeometry::makeRefinedGridGeometry" ref="968532340aeb78d7d001077c7670bc3b" args="(const std::string &amp;fine_geom_name, const IntVector &amp;refine_ratio) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual boost::shared_ptr&lt;<a class="el" href="classSAMRAI_1_1hier_1_1BaseGridGeometry.html">BaseGridGeometry</a>&gt; SAMRAI::hier::BaseGridGeometry::makeRefinedGridGeometry           </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>fine_geom_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>refine_ratio</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Create a pointer to a refined version of this grid geometry object. 
<p>
Virtual method -- should be overridden in specialized grid geometry classes<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>fine_geom_name</em>&nbsp;</td><td>std::string name of the geometry object </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>refine_ratio</em>&nbsp;</td><td>the refinement ratio.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The pointer to the grid geometry object. </dd></dl>

<p>
Implemented in <a class="el" href="classSAMRAI_1_1geom_1_1CartesianGridGeometry.html#710df9890eb6bc2fe209754314a335bd">SAMRAI::geom::CartesianGridGeometry</a>, and <a class="el" href="classSAMRAI_1_1geom_1_1GridGeometry.html#8c94c12b6bb63cea5af78d92d57ea4d9">SAMRAI::geom::GridGeometry</a>.
</div>
</div><p>
<a class="anchor" name="af8de212bb28d3b179a8b72919a665d5"></a><!-- doxytag: member="SAMRAI::hier::BaseGridGeometry::makeCoarsenedGridGeometry" ref="af8de212bb28d3b179a8b72919a665d5" args="(const std::string &amp;coarse_geom_name, const IntVector &amp;coarsen_ratio) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual boost::shared_ptr&lt;<a class="el" href="classSAMRAI_1_1hier_1_1BaseGridGeometry.html">BaseGridGeometry</a>&gt; SAMRAI::hier::BaseGridGeometry::makeCoarsenedGridGeometry           </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>coarse_geom_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>coarsen_ratio</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Create a pointer to a coarsened version of this grid geometry object. 
<p>
Virtual method -- should be overridden in specialized grid geometry classes<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>coarse_geom_name</em>&nbsp;</td><td>std::string name of the geometry object </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>coarsen_ratio</em>&nbsp;</td><td>the coasening ratio</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The pointer to a coarsened version of this grid geometry object. </dd></dl>

<p>
Implemented in <a class="el" href="classSAMRAI_1_1geom_1_1CartesianGridGeometry.html#9ceb85ea50daee60e793b11fc25721cb">SAMRAI::geom::CartesianGridGeometry</a>, and <a class="el" href="classSAMRAI_1_1geom_1_1GridGeometry.html#f7253bb0b1218ecb73f5e895ee568c17">SAMRAI::geom::GridGeometry</a>.
</div>
</div><p>
<a class="anchor" name="19a471295763d5f72cdf8af12f6ec00b"></a><!-- doxytag: member="SAMRAI::hier::BaseGridGeometry::setGeometryDataOnPatch" ref="19a471295763d5f72cdf8af12f6ec00b" args="(Patch &amp;patch, const IntVector &amp;ratio_to_level_zero, const TwoDimBool &amp;touches_regular_bdry, const TwoDimBool &amp;touches_periodic_bdry) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::hier::BaseGridGeometry::setGeometryDataOnPatch           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1hier_1_1Patch.html">Patch</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>patch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>ratio_to_level_zero</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1PatchGeometry_1_1TwoDimBool.html">TwoDimBool</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>touches_regular_bdry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1PatchGeometry_1_1TwoDimBool.html">TwoDimBool</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>touches_periodic_bdry</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Compute and set grid data for patch. 
<p>
Virtual method -- should be overridden in specialized grid geometry classes<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>patch</em>&nbsp;</td><td>The patch on which to set grid data and the new concrete patch geometry object. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>ratio_to_level_zero</em>&nbsp;</td><td>ratio to coarsest level </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>touches_regular_bdry</em>&nbsp;</td><td>Array storing which patches touch non-periodic boundaries. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>touches_periodic_bdry</em>&nbsp;</td><td>Array storing which patches touch periodic boundaries.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Precondition:</b></dt><dd>(<a class="el" href="classSAMRAI_1_1hier_1_1BaseGridGeometry.html#9d11d3bc88025b781369ec0868c7c1c3">getDim()</a> == patch.getDim()) &amp;&amp; (<a class="el" href="classSAMRAI_1_1hier_1_1BaseGridGeometry.html#9d11d3bc88025b781369ec0868c7c1c3">getDim()</a> == ratio_to_level_zero.getDim()) &amp;&amp; (<a class="el" href="classSAMRAI_1_1hier_1_1BaseGridGeometry.html#9d11d3bc88025b781369ec0868c7c1c3">getDim()</a> == touches_regular_bdry.getDim()) &amp;&amp; (<a class="el" href="classSAMRAI_1_1hier_1_1BaseGridGeometry.html#9d11d3bc88025b781369ec0868c7c1c3">getDim()</a> == touches_periodic_bdry.getDim()) </dd></dl>

<p>
Reimplemented in <a class="el" href="classSAMRAI_1_1geom_1_1CartesianGridGeometry.html#ee268dd0852dccda81c659f09a58d338">SAMRAI::geom::CartesianGridGeometry</a>.
</div>
</div><p>
<a class="anchor" name="c86bd5b30025e7dab88524fecdc9b5a1"></a><!-- doxytag: member="SAMRAI::hier::BaseGridGeometry::computeBoundaryBoxesOnLevel" ref="c86bd5b30025e7dab88524fecdc9b5a1" args="(std::map&lt; BoxId, PatchBoundaries &gt; &amp;boundaries, const PatchLevel &amp;level, const IntVector &amp;periodic_shift, const IntVector &amp;ghost_width, const tbox::Array&lt; BoxContainer &gt; &amp;domain, bool do_all_patches=false) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::hier::BaseGridGeometry::computeBoundaryBoxesOnLevel           </td>
          <td>(</td>
          <td class="paramtype">std::map&lt; <a class="el" href="classSAMRAI_1_1hier_1_1BoxId.html">BoxId</a>, <a class="el" href="classSAMRAI_1_1hier_1_1PatchBoundaries.html">PatchBoundaries</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>boundaries</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1PatchLevel.html">PatchLevel</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>periodic_shift</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>ghost_width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1tbox_1_1Array.html">tbox::Array</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>domain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>do_all_patches</em> = <code>false</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Compute boundary boxes for each patch in patch level. 
<p>
Boundary boxes for each patch in a patch level will be computed and assign to boundary box arrays. These arrays are assumed to be of length <div class="fragment"><pre class="fragment">    DIM * num_patches
</pre></div>.<p>
The DIM arrays of boundary boxes for each patch will be stored in groups of DIM. For example in 3D, with <code>n</code> patches on the level, the array of boundary box arrays will be ordered as follows:<p>
<div class="fragment"><pre class="fragment"> (patch 0 face array, patch 0 edge array, patch 0 box array,
  patch 1 face array, patch 1 edge array, patch 1 box array, . . . ,
  patch n-1 face array, patch n-1 edge array, patch n-1 box array)
</pre></div><p>
<dl compact><dt><b>Note:</b></dt><dd>The optional argument <code>do_all_patches</code> defaults to false: the boundary box computation is executed only on patches that touch a non-periodic boundary. When this routine is called during patch level construction to describe a physical boundary, it is known that only patches that touch a non-periodic boundary will have non-empty sets of boundary boxes, so for efficiency's sake the boundary box box computation is supressed for all other patches.</dd></dl>
When this routine is called to create boundary boxes that describe a coarse-fine boundary, the computation must occur for every patch, so <code>do_all_patches</code> must be set to true.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>boundaries</em>&nbsp;</td><td>output boundary description </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>level</em>&nbsp;</td><td>level on which to generate boundaries </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>periodic_shift</em>&nbsp;</td><td>periodic shift for the level (see <a class="el" href="classSAMRAI_1_1hier_1_1BaseGridGeometry.html#0cb5a20a07c1ef2444d73b938f3e2508">getPeriodicShift()</a>) </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>ghost_width</em>&nbsp;</td><td>ghost width to compute geometry for the domain </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>domain</em>&nbsp;</td><td>Physical domain (in index space of level) for computing boundary boxes. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>do_all_patches</em>&nbsp;</td><td>Flag to indicate boundary box computation on all patches, even those known to not touch a boundary</td></tr>
  </table>
</dl>
<dl compact><dt><b>Precondition:</b></dt><dd>(<a class="el" href="classSAMRAI_1_1hier_1_1BaseGridGeometry.html#9d11d3bc88025b781369ec0868c7c1c3">getDim()</a> == level.getDim()) &amp;&amp; (<a class="el" href="classSAMRAI_1_1hier_1_1BaseGridGeometry.html#9d11d3bc88025b781369ec0868c7c1c3">getDim()</a> == periodic_shift.getDim()) &amp;&amp; (<a class="el" href="classSAMRAI_1_1hier_1_1BaseGridGeometry.html#9d11d3bc88025b781369ec0868c7c1c3">getDim()</a> == ghost_width.getDim()) <p>
ghost_width &gt;= <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html#178dc4477a52ff09e80a2c3e86944e7f">IntVector::getZero</a>(ghost_width.getDim()) </dd></dl>

</div>
</div><p>
<a class="anchor" name="0d85bbb9457dd891d2cf79d9ac1b8528"></a><!-- doxytag: member="SAMRAI::hier::BaseGridGeometry::getBoundaryBoxes" ref="0d85bbb9457dd891d2cf79d9ac1b8528" args="(PatchBoundaries &amp;patch_boundaries, const Box &amp;box, const BoxContainer &amp;domain_boxes, const IntVector &amp;ghosts, const IntVector &amp;periodic_shift) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::hier::BaseGridGeometry::getBoundaryBoxes           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1hier_1_1PatchBoundaries.html">PatchBoundaries</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>patch_boundaries</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>box</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>domain_boxes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>ghosts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>periodic_shift</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Compute boundary boxes for patch. 
<p>
Decompose patch boundary region into pieces depending on spatial directions. Boxes are extended along the boundary to the edge of the ghost box_level if necessary.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>patch_boundaries</em>&nbsp;</td><td>output boundaries </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>box</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>domain_boxes</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>ghosts</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>periodic_shift</em>&nbsp;</td><td></td></tr>
  </table>
</dl>
<dl compact><dt><b>Precondition:</b></dt><dd>(<a class="el" href="classSAMRAI_1_1hier_1_1BaseGridGeometry.html#9d11d3bc88025b781369ec0868c7c1c3">getDim()</a> == box.getDim()) &amp;&amp; (<a class="el" href="classSAMRAI_1_1hier_1_1BaseGridGeometry.html#9d11d3bc88025b781369ec0868c7c1c3">getDim()</a> == ghosts.getDim()) &amp;&amp; (<a class="el" href="classSAMRAI_1_1hier_1_1BaseGridGeometry.html#9d11d3bc88025b781369ec0868c7c1c3">getDim()</a> == periodic_shift.getDim()) </dd></dl>

</div>
</div><p>
<a class="anchor" name="8e6feb712b0d3f62061a13e34008f3a0"></a><!-- doxytag: member="SAMRAI::hier::BaseGridGeometry::adjustMultiblockPatchLevelBoundaries" ref="8e6feb712b0d3f62061a13e34008f3a0" args="(PatchLevel &amp;patch_level)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::hier::BaseGridGeometry::adjustMultiblockPatchLevelBoundaries           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1hier_1_1PatchLevel.html">PatchLevel</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>patch_level</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Adjust boundary data of a level to be consistent with the multiblock nature of the domain. 
<p>
In a multiblock problem, the PatchLevels contain patches that were constructed independent of any knowledge of the multiblock nature of the complete domain. Thus the patches will contain boundary data that recognizes no difference between a physical domain boundary and a block boundary. Calling this method will adjust the boundary data on all patches in the given level such that the true boundaries of the domain are represented.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>patch_level</em>&nbsp;</td><td>Level where boundaries need to be adjusted.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Precondition:</b></dt><dd><a class="el" href="classSAMRAI_1_1hier_1_1BaseGridGeometry.html#9d11d3bc88025b781369ec0868c7c1c3">getDim()</a> == patch_level.getDim() <p>
patch_level.getGridGeometry()-&gt;<a class="el" href="classSAMRAI_1_1hier_1_1BaseGridGeometry.html#b232ac0f62df4ddf63640075c9809593">getNumberBlocks()</a> == <a class="el" href="classSAMRAI_1_1hier_1_1BaseGridGeometry.html#b232ac0f62df4ddf63640075c9809593">getNumberBlocks()</a></dd></dl>
TODO: Incorporate into regular boundary box computation once <a class="el" href="classSAMRAI_1_1hier_1_1PatchLevel.html">PatchLevel</a> is multiblock-aware. 
</div>
</div><p>
<a class="anchor" name="bcf69f3e15104c7360e0b5e54125faeb"></a><!-- doxytag: member="SAMRAI::hier::BaseGridGeometry::addCoarsenOperator" ref="bcf69f3e15104c7360e0b5e54125faeb" args="(const char *var_type_name, const boost::shared_ptr&lt; CoarsenOperator &gt; &amp;coarsen_op)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::hier::BaseGridGeometry::addCoarsenOperator           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>var_type_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1hier_1_1CoarsenOperator.html">CoarsenOperator</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>coarsen_op</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Add a concrete spatial coarsening operator. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>var_type_name</em>&nbsp;</td><td>The type name of the variable with which coarsen_op is associated. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>coarsen_op</em>&nbsp;</td><td>The concrete coarsening operator to add to the lookup list. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="ecef292efb8f956281623e8c1be436bf"></a><!-- doxytag: member="SAMRAI::hier::BaseGridGeometry::addRefineOperator" ref="ecef292efb8f956281623e8c1be436bf" args="(const char *var_type_name, const boost::shared_ptr&lt; RefineOperator &gt; &amp;refine_op)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::hier::BaseGridGeometry::addRefineOperator           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>var_type_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1hier_1_1RefineOperator.html">RefineOperator</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>refine_op</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Add a concrete spatial refinement operator. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>var_type_name</em>&nbsp;</td><td>The type name of the variable with which refine_op is associated. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>refine_op</em>&nbsp;</td><td>The concrete refinement operator to add to the lookup list. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="4a2393fa2136747608df8a6bd3e8a942"></a><!-- doxytag: member="SAMRAI::hier::BaseGridGeometry::addTimeInterpolateOperator" ref="4a2393fa2136747608df8a6bd3e8a942" args="(const char *var_type_name, const boost::shared_ptr&lt; TimeInterpolateOperator &gt; &amp;time_op)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::hier::BaseGridGeometry::addTimeInterpolateOperator           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>var_type_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1hier_1_1TimeInterpolateOperator.html">TimeInterpolateOperator</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>time_op</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Add a concrete time interpolation operator. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>var_type_name</em>&nbsp;</td><td>The type name of the variable with which time_op is associated. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>time_op</em>&nbsp;</td><td>The concrete time interpolation operator to add to the lookup list. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="9caec604d95019574c60247c97c75822"></a><!-- doxytag: member="SAMRAI::hier::BaseGridGeometry::lookupCoarsenOperator" ref="9caec604d95019574c60247c97c75822" args="(const boost::shared_ptr&lt; Variable &gt; &amp;var, const std::string &amp;op_name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::shared_ptr&lt;<a class="el" href="classSAMRAI_1_1hier_1_1CoarsenOperator.html">CoarsenOperator</a>&gt; SAMRAI::hier::BaseGridGeometry::lookupCoarsenOperator           </td>
          <td>(</td>
          <td class="paramtype">const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1hier_1_1Variable.html">Variable</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>var</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>op_name</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Lookup function for coarsening operator. 
<p>
Search list for the spatial coarsening operator matching the request for the given variable. If the operator is found, a pointer to it will be returned. Otherwise, an unrecoverable error will result and the program will abort.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>var</em>&nbsp;</td><td>The <a class="el" href="classSAMRAI_1_1hier_1_1Variable.html">Variable</a> for which the corresponding coarsening operator should match. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>op_name</em>&nbsp;</td><td>The string identifier of the coarsening operator. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="24ae5de0cee5397bfec289abbba31715"></a><!-- doxytag: member="SAMRAI::hier::BaseGridGeometry::lookupRefineOperator" ref="24ae5de0cee5397bfec289abbba31715" args="(const boost::shared_ptr&lt; Variable &gt; &amp;var, const std::string &amp;op_name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::shared_ptr&lt;<a class="el" href="classSAMRAI_1_1hier_1_1RefineOperator.html">RefineOperator</a>&gt; SAMRAI::hier::BaseGridGeometry::lookupRefineOperator           </td>
          <td>(</td>
          <td class="paramtype">const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1hier_1_1Variable.html">Variable</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>var</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>op_name</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Lookup function for refinement operator. 
<p>
Search list for the spatial refinement operator matching the request for the given variable. If the operator is found, a pointer to it will be returned. Otherwise, an unrecoverable error will result and the program will abort.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>var</em>&nbsp;</td><td>The <a class="el" href="classSAMRAI_1_1hier_1_1Variable.html">Variable</a> for which the corresponding refinement operator should match. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>op_name</em>&nbsp;</td><td>The string identifier of the refinement operator. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="203c33a511662e9c72fcddb9bc3b871b"></a><!-- doxytag: member="SAMRAI::hier::BaseGridGeometry::lookupTimeInterpolateOperator" ref="203c33a511662e9c72fcddb9bc3b871b" args="(const boost::shared_ptr&lt; Variable &gt; &amp;var, const std::string &amp;op_name=&quot;STD_LINEAR_TIME_INTERPOLATE&quot;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::shared_ptr&lt;<a class="el" href="classSAMRAI_1_1hier_1_1TimeInterpolateOperator.html">TimeInterpolateOperator</a>&gt; SAMRAI::hier::BaseGridGeometry::lookupTimeInterpolateOperator           </td>
          <td>(</td>
          <td class="paramtype">const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1hier_1_1Variable.html">Variable</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>var</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>op_name</em> = <code>&quot;STD_LINEAR_TIME_INTERPOLATE&quot;</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Lookup function for time interpolation operator. 
<p>
Search list for the time interpolation operator matching the request for the given variable. If the operator is found, a pointer to it will be returned. Otherwise, an unrecoverable error will result and the program will abort.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>var</em>&nbsp;</td><td>The <a class="el" href="classSAMRAI_1_1hier_1_1Variable.html">Variable</a> for which the corresponding time interpolation operator should match. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>op_name</em>&nbsp;</td><td>The string identifier of the time interpolation operator. <b>Default:</b> STD_LINEAR_TIME_INTERPOLATE </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="571bd04ea6ef3851ff969cfce86aa1e5"></a><!-- doxytag: member="SAMRAI::hier::BaseGridGeometry::setMinTransferOpStencilWidth" ref="571bd04ea6ef3851ff969cfce86aa1e5" args="(const IntVector &amp;min_value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::hier::BaseGridGeometry::setMinTransferOpStencilWidth           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>min_value</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set a minimum value on the value returned by <a class="el" href="classSAMRAI_1_1hier_1_1BaseGridGeometry.html#4fa66503a18aa7e4bf7f3ed80e196605">getMaxTransferOpStencilWidth()</a>. 
<p>
This method allows users to specify a minimum value returned by <a class="el" href="classSAMRAI_1_1hier_1_1BaseGridGeometry.html#4fa66503a18aa7e4bf7f3ed80e196605">getMaxTransferOpStencilWidth()</a>. The default minimum is zero. This value can be used as a substitute for data that is not yet registered with the Geometry and therefore cannot be reflected in <a class="el" href="classSAMRAI_1_1hier_1_1BaseGridGeometry.html#4fa66503a18aa7e4bf7f3ed80e196605">getMaxTransferOpStencilWidth()</a>.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>min_value</em>&nbsp;</td><td>The minimum value to set. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="9d11d3bc88025b781369ec0868c7c1c3"></a><!-- doxytag: member="SAMRAI::hier::BaseGridGeometry::getDim" ref="9d11d3bc88025b781369ec0868c7c1c3" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classSAMRAI_1_1tbox_1_1Dimension.html">tbox::Dimension</a>&amp; SAMRAI::hier::BaseGridGeometry::getDim           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the dimension of this object. 
<p>
<dl compact><dt><b>Returns:</b></dt><dd>the dimension of this object. </dd></dl>

</div>
</div><p>
<a class="anchor" name="e59b99b58fc078db1c36922ee5e851de"></a><!-- doxytag: member="SAMRAI::hier::BaseGridGeometry::getObjectName" ref="e59b99b58fc078db1c36922ee5e851de" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::string&amp; SAMRAI::hier::BaseGridGeometry::getObjectName           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the name of this object. 
<p>
<dl compact><dt><b>Returns:</b></dt><dd>The name of this object. </dd></dl>

</div>
</div><p>
<a class="anchor" name="87e73fcb379aeb33143d75dc9d028167"></a><!-- doxytag: member="SAMRAI::hier::BaseGridGeometry::registerNeighbors" ref="87e73fcb379aeb33143d75dc9d028167" args="(const BlockId &amp;block_a, const BlockId &amp;block_b, const Transformation::RotationIdentifier rotation_b_to_a, const IntVector &amp;shift_b_to_a, const int neighbor_type)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::hier::BaseGridGeometry::registerNeighbors           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1BlockId.html">BlockId</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>block_a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1BlockId.html">BlockId</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>block_b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1Transformation.html#2dd7d97a19db7c8e97402e8518c0af8d">Transformation::RotationIdentifier</a>&nbsp;</td>
          <td class="paramname"> <em>rotation_b_to_a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>shift_b_to_a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>neighbor_type</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Register a relationship between two neighboring blocks of a multiblock domain. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>block_a</em>&nbsp;</td><td>One block in the relationship </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>block_b</em>&nbsp;</td><td>The other block </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>rotation_b_to_a</em>&nbsp;</td><td>The rotation that aligns block b's index space with block a's </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>shift_b_to_a</em>&nbsp;</td><td>The post-rotation shift to move b into its correct location within a's index space </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>neighbor_type</em>&nbsp;</td><td>The type (codimension) of the neighbor relationship</td></tr>
  </table>
</dl>
<dl compact><dt><b>Precondition:</b></dt><dd><a class="el" href="classSAMRAI_1_1hier_1_1BaseGridGeometry.html#9d11d3bc88025b781369ec0868c7c1c3">getDim()</a> = shift_b_to_a.getDim() </dd></dl>

</div>
</div><p>
<a class="anchor" name="b2ccb71f6163ba0f739f8fca2c5109f1"></a><!-- doxytag: member="SAMRAI::hier::BaseGridGeometry::getDomainOutsideBlock" ref="b2ccb71f6163ba0f739f8fca2c5109f1" args="(BoxContainer &amp;domain_outside_block, const BlockId &amp;block_id) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::hier::BaseGridGeometry::getDomainOutsideBlock           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>domain_outside_block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1BlockId.html">BlockId</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>block_id</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get a <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a> that contains all of the index space of all other blocks in the multiblock domain. 
<p>
A <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a> will be constructed that contains the full set of the coarse level domains of all blocks except the one identified by block_id. The domains will all be transformed into the index space represented by block_id.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>domain_outside_block</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>block_id</em>&nbsp;</td><td></td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="8e8bfc592ce1ce3632c2ce548782d35b"></a><!-- doxytag: member="SAMRAI::hier::BaseGridGeometry::getNumberOfBlockSingularities" ref="8e8bfc592ce1ce3632c2ce548782d35b" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int SAMRAI::hier::BaseGridGeometry::getNumberOfBlockSingularities           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return the number of block singularities in the block configuration. 
<p>

</div>
</div><p>
<a class="anchor" name="fc696ada5b9f9a5d84544a801dfbb5bb"></a><!-- doxytag: member="SAMRAI::hier::BaseGridGeometry::getSingularityBoxContainer" ref="fc696ada5b9f9a5d84544a801dfbb5bb" args="(const BlockId &amp;block_id) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a>&amp; SAMRAI::hier::BaseGridGeometry::getSingularityBoxContainer           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1BlockId.html">BlockId</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>block_id</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return a <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a> that describes all of the singularities touched by the block indicated by block_id. 
<p>
<dl compact><dt><b>Returns:</b></dt><dd>For every singularity point the block touches, the <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a> will contain a single-cell box that lies just outside the block domain, touching the block only at the singularity point. For line singularities, the <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a> will contain boxes of width 1 in all directions except one, lying outside the block's coarse-level domain and touching the domain only along the line of singularity.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>block_id</em>&nbsp;</td><td></td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="aec0483604beb9036172bd05f69d6587"></a><!-- doxytag: member="SAMRAI::hier::BaseGridGeometry::getSingularityIndices" ref="aec0483604beb9036172bd05f69d6587" args="(const BlockId &amp;block_id) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;int&gt;&amp; SAMRAI::hier::BaseGridGeometry::getSingularityIndices           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1BlockId.html">BlockId</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>block_id</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return a list of integers indicating all of the singularities touched by the block indicated by block_id. 
<p>
<dl compact><dt><b>Returns:</b></dt><dd>For every singularity point the block touches, the vector&lt;int&gt; will contain the index of that singularity.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>block_id</em>&nbsp;</td><td></td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="710cc9937538b7fa12880a1b3457b0b2"></a><!-- doxytag: member="SAMRAI::hier::BaseGridGeometry::reducedConnectivityExists" ref="710cc9937538b7fa12880a1b3457b0b2" args="(const BlockId &amp;block_id) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SAMRAI::hier::BaseGridGeometry::reducedConnectivityExists           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1BlockId.html">BlockId</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>block_id</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Tell if block represented by block_id touches a reduced-connectivity singularity. 
<p>
<dl compact><dt><b>Returns:</b></dt><dd>True if the block touches reduced connectivity singularity, false if not.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>block_id</em>&nbsp;</td><td></td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="54d295355deb36e3ff8507bcce711691"></a><!-- doxytag: member="SAMRAI::hier::BaseGridGeometry::transformBox" ref="54d295355deb36e3ff8507bcce711691" args="(Box &amp;box, const IntVector &amp;ratio, const BlockId &amp;output_block, const BlockId &amp;input_block) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SAMRAI::hier::BaseGridGeometry::transformBox           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>box</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>ratio</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1BlockId.html">BlockId</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>output_block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1BlockId.html">BlockId</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>input_block</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Modify a box by rotating and shifting from the index space of the transformed_block to the index space of the base_block at the resolution level defined by ratio_to_level_zero. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>box</em>&nbsp;</td><td>The boxes will be transformed from the transformed_block index space to the base_block index space. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>ratio</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>output_block</em>&nbsp;</td><td>Integer identifier of the block whose index space will be represented in the boxes at output </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>input_block</em>&nbsp;</td><td>Integer identifier of the block whose index space is represented in the boxes at input</td></tr>
  </table>
</dl>
<dl compact><dt><b>Precondition:</b></dt><dd>(<a class="el" href="classSAMRAI_1_1hier_1_1BaseGridGeometry.html#9d11d3bc88025b781369ec0868c7c1c3">getDim()</a> == box.getDim()) &amp;&amp; (<a class="el" href="classSAMRAI_1_1hier_1_1BaseGridGeometry.html#9d11d3bc88025b781369ec0868c7c1c3">getDim()</a> == ratio.getDim())</dd></dl>
<dl compact><dt><b>Returns:</b></dt><dd>Whether the box has been transformed. True if there is a relationship between input_block and output_block. False if there is no such relationship. </dd></dl>

</div>
</div><p>
<a class="anchor" name="6a1defea91aa9a819792130ac87cafb9"></a><!-- doxytag: member="SAMRAI::hier::BaseGridGeometry::transformBoxContainer" ref="6a1defea91aa9a819792130ac87cafb9" args="(BoxContainer &amp;boxes, const IntVector &amp;ratio, const BlockId &amp;output_block, const BlockId &amp;input_block) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SAMRAI::hier::BaseGridGeometry::transformBoxContainer           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>boxes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>ratio</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1BlockId.html">BlockId</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>output_block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1BlockId.html">BlockId</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>input_block</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Modify boxes by rotating and shifting from the index space of the input_block to the index space of the output_block at the resolution level defined by ratio_to_level_zero. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>boxes</em>&nbsp;</td><td>The boxes will be transformed from the input_block index space to the output_block index space. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>ratio</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>output_block</em>&nbsp;</td><td>Integer identifier of the block whose index space will be represented in the boxes at output </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>input_block</em>&nbsp;</td><td>Integer identifier of the block whose index space is represented in the boxes at input</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Whether the boxes have been transformed. True if there is a relationship between input_block and output_block. False if there is no such relationship. </dd></dl>

</div>
</div><p>
<a class="anchor" name="f7d5a8c2276d52a38e2c335fa168f109"></a><!-- doxytag: member="SAMRAI::hier::BaseGridGeometry::getTransformedBlock" ref="f7d5a8c2276d52a38e2c335fa168f109" args="(BoxContainer &amp;block_boxes, const BlockId &amp;base_block, const BlockId &amp;transformed_block)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::hier::BaseGridGeometry::getTransformedBlock           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>block_boxes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1BlockId.html">BlockId</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>base_block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1BlockId.html">BlockId</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>transformed_block</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get a box array that describes the coarse-level domain of the transformed_block in terms of the index space of base_block. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>block_boxes</em>&nbsp;</td><td>The coarse-level domain of the block identified by transformed_block, represented in the index space of the block identified by base_block </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>base_block</em>&nbsp;</td><td>The block whose index space will be used for the output boxes </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>transformed_block</em>&nbsp;</td><td>ID of another block whose domain will be represented in the index space of the base block </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="63e07df4bba597491e27b317b018e7cc"></a><!-- doxytag: member="SAMRAI::hier::BaseGridGeometry::getNeighbors" ref="63e07df4bba597491e27b317b018e7cc" args="(const BlockId &amp;block_id) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::list&lt;<a class="el" href="classSAMRAI_1_1hier_1_1BaseGridGeometry_1_1Neighbor.html">Neighbor</a>&gt;&amp; SAMRAI::hier::BaseGridGeometry::getNeighbors           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1BlockId.html">BlockId</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>block_id</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return a list of <a class="el" href="classSAMRAI_1_1hier_1_1BaseGridGeometry_1_1Neighbor.html">Neighbor</a> objects describing all of the neighbors of the block indicated by the block_id. 
<p>
<dl compact><dt><b>Returns:</b></dt><dd>The list of neighbors</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>block_id</em>&nbsp;</td><td></td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="8f7b5ea584e4bcb325fcc59bc2c0e654"></a><!-- doxytag: member="SAMRAI::hier::BaseGridGeometry::getNumberOfNeighbors" ref="8f7b5ea584e4bcb325fcc59bc2c0e654" args="(const BlockId &amp;block_id) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int SAMRAI::hier::BaseGridGeometry::getNumberOfNeighbors           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1BlockId.html">BlockId</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>block_id</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return the number of neighbors a specific block of the Multiblock domain has. 
<p>
A block is the neighbor of another block if the two blocks abut in any way, whether at a point, a 1D line, or a 2D plane.<p>
<dl compact><dt><b>Returns:</b></dt><dd>The number of neighbors</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>block_id</em>&nbsp;</td><td></td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="b6f08d17ed3d3108f575d44620c66b1d"></a><!-- doxytag: member="SAMRAI::hier::BaseGridGeometry::areNeighbors" ref="b6f08d17ed3d3108f575d44620c66b1d" args="(const BlockId &amp;block_a, const BlockId &amp;block_b) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SAMRAI::hier::BaseGridGeometry::areNeighbors           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1BlockId.html">BlockId</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>block_a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1BlockId.html">BlockId</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>block_b</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Tell if the given BlockIds represent neighboring blocks. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>block_a</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>block_b</em>&nbsp;</td><td></td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="bea2a02283882c0f1b7e2bbeaccd0962"></a><!-- doxytag: member="SAMRAI::hier::BaseGridGeometry::areSingularityNeighbors" ref="bea2a02283882c0f1b7e2bbeaccd0962" args="(const BlockId &amp;block_a, const BlockId &amp;block_b) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SAMRAI::hier::BaseGridGeometry::areSingularityNeighbors           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1BlockId.html">BlockId</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>block_a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1BlockId.html">BlockId</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>block_b</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Tell if the given BlockIds represent neighboring blocks. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>block_a</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>block_b</em>&nbsp;</td><td></td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="e42b72e7ac995e307de1ce3a6a03fc1d"></a><!-- doxytag: member="SAMRAI::hier::BaseGridGeometry::getRotationIdentifier" ref="e42b72e7ac995e307de1ce3a6a03fc1d" args="(const BlockId &amp;dst, const BlockId &amp;src) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSAMRAI_1_1hier_1_1Transformation.html#2dd7d97a19db7c8e97402e8518c0af8d">Transformation::RotationIdentifier</a> SAMRAI::hier::BaseGridGeometry::getRotationIdentifier           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1BlockId.html">BlockId</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1BlockId.html">BlockId</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>src</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the rotation identifier to rotate from src to dst.\. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dst</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>src</em>&nbsp;</td><td></td></tr>
  </table>
</dl>
<dl compact><dt><b>Precondition:</b></dt><dd>areNeighbors(dst, src) </dd></dl>

</div>
</div><p>
<a class="anchor" name="507de6c39e6ad6f40bbafe70ea9f6b9d"></a><!-- doxytag: member="SAMRAI::hier::BaseGridGeometry::getOffset" ref="507de6c39e6ad6f40bbafe70ea9f6b9d" args="(const BlockId &amp;dst, const BlockId &amp;src) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp; SAMRAI::hier::BaseGridGeometry::getOffset           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1BlockId.html">BlockId</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1BlockId.html">BlockId</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>src</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the offset to shift from src to dst after rotation. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dst</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>src</em>&nbsp;</td><td></td></tr>
  </table>
</dl>
<dl compact><dt><b>Precondition:</b></dt><dd>areNeighbors(dst, src) </dd></dl>

</div>
</div><p>
<a class="anchor" name="5bc0d426345a277583c1a8689efb5f85"></a><!-- doxytag: member="SAMRAI::hier::BaseGridGeometry::hasEnhancedConnectivity" ref="5bc0d426345a277583c1a8689efb5f85" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SAMRAI::hier::BaseGridGeometry::hasEnhancedConnectivity           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Query if the geometry has enhanced connectivity. 
<p>

</div>
</div><p>
<a class="anchor" name="2a44cc9f46a022c854e761a8cef83e92"></a><!-- doxytag: member="SAMRAI::hier::BaseGridGeometry::printClassData" ref="2a44cc9f46a022c854e761a8cef83e92" args="(std::ostream &amp;stream) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::hier::BaseGridGeometry::printClassData           </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&nbsp;</td>
          <td class="paramname"> <em>stream</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Print object data to the specified output stream. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>stream</em>&nbsp;</td><td>The output stream (as a std::ostream&amp;) to print to. </td></tr>
  </table>
</dl>

<p>
Reimplemented in <a class="el" href="classSAMRAI_1_1geom_1_1CartesianGridGeometry.html#2b7be3a14abd613b20a062bb6fe43f24">SAMRAI::geom::CartesianGridGeometry</a>.
</div>
</div><p>
<a class="anchor" name="48bbb36fc2179d989b6a148f79c3b977"></a><!-- doxytag: member="SAMRAI::hier::BaseGridGeometry::putToRestart" ref="48bbb36fc2179d989b6a148f79c3b977" args="(const boost::shared_ptr&lt; tbox::Database &gt; &amp;restart_db) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::hier::BaseGridGeometry::putToRestart           </td>
          <td>(</td>
          <td class="paramtype">const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Database.html">tbox::Database</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>restart_db</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Writes the state of the <a class="el" href="classSAMRAI_1_1hier_1_1BaseGridGeometry.html">BaseGridGeometry</a> object to the restart database. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>restart_db</em>&nbsp;</td><td>The restart database to write/serialize to.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Precondition:</b></dt><dd>restart_db </dd></dl>

<p>
Reimplemented in <a class="el" href="classSAMRAI_1_1geom_1_1CartesianGridGeometry.html#1f724c022cc68e70e22d57ad5b9df048">SAMRAI::geom::CartesianGridGeometry</a>.
</div>
</div><p>
<a class="anchor" name="b2d5cbd3201d19708fda5320b94b6402"></a><!-- doxytag: member="SAMRAI::hier::BaseGridGeometry::readBlockDataFromInput" ref="b2d5cbd3201d19708fda5320b94b6402" args="(const boost::shared_ptr&lt; tbox::Database &gt; &amp;input_db)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::hier::BaseGridGeometry::readBlockDataFromInput           </td>
          <td>(</td>
          <td class="paramtype">const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Database.html">tbox::Database</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>input_db</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Read multiblock metadata input from the input database. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>input_db</em>&nbsp;</td><td></td></tr>
  </table>
</dl>
<dl compact><dt><b>Precondition:</b></dt><dd>input_db </dd></dl>

</div>
</div><p>
<hr><h2>Friends And Related Function Documentation</h2>
<a class="anchor" name="fd278c6c8ecae0cdc8c275f95d1eadcb"></a><!-- doxytag: member="SAMRAI::hier::BaseGridGeometry::TransferOperatorRegistry" ref="fd278c6c8ecae0cdc8c275f95d1eadcb" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="classSAMRAI_1_1hier_1_1TransferOperatorRegistry.html">TransferOperatorRegistry</a><code> [friend]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>
Reimplemented in <a class="el" href="classSAMRAI_1_1geom_1_1GridGeometry.html#fd278c6c8ecae0cdc8c275f95d1eadcb">SAMRAI::geom::GridGeometry</a>.
</div>
</div><p>
<hr><h2>Member Data Documentation</h2>
<a class="anchor" name="3f77f497366bc01a1f1082995cb27fd3"></a><!-- doxytag: member="SAMRAI::hier::BaseGridGeometry::d_transfer_operator_registry" ref="3f77f497366bc01a1f1082995cb27fd3" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::shared_ptr&lt;<a class="el" href="classSAMRAI_1_1hier_1_1TransferOperatorRegistry.html">TransferOperatorRegistry</a>&gt; <a class="el" href="classSAMRAI_1_1hier_1_1BaseGridGeometry.html#3f77f497366bc01a1f1082995cb27fd3">SAMRAI::hier::BaseGridGeometry::d_transfer_operator_registry</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The holder of all the transfer operators. 
</div>
</div><p>
<a class="anchor" name="3db460feb609c2e0619cc971dfe5cc94"></a><!-- doxytag: member="SAMRAI::hier::BaseGridGeometry::d_dim" ref="3db460feb609c2e0619cc971dfe5cc94" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSAMRAI_1_1tbox_1_1Dimension.html">tbox::Dimension</a> <a class="el" href="classSAMRAI_1_1hier_1_1BaseGridGeometry.html#3db460feb609c2e0619cc971dfe5cc94">SAMRAI::hier::BaseGridGeometry::d_dim</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<hr>The documentation for this class was generated from the following files:<ul>
<li>source/SAMRAI/hier/<a class="el" href="BaseGridGeometry_8h.html">BaseGridGeometry.h</a><li>source/SAMRAI/hier/<a class="el" href="BaseGridGeometry_8C.html">BaseGridGeometry.C</a></ul>
<hr size="1"><address style="align: right;"><small>Generated on 16 Jan 2013 for SAMRAI by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.7 </small></address>
</body>
</html>
