<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>SAMRAI: SAMRAI::hier::GridGeometry Class Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.7 -->
<div class="tabs">
  <ul>
    <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="namespaces.html"><span>Namespaces</span></a></li>
    <li id="current"><a href="annotated.html"><span>Classes</span></a></li>
    <li><a href="files.html"><span>Files</span></a></li>
    <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
  </ul></div>
<div class="tabs">
  <ul>
    <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
    <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
    <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
  </ul></div>
<div class="nav">
<a class="el" href="namespaceSAMRAI.html">SAMRAI</a>::<a class="el" href="namespaceSAMRAI_1_1hier.html">hier</a>::<a class="el" href="classSAMRAI_1_1hier_1_1GridGeometry.html">GridGeometry</a></div>
<h1>SAMRAI::hier::GridGeometry Class Reference</h1><!-- doxytag: class="SAMRAI::hier::GridGeometry" --><!-- doxytag: inherits="SAMRAI::tbox::Serializable" -->Class <a class="el" href="classSAMRAI_1_1hier_1_1GridGeometry.html">GridGeometry</a> manages the index space that determines the extent of the coarse-level domain of a <a class="el" href="namespaceSAMRAI.html">SAMRAI</a> hierarchy.  
<a href="#_details">More...</a>
<p>
<code>#include &lt;source/SAMRAI/hier/GridGeometry.h&gt;</code>
<p>
<p>Inheritance diagram for SAMRAI::hier::GridGeometry:
<p><center><img src="classSAMRAI_1_1hier_1_1GridGeometry.png" usemap="#SAMRAI::hier::GridGeometry_map" border="0" alt=""></center>
<map name="SAMRAI::hier::GridGeometry_map">
<area href="classSAMRAI_1_1tbox_1_1Serializable.html" alt="SAMRAI::tbox::Serializable" shape="rect" coords="122,56,356,80">
<area href="classtbox_1_1DescribedClass.html" alt="DescribedClass" shape="rect" coords="122,0,356,24">
<area href="classSAMRAI_1_1geom_1_1CartesianGridGeometry.html" alt="SAMRAI::geom::CartesianGridGeometry" shape="rect" coords="0,168,234,192">
<area href="classSAMRAI_1_1geom_1_1SkeletonGridGeometry.html" alt="SAMRAI::geom::SkeletonGridGeometry" shape="rect" coords="244,168,478,192">
</map>
<a href="classSAMRAI_1_1hier_1_1GridGeometry-members.html">List of all members.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Types</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef <a class="el" href="classSAMRAI_1_1hier_1_1PatchGeometry_1_1TwoDimBool.html">PatchGeometry::TwoDimBool</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1GridGeometry.html#a067b43bb245f7db27f1d9c6a6fe60df">TwoDimBool</a></td></tr>

<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1GridGeometry.html#4039a270748db76a5b168ba04b932014">GridGeometry</a> (const <a class="el" href="classSAMRAI_1_1tbox_1_1Dimension.html">tbox::Dimension</a> &amp;dim, const std::string &amp;object_name, <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1TransferOperatorRegistry.html">TransferOperatorRegistry</a> &gt; op_reg, <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Database.html">tbox::Database</a> &gt; input_db, bool register_for_restart=true)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Construct a new <a class="el" href="classSAMRAI_1_1hier_1_1GridGeometry.html">GridGeometry</a> object and initialize from input.  <a href="#4039a270748db76a5b168ba04b932014"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1GridGeometry.html#8bf4551d1b881009ba582d1562a58a1e">GridGeometry</a> (const std::string &amp;object_name, const <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a> &amp;domain, <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1TransferOperatorRegistry.html">TransferOperatorRegistry</a> &gt; op_reg, bool register_for_restart=true)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Construct a new <a class="el" href="classSAMRAI_1_1hier_1_1GridGeometry.html">GridGeometry</a> object based on arguments.  <a href="#8bf4551d1b881009ba582d1562a58a1e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1GridGeometry.html#2596b5f1aaebff123e0c700f24bef2a7">~GridGeometry</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Virtual destructor.  <a href="#2596b5f1aaebff123e0c700f24bef2a7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1GridGeometry.html#bb788a82cee88858e6c1f14f985c30ff">computePhysicalDomain</a> (<a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a> &amp;domain, const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;ratio_to_level_zero, const <a class="el" href="classSAMRAI_1_1hier_1_1BlockId.html">BlockId</a> &amp;block_id) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute the box array describing the index space for a given block of the physical domain.  <a href="#bb788a82cee88858e6c1f14f985c30ff"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1GridGeometry.html#a4602967279869484958b255fdef9687">computePhysicalDomainWithPeriodicImages</a> (<a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a> &amp;domain, const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;ratio_to_level_zero, const <a class="el" href="classSAMRAI_1_1hier_1_1BlockId.html">BlockId</a> &amp;block_id) const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1GridGeometry.html#d9d00cec612bb863e5530052c993255a">computePhysicalDomain</a> (<a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a> &amp;box_level, const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;ratio_to_level_zero, const <a class="el" href="classSAMRAI_1_1hier_1_1BlockId.html">BlockId</a> &amp;block_id) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute the <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a> describing the index space for a given block of the physical domain.  <a href="#d9d00cec612bb863e5530052c993255a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1GridGeometry.html#95e260740993b88bbc314bf1c167e4b0">computePhysicalDomain</a> (<a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a> &amp;domain_mapped_boxes, const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;ratio_to_level_zero) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute the <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a> describing the complete physical domain for all blocks.  <a href="#95e260740993b88bbc314bf1c167e4b0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1GridGeometry.html#910ac179ae4a2e11e8482ab1dfa4d0b9">computePhysicalDomain</a> (<a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a> &amp;box_level, const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;ratio_to_level_zero) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute the <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a> describing the complete physical domain for all blocks.  <a href="#910ac179ae4a2e11e8482ab1dfa4d0b9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1GridGeometry.html#c26e3fd28ea905ce58e2bae7e7b1c2e6">setPhysicalDomain</a> (const <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a> &amp;domain, const int number_blocks)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the physical domain (for level zero).  <a href="#c26e3fd28ea905ce58e2bae7e7b1c2e6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">const <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1GridGeometry.html#ada304bdcf24d9f43ccf96d43bbc90f6">getPhysicalDomain</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the physical domain description for a given block on level zero.  <a href="#ada304bdcf24d9f43ccf96d43bbc90f6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">const <a class="el" href="classSAMRAI_1_1hier_1_1MultiblockBoxTree.html">hier::MultiblockBoxTree</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1GridGeometry.html#92176376dade52932d2ba180f6131807">getDomainSearchTree</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Access the multiblock domain description as a tree without periodic images.  <a href="#92176376dade52932d2ba180f6131807"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">const <a class="el" href="classSAMRAI_1_1hier_1_1MultiblockBoxTree.html">hier::MultiblockBoxTree</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1GridGeometry.html#9d4baca19e485a64caed7c011f5a8165">getPeriodicDomainSearchTree</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Access the multiblock domain description with periodic images (if any).  <a href="#9d4baca19e485a64caed7c011f5a8165"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1GridGeometry.html#e86d6921cc850b1f1faf46912c8fc2b7">getDomainIsSingleBox</a> (const <a class="el" href="classSAMRAI_1_1hier_1_1BlockId.html">hier::BlockId</a> &amp;block_id) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">returns whether the physical domain for a block managed by this geometry object can be represented as a single box.  <a href="#e86d6921cc850b1f1faf46912c8fc2b7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1GridGeometry.html#276b1a57b1936b82db997db1fb68d5ae">initializePeriodicShift</a> (const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;directions)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Initialize the periodic shift on the coarsest level.  <a href="#276b1a57b1936b82db997db1fb68d5ae"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1GridGeometry.html#303b28d43f00b8d2f70c328d9980f09a">getPeriodicShift</a> (const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;ratio_to_level_zero) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the periodic shift in each direction for the physical domain managed by this geometry object.  <a href="#303b28d43f00b8d2f70c328d9980f09a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1GridGeometry.html#565340eb5479af6144f5f94ebd018983">getNumberBlocks</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the number of blocks in the geometry.  <a href="#565340eb5479af6144f5f94ebd018983"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1GridGeometry.html#aedff762bf58267e0f04643c54b0eff5">getMaxTransferOpStencilWidth</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the max stencil width of all transfer operators.  <a href="#aedff762bf58267e0f04643c54b0eff5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1GridGeometry.html">GridGeometry</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1GridGeometry.html#163389d7c32ac0bd63cc1b423d4c29ae">makeRefinedGridGeometry</a> (const std::string &amp;fine_geom_name, const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;refine_ratio, bool register_for_restart) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a pointer to a refined version of this grid geometry object.  <a href="#163389d7c32ac0bd63cc1b423d4c29ae"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1GridGeometry.html">GridGeometry</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1GridGeometry.html#2b74abf55f7dbcbb2c0c0da0ff2281fa">makeCoarsenedGridGeometry</a> (const std::string &amp;coarse_geom_name, const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;coarsen_ratio, bool register_for_restart) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a pointer to a coarsened version of this grid geometry object.  <a href="#2b74abf55f7dbcbb2c0c0da0ff2281fa"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1GridGeometry.html#450641490d60bee95396607bb657a200">setGeometryDataOnPatch</a> (<a class="el" href="classSAMRAI_1_1hier_1_1Patch.html">Patch</a> &amp;patch, const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;ratio_to_level_zero, const <a class="el" href="classSAMRAI_1_1hier_1_1PatchGeometry_1_1TwoDimBool.html">TwoDimBool</a> &amp;touches_regular_bdry, const <a class="el" href="classSAMRAI_1_1hier_1_1PatchGeometry_1_1TwoDimBool.html">TwoDimBool</a> &amp;touches_periodic_bdry) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute and set grid data for patch.  <a href="#450641490d60bee95396607bb657a200"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1GridGeometry.html#10100ad2eb58db0fc733d1ee3a45e4aa">computeBoundaryBoxesOnLevel</a> (std::map&lt; <a class="el" href="classSAMRAI_1_1hier_1_1BoxId.html">BoxId</a>, <a class="el" href="classSAMRAI_1_1hier_1_1PatchBoundaries.html">PatchBoundaries</a> &gt; &amp;boundaries, const <a class="el" href="classSAMRAI_1_1hier_1_1PatchLevel.html">PatchLevel</a> &amp;level, const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;periodic_shift, const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;ghost_width, const <a class="el" href="classSAMRAI_1_1tbox_1_1Array.html">tbox::Array</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a> &gt; &amp;domain, bool do_all_patches=false) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute boundary boxes for each patch in patch level.  <a href="#10100ad2eb58db0fc733d1ee3a45e4aa"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1GridGeometry.html#3a080e93fea5e637c44d302c54a221f8">getBoundaryBoxes</a> (<a class="el" href="classSAMRAI_1_1hier_1_1PatchBoundaries.html">PatchBoundaries</a> &amp;patch_boundaries, const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> &amp;box, const <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a> &amp;domain_boxes, const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;ghosts, const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;periodic_shift) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute boundary boxes for patch.  <a href="#3a080e93fea5e637c44d302c54a221f8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1GridGeometry.html#6d1b0986f56769b47a1fa20632796c84">adjustMultiblockPatchLevelBoundaries</a> (<a class="el" href="classSAMRAI_1_1hier_1_1PatchLevel.html">PatchLevel</a> &amp;patch_level)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adjust boundary data of a level to be consistent with the multiblock nature of the domain.  <a href="#6d1b0986f56769b47a1fa20632796c84"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1GridGeometry.html#e729afebacb7c28b91971d6e14c6953f">addCoarsenOperator</a> (<a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1CoarsenOperator.html">CoarsenOperator</a> &gt; coarsen_op)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Add a concrete spatial coarsening operator.  <a href="#e729afebacb7c28b91971d6e14c6953f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1GridGeometry.html#470a3d7189169675e7ef2372d1fffdcd">addRefineOperator</a> (<a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1RefineOperator.html">RefineOperator</a> &gt; refine_op)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Add a concrete spatial refinement operator.  <a href="#470a3d7189169675e7ef2372d1fffdcd"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1GridGeometry.html#3ec574be30faf410e8a85bb524eef980">addTimeInterpolateOperator</a> (<a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1TimeInterpolateOperator.html">TimeInterpolateOperator</a> &gt; time_op)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Add a concrete time interpolation operator.  <a href="#3ec574be30faf410e8a85bb524eef980"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1CoarsenOperator.html">CoarsenOperator</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1GridGeometry.html#13568e6dc5d25c1cf4493631753bd7f2">lookupCoarsenOperator</a> (const <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1Variable.html">Variable</a> &gt; &amp;var, const std::string &amp;op_name)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Lookup function for coarsening operator.  <a href="#13568e6dc5d25c1cf4493631753bd7f2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1RefineOperator.html">RefineOperator</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1GridGeometry.html#de29d884bc838dbcaf83c90cf870c762">lookupRefineOperator</a> (const <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1Variable.html">Variable</a> &gt; &amp;var, const std::string &amp;op_name)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Lookup function for refinement operator.  <a href="#de29d884bc838dbcaf83c90cf870c762"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1TimeInterpolateOperator.html">TimeInterpolateOperator</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1GridGeometry.html#d1ece0d12058bf8ebd05ae5cbe4b063e">lookupTimeInterpolateOperator</a> (const <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1Variable.html">Variable</a> &gt; &amp;var, const std::string &amp;op_name=&quot;STD_LINEAR_TIME_INTERPOLATE&quot;)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Lookup function for time interpolation operator.  <a href="#d1ece0d12058bf8ebd05ae5cbe4b063e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1GridGeometry.html#5d9d8719877289c4d90b56a3d04327b0">setMinTransferOpStencilWidth</a> (const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;min_value)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set a minimum value on the value returned by <a class="el" href="classSAMRAI_1_1hier_1_1GridGeometry.html#aedff762bf58267e0f04643c54b0eff5">getMaxTransferOpStencilWidth()</a>.  <a href="#5d9d8719877289c4d90b56a3d04327b0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">const <a class="el" href="classSAMRAI_1_1tbox_1_1Dimension.html">tbox::Dimension</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1GridGeometry.html#35b725f27cb55767ce368321bcd5b72a">getDim</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the dimension of this object.  <a href="#35b725f27cb55767ce368321bcd5b72a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">const std::string &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1GridGeometry.html#d86c032af40967330aeec23e9045e4c6">getObjectName</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the name of this object.  <a href="#d86c032af40967330aeec23e9045e4c6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1GridGeometry.html#816bc77a0a929abf0c4a6ec17fcde11e">registerNeighbors</a> (const <a class="el" href="classSAMRAI_1_1hier_1_1BlockId.html">BlockId</a> &amp;block_a, const <a class="el" href="classSAMRAI_1_1hier_1_1BlockId.html">BlockId</a> &amp;block_b, const <a class="el" href="classSAMRAI_1_1hier_1_1Transformation.html#1908f436f2e3bec8b6c0c24b3fcb8cd9">Transformation::RotationIdentifier</a> rotation_b_to_a, const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;shift_b_to_a, const int neighbor_type)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Register a relationship between two neighboring blocks of a multiblock domain.  <a href="#816bc77a0a929abf0c4a6ec17fcde11e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1GridGeometry.html#d59c74e6976cd369dc2c69014f850516">getDomainOutsideBlock</a> (<a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a> &amp;domain_outside_block, const <a class="el" href="classSAMRAI_1_1hier_1_1BlockId.html">BlockId</a> &amp;block_id) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get a <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a> that contains all of the index space of all other blocks in the multiblock domain.  <a href="#d59c74e6976cd369dc2c69014f850516"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1GridGeometry.html#d9b60652d713a1ff3ce7721c647c8d45">getNumberOfBlockSingularities</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the number of block singularities in the block configuration.  <a href="#d9b60652d713a1ff3ce7721c647c8d45"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">const <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1GridGeometry.html#1a3ff8d09d283250fc144ffaae4ccb09">getSingularityBoxContainer</a> (const <a class="el" href="classSAMRAI_1_1hier_1_1BlockId.html">BlockId</a> &amp;block_id) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return a <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a> that describes all of the singularities touched by the block indicated by block_id.  <a href="#1a3ff8d09d283250fc144ffaae4ccb09"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">const std::vector&lt; int &gt; &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1GridGeometry.html#0c4b5a9bd8b6a24a61706c7a75698b37">getSingularityIndices</a> (const <a class="el" href="classSAMRAI_1_1hier_1_1BlockId.html">BlockId</a> &amp;block_id) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return a list of integers indicating all of the singularities touched by the block indicated by block_id.  <a href="#0c4b5a9bd8b6a24a61706c7a75698b37"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1GridGeometry.html#01cdbc71930809e425f4b3c09d8f6ec2">reducedConnectivityExists</a> (const <a class="el" href="classSAMRAI_1_1hier_1_1BlockId.html">BlockId</a> &amp;block_id) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Tell if block represented by block_id touches a reduced-connectivity singularity.  <a href="#01cdbc71930809e425f4b3c09d8f6ec2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1GridGeometry.html#f486765951cef181c91a3b84a3b5e799">transformBox</a> (<a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> &amp;box, const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;ratio, const <a class="el" href="classSAMRAI_1_1hier_1_1BlockId.html">BlockId</a> &amp;output_block, const <a class="el" href="classSAMRAI_1_1hier_1_1BlockId.html">BlockId</a> &amp;input_block) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Modify a box by rotating and shifting from the index space of the transformed_block to the index space of the base_block at the resolution level defined by ratio_to_level_zero.  <a href="#f486765951cef181c91a3b84a3b5e799"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1GridGeometry.html#c57e694962a56f62ba5602125b0819db">transformBoxContainer</a> (<a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a> &amp;boxes, const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;ratio, const <a class="el" href="classSAMRAI_1_1hier_1_1BlockId.html">BlockId</a> &amp;output_block, const <a class="el" href="classSAMRAI_1_1hier_1_1BlockId.html">BlockId</a> &amp;input_block) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Modify boxes by rotating and shifting from the index space of the input_block to the index space of the output_block at the resolution level defined by ratio_to_level_zero.  <a href="#c57e694962a56f62ba5602125b0819db"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1GridGeometry.html#07dcda0cc3204ae0c8e86cef7006f4ef">getTransformedBlock</a> (<a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a> &amp;block_boxes, const <a class="el" href="classSAMRAI_1_1hier_1_1BlockId.html">BlockId</a> &amp;base_block, const <a class="el" href="classSAMRAI_1_1hier_1_1BlockId.html">BlockId</a> &amp;transformed_block)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get a box array that describes the coarse-level domain of the transformed_block in terms of the index space of base_block.  <a href="#07dcda0cc3204ae0c8e86cef7006f4ef"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">const <a class="el" href="classSAMRAI_1_1tbox_1_1List.html">tbox::List</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1GridGeometry_1_1Neighbor.html">Neighbor</a> &gt; &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1GridGeometry.html#0b23ed4d51934326c8e3dad30465b7b9">getNeighbors</a> (const <a class="el" href="classSAMRAI_1_1hier_1_1BlockId.html">BlockId</a> &amp;block_id) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return a list of <a class="el" href="classSAMRAI_1_1hier_1_1GridGeometry_1_1Neighbor.html">Neighbor</a> objects describing all of the neighbors of the block indicated by the block_id.  <a href="#0b23ed4d51934326c8e3dad30465b7b9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1GridGeometry.html#417bd4a8a3ec5e760262d9202ee716ad">getNumberOfNeighbors</a> (const <a class="el" href="classSAMRAI_1_1hier_1_1BlockId.html">BlockId</a> &amp;block_id) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the number of neighbors a specific block of the Multiblock domain has.  <a href="#417bd4a8a3ec5e760262d9202ee716ad"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1GridGeometry.html#4855bd2bfe4091f7b43fc85153109864">areNeighbors</a> (const <a class="el" href="classSAMRAI_1_1hier_1_1BlockId.html">BlockId</a> &amp;block_a, const <a class="el" href="classSAMRAI_1_1hier_1_1BlockId.html">BlockId</a> &amp;block_b) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Tell if the given BlockIds represent neighboring blocks.  <a href="#4855bd2bfe4091f7b43fc85153109864"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1GridGeometry.html#5d808205801fc6a990d9964c6bcb682a">areSingularityNeighbors</a> (const <a class="el" href="classSAMRAI_1_1hier_1_1BlockId.html">BlockId</a> &amp;block_a, const <a class="el" href="classSAMRAI_1_1hier_1_1BlockId.html">BlockId</a> &amp;block_b) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Tell if the given BlockIds represent neighboring blocks.  <a href="#5d808205801fc6a990d9964c6bcb682a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classSAMRAI_1_1hier_1_1Transformation.html#1908f436f2e3bec8b6c0c24b3fcb8cd9">Transformation::RotationIdentifier</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1GridGeometry.html#a0ff3bcadf6b95294cfe27a7d0ccd82c">getRotationIdentifier</a> (const <a class="el" href="classSAMRAI_1_1hier_1_1BlockId.html">BlockId</a> &amp;dst, const <a class="el" href="classSAMRAI_1_1hier_1_1BlockId.html">BlockId</a> &amp;src) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the rotation identifier to rotate from src to dst.  <a href="#a0ff3bcadf6b95294cfe27a7d0ccd82c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1GridGeometry.html#7c5c47a23cfe6e0842e4f71d63fa71f9">getOffset</a> (const <a class="el" href="classSAMRAI_1_1hier_1_1BlockId.html">BlockId</a> &amp;dst, const <a class="el" href="classSAMRAI_1_1hier_1_1BlockId.html">BlockId</a> &amp;src) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the offset to shift from src to dst after rotation.  <a href="#7c5c47a23cfe6e0842e4f71d63fa71f9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1GridGeometry.html#59943bac359d3bb97bdf8a6931c4d1c1">hasEnhancedConnectivity</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Query if the geometry has enhanced connectivity.  <a href="#59943bac359d3bb97bdf8a6931c4d1c1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1GridGeometry.html#6e7001b9263ee5058128e75c1126cbd0">printClassData</a> (std::ostream &amp;stream) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Print object data to the specified output stream.  <a href="#6e7001b9263ee5058128e75c1126cbd0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1GridGeometry.html#49293d85dc8096cd4bf0200d82d9da0c">putToDatabase</a> (<a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Database.html">tbox::Database</a> &gt; db)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Writes the state of the <a class="el" href="classSAMRAI_1_1hier_1_1GridGeometry.html">GridGeometry</a> object to the database.  <a href="#49293d85dc8096cd4bf0200d82d9da0c"></a><br></td></tr>
<tr><td colspan="2"><div class="groupHeader">Functions for computing boundary boxes</div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1GridGeometry.html#b6e9ce99ee266a95a635430dba31c0b9">findPatchesTouchingBoundaries</a> (std::map&lt; <a class="el" href="classSAMRAI_1_1hier_1_1BoxId.html">BoxId</a>, <a class="el" href="classSAMRAI_1_1hier_1_1PatchGeometry_1_1TwoDimBool.html">TwoDimBool</a> &gt; &amp;touches_regular_boundary, std::map&lt; <a class="el" href="classSAMRAI_1_1hier_1_1BoxId.html">BoxId</a>, <a class="el" href="classSAMRAI_1_1hier_1_1PatchGeometry_1_1TwoDimBool.html">TwoDimBool</a> &gt; &amp;touches_periodic_boundary, const <a class="el" href="classSAMRAI_1_1hier_1_1PatchLevel.html">PatchLevel</a> &amp;level) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">For every patch on a level, find all ways a patch touches a physical or periodic boundary.  <a href="#b6e9ce99ee266a95a635430dba31c0b9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1GridGeometry.html#e3dcc868ff2f9db1b40567cfff2b6f71">computeBoxTouchingBoundaries</a> (<a class="el" href="classSAMRAI_1_1hier_1_1PatchGeometry_1_1TwoDimBool.html">TwoDimBool</a> &amp;touches_regular_bdry, <a class="el" href="classSAMRAI_1_1hier_1_1PatchGeometry_1_1TwoDimBool.html">TwoDimBool</a> &amp;touches_periodic_bdry, const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> &amp;box, const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a> &amp;refinement_ratio, const <a class="el" href="classSAMRAI_1_1hier_1_1MultiblockBoxTree.html">MultiblockBoxTree</a> &amp;refined_periodic_domain_tree) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Version of findPatchTouchingBoundaries for a single box.  <a href="#e3dcc868ff2f9db1b40567cfff2b6f71"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1GridGeometry.html#39c4a254f5a5ce2639ef25929282ab68">setGeometryOnPatches</a> (<a class="el" href="classSAMRAI_1_1hier_1_1PatchLevel.html">PatchLevel</a> &amp;level, const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;ratio_to_level_zero, std::map&lt; <a class="el" href="classSAMRAI_1_1hier_1_1BoxId.html">BoxId</a>, <a class="el" href="classSAMRAI_1_1hier_1_1PatchGeometry_1_1TwoDimBool.html">TwoDimBool</a> &gt; &amp;touches_regular_bdry, std::map&lt; <a class="el" href="classSAMRAI_1_1hier_1_1BoxId.html">BoxId</a>, <a class="el" href="classSAMRAI_1_1hier_1_1PatchGeometry_1_1TwoDimBool.html">TwoDimBool</a> &gt; &amp;touches_periodic_bdry, bool defer_boundary_box_creation)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets geometry data for patches on a level.  <a href="#39c4a254f5a5ce2639ef25929282ab68"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1GridGeometry.html#e9e024b37b16c6e9bcfc37b7af1415af">setBoundaryBoxes</a> (<a class="el" href="classSAMRAI_1_1hier_1_1PatchLevel.html">PatchLevel</a> &amp;level)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Construct and set the boundary boxes for each patch.  <a href="#e9e024b37b16c6e9bcfc37b7af1415af"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1GridGeometry.html#fa180e64507f33c6c34a4ab36855c799">GridGeometry</a> (const <a class="el" href="classSAMRAI_1_1tbox_1_1Dimension.html">tbox::Dimension</a> &amp;dim, const std::string &amp;object_name, <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1TransferOperatorRegistry.html">TransferOperatorRegistry</a> &gt; op_reg)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Construct a new <a class="el" href="classSAMRAI_1_1hier_1_1GridGeometry.html">GridGeometry</a> object in its default state.  <a href="#fa180e64507f33c6c34a4ab36855c799"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1GridGeometry.html#339d863d111f08499f1f34109fa002fe">readBlockDataFromInput</a> (const <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Database.html">tbox::Database</a> &gt; &amp;input_db)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Read multiblock metadata input from the input database.  <a href="#339d863d111f08499f1f34109fa002fe"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Classes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1GridGeometry_1_1Neighbor.html">Neighbor</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Class to represent the neighbor of a given block.  <a href="classSAMRAI_1_1hier_1_1GridGeometry_1_1Neighbor.html#_details">More...</a><br></td></tr>
</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
Class <a class="el" href="classSAMRAI_1_1hier_1_1GridGeometry.html">GridGeometry</a> manages the index space that determines the extent of the coarse-level domain of a <a class="el" href="namespaceSAMRAI.html">SAMRAI</a> hierarchy. 
<p>
A <a class="el" href="classSAMRAI_1_1hier_1_1GridGeometry.html">GridGeometry</a> object can be directly constructed with a consistent state, or it may be used as a base class to derive child classes that manage particular grid types (e.g., Cartesian, cylindrical, etc.). Direct construction of a <a class="el" href="classSAMRAI_1_1hier_1_1GridGeometry.html">GridGeometry</a> object is recommended for multiblock problems and other problems where the physical locations of mesh coordinates are managed by user code.<p>
The grid geometry class is responsible for maintaining information about the index space describing the physical domain and computing this information for patches in an AMR hierarchy.<p>
Required input file keys and data types (only required when using first constructor which takes an input database):<p>
<ul>
<li><b>num_blocks</b> Integer value specifying the number of blocks in the multiblock mesh configuration.</li></ul>
<p>
<ul>
<li><b>domain_boxes_</b> For each block, an array of boxes representing the index space for the entire domain within a block (on the coarsest mesh level; i.e., level zero). The key must have an integer value as a suffix (domain_boxes_0, domain_boxes_1, etc.), and there must be an entry for every block from 0 to num_blocks-1.</li></ul>
<p>
Optional input file keys and data types (for first constructor which takes an input database):<p>
<ul>
<li><b>periodic_dimension</b> An array of integer values (expected number of values is equal to the spatial dimension of the mesh) representing the directions in which the physical domain is periodic. A non-zero value indicates that the direction is periodic. A zero value indicates that the direction is not periodic. If no values are specified, then the array is initialized to all zeros (no periodic directions). This key should only be used when the number of blocks is 1 (a single block mesh), as periodic boundaries are not supported for multiblock meshes.</li></ul>
<p>
<ul>
<li><b>BlockNeighbors</b> </li></ul>
<p>
For multiblock grids, a BlockNeighbors entry must be given for every pair of blocks that touch each other in any way. The key for this entry must include a unique trailing integer, and the integers for the full set of BlockNeighbors keys must be a continuous sequence beginning with 0.<p>
<ul>
<li><b>Singularity</b> </li></ul>
<p>
When there is a reduced or enhanced connectivity singularity, this key must be used to identify which blocks touch the singularity and the position of the singularity in relation to each block's index space. Like BlockNeighbors, each entry must have a trailing integer beginning with 0.<p>
A description of the input format for BlockNeighbors* and Singularity is included in the Multiblock.pdf document in the docs/userdocs directory of the <a class="el" href="namespaceSAMRAI.html">SAMRAI</a> distribution.<p>
<dl compact><dt><b>Additional Functionality</b></dt><dd>Operations performed by this class include determining which patches are adjacent to the physical domain boundary and computing boundary boxes for patches which describe how the patch touches the domain boundary (useful for filling ghost cell data for physical boundary conditions).</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>The derivation from <a class="el" href="classtbox_1_1DescribedClass.html">tbox::DescribedClass</a> is virtual. The reason for this is to avoid dynamic casting problems for smart pointers. Typically, <a class="el" href="namespaceSAMRAI.html">SAMRAI</a> geometry objects inherit from <a class="el" href="classSAMRAI_1_1tbox_1_1Serializable.html">tbox::Serializable</a> as well as this base geometry class. Thus, there is usually more than one class hierarchy for geometry objects. Pointers to base objects may need to be dynamically cast to derived objects in either hierarchy.</dd></dl>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classSAMRAI_1_1hier_1_1BoundaryBox.html">hier::BoundaryBox</a> </dd></dl>

<p>
<hr><h2>Member Typedef Documentation</h2>
<a class="anchor" name="a067b43bb245f7db27f1d9c6a6fe60df"></a><!-- doxytag: member="SAMRAI::hier::GridGeometry::TwoDimBool" ref="a067b43bb245f7db27f1d9c6a6fe60df" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classSAMRAI_1_1hier_1_1PatchGeometry_1_1TwoDimBool.html">PatchGeometry::TwoDimBool</a> <a class="el" href="classSAMRAI_1_1hier_1_1PatchGeometry_1_1TwoDimBool.html">SAMRAI::hier::GridGeometry::TwoDimBool</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<hr><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" name="4039a270748db76a5b168ba04b932014"></a><!-- doxytag: member="SAMRAI::hier::GridGeometry::GridGeometry" ref="4039a270748db76a5b168ba04b932014" args="(const tbox::Dimension &amp;dim, const std::string &amp;object_name, tbox::Pointer&lt; TransferOperatorRegistry &gt; op_reg, tbox::Pointer&lt; tbox::Database &gt; input_db, bool register_for_restart=true)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SAMRAI::hier::GridGeometry::GridGeometry           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1tbox_1_1Dimension.html">tbox::Dimension</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>dim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>object_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1TransferOperatorRegistry.html">TransferOperatorRegistry</a> &gt;&nbsp;</td>
          <td class="paramname"> <em>op_reg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Database.html">tbox::Database</a> &gt;&nbsp;</td>
          <td class="paramname"> <em>input_db</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>register_for_restart</em> = <code>true</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Construct a new <a class="el" href="classSAMRAI_1_1hier_1_1GridGeometry.html">GridGeometry</a> object and initialize from input. 
<p>
This constructor for <a class="el" href="classSAMRAI_1_1hier_1_1GridGeometry.html">GridGeometry</a> initializes data members based on parameters read from the specified input database. The constructor also registers this object for restart using the specified object name, when the boolean argument is true. Whether the object will write its state to restart files during program execution is determined by this argument.<p>
This constructor is intended for use when directly constructing a <a class="el" href="classSAMRAI_1_1hier_1_1GridGeometry.html">GridGeometry</a> without using a derived child class. The object will contain all index space grid information for a mesh, but nothing about the physical coordinates of the mesh.<p>
<dl compact><dt><b>Note:</b></dt><dd><b>Errors:</b> passing in a null database pointer or an empty string will result in an unrecoverable assertion.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>dim</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>object_name</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>input_db</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>register_for_restart</em>&nbsp;</td><td>Flag indicating whether this instance should be registered for restart. <b>Default:</b> true </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="8bf4551d1b881009ba582d1562a58a1e"></a><!-- doxytag: member="SAMRAI::hier::GridGeometry::GridGeometry" ref="8bf4551d1b881009ba582d1562a58a1e" args="(const std::string &amp;object_name, const BoxContainer &amp;domain, tbox::Pointer&lt; TransferOperatorRegistry &gt; op_reg, bool register_for_restart=true)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SAMRAI::hier::GridGeometry::GridGeometry           </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>object_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>domain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1TransferOperatorRegistry.html">TransferOperatorRegistry</a> &gt;&nbsp;</td>
          <td class="paramname"> <em>op_reg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>register_for_restart</em> = <code>true</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Construct a new <a class="el" href="classSAMRAI_1_1hier_1_1GridGeometry.html">GridGeometry</a> object based on arguments. 
<p>
This constructor creates a new <a class="el" href="classSAMRAI_1_1hier_1_1GridGeometry.html">GridGeometry</a> object based on the arguments, rather than relying on input or restart data. The constructor also registers this object for restart using the specified object name, when the boolean argument is true. Whether the object will write its state to restart files during program execution is determined by this argument.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>object_name</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>domain</em>&nbsp;</td><td>Each element of the array describes the index space for a block. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>register_for_restart</em>&nbsp;</td><td>Flag indicating whether this instance should be registered for restart. <b>Default:</b> true </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="2596b5f1aaebff123e0c700f24bef2a7"></a><!-- doxytag: member="SAMRAI::hier::GridGeometry::~GridGeometry" ref="2596b5f1aaebff123e0c700f24bef2a7" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SAMRAI::hier::GridGeometry::~GridGeometry           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Virtual destructor. 
<p>

</div>
</div><p>
<a class="anchor" name="fa180e64507f33c6c34a4ab36855c799"></a><!-- doxytag: member="SAMRAI::hier::GridGeometry::GridGeometry" ref="fa180e64507f33c6c34a4ab36855c799" args="(const tbox::Dimension &amp;dim, const std::string &amp;object_name, tbox::Pointer&lt; TransferOperatorRegistry &gt; op_reg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SAMRAI::hier::GridGeometry::GridGeometry           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1tbox_1_1Dimension.html">tbox::Dimension</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>dim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>object_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1TransferOperatorRegistry.html">TransferOperatorRegistry</a> &gt;&nbsp;</td>
          <td class="paramname"> <em>op_reg</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [explicit, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Construct a new <a class="el" href="classSAMRAI_1_1hier_1_1GridGeometry.html">GridGeometry</a> object in its default state. 
<p>
This constructor is intended to be called from a child class derived from <a class="el" href="classSAMRAI_1_1hier_1_1GridGeometry.html">GridGeometry</a>. It will not register for restart nor read any input data, as it is expected that the child class will handle those operations.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>dim</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>object_name</em>&nbsp;</td><td></td></tr>
  </table>
</dl>

</div>
</div><p>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="b6e9ce99ee266a95a635430dba31c0b9"></a><!-- doxytag: member="SAMRAI::hier::GridGeometry::findPatchesTouchingBoundaries" ref="b6e9ce99ee266a95a635430dba31c0b9" args="(std::map&lt; BoxId, TwoDimBool &gt; &amp;touches_regular_boundary, std::map&lt; BoxId, TwoDimBool &gt; &amp;touches_periodic_boundary, const PatchLevel &amp;level) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::hier::GridGeometry::findPatchesTouchingBoundaries           </td>
          <td>(</td>
          <td class="paramtype">std::map&lt; <a class="el" href="classSAMRAI_1_1hier_1_1BoxId.html">BoxId</a>, <a class="el" href="classSAMRAI_1_1hier_1_1PatchGeometry_1_1TwoDimBool.html">TwoDimBool</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>touches_regular_boundary</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::map&lt; <a class="el" href="classSAMRAI_1_1hier_1_1BoxId.html">BoxId</a>, <a class="el" href="classSAMRAI_1_1hier_1_1PatchGeometry_1_1TwoDimBool.html">TwoDimBool</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>touches_periodic_boundary</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1PatchLevel.html">PatchLevel</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>level</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
For every patch on a level, find all ways a patch touches a physical or periodic boundary. 
<p>
For every patch on the given <a class="el" href="classSAMRAI_1_1hier_1_1PatchLevel.html">PatchLevel</a>, this routine determines which kinds of boundaries are touched (regular, periodic, both, or neither).<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>touches_regular_bdry</em>&nbsp;</td><td>map to store which patches touch non-periodic boundaries. </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>touches_periodic_bdry</em>&nbsp;</td><td>map to store which patches touch periodic boundaries. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>level</em>&nbsp;</td><td>containing the patches to be checked </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="e3dcc868ff2f9db1b40567cfff2b6f71"></a><!-- doxytag: member="SAMRAI::hier::GridGeometry::computeBoxTouchingBoundaries" ref="e3dcc868ff2f9db1b40567cfff2b6f71" args="(TwoDimBool &amp;touches_regular_bdry, TwoDimBool &amp;touches_periodic_bdry, const Box &amp;box, const hier::IntVector &amp;refinement_ratio, const MultiblockBoxTree &amp;refined_periodic_domain_tree) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::hier::GridGeometry::computeBoxTouchingBoundaries           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1hier_1_1PatchGeometry_1_1TwoDimBool.html">TwoDimBool</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>touches_regular_bdry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1hier_1_1PatchGeometry_1_1TwoDimBool.html">TwoDimBool</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>touches_periodic_bdry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>box</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>refinement_ratio</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1MultiblockBoxTree.html">MultiblockBoxTree</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>refined_periodic_domain_tree</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Version of findPatchTouchingBoundaries for a single box. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>touches_regular_bdry</em>&nbsp;</td><td>TwoDimBool to store which patches touch non-periodic boundaries. </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>touches_periodic_bdry</em>&nbsp;</td><td>TwoDimBool to store which patches touch periodic boundaries. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>box</em>&nbsp;</td><td>to be checked</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>refinement_ratio</em>&nbsp;</td><td>Refinement ratio of given box</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>in</em>&nbsp;</td><td>refined_periodic_domain_tree </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="39c4a254f5a5ce2639ef25929282ab68"></a><!-- doxytag: member="SAMRAI::hier::GridGeometry::setGeometryOnPatches" ref="39c4a254f5a5ce2639ef25929282ab68" args="(PatchLevel &amp;level, const IntVector &amp;ratio_to_level_zero, std::map&lt; BoxId, TwoDimBool &gt; &amp;touches_regular_bdry, std::map&lt; BoxId, TwoDimBool &gt; &amp;touches_periodic_bdry, bool defer_boundary_box_creation)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::hier::GridGeometry::setGeometryOnPatches           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1hier_1_1PatchLevel.html">PatchLevel</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>ratio_to_level_zero</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::map&lt; <a class="el" href="classSAMRAI_1_1hier_1_1BoxId.html">BoxId</a>, <a class="el" href="classSAMRAI_1_1hier_1_1PatchGeometry_1_1TwoDimBool.html">TwoDimBool</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>touches_regular_bdry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::map&lt; <a class="el" href="classSAMRAI_1_1hier_1_1BoxId.html">BoxId</a>, <a class="el" href="classSAMRAI_1_1hier_1_1PatchGeometry_1_1TwoDimBool.html">TwoDimBool</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>touches_periodic_bdry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>defer_boundary_box_creation</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets geometry data for patches on a level. 
<p>
Using the boundary information previously computed, this method will pass the information to the concrete implementation of the geometry class, and construct boundary boxes if required.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>level</em>&nbsp;</td><td>containing the patches to be checked. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>ratio_to_level_zero</em>&nbsp;</td><td>ratio to the coarsest level. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>touches_regular_bdry</em>&nbsp;</td><td>Array storing which patches touch non-periodic boundaries. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>touches_periodic_bdry</em>&nbsp;</td><td>Array storing which patches touch periodic boundaries. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>defer_boundary_box_creation</em>&nbsp;</td><td>Flag to indicate if boundary boxes should be created </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="e9e024b37b16c6e9bcfc37b7af1415af"></a><!-- doxytag: member="SAMRAI::hier::GridGeometry::setBoundaryBoxes" ref="e9e024b37b16c6e9bcfc37b7af1415af" args="(PatchLevel &amp;level)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::hier::GridGeometry::setBoundaryBoxes           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1hier_1_1PatchLevel.html">PatchLevel</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>level</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Construct and set the boundary boxes for each patch. 
<p>
Construct the boundary boxes for every patch in the level. Once constructed, the boundary boxes are set on each patch's <a class="el" href="classSAMRAI_1_1hier_1_1PatchGeometry.html">PatchGeometry</a> object.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>level</em>&nbsp;</td><td>The level for which boundary boxes are constructed. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="bb788a82cee88858e6c1f14f985c30ff"></a><!-- doxytag: member="SAMRAI::hier::GridGeometry::computePhysicalDomain" ref="bb788a82cee88858e6c1f14f985c30ff" args="(BoxContainer &amp;domain, const IntVector &amp;ratio_to_level_zero, const BlockId &amp;block_id) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::hier::GridGeometry::computePhysicalDomain           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>domain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>ratio_to_level_zero</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1BlockId.html">BlockId</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>block_id</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Compute the box array describing the index space for a given block of the physical domain. 
<p>
The domain description does not include periodic images.<p>
If any entry of the ratio vector is negative, the index space is coarsened with respect to the physical domain description. Otherwise, the index space is refined.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>domain</em>&nbsp;</td><td>The <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a> to be computed </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>ratio_to_level_zero</em>&nbsp;</td><td>ratio to the coarsest level </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>block_id</em>&nbsp;</td><td></td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="a4602967279869484958b255fdef9687"></a><!-- doxytag: member="SAMRAI::hier::GridGeometry::computePhysicalDomainWithPeriodicImages" ref="a4602967279869484958b255fdef9687" args="(BoxContainer &amp;domain, const IntVector &amp;ratio_to_level_zero, const BlockId &amp;block_id) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::hier::GridGeometry::computePhysicalDomainWithPeriodicImages           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>domain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>ratio_to_level_zero</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1BlockId.html">BlockId</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>block_id</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="d9d00cec612bb863e5530052c993255a"></a><!-- doxytag: member="SAMRAI::hier::GridGeometry::computePhysicalDomain" ref="d9d00cec612bb863e5530052c993255a" args="(BoxLevel &amp;box_level, const IntVector &amp;ratio_to_level_zero, const BlockId &amp;block_id) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::hier::GridGeometry::computePhysicalDomain           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>box_level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>ratio_to_level_zero</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1BlockId.html">BlockId</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>block_id</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Compute the <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a> describing the index space for a given block of the physical domain. 
<p>
The domain description includes periodic images, if any exist.<p>
Unlike the <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a> version of this function, the domain computed contains periodic image boxes. If any entry of ratio vector is negative, the index space is coarsened with respect to the physical domain description. Otherwise, the index space is refined.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>box_level</em>&nbsp;</td><td>The <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a> containing all Boxes describing the index space </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>ratio_to_level_zero</em>&nbsp;</td><td>ratio to the coarsest level </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>block_id</em>&nbsp;</td><td></td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="95e260740993b88bbc314bf1c167e4b0"></a><!-- doxytag: member="SAMRAI::hier::GridGeometry::computePhysicalDomain" ref="95e260740993b88bbc314bf1c167e4b0" args="(BoxContainer &amp;domain_mapped_boxes, const IntVector &amp;ratio_to_level_zero) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::hier::GridGeometry::computePhysicalDomain           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>domain_mapped_boxes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>ratio_to_level_zero</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Compute the <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a> describing the complete physical domain for all blocks. 
<p>
The domain description includes periodic images, if any exist.<p>
If any entry of the ratio vector is negative, the index space is coarsened with respect to the physical domain description. Otherwise, the index space is refined.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>domain_mapped_boxes</em>&nbsp;</td><td>The <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a> containing all Boxes describing the physical domain </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>ratio_to_level_zero</em>&nbsp;</td><td>ratio to the coarsest level </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="910ac179ae4a2e11e8482ab1dfa4d0b9"></a><!-- doxytag: member="SAMRAI::hier::GridGeometry::computePhysicalDomain" ref="910ac179ae4a2e11e8482ab1dfa4d0b9" args="(BoxLevel &amp;box_level, const IntVector &amp;ratio_to_level_zero) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::hier::GridGeometry::computePhysicalDomain           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>box_level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>ratio_to_level_zero</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Compute the <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a> describing the complete physical domain for all blocks. 
<p>
The domain description includes periodic images, if any exist.<p>
If any entry of the ratio vector is negative, the index space is coarsened with respect to the physical domain description. Otherwise, the index space is refined.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>box_level</em>&nbsp;</td><td>The <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a> containing all Boxes describing the physical domain </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>ratio_to_level_zero</em>&nbsp;</td><td>ratio to the coarsest level </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="c26e3fd28ea905ce58e2bae7e7b1c2e6"></a><!-- doxytag: member="SAMRAI::hier::GridGeometry::setPhysicalDomain" ref="c26e3fd28ea905ce58e2bae7e7b1c2e6" args="(const BoxContainer &amp;domain, const int number_blocks)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::hier::GridGeometry::setPhysicalDomain           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>domain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>number_blocks</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set the physical domain (for level zero). 
<p>
Each entry in the array of box arrays represents the physical domain for a single block<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>domain</em>&nbsp;</td><td>The input array of <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a> </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="ada304bdcf24d9f43ccf96d43bbc90f6"></a><!-- doxytag: member="SAMRAI::hier::GridGeometry::getPhysicalDomain" ref="ada304bdcf24d9f43ccf96d43bbc90f6" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SAMRAI_INLINE_KEYWORD const <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a> &amp; SAMRAI::hier::GridGeometry::getPhysicalDomain           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the physical domain description for a given block on level zero. 
<p>
<dl compact><dt><b>Returns:</b></dt><dd>const reference to physical domain description for level 0.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>block_id</em>&nbsp;</td><td></td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="92176376dade52932d2ba180f6131807"></a><!-- doxytag: member="SAMRAI::hier::GridGeometry::getDomainSearchTree" ref="92176376dade52932d2ba180f6131807" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SAMRAI_INLINE_KEYWORD const <a class="el" href="classSAMRAI_1_1hier_1_1MultiblockBoxTree.html">hier::MultiblockBoxTree</a> &amp; SAMRAI::hier::GridGeometry::getDomainSearchTree           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Access the multiblock domain description as a tree without periodic images. 
<p>
This tree does not contain periodic images, even if there is only one block and the domain is periodic.<p>
<dl compact><dt><b>Returns:</b></dt><dd>The multiblock domain description as a search tree. </dd></dl>

</div>
</div><p>
<a class="anchor" name="9d4baca19e485a64caed7c011f5a8165"></a><!-- doxytag: member="SAMRAI::hier::GridGeometry::getPeriodicDomainSearchTree" ref="9d4baca19e485a64caed7c011f5a8165" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SAMRAI_INLINE_KEYWORD const <a class="el" href="classSAMRAI_1_1hier_1_1MultiblockBoxTree.html">hier::MultiblockBoxTree</a> &amp; SAMRAI::hier::GridGeometry::getPeriodicDomainSearchTree           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Access the multiblock domain description with periodic images (if any). 
<p>
<dl compact><dt><b>Returns:</b></dt><dd>The domain description as a search tree with periodic images (if any). </dd></dl>

</div>
</div><p>
<a class="anchor" name="e86d6921cc850b1f1faf46912c8fc2b7"></a><!-- doxytag: member="SAMRAI::hier::GridGeometry::getDomainIsSingleBox" ref="e86d6921cc850b1f1faf46912c8fc2b7" args="(const hier::BlockId &amp;block_id) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SAMRAI_INLINE_KEYWORD bool SAMRAI::hier::GridGeometry::getDomainIsSingleBox           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1BlockId.html">hier::BlockId</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>block_id</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
returns whether the physical domain for a block managed by this geometry object can be represented as a single box. 
<p>
<dl compact><dt><b>Returns:</b></dt><dd>true if the physical domain can be represented as a single box, otherwise false.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>block_id</em>&nbsp;</td><td></td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="276b1a57b1936b82db997db1fb68d5ae"></a><!-- doxytag: member="SAMRAI::hier::GridGeometry::initializePeriodicShift" ref="276b1a57b1936b82db997db1fb68d5ae" args="(const IntVector &amp;directions)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::hier::GridGeometry::initializePeriodicShift           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>directions</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Initialize the periodic shift on the coarsest level. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>directions</em>&nbsp;</td><td>an array indicating periodic directions(1) or all others (0).</td></tr>
  </table>
</dl>
<dl compact><dt><b>Note:</b></dt><dd>The <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> argument should be set to 1 for periodic directions and 0 for all other directions. The shift will be calculated to the number of cells in the periodic direction and zero in all other directions. </dd></dl>

</div>
</div><p>
<a class="anchor" name="303b28d43f00b8d2f70c328d9980f09a"></a><!-- doxytag: member="SAMRAI::hier::GridGeometry::getPeriodicShift" ref="303b28d43f00b8d2f70c328d9980f09a" args="(const IntVector &amp;ratio_to_level_zero) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> SAMRAI::hier::GridGeometry::getPeriodicShift           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>ratio_to_level_zero</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the periodic shift in each direction for the physical domain managed by this geometry object. 
<p>
The returned <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> contains the periodic shift in each direction for a domain represented by a refinement of the reference physical domain (i.e. level zero) by the given ratio vector. Entries will be zero for non-periodic directions.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>ratio_to_level_zero</em>&nbsp;</td><td>ratio to the coarsest level.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The periodic shift in each direction for a domain represented by a refinement of the reference physical domain. </dd></dl>

</div>
</div><p>
<a class="anchor" name="565340eb5479af6144f5f94ebd018983"></a><!-- doxytag: member="SAMRAI::hier::GridGeometry::getNumberBlocks" ref="565340eb5479af6144f5f94ebd018983" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SAMRAI_INLINE_KEYWORD int SAMRAI::hier::GridGeometry::getNumberBlocks           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the number of blocks in the geometry. 
<p>

</div>
</div><p>
<a class="anchor" name="aedff762bf58267e0f04643c54b0eff5"></a><!-- doxytag: member="SAMRAI::hier::GridGeometry::getMaxTransferOpStencilWidth" ref="aedff762bf58267e0f04643c54b0eff5" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> SAMRAI::hier::GridGeometry::getMaxTransferOpStencilWidth           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the max stencil width of all transfer operators. 
<p>
The max stencil width is required by the DLBG to determine when two nearby boxes are defined as neighbors. The DLBG in turn provides the neighbor information for various operations such as schedule construction.<p>
<dl compact><dt><b>Returns:</b></dt><dd>The max stencil width of all transfer operators. </dd></dl>

</div>
</div><p>
<a class="anchor" name="163389d7c32ac0bd63cc1b423d4c29ae"></a><!-- doxytag: member="SAMRAI::hier::GridGeometry::makeRefinedGridGeometry" ref="163389d7c32ac0bd63cc1b423d4c29ae" args="(const std::string &amp;fine_geom_name, const IntVector &amp;refine_ratio, bool register_for_restart) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1GridGeometry.html">GridGeometry</a> &gt; SAMRAI::hier::GridGeometry::makeRefinedGridGeometry           </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>fine_geom_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>refine_ratio</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>register_for_restart</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Create a pointer to a refined version of this grid geometry object. 
<p>
Pure virtual function. Implementers must override this method.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>fine_geom_name</em>&nbsp;</td><td>std::string name of the geometry object </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>refine_ratio</em>&nbsp;</td><td>the refinement ratio. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>register_for_restart</em>&nbsp;</td><td>Flag to indicate whether to register for restart.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The pointer to the grid geometry object. </dd></dl>

<p>
Reimplemented in <a class="el" href="classSAMRAI_1_1geom_1_1CartesianGridGeometry.html#a10363ea7202d51159354000de170b52">SAMRAI::geom::CartesianGridGeometry</a>, and <a class="el" href="classSAMRAI_1_1geom_1_1SkeletonGridGeometry.html#f52014c6dec6ece5629a87fe248e7240">SAMRAI::geom::SkeletonGridGeometry</a>.
</div>
</div><p>
<a class="anchor" name="2b74abf55f7dbcbb2c0c0da0ff2281fa"></a><!-- doxytag: member="SAMRAI::hier::GridGeometry::makeCoarsenedGridGeometry" ref="2b74abf55f7dbcbb2c0c0da0ff2281fa" args="(const std::string &amp;coarse_geom_name, const IntVector &amp;coarsen_ratio, bool register_for_restart) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1GridGeometry.html">GridGeometry</a> &gt; SAMRAI::hier::GridGeometry::makeCoarsenedGridGeometry           </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>coarse_geom_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>coarsen_ratio</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>register_for_restart</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Create a pointer to a coarsened version of this grid geometry object. 
<p>
Pure virtual function. Implementers must override this method.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>coarse_geom_name</em>&nbsp;</td><td>std::string name of the geometry object </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>coarsen_ratio</em>&nbsp;</td><td>the coasening ratio </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>register_for_restart</em>&nbsp;</td><td>Flag to indicate whether to register for restart.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The pointer to a coarsened version of this grid geometry object. </dd></dl>

<p>
Reimplemented in <a class="el" href="classSAMRAI_1_1geom_1_1CartesianGridGeometry.html#92dc6a4f7e11b47c850a78b55e6926bc">SAMRAI::geom::CartesianGridGeometry</a>, and <a class="el" href="classSAMRAI_1_1geom_1_1SkeletonGridGeometry.html#1053f1e92de8c1be1347277c8414e834">SAMRAI::geom::SkeletonGridGeometry</a>.
</div>
</div><p>
<a class="anchor" name="450641490d60bee95396607bb657a200"></a><!-- doxytag: member="SAMRAI::hier::GridGeometry::setGeometryDataOnPatch" ref="450641490d60bee95396607bb657a200" args="(Patch &amp;patch, const IntVector &amp;ratio_to_level_zero, const TwoDimBool &amp;touches_regular_bdry, const TwoDimBool &amp;touches_periodic_bdry) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::hier::GridGeometry::setGeometryDataOnPatch           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1hier_1_1Patch.html">Patch</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>patch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>ratio_to_level_zero</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1PatchGeometry_1_1TwoDimBool.html">TwoDimBool</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>touches_regular_bdry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1PatchGeometry_1_1TwoDimBool.html">TwoDimBool</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>touches_periodic_bdry</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Compute and set grid data for patch. 
<p>
Pure virtual function. Implementers must override this method.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>patch</em>&nbsp;</td><td>The patch on which to set grid data and the new concrete patch geometry object. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>ratio_to_level_zero</em>&nbsp;</td><td>ratio to coarsest level </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>touches_regular_bdry</em>&nbsp;</td><td>Array storing which patches touch non-periodic boundaries. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>touches_periodic_bdry</em>&nbsp;</td><td>Array storing which patches touch periodic boundaries. </td></tr>
  </table>
</dl>

<p>
Reimplemented in <a class="el" href="classSAMRAI_1_1geom_1_1CartesianGridGeometry.html#85122a9d54d3f375585ffd3c41e908ed">SAMRAI::geom::CartesianGridGeometry</a>, and <a class="el" href="classSAMRAI_1_1geom_1_1SkeletonGridGeometry.html#47b2b2063a84814cf020a34562da113e">SAMRAI::geom::SkeletonGridGeometry</a>.
</div>
</div><p>
<a class="anchor" name="10100ad2eb58db0fc733d1ee3a45e4aa"></a><!-- doxytag: member="SAMRAI::hier::GridGeometry::computeBoundaryBoxesOnLevel" ref="10100ad2eb58db0fc733d1ee3a45e4aa" args="(std::map&lt; BoxId, PatchBoundaries &gt; &amp;boundaries, const PatchLevel &amp;level, const IntVector &amp;periodic_shift, const IntVector &amp;ghost_width, const tbox::Array&lt; BoxContainer &gt; &amp;domain, bool do_all_patches=false) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::hier::GridGeometry::computeBoundaryBoxesOnLevel           </td>
          <td>(</td>
          <td class="paramtype">std::map&lt; <a class="el" href="classSAMRAI_1_1hier_1_1BoxId.html">BoxId</a>, <a class="el" href="classSAMRAI_1_1hier_1_1PatchBoundaries.html">PatchBoundaries</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>boundaries</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1PatchLevel.html">PatchLevel</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>periodic_shift</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>ghost_width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1tbox_1_1Array.html">tbox::Array</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>domain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>do_all_patches</em> = <code>false</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Compute boundary boxes for each patch in patch level. 
<p>
Boundary boxes for each patch in a patch level will be computed and assign to boundary box arrays. These arrays are assumed to be of length <div class="fragment"><pre class="fragment">    DIM * num_patches
</pre></div>.<p>
The DIM arrays of boundary boxes for each patch will be stored in groups of DIM. For example in 3D, with <code>n</code> patches on the level, the array of boundary box arrays will be ordered as follows:<p>
<div class="fragment"><pre class="fragment"> (patch 0 face array, patch 0 edge array, patch 0 mapped_box array,
  patch 1 face array, patch 1 edge array, patch 1 mapped_box array, . . . ,
  patch n-1 face array, patch n-1 edge array, patch n-1 mapped_box array)
</pre></div><p>
<dl compact><dt><b>Note:</b></dt><dd>The optional argument <code>do_all_patches</code> defaults to false: the boundary box computation is executed only on patches that touch a non-periodic boundary. When this routine is called during patch level construction to describe a physical boundary, it is known that only patches that touch a non-periodic boundary will have non-empty sets of boundary boxes, so for efficiency's sake the boundary box box computation is supressed for all other patches.</dd></dl>
When this routine is called to create boundary boxes that describe a coarse-fine boundary, the computation must occur for every patch, so <code>do_all_patches</code> must be set to true.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>boundaries</em>&nbsp;</td><td>output boundary description </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>level</em>&nbsp;</td><td>level on which to generate boundaries </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>periodic_shift</em>&nbsp;</td><td>periodic shift for the level (see <a class="el" href="classSAMRAI_1_1hier_1_1GridGeometry.html#303b28d43f00b8d2f70c328d9980f09a">getPeriodicShift()</a>) </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>ghost_width</em>&nbsp;</td><td>ghost width to compute geometry for the domain </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>domain</em>&nbsp;</td><td>Physical domain (in index space of level) for computing boundary boxes. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>do_all_patches</em>&nbsp;</td><td>Flag to indicate boundary box computation on all patches, even those known to not touch a boundary </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="3a080e93fea5e637c44d302c54a221f8"></a><!-- doxytag: member="SAMRAI::hier::GridGeometry::getBoundaryBoxes" ref="3a080e93fea5e637c44d302c54a221f8" args="(PatchBoundaries &amp;patch_boundaries, const Box &amp;box, const BoxContainer &amp;domain_boxes, const IntVector &amp;ghosts, const IntVector &amp;periodic_shift) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::hier::GridGeometry::getBoundaryBoxes           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1hier_1_1PatchBoundaries.html">PatchBoundaries</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>patch_boundaries</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>box</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>domain_boxes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>ghosts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>periodic_shift</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Compute boundary boxes for patch. 
<p>
Decompose patch boundary region into pieces depending on spatial dimensions. Boxes are extended along the boundary to the edge of the ghost mapped_box_level if necessary.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>patch_boundaries</em>&nbsp;</td><td>output boundaries </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>box</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>domain_boxes</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>ghosts</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>periodic_shift</em>&nbsp;</td><td></td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="6d1b0986f56769b47a1fa20632796c84"></a><!-- doxytag: member="SAMRAI::hier::GridGeometry::adjustMultiblockPatchLevelBoundaries" ref="6d1b0986f56769b47a1fa20632796c84" args="(PatchLevel &amp;patch_level)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::hier::GridGeometry::adjustMultiblockPatchLevelBoundaries           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1hier_1_1PatchLevel.html">PatchLevel</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>patch_level</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Adjust boundary data of a level to be consistent with the multiblock nature of the domain. 
<p>
In a multiblock problem, the PatchLevels contain patches that were constructed independent of any knowledge of the multiblock nature of the complete domain. Thus the patches will contain boundary data that recognizes no difference between a physical domain boundary and a block boundary. Calling this method will adjust the boundary data on all patches in the given level such that the true boundaries of the domain are represented.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>patch_level</em>&nbsp;</td><td>Level where boundaries need to be adjusted. TODO: Incorporate into regular boundary box computation once <a class="el" href="classSAMRAI_1_1hier_1_1PatchLevel.html">PatchLevel</a> is multiblock-aware. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="e729afebacb7c28b91971d6e14c6953f"></a><!-- doxytag: member="SAMRAI::hier::GridGeometry::addCoarsenOperator" ref="e729afebacb7c28b91971d6e14c6953f" args="(tbox::Pointer&lt; CoarsenOperator &gt; coarsen_op)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::hier::GridGeometry::addCoarsenOperator           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1CoarsenOperator.html">CoarsenOperator</a> &gt;&nbsp;</td>
          <td class="paramname"> <em>coarsen_op</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Add a concrete spatial coarsening operator. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>coarsen_op</em>&nbsp;</td><td>The concrete coarsening operator to add to the lookup list. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="470a3d7189169675e7ef2372d1fffdcd"></a><!-- doxytag: member="SAMRAI::hier::GridGeometry::addRefineOperator" ref="470a3d7189169675e7ef2372d1fffdcd" args="(tbox::Pointer&lt; RefineOperator &gt; refine_op)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::hier::GridGeometry::addRefineOperator           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1RefineOperator.html">RefineOperator</a> &gt;&nbsp;</td>
          <td class="paramname"> <em>refine_op</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Add a concrete spatial refinement operator. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>refine_op</em>&nbsp;</td><td>The concrete refinement operator to add to the lookup list. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="3ec574be30faf410e8a85bb524eef980"></a><!-- doxytag: member="SAMRAI::hier::GridGeometry::addTimeInterpolateOperator" ref="3ec574be30faf410e8a85bb524eef980" args="(tbox::Pointer&lt; TimeInterpolateOperator &gt; time_op)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::hier::GridGeometry::addTimeInterpolateOperator           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1TimeInterpolateOperator.html">TimeInterpolateOperator</a> &gt;&nbsp;</td>
          <td class="paramname"> <em>time_op</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Add a concrete time interpolation operator. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>time_op</em>&nbsp;</td><td>The concrete time interpolation operator to add to the lookup list. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="13568e6dc5d25c1cf4493631753bd7f2"></a><!-- doxytag: member="SAMRAI::hier::GridGeometry::lookupCoarsenOperator" ref="13568e6dc5d25c1cf4493631753bd7f2" args="(const tbox::Pointer&lt; Variable &gt; &amp;var, const std::string &amp;op_name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1CoarsenOperator.html">CoarsenOperator</a> &gt; SAMRAI::hier::GridGeometry::lookupCoarsenOperator           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1Variable.html">Variable</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>var</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>op_name</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Lookup function for coarsening operator. 
<p>
Search list for the spatial coarsening operator matching the request for the given variable. If the operator is found, a pointer to it will be returned. Otherwise, an unrecoverable error will result and the program will abort.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>var</em>&nbsp;</td><td>The <a class="el" href="classSAMRAI_1_1hier_1_1Variable.html">Variable</a> for which the corresponding coarsening operator should match. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>op_name</em>&nbsp;</td><td>The string identifier of the coarsening operator. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="de29d884bc838dbcaf83c90cf870c762"></a><!-- doxytag: member="SAMRAI::hier::GridGeometry::lookupRefineOperator" ref="de29d884bc838dbcaf83c90cf870c762" args="(const tbox::Pointer&lt; Variable &gt; &amp;var, const std::string &amp;op_name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1RefineOperator.html">RefineOperator</a> &gt; SAMRAI::hier::GridGeometry::lookupRefineOperator           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1Variable.html">Variable</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>var</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>op_name</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Lookup function for refinement operator. 
<p>
Search list for the spatial refinement operator matching the request for the given variable. If the operator is found, a pointer to it will be returned. Otherwise, an unrecoverable error will result and the program will abort.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>var</em>&nbsp;</td><td>The <a class="el" href="classSAMRAI_1_1hier_1_1Variable.html">Variable</a> for which the corresponding refinement operator should match. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>op_name</em>&nbsp;</td><td>The string identifier of the refinement operator. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="d1ece0d12058bf8ebd05ae5cbe4b063e"></a><!-- doxytag: member="SAMRAI::hier::GridGeometry::lookupTimeInterpolateOperator" ref="d1ece0d12058bf8ebd05ae5cbe4b063e" args="(const tbox::Pointer&lt; Variable &gt; &amp;var, const std::string &amp;op_name=&quot;STD_LINEAR_TIME_INTERPOLATE&quot;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1TimeInterpolateOperator.html">TimeInterpolateOperator</a> &gt; SAMRAI::hier::GridGeometry::lookupTimeInterpolateOperator           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1Variable.html">Variable</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>var</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>op_name</em> = <code>&quot;STD_LINEAR_TIME_INTERPOLATE&quot;</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Lookup function for time interpolation operator. 
<p>
Search list for the time interpolation operator matching the request for the given variable. If the operator is found, a pointer to it will be returned. Otherwise, an unrecoverable error will result and the program will abort.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>var</em>&nbsp;</td><td>The <a class="el" href="classSAMRAI_1_1hier_1_1Variable.html">Variable</a> for which the corresponding time interpolation operator should match. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>op_name</em>&nbsp;</td><td>The string identifier of the time interpolation operator. <b>Default:</b> STD_LINEAR_TIME_INTERPOLATE </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="5d9d8719877289c4d90b56a3d04327b0"></a><!-- doxytag: member="SAMRAI::hier::GridGeometry::setMinTransferOpStencilWidth" ref="5d9d8719877289c4d90b56a3d04327b0" args="(const IntVector &amp;min_value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::hier::GridGeometry::setMinTransferOpStencilWidth           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>min_value</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set a minimum value on the value returned by <a class="el" href="classSAMRAI_1_1hier_1_1GridGeometry.html#aedff762bf58267e0f04643c54b0eff5">getMaxTransferOpStencilWidth()</a>. 
<p>
This method allows users to specify a minimum value returned by <a class="el" href="classSAMRAI_1_1hier_1_1GridGeometry.html#aedff762bf58267e0f04643c54b0eff5">getMaxTransferOpStencilWidth()</a>. The default minimum is zero. This value can be used as a substitute for data that is not yet registered with the Geometry and therefore cannot be reflected in <a class="el" href="classSAMRAI_1_1hier_1_1GridGeometry.html#aedff762bf58267e0f04643c54b0eff5">getMaxTransferOpStencilWidth()</a>.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>min_value</em>&nbsp;</td><td>The minimum value to set. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="35b725f27cb55767ce368321bcd5b72a"></a><!-- doxytag: member="SAMRAI::hier::GridGeometry::getDim" ref="35b725f27cb55767ce368321bcd5b72a" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SAMRAI_INLINE_KEYWORD const <a class="el" href="classSAMRAI_1_1tbox_1_1Dimension.html">tbox::Dimension</a> &amp; SAMRAI::hier::GridGeometry::getDim           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the dimension of this object. 
<p>
<dl compact><dt><b>Returns:</b></dt><dd>the dimension of this object. </dd></dl>

</div>
</div><p>
<a class="anchor" name="d86c032af40967330aeec23e9045e4c6"></a><!-- doxytag: member="SAMRAI::hier::GridGeometry::getObjectName" ref="d86c032af40967330aeec23e9045e4c6" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SAMRAI_INLINE_KEYWORD const std::string &amp; SAMRAI::hier::GridGeometry::getObjectName           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the name of this object. 
<p>
<dl compact><dt><b>Returns:</b></dt><dd>The name of this object. </dd></dl>

</div>
</div><p>
<a class="anchor" name="816bc77a0a929abf0c4a6ec17fcde11e"></a><!-- doxytag: member="SAMRAI::hier::GridGeometry::registerNeighbors" ref="816bc77a0a929abf0c4a6ec17fcde11e" args="(const BlockId &amp;block_a, const BlockId &amp;block_b, const Transformation::RotationIdentifier rotation_b_to_a, const IntVector &amp;shift_b_to_a, const int neighbor_type)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::hier::GridGeometry::registerNeighbors           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1BlockId.html">BlockId</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>block_a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1BlockId.html">BlockId</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>block_b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1Transformation.html#1908f436f2e3bec8b6c0c24b3fcb8cd9">Transformation::RotationIdentifier</a>&nbsp;</td>
          <td class="paramname"> <em>rotation_b_to_a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>shift_b_to_a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>neighbor_type</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Register a relationship between two neighboring blocks of a multiblock domain. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>block_a</em>&nbsp;</td><td>One block in the relationship </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>block_b</em>&nbsp;</td><td>The other block </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>rotation_b_to_a</em>&nbsp;</td><td>The rotation that aligns block b's index space with block a's </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>shift_b_to_a</em>&nbsp;</td><td>The post-rotation shift to move b into its correct location within a's index space </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>neighbor_type</em>&nbsp;</td><td>The type (codimension) of the neighbor relationship </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="d59c74e6976cd369dc2c69014f850516"></a><!-- doxytag: member="SAMRAI::hier::GridGeometry::getDomainOutsideBlock" ref="d59c74e6976cd369dc2c69014f850516" args="(BoxContainer &amp;domain_outside_block, const BlockId &amp;block_id) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::hier::GridGeometry::getDomainOutsideBlock           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>domain_outside_block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1BlockId.html">BlockId</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>block_id</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get a <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a> that contains all of the index space of all other blocks in the multiblock domain. 
<p>
A <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a> will be constructed that contains the full set of the coarse level domains of all blocks except the one identified by block_id. The domains will all be transformed into the index space represented by block_id.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>domain_outside_block</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>block_id</em>&nbsp;</td><td></td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="d9b60652d713a1ff3ce7721c647c8d45"></a><!-- doxytag: member="SAMRAI::hier::GridGeometry::getNumberOfBlockSingularities" ref="d9b60652d713a1ff3ce7721c647c8d45" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SAMRAI_INLINE_KEYWORD int SAMRAI::hier::GridGeometry::getNumberOfBlockSingularities           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return the number of block singularities in the block configuration. 
<p>

</div>
</div><p>
<a class="anchor" name="1a3ff8d09d283250fc144ffaae4ccb09"></a><!-- doxytag: member="SAMRAI::hier::GridGeometry::getSingularityBoxContainer" ref="1a3ff8d09d283250fc144ffaae4ccb09" args="(const BlockId &amp;block_id) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SAMRAI_INLINE_KEYWORD const <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a> &amp; SAMRAI::hier::GridGeometry::getSingularityBoxContainer           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1BlockId.html">BlockId</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>block_id</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return a <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a> that describes all of the singularities touched by the block indicated by block_id. 
<p>
<dl compact><dt><b>Returns:</b></dt><dd>For every singularity point the block touches, the <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a> will contain a single-cell box that lies just outside the block domain, touching the block only at the singularity point. For line singularities, the <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a> will contain boxes of width 1 in all dimensions except one, lying outside the block's coarse-level domain and touching the domain only along the line of singularity.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>io]</em>&nbsp;</td><td>block_id </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="0c4b5a9bd8b6a24a61706c7a75698b37"></a><!-- doxytag: member="SAMRAI::hier::GridGeometry::getSingularityIndices" ref="0c4b5a9bd8b6a24a61706c7a75698b37" args="(const BlockId &amp;block_id) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SAMRAI_INLINE_KEYWORD const std::vector&lt; int &gt; &amp; SAMRAI::hier::GridGeometry::getSingularityIndices           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1BlockId.html">BlockId</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>block_id</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return a list of integers indicating all of the singularities touched by the block indicated by block_id. 
<p>
<dl compact><dt><b>Returns:</b></dt><dd>For every singularity point the block touches, the vector&lt;int&gt; will contain the index of that singularity.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>i]</em>&nbsp;</td><td>block_id </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="01cdbc71930809e425f4b3c09d8f6ec2"></a><!-- doxytag: member="SAMRAI::hier::GridGeometry::reducedConnectivityExists" ref="01cdbc71930809e425f4b3c09d8f6ec2" args="(const BlockId &amp;block_id) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SAMRAI_INLINE_KEYWORD bool SAMRAI::hier::GridGeometry::reducedConnectivityExists           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1BlockId.html">BlockId</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>block_id</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Tell if block represented by block_id touches a reduced-connectivity singularity. 
<p>
<dl compact><dt><b>Returns:</b></dt><dd>True if the block touches reduced connectivity singularity, false if not.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>block_id</em>&nbsp;</td><td></td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="f486765951cef181c91a3b84a3b5e799"></a><!-- doxytag: member="SAMRAI::hier::GridGeometry::transformBox" ref="f486765951cef181c91a3b84a3b5e799" args="(Box &amp;box, const IntVector &amp;ratio, const BlockId &amp;output_block, const BlockId &amp;input_block) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SAMRAI::hier::GridGeometry::transformBox           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>box</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>ratio</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1BlockId.html">BlockId</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>output_block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1BlockId.html">BlockId</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>input_block</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Modify a box by rotating and shifting from the index space of the transformed_block to the index space of the base_block at the resolution level defined by ratio_to_level_zero. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>box</em>&nbsp;</td><td>The boxes will be transformed from the transformed_block index space to the base_block index space. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>ratio_to_level_zero</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>output_block</em>&nbsp;</td><td>Integer identifier of the block whose index space will be represented in the boxes at output </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>input_block</em>&nbsp;</td><td>Integer identifier of the block whose index space is represented in the boxes at input</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Whether the box has been transformed. True if there is a relationship between input_block and output_block. False if there is no such relationship. </dd></dl>

</div>
</div><p>
<a class="anchor" name="c57e694962a56f62ba5602125b0819db"></a><!-- doxytag: member="SAMRAI::hier::GridGeometry::transformBoxContainer" ref="c57e694962a56f62ba5602125b0819db" args="(BoxContainer &amp;boxes, const IntVector &amp;ratio, const BlockId &amp;output_block, const BlockId &amp;input_block) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SAMRAI::hier::GridGeometry::transformBoxContainer           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>boxes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>ratio</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1BlockId.html">BlockId</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>output_block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1BlockId.html">BlockId</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>input_block</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Modify boxes by rotating and shifting from the index space of the input_block to the index space of the output_block at the resolution level defined by ratio_to_level_zero. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>boxes</em>&nbsp;</td><td>The boxes will be transformed from the input_block index space to the output_block index space. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>ratio_to_level_zero</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>output_block</em>&nbsp;</td><td>Integer identifier of the block whose index space will be represented in the boxes at output </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>input_block</em>&nbsp;</td><td>Integer identifier of the block whose index space is represented in the boxes at input</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Whether the boxes have been transformed. True if there is a relationship between input_block and output_block. False if there is no such relationship. </dd></dl>

</div>
</div><p>
<a class="anchor" name="07dcda0cc3204ae0c8e86cef7006f4ef"></a><!-- doxytag: member="SAMRAI::hier::GridGeometry::getTransformedBlock" ref="07dcda0cc3204ae0c8e86cef7006f4ef" args="(BoxContainer &amp;block_boxes, const BlockId &amp;base_block, const BlockId &amp;transformed_block)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::hier::GridGeometry::getTransformedBlock           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>block_boxes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1BlockId.html">BlockId</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>base_block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1BlockId.html">BlockId</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>transformed_block</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get a box array that describes the coarse-level domain of the transformed_block in terms of the index space of base_block. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>block_boxes</em>&nbsp;</td><td>The coarse-level domain of the block identified by transformed_block, represented in the index space of the block identified by base_block </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>base_block</em>&nbsp;</td><td>The block whose index space will be used for the output boxes </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>transformed_block</em>&nbsp;</td><td>ID of another block whose domain will be represented in the index space of the base block </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="0b23ed4d51934326c8e3dad30465b7b9"></a><!-- doxytag: member="SAMRAI::hier::GridGeometry::getNeighbors" ref="0b23ed4d51934326c8e3dad30465b7b9" args="(const BlockId &amp;block_id) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SAMRAI_INLINE_KEYWORD const <a class="el" href="classSAMRAI_1_1tbox_1_1List.html">tbox::List</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1GridGeometry_1_1Neighbor.html">GridGeometry::Neighbor</a> &gt; &amp; SAMRAI::hier::GridGeometry::getNeighbors           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1BlockId.html">BlockId</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>block_id</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return a list of <a class="el" href="classSAMRAI_1_1hier_1_1GridGeometry_1_1Neighbor.html">Neighbor</a> objects describing all of the neighbors of the block indicated by the block_id. 
<p>
<dl compact><dt><b>Returns:</b></dt><dd>The list of neighbors</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>block_id</em>&nbsp;</td><td></td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="417bd4a8a3ec5e760262d9202ee716ad"></a><!-- doxytag: member="SAMRAI::hier::GridGeometry::getNumberOfNeighbors" ref="417bd4a8a3ec5e760262d9202ee716ad" args="(const BlockId &amp;block_id) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SAMRAI_INLINE_KEYWORD int SAMRAI::hier::GridGeometry::getNumberOfNeighbors           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1BlockId.html">BlockId</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>block_id</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return the number of neighbors a specific block of the Multiblock domain has. 
<p>
A block is the neighbor of another block if the two blocks abut in any way, whether at a point, a 1D line, or a 2D plane.<p>
<dl compact><dt><b>Returns:</b></dt><dd>The number of neighbors</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>block_id</em>&nbsp;</td><td></td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="4855bd2bfe4091f7b43fc85153109864"></a><!-- doxytag: member="SAMRAI::hier::GridGeometry::areNeighbors" ref="4855bd2bfe4091f7b43fc85153109864" args="(const BlockId &amp;block_a, const BlockId &amp;block_b) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SAMRAI::hier::GridGeometry::areNeighbors           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1BlockId.html">BlockId</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>block_a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1BlockId.html">BlockId</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>block_b</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Tell if the given BlockIds represent neighboring blocks. 
<p>

</div>
</div><p>
<a class="anchor" name="5d808205801fc6a990d9964c6bcb682a"></a><!-- doxytag: member="SAMRAI::hier::GridGeometry::areSingularityNeighbors" ref="5d808205801fc6a990d9964c6bcb682a" args="(const BlockId &amp;block_a, const BlockId &amp;block_b) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SAMRAI::hier::GridGeometry::areSingularityNeighbors           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1BlockId.html">BlockId</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>block_a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1BlockId.html">BlockId</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>block_b</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Tell if the given BlockIds represent neighboring blocks. 
<p>

</div>
</div><p>
<a class="anchor" name="a0ff3bcadf6b95294cfe27a7d0ccd82c"></a><!-- doxytag: member="SAMRAI::hier::GridGeometry::getRotationIdentifier" ref="a0ff3bcadf6b95294cfe27a7d0ccd82c" args="(const BlockId &amp;dst, const BlockId &amp;src) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSAMRAI_1_1hier_1_1Transformation.html#1908f436f2e3bec8b6c0c24b3fcb8cd9">Transformation::RotationIdentifier</a> SAMRAI::hier::GridGeometry::getRotationIdentifier           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1BlockId.html">BlockId</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1BlockId.html">BlockId</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>src</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the rotation identifier to rotate from src to dst. 
<p>

</div>
</div><p>
<a class="anchor" name="7c5c47a23cfe6e0842e4f71d63fa71f9"></a><!-- doxytag: member="SAMRAI::hier::GridGeometry::getOffset" ref="7c5c47a23cfe6e0842e4f71d63fa71f9" args="(const BlockId &amp;dst, const BlockId &amp;src) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp; SAMRAI::hier::GridGeometry::getOffset           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1BlockId.html">BlockId</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1BlockId.html">BlockId</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>src</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the offset to shift from src to dst after rotation. 
<p>

</div>
</div><p>
<a class="anchor" name="59943bac359d3bb97bdf8a6931c4d1c1"></a><!-- doxytag: member="SAMRAI::hier::GridGeometry::hasEnhancedConnectivity" ref="59943bac359d3bb97bdf8a6931c4d1c1" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SAMRAI_INLINE_KEYWORD bool SAMRAI::hier::GridGeometry::hasEnhancedConnectivity           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Query if the geometry has enhanced connectivity. 
<p>

</div>
</div><p>
<a class="anchor" name="6e7001b9263ee5058128e75c1126cbd0"></a><!-- doxytag: member="SAMRAI::hier::GridGeometry::printClassData" ref="6e7001b9263ee5058128e75c1126cbd0" args="(std::ostream &amp;stream) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::hier::GridGeometry::printClassData           </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&nbsp;</td>
          <td class="paramname"> <em>stream</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Print object data to the specified output stream. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>stream</em>&nbsp;</td><td>The output stream (as a std::ostream&amp;) to print to. </td></tr>
  </table>
</dl>

<p>
Reimplemented in <a class="el" href="classSAMRAI_1_1geom_1_1CartesianGridGeometry.html#6b2ff51d7f095807d59eac0d488337a5">SAMRAI::geom::CartesianGridGeometry</a>, and <a class="el" href="classSAMRAI_1_1geom_1_1SkeletonGridGeometry.html#96fc7365bf23c65859b773d961f3605d">SAMRAI::geom::SkeletonGridGeometry</a>.
</div>
</div><p>
<a class="anchor" name="49293d85dc8096cd4bf0200d82d9da0c"></a><!-- doxytag: member="SAMRAI::hier::GridGeometry::putToDatabase" ref="49293d85dc8096cd4bf0200d82d9da0c" args="(tbox::Pointer&lt; tbox::Database &gt; db)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::hier::GridGeometry::putToDatabase           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Database.html">tbox::Database</a> &gt;&nbsp;</td>
          <td class="paramname"> <em>db</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Writes the state of the <a class="el" href="classSAMRAI_1_1hier_1_1GridGeometry.html">GridGeometry</a> object to the database. 
<p>
When assertion checking is active, db cannot be a null database pointer.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>db</em>&nbsp;</td><td>The database to write to write/serialize. </td></tr>
  </table>
</dl>

<p>
Implements <a class="el" href="classSAMRAI_1_1tbox_1_1Serializable.html#b6a4bd6fd7a9046bd2f60ad716c21293">SAMRAI::tbox::Serializable</a>.
<p>
Reimplemented in <a class="el" href="classSAMRAI_1_1geom_1_1CartesianGridGeometry.html#3660dcab5751f0b43e179bd16cfa7921">SAMRAI::geom::CartesianGridGeometry</a>, and <a class="el" href="classSAMRAI_1_1geom_1_1SkeletonGridGeometry.html#253a616c566ca299d134346752217270">SAMRAI::geom::SkeletonGridGeometry</a>.
</div>
</div><p>
<a class="anchor" name="339d863d111f08499f1f34109fa002fe"></a><!-- doxytag: member="SAMRAI::hier::GridGeometry::readBlockDataFromInput" ref="339d863d111f08499f1f34109fa002fe" args="(const tbox::Pointer&lt; tbox::Database &gt; &amp;input_db)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::hier::GridGeometry::readBlockDataFromInput           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Database.html">tbox::Database</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>input_db</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Read multiblock metadata input from the input database. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>input_db</em>&nbsp;</td><td></td></tr>
  </table>
</dl>

</div>
</div><p>
<hr>The documentation for this class was generated from the following files:<ul>
<li>source/SAMRAI/hier/<a class="el" href="GridGeometry_8h.html">GridGeometry.h</a><li>source/SAMRAI/hier/<a class="el" href="GridGeometry_8C.html">GridGeometry.C</a><li>source/SAMRAI/hier/<a class="el" href="GridGeometry_8I.html">GridGeometry.I</a></ul>
<hr size="1"><address style="align: right;"><small>Generated on Wed Jan 18 16:05:15 2012 for SAMRAI by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.7 </small></address>
</body>
</html>
