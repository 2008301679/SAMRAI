<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>SAMRAI: Class List</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.7 -->
<div class="tabs">
  <ul>
    <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="namespaces.html"><span>Namespaces</span></a></li>
    <li id="current"><a href="annotated.html"><span>Classes</span></a></li>
    <li><a href="files.html"><span>Files</span></a></li>
    <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
  </ul></div>
<div class="tabs">
  <ul>
    <li id="current"><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
    <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
    <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
  </ul></div>
<h1>SAMRAI Class List</h1>Here are the classes, structs, unions and interfaces with brief descriptions:<table>
  <tr><td class="indexkey"><a class="el" href="structarith__functions.html">arith_functions</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structKeyData.html">KeyData</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classMDA__Access.html">MDA_Access&lt; MDA_TYPE, MDA_DIM, OrderType &gt;</a></td><td class="indexvalue">Non-const multidimensional array access </td></tr>
  <tr><td class="indexkey"><a class="el" href="classMDA__AccessConst.html">MDA_AccessConst&lt; MDA_TYPE, MDA_DIM, OrderType &gt;</a></td><td class="indexvalue">Const data version of the multidimensional array access template class <a class="el" href="classMDA__Access.html">MDA_Access</a> </td></tr>
  <tr><td class="indexkey"><a class="el" href="classMDA__IndexRange.html">MDA_IndexRange&lt; MDA_DIM &gt;</a></td><td class="indexvalue">Defines index ranges for multidimensional arrays </td></tr>
  <tr><td class="indexkey"><a class="el" href="classMDA__OrderColMajor.html">MDA_OrderColMajor&lt; MDA_DIM &gt;</a></td><td class="indexvalue">Performs computations based for column-major arrays </td></tr>
  <tr><td class="indexkey"><a class="el" href="classMDA__OrderRowMajor.html">MDA_OrderRowMajor&lt; MDA_DIM &gt;</a></td><td class="indexvalue">Performs computations based for row-major arrays </td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1algs_1_1HyperbolicLevelIntegrator.html">SAMRAI::algs::HyperbolicLevelIntegrator</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1algs_1_1HyperbolicPatchStrategy.html">SAMRAI::algs::HyperbolicPatchStrategy</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1algs_1_1ImplicitEquationStrategy.html">SAMRAI::algs::ImplicitEquationStrategy</a></td><td class="indexvalue"><b>Abstract</b> base class defining the interface between <a class="el" href="classSAMRAI_1_1algs_1_1ImplicitIntegrator.html">ImplicitIntegrator</a> object and routines specific to the system of equations to be solved </td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1algs_1_1ImplicitIntegrator.html">SAMRAI::algs::ImplicitIntegrator</a></td><td class="indexvalue">Manage implicit time integration over an AMR patch hierarchy </td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1algs_1_1MblkPatchBoundaryNodeSum.html">SAMRAI::algs::MblkPatchBoundaryNodeSum</a></td><td class="indexvalue">Class <a class="el" href="classSAMRAI_1_1algs_1_1MblkPatchBoundaryNodeSum.html">MblkPatchBoundaryNodeSum</a> provides operations for summing node data values at nodes that are shared by multiple patches on a single level or across multiple hierarchy levels </td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1algs_1_1MethodOfLinesIntegrator.html">SAMRAI::algs::MethodOfLinesIntegrator</a></td><td class="indexvalue">Class <a class="el" href="classSAMRAI_1_1algs_1_1MethodOfLinesIntegrator.html">MethodOfLinesIntegrator</a> implements a spatially adaptive version of the Strong Stability Preserving (SSP) Runge-Kutta time integration algorithm </td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1algs_1_1MethodOfLinesPatchStrategy.html">SAMRAI::algs::MethodOfLinesPatchStrategy</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1algs_1_1OuteredgeSumTransaction.html">SAMRAI::algs::OuteredgeSumTransaction</a></td><td class="indexvalue">Class <a class="el" href="classSAMRAI_1_1algs_1_1OuteredgeSumTransaction.html">OuteredgeSumTransaction</a> represents a single outeredge data sum communication transaction between two processors or a local data sum for refine schedules. Note that to there is an implicit hand-shaking between objects of this class and the <a class="el" href="classSAMRAI_1_1xfer_1_1RefineSchedule.html">xfer::RefineSchedule</a> object that constructs them. Following the refine schedule implementation, the source patch data index for a transaction always refers to the source data and the destination patch data index for a transaction is always the scratch data, all as defined in the <a class="el" href="classSAMRAI_1_1xfer_1_1RefineClasses.html">xfer::RefineClasses</a> class </td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1algs_1_1OuteredgeSumTransactionFactory.html">SAMRAI::algs::OuteredgeSumTransactionFactory</a></td><td class="indexvalue">Concrete subclass of the <a class="el" href="classSAMRAI_1_1xfer_1_1RefineTransactionFactory.html">xfer::RefineTransactionFactory</a> base class that allocates outeredge sum transaction objects for a <a class="el" href="classSAMRAI_1_1xfer_1_1RefineSchedule.html">xfer::RefineSchedule</a> object </td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1algs_1_1OuternodeSumTransaction.html">SAMRAI::algs::OuternodeSumTransaction</a></td><td class="indexvalue">Class <a class="el" href="classSAMRAI_1_1algs_1_1OuternodeSumTransaction.html">OuternodeSumTransaction</a> represents a single outernode data sum communication transaction between two processors or a local data sum for refine schedules. Note that to there is an implicit hand-shaking between objects of this class and the <a class="el" href="classSAMRAI_1_1xfer_1_1RefineSchedule.html">xfer::RefineSchedule</a> object that constructs them. Following the refine schedule implementation, the source patch data index for a transaction always refers to the source data and the destination patch data index for a transaction is always the scratch data, all as defined in the <a class="el" href="classSAMRAI_1_1xfer_1_1RefineClasses.html">xfer::RefineClasses</a> class </td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1algs_1_1OuternodeSumTransactionFactory.html">SAMRAI::algs::OuternodeSumTransactionFactory</a></td><td class="indexvalue">Concrete subclass of the <a class="el" href="classSAMRAI_1_1xfer_1_1RefineTransactionFactory.html">xfer::RefineTransactionFactory</a> base class that allocates transaction outernode sum objects for a <a class="el" href="classSAMRAI_1_1xfer_1_1RefineSchedule.html">xfer::RefineSchedule</a> object </td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1algs_1_1PatchBoundaryEdgeSum.html">SAMRAI::algs::PatchBoundaryEdgeSum</a></td><td class="indexvalue">Class <a class="el" href="classSAMRAI_1_1algs_1_1PatchBoundaryEdgeSum.html">PatchBoundaryEdgeSum</a> provides operations summing edge data values at edges that are shared by multiple patches on a single level. Note that this utility only works on a SINGLE patch level, not on a multiple levels in an AMR patch hierarchy like the <a class="el" href="classSAMRAI_1_1algs_1_1PatchBoundaryNodeSum.html">PatchBoundaryNodeSum</a> class. Unlike node data, edge data at coarse-fine boundaries are not co-located, so the sum operation is not clearly defined </td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1algs_1_1PatchBoundaryNodeSum.html">SAMRAI::algs::PatchBoundaryNodeSum</a></td><td class="indexvalue">Class <a class="el" href="classSAMRAI_1_1algs_1_1PatchBoundaryNodeSum.html">PatchBoundaryNodeSum</a> provides operations for summing node data values at nodes that are shared by multiple patches on a single level or across multiple hierarchy levels </td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1algs_1_1TimeRefinementIntegrator.html">SAMRAI::algs::TimeRefinementIntegrator</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1algs_1_1TimeRefinementLevelStrategy.html">SAMRAI::algs::TimeRefinementLevelStrategy</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1appu_1_1BoundaryUtilityStrategy.html">SAMRAI::appu::BoundaryUtilityStrategy</a></td><td class="indexvalue">Class <a class="el" href="classSAMRAI_1_1appu_1_1BoundaryUtilityStrategy.html">BoundaryUtilityStrategy</a> is an abstract base class that declares an interface that allows application code to read problem-specific boundary data when using the <a class="el" href="namespaceSAMRAI.html">SAMRAI</a> boundary utilities. Currently, there are two virtual member functions defined. One allows users to read problem-specific DIRICHLET boundary values from an input database; the other does the same for NEUMANN boundary values. More virtual functions may be added in the future as additional boundary conditions are supported </td></tr>
  <tr><td class="indexkey"><a class="el" href="structSAMRAI_1_1appu_1_1CartesianBoundaryUtilities2.html">SAMRAI::appu::CartesianBoundaryUtilities2</a></td><td class="indexvalue">Class <a class="el" href="structSAMRAI_1_1appu_1_1CartesianBoundaryUtilities2.html">CartesianBoundaryUtilities2</a> is a utility class that simplifies the implementation of simple physical boundary data in 2 spatial dimensions. It contains routines for reading boundary data information from input files, applying those boundary conditions, and error checking boundary data. These routines apply to the case of cell-centered double data only. One may use all of these capabilities, or use the input reading, boundary setting, and error checking routines independently </td></tr>
  <tr><td class="indexkey"><a class="el" href="structSAMRAI_1_1appu_1_1CartesianBoundaryUtilities3.html">SAMRAI::appu::CartesianBoundaryUtilities3</a></td><td class="indexvalue">Class <a class="el" href="structSAMRAI_1_1appu_1_1CartesianBoundaryUtilities3.html">CartesianBoundaryUtilities3</a> is a utility class that simplifies the implementation of simple physical boundary data in 3 spatial dimensions. It contains routines for reading boundary data information from input files, applying those boundary conditions, and error checking boundary data. These routines apply to the case of cell-centered double data only. One may use all of these capabilities, or use the input reading, boundary setting, and error checking routines independently </td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1appu_1_1VisDerivedDataStrategy.html">SAMRAI::appu::VisDerivedDataStrategy</a></td><td class="indexvalue">Class <a class="el" href="classSAMRAI_1_1appu_1_1VisDerivedDataStrategy.html">VisDerivedDataStrategy</a> is an abstract base class that defines an interface allowing an <a class="el" href="classSAMRAI_1_1appu_1_1VisItDataWriter.html">VisItDataWriter</a> object to generate plot files that contain "derived" quantities; that is, data that does not reside on the hierarchy, but which is derived from data that does reside on the hierarchy. The derived data may be scalar, vector, or tensor, and cell-centered or node-centered. A concrete object of this type must be registered with the data writer if any derived variable is registered with the data writer. The registration of the concrete strategy object may be done independently using the method setDefaultDerivedDataWriter() from the relevant DataWriter class, or the concrete strategy object may be registered concurrently with the derived variable using the method registerDerivedPlotScalar/Vector/Tensor() </td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1appu_1_1VisItDataWriter.html">SAMRAI::appu::VisItDataWriter</a></td><td class="indexvalue">Class <a class="el" href="classSAMRAI_1_1appu_1_1VisItDataWriter.html">VisItDataWriter</a> is used by SAMRAI-based application codes to generate VisIt data files. VisIt provides a wide range of visualization and post-processing capabilities. This class supports both cell-centered and node-centered 2D and 3D AMR data where the underlying data type is either double, float, or int. Scalar, vector and 2nd-order tensor variables are supported. This class may be used when the mesh geometry is managed by a <a class="el" href="classSAMRAI_1_1geom_1_1CartesianGridGeometry.html">geom::CartesianGridGeometry</a> object, or when the mesh itself is stored in a state variable to allow moving deformed grids </td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1appu_1_1VisMaterialsDataStrategy.html">SAMRAI::appu::VisMaterialsDataStrategy</a></td><td class="indexvalue">Class <a class="el" href="classSAMRAI_1_1appu_1_1VisMaterialsDataStrategy.html">VisMaterialsDataStrategy</a> is an abstract base class that defines an interface allowing an <a class="el" href="classSAMRAI_1_1appu_1_1VisItDataWriter.html">VisItDataWriter</a> object to generate plot files that contain material and species fractions, as well as state variables for individual materials. A concrete object of this type must be registered with the data writer in order to use materials or species with the data writer. The registration of the concrete object is done using the method setMaterialsDataWriter() from the <a class="el" href="classSAMRAI_1_1appu_1_1VisItDataWriter.html">VisItDataWriter</a> class. VisIt requires that material fractions, species fractions, and material state variables be cell-centered. If they are not cell-centered in the simulation, it is the job of the relevant packing method to convert them to a cell-centered basis before packing them into the buffer </td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1geom_1_1CartesianCellComplexConservativeLinearRefine.html">SAMRAI::geom::CartesianCellComplexConservativeLinearRefine</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1geom_1_1CartesianCellComplexLinearRefine.html">SAMRAI::geom::CartesianCellComplexLinearRefine</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1geom_1_1CartesianCellComplexWeightedAverage.html">SAMRAI::geom::CartesianCellComplexWeightedAverage</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1geom_1_1CartesianCellDoubleConservativeLinearRefine.html">SAMRAI::geom::CartesianCellDoubleConservativeLinearRefine</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1geom_1_1CartesianCellDoubleLinearRefine.html">SAMRAI::geom::CartesianCellDoubleLinearRefine</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1geom_1_1CartesianCellDoubleWeightedAverage.html">SAMRAI::geom::CartesianCellDoubleWeightedAverage</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1geom_1_1CartesianCellFloatConservativeLinearRefine.html">SAMRAI::geom::CartesianCellFloatConservativeLinearRefine</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1geom_1_1CartesianCellFloatLinearRefine.html">SAMRAI::geom::CartesianCellFloatLinearRefine</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1geom_1_1CartesianCellFloatWeightedAverage.html">SAMRAI::geom::CartesianCellFloatWeightedAverage</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1geom_1_1CartesianEdgeComplexWeightedAverage.html">SAMRAI::geom::CartesianEdgeComplexWeightedAverage</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1geom_1_1CartesianEdgeDoubleConservativeLinearRefine.html">SAMRAI::geom::CartesianEdgeDoubleConservativeLinearRefine</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1geom_1_1CartesianEdgeDoubleWeightedAverage.html">SAMRAI::geom::CartesianEdgeDoubleWeightedAverage</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1geom_1_1CartesianEdgeFloatConservativeLinearRefine.html">SAMRAI::geom::CartesianEdgeFloatConservativeLinearRefine</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1geom_1_1CartesianEdgeFloatWeightedAverage.html">SAMRAI::geom::CartesianEdgeFloatWeightedAverage</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1geom_1_1CartesianFaceComplexWeightedAverage.html">SAMRAI::geom::CartesianFaceComplexWeightedAverage</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1geom_1_1CartesianFaceDoubleConservativeLinearRefine.html">SAMRAI::geom::CartesianFaceDoubleConservativeLinearRefine</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1geom_1_1CartesianFaceDoubleWeightedAverage.html">SAMRAI::geom::CartesianFaceDoubleWeightedAverage</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1geom_1_1CartesianFaceFloatConservativeLinearRefine.html">SAMRAI::geom::CartesianFaceFloatConservativeLinearRefine</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1geom_1_1CartesianFaceFloatWeightedAverage.html">SAMRAI::geom::CartesianFaceFloatWeightedAverage</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1geom_1_1CartesianGridGeometry.html">SAMRAI::geom::CartesianGridGeometry</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1geom_1_1CartesianNodeComplexLinearRefine.html">SAMRAI::geom::CartesianNodeComplexLinearRefine</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1geom_1_1CartesianNodeDoubleLinearRefine.html">SAMRAI::geom::CartesianNodeDoubleLinearRefine</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1geom_1_1CartesianNodeFloatLinearRefine.html">SAMRAI::geom::CartesianNodeFloatLinearRefine</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1geom_1_1CartesianOuterfaceComplexWeightedAverage.html">SAMRAI::geom::CartesianOuterfaceComplexWeightedAverage</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1geom_1_1CartesianOuterfaceDoubleWeightedAverage.html">SAMRAI::geom::CartesianOuterfaceDoubleWeightedAverage</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1geom_1_1CartesianOuterfaceFloatWeightedAverage.html">SAMRAI::geom::CartesianOuterfaceFloatWeightedAverage</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1geom_1_1CartesianOutersideDoubleWeightedAverage.html">SAMRAI::geom::CartesianOutersideDoubleWeightedAverage</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1geom_1_1CartesianPatchGeometry.html">SAMRAI::geom::CartesianPatchGeometry</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1geom_1_1CartesianSideComplexWeightedAverage.html">SAMRAI::geom::CartesianSideComplexWeightedAverage</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1geom_1_1CartesianSideDoubleConservativeLinearRefine.html">SAMRAI::geom::CartesianSideDoubleConservativeLinearRefine</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1geom_1_1CartesianSideDoubleWeightedAverage.html">SAMRAI::geom::CartesianSideDoubleWeightedAverage</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1geom_1_1CartesianSideFloatConservativeLinearRefine.html">SAMRAI::geom::CartesianSideFloatConservativeLinearRefine</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1geom_1_1CartesianSideFloatWeightedAverage.html">SAMRAI::geom::CartesianSideFloatWeightedAverage</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1geom_1_1GridGeometry.html">SAMRAI::geom::GridGeometry</a></td><td class="indexvalue">Class <a class="el" href="classSAMRAI_1_1geom_1_1GridGeometry.html">GridGeometry</a> manages the index space that determines the extent of the coarse-level domain of a <a class="el" href="namespaceSAMRAI.html">SAMRAI</a> hierarchy </td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1hier_1_1BaseConnectorAlgorithm.html">SAMRAI::hier::BaseConnectorAlgorithm</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1hier_1_1BaseGridGeometry.html">SAMRAI::hier::BaseGridGeometry</a></td><td class="indexvalue">Class <a class="el" href="classSAMRAI_1_1hier_1_1BaseGridGeometry.html">BaseGridGeometry</a> manages the index space that determines the extent of the coarse-level domain of a <a class="el" href="namespaceSAMRAI.html">SAMRAI</a> hierarchy </td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1hier_1_1BaseGridGeometry_1_1Neighbor.html">SAMRAI::hier::BaseGridGeometry::Neighbor</a></td><td class="indexvalue">Class to represent the neighbor of a given block </td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1hier_1_1BlockId.html">SAMRAI::hier::BlockId</a></td><td class="indexvalue">Generic identifier for identifying the block id </td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1hier_1_1BoundaryBox.html">SAMRAI::hier::BoundaryBox</a></td><td class="indexvalue">Class <a class="el" href="classSAMRAI_1_1hier_1_1BoundaryBox.html">BoundaryBox</a> is is used to describe boundaries of a patch </td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1hier_1_1BoundaryBoxUtils.html">SAMRAI::hier::BoundaryBoxUtils</a></td><td class="indexvalue">Perform shifts, extensions, etc on a <a class="el" href="classSAMRAI_1_1hier_1_1BoundaryBox.html">BoundaryBox</a> using the box's location index and type </td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1hier_1_1BoundaryLookupTable.html">SAMRAI::hier::BoundaryLookupTable</a></td><td class="indexvalue">Singleton class to organize patch boundary information </td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1hier_1_1Box.html">SAMRAI::hier::Box</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structSAMRAI_1_1hier_1_1Box_1_1box__equality.html">SAMRAI::hier::Box::box_equality</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structSAMRAI_1_1hier_1_1Box_1_1id__equal.html">SAMRAI::hier::Box::id_equal</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structSAMRAI_1_1hier_1_1Box_1_1id__less.html">SAMRAI::hier::Box::id_less</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">SAMRAI::hier::BoxContainer</a></td><td class="indexvalue">A container for Boxes </td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer_1_1BoxContainerConstIterator.html">SAMRAI::hier::BoxContainer::BoxContainerConstIterator</a></td><td class="indexvalue">A immutable iterator over the boxes in a <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a> </td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer_1_1BoxContainerIterator.html">SAMRAI::hier::BoxContainer::BoxContainerIterator</a></td><td class="indexvalue">A mutable iterator over the boxes in a <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a> </td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer_1_1Outputter.html">SAMRAI::hier::BoxContainer::Outputter</a></td><td class="indexvalue">Intermediary between <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a> and output streams, adding ability to control the output. See <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html#690469554c526eae84d5763ac0965e3c">BoxContainer::format()</a> </td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainerSingleBlockIterator.html">SAMRAI::hier::BoxContainerSingleBlockIterator</a></td><td class="indexvalue"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a> iterator picking items with a specified <a class="el" href="classSAMRAI_1_1hier_1_1BlockId.html">BlockId</a> </td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainerSingleOwnerIterator.html">SAMRAI::hier::BoxContainerSingleOwnerIterator</a></td><td class="indexvalue"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a> iterator picking items with a specified owner rank </td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainerUtils.html">SAMRAI::hier::BoxContainerUtils</a></td><td class="indexvalue">Utilities for performing simple common tasks on a container of Boxes </td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1hier_1_1BoxGeometry.html">SAMRAI::hier::BoxGeometry</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1hier_1_1BoxId.html">SAMRAI::hier::BoxId</a></td><td class="indexvalue">Identifier for a <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a>, consisting of a <a class="el" href="classSAMRAI_1_1hier_1_1GlobalId.html">GlobalId</a> and a <a class="el" href="classSAMRAI_1_1hier_1_1PeriodicId.html">PeriodicId</a> </td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1hier_1_1BoxIterator.html">SAMRAI::hier::BoxIterator</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">SAMRAI::hier::BoxLevel</a></td><td class="indexvalue">A distributed set of <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> objects which reside in the same index space </td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel_1_1Outputter.html">SAMRAI::hier::BoxLevel::Outputter</a></td><td class="indexvalue">A class for outputting <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a> </td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevelConnectorUtils.html">SAMRAI::hier::BoxLevelConnectorUtils</a></td><td class="indexvalue">Utilities for common operating on BoxLevels </td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevelHandle.html">SAMRAI::hier::BoxLevelHandle</a></td><td class="indexvalue">A handle for Connectors to access their head and base BoxLevels. A <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a> automatically releases its handle when it changes in a way that can invalidate <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">Connector</a> data, preventing the use of inconsistent data and deallocated objects </td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevelStatistics.html">SAMRAI::hier::BoxLevelStatistics</a></td><td class="indexvalue">A utility for writing out various statistics of Boxes </td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1hier_1_1BoxNeighborhoodCollection.html">SAMRAI::hier::BoxNeighborhoodCollection</a></td><td class="indexvalue">Given a <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> in a base <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a>, the Boxes in a head <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a> which are adjacent to the base <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> are its neighbors and are said to form the neighborhood of the base <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a>. This class describes the neighborhoods of a collection of base Boxes. Each base <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> in the collection has a neighborhood of adjacent head Boxes </td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1hier_1_1BoxNeighborhoodCollection_1_1ConstIterator.html">SAMRAI::hier::BoxNeighborhoodCollection::ConstIterator</a></td><td class="indexvalue">An iterator over the base Boxes of the neighborhoods in a const <a class="el" href="classSAMRAI_1_1hier_1_1BoxNeighborhoodCollection.html">BoxNeighborhoodCollection</a>. The interface does not allow modification of the base Boxes </td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1hier_1_1BoxNeighborhoodCollection_1_1ConstNeighborIterator.html">SAMRAI::hier::BoxNeighborhoodCollection::ConstNeighborIterator</a></td><td class="indexvalue">An iterator over the neighbors in the neighborhood of a base <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> in a const <a class="el" href="classSAMRAI_1_1hier_1_1BoxNeighborhoodCollection.html">BoxNeighborhoodCollection</a>. The interface does not allow modification of the neighbors </td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1hier_1_1BoxNeighborhoodCollection_1_1Iterator.html">SAMRAI::hier::BoxNeighborhoodCollection::Iterator</a></td><td class="indexvalue">An iterator over the base Boxes of the neighborhoods in a <a class="el" href="classSAMRAI_1_1hier_1_1BoxNeighborhoodCollection.html">BoxNeighborhoodCollection</a>. The interface does not allow modification of the base Boxes </td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1hier_1_1BoxNeighborhoodCollection_1_1NeighborIterator.html">SAMRAI::hier::BoxNeighborhoodCollection::NeighborIterator</a></td><td class="indexvalue">An iterator over the neighbors in the neighborhood of a base <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> in a <a class="el" href="classSAMRAI_1_1hier_1_1BoxNeighborhoodCollection.html">BoxNeighborhoodCollection</a>. The interface does not allow modification of the neighbors </td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1hier_1_1BoxOverlap.html">SAMRAI::hier::BoxOverlap</a></td><td class="indexvalue">Class <a class="el" href="classSAMRAI_1_1hier_1_1BoxOverlap.html">BoxOverlap</a> is an abstract base class used to represent a region where data will be communicated between two AMR patches </td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1hier_1_1BoxTree.html">SAMRAI::hier::BoxTree</a></td><td class="indexvalue">Utility sorting Boxes into tree-like form for finding box overlaps </td></tr>
  <tr><td class="indexkey"><a class="el" href="structSAMRAI_1_1hier_1_1BoxUtilities.html">SAMRAI::hier::BoxUtilities</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1hier_1_1CoarseFineBoundary.html">SAMRAI::hier::CoarseFineBoundary</a></td><td class="indexvalue">Utility class to construct and maintain a description of the coarse-fine boundary between a patch level and a coarser level </td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1hier_1_1CoarsenOperator.html">SAMRAI::hier::CoarsenOperator</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1hier_1_1ComponentSelector.html">SAMRAI::hier::ComponentSelector</a></td><td class="indexvalue">Bit vector used to indicate on which patch data elements to apply operations </td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">SAMRAI::hier::Connector</a></td><td class="indexvalue">A container which holds relationship connections between two BoxLevels </td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1hier_1_1Connector_1_1Outputter.html">SAMRAI::hier::Connector::Outputter</a></td><td class="indexvalue">A class for outputting <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">Connector</a> </td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1hier_1_1ConnectorStatistics.html">SAMRAI::hier::ConnectorStatistics</a></td><td class="indexvalue">A utility for writing out various statistics of Connectors </td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1hier_1_1GlobalId.html">SAMRAI::hier::GlobalId</a></td><td class="indexvalue">A locally determined, globally unique identifier </td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1hier_1_1Index.html">SAMRAI::hier::Index</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">SAMRAI::hier::IntVector</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1hier_1_1LocalId.html">SAMRAI::hier::LocalId</a></td><td class="indexvalue">Generic identifier for identifying things on the local process </td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1hier_1_1MappingConnector.html">SAMRAI::hier::MappingConnector</a></td><td class="indexvalue">A container which holds overlap relationship connections between two BoxLevels </td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1hier_1_1MappingConnectorAlgorithm.html">SAMRAI::hier::MappingConnectorAlgorithm</a></td><td class="indexvalue">Algorithms for using MappingConnectors representing changes to a <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a> </td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1hier_1_1MultiblockBoxTree.html">SAMRAI::hier::MultiblockBoxTree</a></td><td class="indexvalue">Utility sorting Boxes into tree-like form for finding box overlaps. Boxes are sorted by <a class="el" href="classSAMRAI_1_1hier_1_1BlockId.html">BlockId</a> and then a <a class="el" href="classSAMRAI_1_1hier_1_1BoxTree.html">BoxTree</a> is constructed for each block in a <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a> </td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1hier_1_1OverlapConnectorAlgorithm.html">SAMRAI::hier::OverlapConnectorAlgorithm</a></td><td class="indexvalue">Algorithms for working Connectors whose neighbor data represents overlaps </td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1hier_1_1Patch.html">SAMRAI::hier::Patch</a></td><td class="indexvalue">A container for patch data objects defined over a box </td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1hier_1_1PatchBoundaries.html">SAMRAI::hier::PatchBoundaries</a></td><td class="indexvalue">Class <a class="el" href="classSAMRAI_1_1hier_1_1PatchBoundaries.html">PatchBoundaries</a> is a container class for storing <a class="el" href="classSAMRAI_1_1hier_1_1BoundaryBox.html">BoundaryBox</a> objects for a single patch </td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1hier_1_1PatchData.html">SAMRAI::hier::PatchData</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1hier_1_1PatchDataFactory.html">SAMRAI::hier::PatchDataFactory</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1hier_1_1PatchDescriptor.html">SAMRAI::hier::PatchDescriptor</a></td><td class="indexvalue">Class <a class="el" href="classSAMRAI_1_1hier_1_1PatchDescriptor.html">PatchDescriptor</a> maintains a collection of patch data factories and associated names that describes how patch data entries are constructed on each patch in an AMR hierarchy. The factory mechanism is used to create new instances of concrete patch data objects without knowing their actual types. See the Design Patterns book by Gamma {<em>et</em> al.} for more details about the Abstract Factory pattern. Generally, a <a class="el" href="classSAMRAI_1_1hier_1_1PatchDescriptor.html">PatchDescriptor</a> object is intended to be shared among all patches (which are distributed across processors) so that they store patch data objects in the same way </td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1hier_1_1PatchFactory.html">SAMRAI::hier::PatchFactory</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1hier_1_1PatchGeometry.html">SAMRAI::hier::PatchGeometry</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1hier_1_1PatchGeometry_1_1TwoDimBool.html">SAMRAI::hier::PatchGeometry::TwoDimBool</a></td><td class="indexvalue">Array of 2*DIM booleans (with default constructor), used to instantiate the sparse container map&lt;LocalId,TwoDimBool&gt; (map&lt;<a class="el" href="classSAMRAI_1_1hier_1_1LocalId.html">LocalId</a>,bool[2*DIM]&gt; does not work) </td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1hier_1_1PatchHierarchy.html">SAMRAI::hier::PatchHierarchy</a></td><td class="indexvalue">Class <a class="el" href="classSAMRAI_1_1hier_1_1PatchHierarchy.html">PatchHierarchy</a> maintains the patch levels that define the AMR hierarchy </td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1hier_1_1PatchHierarchy_1_1ConnectorWidthRequestorStrategy.html">SAMRAI::hier::PatchHierarchy::ConnectorWidthRequestorStrategy</a></td><td class="indexvalue">Abstract base class defining a Strategy pattern interface for providing <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">Connector</a> width information to the <a class="el" href="classSAMRAI_1_1hier_1_1PatchHierarchy.html">PatchHierarchy</a> </td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1hier_1_1PatchLevel.html">SAMRAI::hier::PatchLevel</a></td><td class="indexvalue">Container class for patches defined at a single level of the AMR hierarchy </td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1hier_1_1PatchLevel_1_1Iterator.html">SAMRAI::hier::PatchLevel::Iterator</a></td><td class="indexvalue"><a class="el" href="classSAMRAI_1_1hier_1_1PatchLevel_1_1Iterator.html">Iterator</a> for looping through local patches </td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1hier_1_1PatchLevelFactory.html">SAMRAI::hier::PatchLevelFactory</a></td><td class="indexvalue">Factory used to create new patch levels </td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1hier_1_1PeriodicId.html">SAMRAI::hier::PeriodicId</a></td><td class="indexvalue">Generic identifier for identifying the periodic shift </td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1hier_1_1PeriodicShiftCatalog.html">SAMRAI::hier::PeriodicShiftCatalog</a></td><td class="indexvalue">Singleton for cataloging periodic shifts and assigning each one a unique "shift number" </td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1hier_1_1PersistentOverlapConnectors.html">SAMRAI::hier::PersistentOverlapConnectors</a></td><td class="indexvalue">A managager of overlap Connectors incident from a <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a>, used to store and, if needed, generate overlap Connectors in <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">BoxLevel</a> </td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1hier_1_1ProcessorMapping.html">SAMRAI::hier::ProcessorMapping</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1hier_1_1RealBoxConstIterator.html">SAMRAI::hier::RealBoxConstIterator</a></td><td class="indexvalue">Iterator through real Boxes (not periodic images) in a const <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a> </td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1hier_1_1RefineOperator.html">SAMRAI::hier::RefineOperator</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1hier_1_1TimeInterpolateOperator.html">SAMRAI::hier::TimeInterpolateOperator</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1hier_1_1TransferOperatorRegistry.html">SAMRAI::hier::TransferOperatorRegistry</a></td><td class="indexvalue">Class <a class="el" href="classSAMRAI_1_1hier_1_1TransferOperatorRegistry.html">TransferOperatorRegistry</a> is intended to serve as the registry for <a class="el" href="namespaceSAMRAI.html">SAMRAI</a> transfer operators. It will be a singleton object held by class <a class="el" href="classSAMRAI_1_1hier_1_1BaseGridGeometry.html">hier::BaseGridGeometry</a> </td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1hier_1_1Transformation.html">SAMRAI::hier::Transformation</a></td><td class="indexvalue">Class <a class="el" href="classSAMRAI_1_1hier_1_1Transformation.html">Transformation</a> represents generalized transformations between coordinate systems or within coordinate systems </td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1hier_1_1Variable.html">SAMRAI::hier::Variable</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1hier_1_1VariableContext.html">SAMRAI::hier::VariableContext</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1hier_1_1VariableDatabase.html">SAMRAI::hier::VariableDatabase</a></td><td class="indexvalue">Generates and manages mappings between Variables and/or (<a class="el" href="classSAMRAI_1_1hier_1_1Variable.html">Variable</a>,<a class="el" href="classSAMRAI_1_1hier_1_1VariableContext.html">VariableContext</a>) pairs and patch data indices </td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1math_1_1ArrayDataBasicOps.html">SAMRAI::math::ArrayDataBasicOps&lt; TYPE &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1math_1_1ArrayDataMiscellaneousOpsReal.html">SAMRAI::math::ArrayDataMiscellaneousOpsReal&lt; TYPE &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1math_1_1ArrayDataNormOpsComplex.html">SAMRAI::math::ArrayDataNormOpsComplex</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1math_1_1ArrayDataNormOpsInteger.html">SAMRAI::math::ArrayDataNormOpsInteger</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1math_1_1ArrayDataNormOpsReal.html">SAMRAI::math::ArrayDataNormOpsReal&lt; TYPE &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1math_1_1HierarchyCellDataOpsComplex.html">SAMRAI::math::HierarchyCellDataOpsComplex</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1math_1_1HierarchyCellDataOpsInteger.html">SAMRAI::math::HierarchyCellDataOpsInteger</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1math_1_1HierarchyCellDataOpsReal.html">SAMRAI::math::HierarchyCellDataOpsReal&lt; TYPE &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1math_1_1HierarchyDataOpsComplex.html">SAMRAI::math::HierarchyDataOpsComplex</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1math_1_1HierarchyDataOpsInteger.html">SAMRAI::math::HierarchyDataOpsInteger</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1math_1_1HierarchyDataOpsManager.html">SAMRAI::math::HierarchyDataOpsManager</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1math_1_1HierarchyDataOpsReal.html">SAMRAI::math::HierarchyDataOpsReal&lt; TYPE &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1math_1_1HierarchyEdgeDataOpsComplex.html">SAMRAI::math::HierarchyEdgeDataOpsComplex</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1math_1_1HierarchyEdgeDataOpsInteger.html">SAMRAI::math::HierarchyEdgeDataOpsInteger</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1math_1_1HierarchyEdgeDataOpsReal.html">SAMRAI::math::HierarchyEdgeDataOpsReal&lt; TYPE &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1math_1_1HierarchyFaceDataOpsComplex.html">SAMRAI::math::HierarchyFaceDataOpsComplex</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1math_1_1HierarchyFaceDataOpsInteger.html">SAMRAI::math::HierarchyFaceDataOpsInteger</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1math_1_1HierarchyFaceDataOpsReal.html">SAMRAI::math::HierarchyFaceDataOpsReal&lt; TYPE &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1math_1_1HierarchyNodeDataOpsComplex.html">SAMRAI::math::HierarchyNodeDataOpsComplex</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1math_1_1HierarchyNodeDataOpsInteger.html">SAMRAI::math::HierarchyNodeDataOpsInteger</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1math_1_1HierarchyNodeDataOpsReal.html">SAMRAI::math::HierarchyNodeDataOpsReal&lt; TYPE &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1math_1_1HierarchySideDataOpsComplex.html">SAMRAI::math::HierarchySideDataOpsComplex</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1math_1_1HierarchySideDataOpsInteger.html">SAMRAI::math::HierarchySideDataOpsInteger</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1math_1_1HierarchySideDataOpsReal.html">SAMRAI::math::HierarchySideDataOpsReal&lt; TYPE &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1math_1_1PatchCellDataBasicOps.html">SAMRAI::math::PatchCellDataBasicOps&lt; TYPE &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1math_1_1PatchCellDataMiscellaneousOpsReal.html">SAMRAI::math::PatchCellDataMiscellaneousOpsReal&lt; TYPE &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1math_1_1PatchCellDataNormOpsComplex.html">SAMRAI::math::PatchCellDataNormOpsComplex</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1math_1_1PatchCellDataNormOpsReal.html">SAMRAI::math::PatchCellDataNormOpsReal&lt; TYPE &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1math_1_1PatchCellDataOpsComplex.html">SAMRAI::math::PatchCellDataOpsComplex</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1math_1_1PatchCellDataOpsInteger.html">SAMRAI::math::PatchCellDataOpsInteger</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1math_1_1PatchCellDataOpsReal.html">SAMRAI::math::PatchCellDataOpsReal&lt; TYPE &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1math_1_1PatchEdgeDataBasicOps.html">SAMRAI::math::PatchEdgeDataBasicOps&lt; TYPE &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1math_1_1PatchEdgeDataMiscellaneousOpsReal.html">SAMRAI::math::PatchEdgeDataMiscellaneousOpsReal&lt; TYPE &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1math_1_1PatchEdgeDataNormOpsComplex.html">SAMRAI::math::PatchEdgeDataNormOpsComplex</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1math_1_1PatchEdgeDataNormOpsReal.html">SAMRAI::math::PatchEdgeDataNormOpsReal&lt; TYPE &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1math_1_1PatchEdgeDataOpsComplex.html">SAMRAI::math::PatchEdgeDataOpsComplex</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1math_1_1PatchEdgeDataOpsInteger.html">SAMRAI::math::PatchEdgeDataOpsInteger</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1math_1_1PatchEdgeDataOpsReal.html">SAMRAI::math::PatchEdgeDataOpsReal&lt; TYPE &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1math_1_1PatchFaceDataBasicOps.html">SAMRAI::math::PatchFaceDataBasicOps&lt; TYPE &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1math_1_1PatchFaceDataMiscellaneousOpsReal.html">SAMRAI::math::PatchFaceDataMiscellaneousOpsReal&lt; TYPE &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1math_1_1PatchFaceDataNormOpsComplex.html">SAMRAI::math::PatchFaceDataNormOpsComplex</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1math_1_1PatchFaceDataNormOpsReal.html">SAMRAI::math::PatchFaceDataNormOpsReal&lt; TYPE &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1math_1_1PatchFaceDataOpsComplex.html">SAMRAI::math::PatchFaceDataOpsComplex</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1math_1_1PatchFaceDataOpsInteger.html">SAMRAI::math::PatchFaceDataOpsInteger</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1math_1_1PatchFaceDataOpsReal.html">SAMRAI::math::PatchFaceDataOpsReal&lt; TYPE &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1math_1_1PatchNodeDataBasicOps.html">SAMRAI::math::PatchNodeDataBasicOps&lt; TYPE &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1math_1_1PatchNodeDataMiscellaneousOpsReal.html">SAMRAI::math::PatchNodeDataMiscellaneousOpsReal&lt; TYPE &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1math_1_1PatchNodeDataNormOpsComplex.html">SAMRAI::math::PatchNodeDataNormOpsComplex</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1math_1_1PatchNodeDataNormOpsReal.html">SAMRAI::math::PatchNodeDataNormOpsReal&lt; TYPE &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1math_1_1PatchNodeDataOpsComplex.html">SAMRAI::math::PatchNodeDataOpsComplex</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1math_1_1PatchNodeDataOpsInteger.html">SAMRAI::math::PatchNodeDataOpsInteger</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1math_1_1PatchNodeDataOpsReal.html">SAMRAI::math::PatchNodeDataOpsReal&lt; TYPE &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1math_1_1PatchSideDataBasicOps.html">SAMRAI::math::PatchSideDataBasicOps&lt; TYPE &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1math_1_1PatchSideDataMiscellaneousOpsReal.html">SAMRAI::math::PatchSideDataMiscellaneousOpsReal&lt; TYPE &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1math_1_1PatchSideDataNormOpsComplex.html">SAMRAI::math::PatchSideDataNormOpsComplex</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1math_1_1PatchSideDataNormOpsReal.html">SAMRAI::math::PatchSideDataNormOpsReal&lt; TYPE &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1math_1_1PatchSideDataOpsComplex.html">SAMRAI::math::PatchSideDataOpsComplex</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1math_1_1PatchSideDataOpsInteger.html">SAMRAI::math::PatchSideDataOpsInteger</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1math_1_1PatchSideDataOpsReal.html">SAMRAI::math::PatchSideDataOpsReal&lt; TYPE &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structSAMRAI_1_1mesh_1_1BalanceUtilities.html">SAMRAI::mesh::BalanceUtilities</a></td><td class="indexvalue">Utility class <a class="el" href="structSAMRAI_1_1mesh_1_1BalanceUtilities.html">BalanceUtilities</a> provides several functions useful in various load balancing operations. These utilities include bin packing operations, box chopping by recursive bisection, and computation of effective processor layouts for boxes </td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1mesh_1_1BergerRigoutsos.html">SAMRAI::mesh::BergerRigoutsos</a></td><td class="indexvalue">Asynchronous Berger-Rigoutsos implementation. This class is derived from the abstract base class <a class="el" href="classSAMRAI_1_1mesh_1_1BoxGeneratorStrategy.html">mesh::BoxGeneratorStrategy</a>. Thus, it serves as a concrete implementation of the box generator Strategy pattern interface </td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1mesh_1_1BergerRigoutsosNode.html">SAMRAI::mesh::BergerRigoutsosNode</a></td><td class="indexvalue">Node in the asynchronous Berger-Rigoutsos (BR) tree. Do not directly use this class; for clustering, use <a class="el" href="classSAMRAI_1_1mesh_1_1BergerRigoutsos.html">BergerRigoutsos</a> instead </td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1mesh_1_1BoxGeneratorStrategy.html">SAMRAI::mesh::BoxGeneratorStrategy</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1mesh_1_1ChopAndPackLoadBalancer.html">SAMRAI::mesh::ChopAndPackLoadBalancer</a></td><td class="indexvalue">Class <a class="el" href="classSAMRAI_1_1mesh_1_1ChopAndPackLoadBalancer.html">ChopAndPackLoadBalancer</a> provides load balancing routines for AMR hierarchy levels based on either uniform or non-uniform workload estimates </td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1mesh_1_1GriddingAlgorithm.html">SAMRAI::mesh::GriddingAlgorithm</a></td><td class="indexvalue">Class <a class="el" href="classSAMRAI_1_1mesh_1_1GriddingAlgorithm.html">GriddingAlgorithm</a> manages AMR patch hierarchy construction operations in <a class="el" href="namespaceSAMRAI.html">SAMRAI</a>. Specifically, it provides AMR patch hierarchy generation and regridding routines that may be used with a variety of AMR solution algorithms and application codes </td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1mesh_1_1GriddingAlgorithmConnectorWidthRequestor.html">SAMRAI::mesh::GriddingAlgorithmConnectorWidthRequestor</a></td><td class="indexvalue">Implementation of the strategy class <a class="el" href="classSAMRAI_1_1hier_1_1PatchHierarchy_1_1ConnectorWidthRequestorStrategy.html">hier::PatchHierarchy::ConnectorWidthRequestorStrategy</a> to tell the <a class="el" href="classSAMRAI_1_1hier_1_1PatchHierarchy.html">hier::PatchHierarchy</a> how wide <a class="el" href="classSAMRAI_1_1mesh_1_1GriddingAlgorithm.html">GriddingAlgorithm</a> needs Connectors between hierarchy levels to be </td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1mesh_1_1GriddingAlgorithmStrategy.html">SAMRAI::mesh::GriddingAlgorithmStrategy</a></td><td class="indexvalue">Virtual base class providing interface for gridding algorithms </td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1mesh_1_1LoadBalanceStrategy.html">SAMRAI::mesh::LoadBalanceStrategy</a></td><td class="indexvalue">Class <a class="el" href="classSAMRAI_1_1mesh_1_1LoadBalanceStrategy.html">LoadBalanceStrategy</a> is an abstract base class that defines a Strategy pattern interface for operations that load balance patches on a single AMR patch hierarchy level. Typically, such operations are invoked after the domain of a new hierarchy level is determined (e.g., via some error estimation procedure) and is applied to the collection of boxes that describe the domain. The load balancing process produces a set of boxes from which patches on the new level are created and a processor mapping describing how the new patches are mapped to processors </td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1mesh_1_1MultiblockGriddingTagger.html">SAMRAI::mesh::MultiblockGriddingTagger</a></td><td class="indexvalue">Class <a class="el" href="classSAMRAI_1_1mesh_1_1MultiblockGriddingTagger.html">MultiblockGriddingTagger</a> is a concrete implementation of RefinePatchStrategy that is used for boundary filling of tag data </td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1mesh_1_1SpatialKey.html">SAMRAI::mesh::SpatialKey</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1mesh_1_1StandardTagAndInitialize.html">SAMRAI::mesh::StandardTagAndInitialize</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1mesh_1_1StandardTagAndInitializeConnectorWidthRequestor.html">SAMRAI::mesh::StandardTagAndInitializeConnectorWidthRequestor</a></td><td class="indexvalue">Implementation of the strategy class <a class="el" href="classSAMRAI_1_1hier_1_1PatchHierarchy_1_1ConnectorWidthRequestorStrategy.html">hier::PatchHierarchy::ConnectorWidthRequestorStrategy</a> to tell the <a class="el" href="classSAMRAI_1_1hier_1_1PatchHierarchy.html">hier::PatchHierarchy</a> how wide <a class="el" href="classSAMRAI_1_1mesh_1_1StandardTagAndInitialize.html">StandardTagAndInitialize</a> needs Connectors between hierarchy levels to be </td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1mesh_1_1StandardTagAndInitStrategy.html">SAMRAI::mesh::StandardTagAndInitStrategy</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1mesh_1_1TagAndInitializeStrategy.html">SAMRAI::mesh::TagAndInitializeStrategy</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1mesh_1_1TileClustering.html">SAMRAI::mesh::TileClustering</a></td><td class="indexvalue">Tiled patch clustering algorithm. This is UNSUPPORTED, EXPERIMENTAL code not for general use </td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1mesh_1_1TilePartitioner.html">SAMRAI::mesh::TilePartitioner</a></td><td class="indexvalue">Load balance by cutting boxes along designated mesh lines defining a tile box grid. Implemementing the LoadBalancerStrategy. This is UNSUPPORTED, EXPERIMENTAL code not for general use </td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1mesh_1_1TreeLoadBalancer.html">SAMRAI::mesh::TreeLoadBalancer</a></td><td class="indexvalue">Provides load balancing routines for AMR hierarchy by implemementing the LoadBalancerStrategy </td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html">SAMRAI::pdat::ArrayData&lt; TYPE &gt;</a></td><td class="indexvalue">Class ArrayData&lt;TYPE&gt; is a basic templated array structure defined over the index space of a box (with a specified depth) that provides the support for the various standard array-based patch data subclasses </td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1pdat_1_1ArrayDataAccess.html">SAMRAI::pdat::ArrayDataAccess</a></td><td class="indexvalue">Utility for wrapping data from <a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html">ArrayData</a> class in an <a class="el" href="classMDA__Access.html">MDA_Access</a> or <a class="el" href="classMDA__AccessConst.html">MDA_AccessConst</a> object </td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1pdat_1_1ArrayDataIterator.html">SAMRAI::pdat::ArrayDataIterator</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1pdat_1_1ArrayDataOperationUtilities.html">SAMRAI::pdat::ArrayDataOperationUtilities&lt; TYPE, OP &gt;</a></td><td class="indexvalue">Struct ArrayDataOperationUtilities&lt;TYPE, OP&gt; provides generic looping operations for all array-based patch data types. The operations are templated on data type and the operation that will be performed on individual array elements in the innermost loop </td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1pdat_1_1CellComplexConstantRefine.html">SAMRAI::pdat::CellComplexConstantRefine</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1pdat_1_1CellComplexLinearTimeInterpolateOp.html">SAMRAI::pdat::CellComplexLinearTimeInterpolateOp</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1pdat_1_1CellData.html">SAMRAI::pdat::CellData&lt; TYPE &gt;</a></td><td class="indexvalue">Class CellData&lt;TYPE&gt; provides an implementation for data defined at cell centers on AMR patches. It is derived from the <a class="el" href="classSAMRAI_1_1hier_1_1PatchData.html">hier::PatchData</a> interface common to all <a class="el" href="namespaceSAMRAI.html">SAMRAI</a> patch data types. Given a CELL-centered AMR index space box, a cell data object represents data of some template TYPE and depth at the centers of the cells in the box. Here, depth indicates the number of data values at each cell index location. The <a class="el" href="classSAMRAI_1_1pdat_1_1CellGeometry.html">CellGeometry</a> class provides the translation between the standard <a class="el" href="namespaceSAMRAI.html">SAMRAI</a> cell-centered AMR index space and cell-centered data </td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1pdat_1_1CellDataFactory.html">SAMRAI::pdat::CellDataFactory&lt; TYPE &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1pdat_1_1CellDoubleConstantRefine.html">SAMRAI::pdat::CellDoubleConstantRefine</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1pdat_1_1CellDoubleLinearTimeInterpolateOp.html">SAMRAI::pdat::CellDoubleLinearTimeInterpolateOp</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1pdat_1_1CellFloatConstantRefine.html">SAMRAI::pdat::CellFloatConstantRefine</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1pdat_1_1CellFloatLinearTimeInterpolateOp.html">SAMRAI::pdat::CellFloatLinearTimeInterpolateOp</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1pdat_1_1CellGeometry.html">SAMRAI::pdat::CellGeometry</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1pdat_1_1CellIndex.html">SAMRAI::pdat::CellIndex</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1pdat_1_1CellIntegerConstantRefine.html">SAMRAI::pdat::CellIntegerConstantRefine</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1pdat_1_1CellIterator.html">SAMRAI::pdat::CellIterator</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1pdat_1_1CellOverlap.html">SAMRAI::pdat::CellOverlap</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1pdat_1_1CellVariable.html">SAMRAI::pdat::CellVariable&lt; TYPE &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1pdat_1_1CopyOperation.html">SAMRAI::pdat::CopyOperation&lt; TYPE &gt;</a></td><td class="indexvalue">Class CopyOperation&lt;TYPE&gt; encapsulates a copy operation into an object </td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1pdat_1_1DoubleAttributeId.html">SAMRAI::pdat::DoubleAttributeId</a></td><td class="indexvalue">Attribute identifying class for double-valued attributes </td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1pdat_1_1EdgeComplexConstantRefine.html">SAMRAI::pdat::EdgeComplexConstantRefine</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1pdat_1_1EdgeComplexLinearTimeInterpolateOp.html">SAMRAI::pdat::EdgeComplexLinearTimeInterpolateOp</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1pdat_1_1EdgeData.html">SAMRAI::pdat::EdgeData&lt; TYPE &gt;</a></td><td class="indexvalue">Class EdgeData&lt;TYPE&gt; provides an implementation for data defined at cell edges on AMR patches. It is derived from the <a class="el" href="classSAMRAI_1_1hier_1_1PatchData.html">hier::PatchData</a> interface common to all <a class="el" href="namespaceSAMRAI.html">SAMRAI</a> patch data types. Given a CELL-centered AMR index space box, an edge data object represents data of some template TYPE and depth on the edges of the cells in the box. Here, depth indicates the number of data values at each edge index location. The <a class="el" href="classSAMRAI_1_1pdat_1_1EdgeGeometry.html">EdgeGeometry</a> class provides the translation between the standard <a class="el" href="namespaceSAMRAI.html">SAMRAI</a> cell-centered AMR index space and edge-centered data </td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1pdat_1_1EdgeDataFactory.html">SAMRAI::pdat::EdgeDataFactory&lt; TYPE &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1pdat_1_1EdgeDoubleConstantRefine.html">SAMRAI::pdat::EdgeDoubleConstantRefine</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1pdat_1_1EdgeDoubleLinearTimeInterpolateOp.html">SAMRAI::pdat::EdgeDoubleLinearTimeInterpolateOp</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1pdat_1_1EdgeFloatConstantRefine.html">SAMRAI::pdat::EdgeFloatConstantRefine</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1pdat_1_1EdgeFloatLinearTimeInterpolateOp.html">SAMRAI::pdat::EdgeFloatLinearTimeInterpolateOp</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1pdat_1_1EdgeGeometry.html">SAMRAI::pdat::EdgeGeometry</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1pdat_1_1EdgeIndex.html">SAMRAI::pdat::EdgeIndex</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1pdat_1_1EdgeIntegerConstantRefine.html">SAMRAI::pdat::EdgeIntegerConstantRefine</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1pdat_1_1EdgeIterator.html">SAMRAI::pdat::EdgeIterator</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1pdat_1_1EdgeOverlap.html">SAMRAI::pdat::EdgeOverlap</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1pdat_1_1EdgeVariable.html">SAMRAI::pdat::EdgeVariable&lt; TYPE &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1pdat_1_1FaceComplexConstantRefine.html">SAMRAI::pdat::FaceComplexConstantRefine</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1pdat_1_1FaceComplexLinearTimeInterpolateOp.html">SAMRAI::pdat::FaceComplexLinearTimeInterpolateOp</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1pdat_1_1FaceData.html">SAMRAI::pdat::FaceData&lt; TYPE &gt;</a></td><td class="indexvalue">Class FaceData&lt;TYPE&gt; provides an implementation for data defined at cell faces on AMR patches. It is derived from the <a class="el" href="classSAMRAI_1_1hier_1_1PatchData.html">hier::PatchData</a> interface common to all <a class="el" href="namespaceSAMRAI.html">SAMRAI</a> patch data types. Given a CELL-centered AMR index space box, a face data object represents data of some template TYPE and depth on the faces of the cells in the box. Here, depth indicates the number of data values at each face index location. The <a class="el" href="classSAMRAI_1_1pdat_1_1FaceGeometry.html">FaceGeometry</a> class provides the translation between the standard <a class="el" href="namespaceSAMRAI.html">SAMRAI</a> cell-centered AMR index space and face-centered data </td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1pdat_1_1FaceDataFactory.html">SAMRAI::pdat::FaceDataFactory&lt; TYPE &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1pdat_1_1FaceDoubleConstantRefine.html">SAMRAI::pdat::FaceDoubleConstantRefine</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1pdat_1_1FaceDoubleLinearTimeInterpolateOp.html">SAMRAI::pdat::FaceDoubleLinearTimeInterpolateOp</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1pdat_1_1FaceFloatConstantRefine.html">SAMRAI::pdat::FaceFloatConstantRefine</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1pdat_1_1FaceFloatLinearTimeInterpolateOp.html">SAMRAI::pdat::FaceFloatLinearTimeInterpolateOp</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1pdat_1_1FaceGeometry.html">SAMRAI::pdat::FaceGeometry</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1pdat_1_1FaceIndex.html">SAMRAI::pdat::FaceIndex</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1pdat_1_1FaceIntegerConstantRefine.html">SAMRAI::pdat::FaceIntegerConstantRefine</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1pdat_1_1FaceIterator.html">SAMRAI::pdat::FaceIterator</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1pdat_1_1FaceOverlap.html">SAMRAI::pdat::FaceOverlap</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1pdat_1_1FaceVariable.html">SAMRAI::pdat::FaceVariable&lt; TYPE &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1pdat_1_1FirstLayerCellNoCornersVariableFillPattern.html">SAMRAI::pdat::FirstLayerCellNoCornersVariableFillPattern</a></td><td class="indexvalue">Class <a class="el" href="classSAMRAI_1_1pdat_1_1FirstLayerCellNoCornersVariableFillPattern.html">FirstLayerCellNoCornersVariableFillPattern</a> is a concrete implementation of the abstract base class VariableFillPattern </td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1pdat_1_1FirstLayerCellVariableFillPattern.html">SAMRAI::pdat::FirstLayerCellVariableFillPattern</a></td><td class="indexvalue">Class <a class="el" href="classSAMRAI_1_1pdat_1_1FirstLayerCellVariableFillPattern.html">FirstLayerCellVariableFillPattern</a> is a concrete implementation of the abstract base class VariableFillPattern </td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1pdat_1_1FirstLayerEdgeVariableFillPattern.html">SAMRAI::pdat::FirstLayerEdgeVariableFillPattern</a></td><td class="indexvalue">Class <a class="el" href="classSAMRAI_1_1pdat_1_1FirstLayerEdgeVariableFillPattern.html">FirstLayerEdgeVariableFillPattern</a> is a concrete implementation of the abstract base class VariableFillPattern </td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1pdat_1_1FirstLayerNodeVariableFillPattern.html">SAMRAI::pdat::FirstLayerNodeVariableFillPattern</a></td><td class="indexvalue">Class <a class="el" href="classSAMRAI_1_1pdat_1_1FirstLayerNodeVariableFillPattern.html">FirstLayerNodeVariableFillPattern</a> is a concrete implementation of the abstract base class VariableFillPattern </td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1pdat_1_1FirstLayerSideVariableFillPattern.html">SAMRAI::pdat::FirstLayerSideVariableFillPattern</a></td><td class="indexvalue">Class <a class="el" href="classSAMRAI_1_1pdat_1_1FirstLayerSideVariableFillPattern.html">FirstLayerSideVariableFillPattern</a> is a concrete implementation of the abstract base class VariableFillPattern </td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1pdat_1_1IndexData.html">SAMRAI::pdat::IndexData&lt; TYPE, BOX_GEOMETRY &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1pdat_1_1IndexDataFactory.html">SAMRAI::pdat::IndexDataFactory&lt; TYPE, BOX_GEOMETRY &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1pdat_1_1IndexDataNode.html">SAMRAI::pdat::IndexDataNode&lt; TYPE, BOX_GEOMETRY &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1pdat_1_1IndexIterator.html">SAMRAI::pdat::IndexIterator&lt; TYPE, BOX_GEOMETRY &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1pdat_1_1IndexVariable.html">SAMRAI::pdat::IndexVariable&lt; TYPE, BOX_GEOMETRY &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1pdat_1_1IntegerAttributeId.html">SAMRAI::pdat::IntegerAttributeId</a></td><td class="indexvalue">Attribute identifying class for integer-valued attributes </td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1pdat_1_1NodeComplexInjection.html">SAMRAI::pdat::NodeComplexInjection</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1pdat_1_1NodeComplexLinearTimeInterpolateOp.html">SAMRAI::pdat::NodeComplexLinearTimeInterpolateOp</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1pdat_1_1NodeData.html">SAMRAI::pdat::NodeData&lt; TYPE &gt;</a></td><td class="indexvalue">Class NodeData&lt;TYPE&gt; provides an implementation for data defined at nodes on AMR patches. It is derived from the <a class="el" href="classSAMRAI_1_1hier_1_1PatchData.html">hier::PatchData</a> interface common to all <a class="el" href="namespaceSAMRAI.html">SAMRAI</a> patch data types. Given a CELL-centered AMR index space box, a node data object represents data of some template TYPE and depth at the nodes of the cells in the box. Here, depth indicates the number of data values at each node index location. The <a class="el" href="classSAMRAI_1_1pdat_1_1NodeGeometry.html">NodeGeometry</a> class provides the translation between the standard <a class="el" href="namespaceSAMRAI.html">SAMRAI</a> cell-centered AMR index space and node-centered data </td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1pdat_1_1NodeDataFactory.html">SAMRAI::pdat::NodeDataFactory&lt; TYPE &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1pdat_1_1NodeDoubleInjection.html">SAMRAI::pdat::NodeDoubleInjection</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1pdat_1_1NodeDoubleLinearTimeInterpolateOp.html">SAMRAI::pdat::NodeDoubleLinearTimeInterpolateOp</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1pdat_1_1NodeFloatInjection.html">SAMRAI::pdat::NodeFloatInjection</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1pdat_1_1NodeFloatLinearTimeInterpolateOp.html">SAMRAI::pdat::NodeFloatLinearTimeInterpolateOp</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1pdat_1_1NodeGeometry.html">SAMRAI::pdat::NodeGeometry</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1pdat_1_1NodeIndex.html">SAMRAI::pdat::NodeIndex</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1pdat_1_1NodeIntegerInjection.html">SAMRAI::pdat::NodeIntegerInjection</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1pdat_1_1NodeIterator.html">SAMRAI::pdat::NodeIterator</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1pdat_1_1NodeOverlap.html">SAMRAI::pdat::NodeOverlap</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1pdat_1_1NodeVariable.html">SAMRAI::pdat::NodeVariable&lt; TYPE &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1pdat_1_1OuteredgeData.html">SAMRAI::pdat::OuteredgeData&lt; TYPE &gt;</a></td><td class="indexvalue">Class OuteredgeData&lt;TYPE&gt; provides an implementation for data defined at cell edges on the boundaries of AMR patches. It is derived from the <a class="el" href="classSAMRAI_1_1hier_1_1PatchData.html">hier::PatchData</a> interface common to all <a class="el" href="namespaceSAMRAI.html">SAMRAI</a> patch data types. Given a CELL-centered AMR index space box, an outeredge data object represents data of some template TYPE and depth on the cell edges on the boundary of the box. Here, depth indicates the number of data values at each edge index location. The OuteredgedgeGeometry class provides the translation between the standard <a class="el" href="namespaceSAMRAI.html">SAMRAI</a> cell-centered AMR index space and outeredge-centered data </td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1pdat_1_1OuteredgeDataFactory.html">SAMRAI::pdat::OuteredgeDataFactory&lt; TYPE &gt;</a></td><td class="indexvalue">Class OuteredgeDataFactory&lt;TYPE&gt; is a factory class used to allocate new instances of OuteredgeData&lt;TYPE&gt; objects. It is a subclass of the patch data factory class and outeredge data is a subclass of patch data. Both the factory and data classes are templated on the type of the contained object (e.g., double or int) </td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1pdat_1_1OuteredgeGeometry.html">SAMRAI::pdat::OuteredgeGeometry</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1pdat_1_1OuteredgeVariable.html">SAMRAI::pdat::OuteredgeVariable&lt; TYPE &gt;</a></td><td class="indexvalue">Class OuteredgeVariable&lt;TYPE&gt; is a templated variable class used to define edge-centered data quantities only on patch boundaries. It is a subclass of <a class="el" href="classSAMRAI_1_1hier_1_1Variable.html">hier::Variable</a> and is templated on the type of the underlying data (e.g., double, int, bool, etc.) </td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1pdat_1_1OuterfaceComplexConstantRefine.html">SAMRAI::pdat::OuterfaceComplexConstantRefine</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1pdat_1_1OuterfaceComplexLinearTimeInterpolateOp.html">SAMRAI::pdat::OuterfaceComplexLinearTimeInterpolateOp</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1pdat_1_1OuterfaceData.html">SAMRAI::pdat::OuterfaceData&lt; TYPE &gt;</a></td><td class="indexvalue">Class OuterfaceData&lt;TYPE&gt; provides an implementation for data defined at cell faces on the boundaries of AMR patches. It is derived from the <a class="el" href="classSAMRAI_1_1hier_1_1PatchData.html">hier::PatchData</a> interface common to all <a class="el" href="namespaceSAMRAI.html">SAMRAI</a> patch data types. Given a CELL-centered AMR index space box, an outerface data object represents data of some template TYPE and depth on the cell faces on the boundary of the box. Here, depth indicates the number of data values at each face index location. The OuteredgfaceGeometry class provides the translation between the standard <a class="el" href="namespaceSAMRAI.html">SAMRAI</a> cell-centered AMR index space and outerface-centered data </td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1pdat_1_1OuterfaceDataFactory.html">SAMRAI::pdat::OuterfaceDataFactory&lt; TYPE &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1pdat_1_1OuterfaceDoubleConstantRefine.html">SAMRAI::pdat::OuterfaceDoubleConstantRefine</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1pdat_1_1OuterfaceDoubleLinearTimeInterpolateOp.html">SAMRAI::pdat::OuterfaceDoubleLinearTimeInterpolateOp</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1pdat_1_1OuterfaceFloatConstantRefine.html">SAMRAI::pdat::OuterfaceFloatConstantRefine</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1pdat_1_1OuterfaceFloatLinearTimeInterpolateOp.html">SAMRAI::pdat::OuterfaceFloatLinearTimeInterpolateOp</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1pdat_1_1OuterfaceGeometry.html">SAMRAI::pdat::OuterfaceGeometry</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1pdat_1_1OuterfaceIntegerConstantRefine.html">SAMRAI::pdat::OuterfaceIntegerConstantRefine</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1pdat_1_1OuterfaceVariable.html">SAMRAI::pdat::OuterfaceVariable&lt; TYPE &gt;</a></td><td class="indexvalue">Class OuterfaceVariable&lt;TYPE&gt; is a templated variable class used to define face-centered data quantities only on patch boundaries. It is a subclass of <a class="el" href="classSAMRAI_1_1hier_1_1Variable.html">hier::Variable</a> and is templated on the type of the underlying data (e.g., double, int, bool, etc.) </td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1pdat_1_1OuternodeData.html">SAMRAI::pdat::OuternodeData&lt; TYPE &gt;</a></td><td class="indexvalue">Class OuternodeData&lt;TYPE&gt; provides an implementation for data defined at cell nodes on the boundaries of AMR patches. It is derived from the <a class="el" href="classSAMRAI_1_1hier_1_1PatchData.html">hier::PatchData</a> interface common to all <a class="el" href="namespaceSAMRAI.html">SAMRAI</a> patch data types. Given a CELL-centered AMR index space box, an outernode data object represents data of some template TYPE and depth on the cell nodes on the boundary of the box. Here, depth indicates the number of data values at each node index location. The OuternodnodeGeometry class provides the translation between the standard <a class="el" href="namespaceSAMRAI.html">SAMRAI</a> cell-centered AMR index space and outernode-centered data </td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1pdat_1_1OuternodeDataFactory.html">SAMRAI::pdat::OuternodeDataFactory&lt; TYPE &gt;</a></td><td class="indexvalue">Class <a class="el" href="classSAMRAI_1_1pdat_1_1OuternodeDataFactory.html">OuternodeDataFactory</a> is a factory class used to allocate new instances of <a class="el" href="classSAMRAI_1_1pdat_1_1OuternodeData.html">OuternodeData</a> objects. It is a subclass of the patch data factory class and outernode data is a subclass of patch data. Both the factory and data classes are templated on the type of the contained object (e.g., double or int) </td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1pdat_1_1OuternodeDoubleInjection.html">SAMRAI::pdat::OuternodeDoubleInjection</a></td><td class="indexvalue">Class <a class="el" href="classSAMRAI_1_1pdat_1_1OuternodeDoubleInjection.html">OuternodeDoubleInjection</a> implements constant averaging (i.e., injection) for outernode-centered double patch data defined over a mesh </td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1pdat_1_1OuternodeGeometry.html">SAMRAI::pdat::OuternodeGeometry</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1pdat_1_1OuternodeVariable.html">SAMRAI::pdat::OuternodeVariable&lt; TYPE &gt;</a></td><td class="indexvalue">Class OuternodeVariable&lt;TYPE&gt; is a templated variable class used to define node-centered data quantities only on patch boundaries. It is a subclass of <a class="el" href="classSAMRAI_1_1hier_1_1Variable.html">hier::Variable</a> and is templated on the type of the underlying data (e.g., double, int, bool, etc.) </td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1pdat_1_1OutersideComplexLinearTimeInterpolateOp.html">SAMRAI::pdat::OutersideComplexLinearTimeInterpolateOp</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1pdat_1_1OutersideData.html">SAMRAI::pdat::OutersideData&lt; TYPE &gt;</a></td><td class="indexvalue">Class OutersideData&lt;TYPE&gt; provides an implementation for data defined at cell sides (faces) on the boundaries of AMR patches. It is derived from the <a class="el" href="classSAMRAI_1_1hier_1_1PatchData.html">hier::PatchData</a> interface common to all <a class="el" href="namespaceSAMRAI.html">SAMRAI</a> patch data types. Given a CELL-centered AMR index space box, an outerside data object represents data of some template TYPE and depth on the cell sides (faces) on the boundary of the box. Here, depth indicates the number of data values at each face index location. The OuteredgsideGeometry class provides the translation between the standard <a class="el" href="namespaceSAMRAI.html">SAMRAI</a> cell-centered AMR index space and outerside-centered data </td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1pdat_1_1OutersideDataFactory.html">SAMRAI::pdat::OutersideDataFactory&lt; TYPE &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1pdat_1_1OutersideDoubleLinearTimeInterpolateOp.html">SAMRAI::pdat::OutersideDoubleLinearTimeInterpolateOp</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1pdat_1_1OutersideFloatLinearTimeInterpolateOp.html">SAMRAI::pdat::OutersideFloatLinearTimeInterpolateOp</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1pdat_1_1OutersideGeometry.html">SAMRAI::pdat::OutersideGeometry</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1pdat_1_1OutersideVariable.html">SAMRAI::pdat::OutersideVariable&lt; TYPE &gt;</a></td><td class="indexvalue">Class OutersideVariable&lt;TYPE&gt; is a templated variable class used to define side-centered data quantities only on patch boundaries. It is a subclass of <a class="el" href="classSAMRAI_1_1hier_1_1Variable.html">hier::Variable</a> and is templated on the type of the underlying data (e.g., double, int, bool, etc.) </td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1pdat_1_1SecondLayerNodeNoCornersVariableFillPattern.html">SAMRAI::pdat::SecondLayerNodeNoCornersVariableFillPattern</a></td><td class="indexvalue">Class <a class="el" href="classSAMRAI_1_1pdat_1_1SecondLayerNodeNoCornersVariableFillPattern.html">SecondLayerNodeNoCornersVariableFillPattern</a> is a concrete implementation of the abstract base class VariableFillPattern </td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1pdat_1_1SecondLayerNodeVariableFillPattern.html">SAMRAI::pdat::SecondLayerNodeVariableFillPattern</a></td><td class="indexvalue">Class <a class="el" href="classSAMRAI_1_1pdat_1_1SecondLayerNodeVariableFillPattern.html">SecondLayerNodeVariableFillPattern</a> is a concrete implementation of the abstract base class VariableFillPattern </td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1pdat_1_1SideComplexConstantRefine.html">SAMRAI::pdat::SideComplexConstantRefine</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1pdat_1_1SideComplexLinearTimeInterpolateOp.html">SAMRAI::pdat::SideComplexLinearTimeInterpolateOp</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1pdat_1_1SideData.html">SAMRAI::pdat::SideData&lt; TYPE &gt;</a></td><td class="indexvalue">Class SideData&lt;TYPE&gt; provides an implementation for data defined at cell sides (faces) on AMR patches. It is derived from the <a class="el" href="classSAMRAI_1_1hier_1_1PatchData.html">hier::PatchData</a> interface common to all <a class="el" href="namespaceSAMRAI.html">SAMRAI</a> patch data types. Given a CELL-centered AMR index space box, a side data object represents data of some template TYPE and depth on the sides (faces) of the cells in the box. Here, depth indicates the number of data values at each side index location. The <a class="el" href="classSAMRAI_1_1pdat_1_1SideGeometry.html">SideGeometry</a> class provides the translation between the standard <a class="el" href="namespaceSAMRAI.html">SAMRAI</a> cell-centered AMR index space and side-centered data </td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1pdat_1_1SideDataFactory.html">SAMRAI::pdat::SideDataFactory&lt; TYPE &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1pdat_1_1SideDoubleConstantRefine.html">SAMRAI::pdat::SideDoubleConstantRefine</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1pdat_1_1SideDoubleLinearTimeInterpolateOp.html">SAMRAI::pdat::SideDoubleLinearTimeInterpolateOp</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1pdat_1_1SideFloatConstantRefine.html">SAMRAI::pdat::SideFloatConstantRefine</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1pdat_1_1SideFloatLinearTimeInterpolateOp.html">SAMRAI::pdat::SideFloatLinearTimeInterpolateOp</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1pdat_1_1SideGeometry.html">SAMRAI::pdat::SideGeometry</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1pdat_1_1SideIndex.html">SAMRAI::pdat::SideIndex</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1pdat_1_1SideIntegerConstantRefine.html">SAMRAI::pdat::SideIntegerConstantRefine</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1pdat_1_1SideIterator.html">SAMRAI::pdat::SideIterator</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1pdat_1_1SideOverlap.html">SAMRAI::pdat::SideOverlap</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1pdat_1_1SideVariable.html">SAMRAI::pdat::SideVariable&lt; TYPE &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1pdat_1_1SumOperation.html">SAMRAI::pdat::SumOperation&lt; TYPE &gt;</a></td><td class="indexvalue">Class SumOperation&lt;TYPE&gt; encapsulates a summation operation into an object </td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1solv_1_1CartesianRobinBcHelper.html">SAMRAI::solv::CartesianRobinBcHelper</a></td><td class="indexvalue">Helper utility for setting Robin boundary conditions </td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonFACOps.html">SAMRAI::solv::CellPoissonFACOps</a></td><td class="indexvalue">FAC operator class to solve Poisson's equation on a SAMR grid, using cell-centered, second-order finite-volume method, with Robin boundary conditions </td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonFACSolver.html">SAMRAI::solv::CellPoissonFACSolver</a></td><td class="indexvalue">Class for solving scalar Poisson's equation on SAMR grid, wrapping up lower-level components (FAC cycling, Poisson equation operations and boundary conditions) in a single high-level interface </td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonHypreSolver.html">SAMRAI::solv::CellPoissonHypreSolver</a></td><td class="indexvalue">Use the HYPRE preconditioner library to solve (the cell-centered) Poisson's equation on a single level in a hierarchy </td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1solv_1_1CVODEAbstractFunctions.html">SAMRAI::solv::CVODEAbstractFunctions</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1solv_1_1CVODESolver.html">SAMRAI::solv::CVODESolver</a></td><td class="indexvalue">Class <a class="el" href="classSAMRAI_1_1solv_1_1CVODESolver.html">CVODESolver</a> serves as a C++ wrapper for the CVODE ordinary differential equation solver package </td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1solv_1_1FACOperatorStrategy.html">SAMRAI::solv::FACOperatorStrategy</a></td><td class="indexvalue">Defines a Strategy pattern interface to problem-specific operations needed to implement the FAC preconditioner algorithm </td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1solv_1_1FACPreconditioner.html">SAMRAI::solv::FACPreconditioner</a></td><td class="indexvalue">Implements the FAC iterative solution procedure for a linear system of equations, Au=f, defined on some subset of levels in an AMR patch hierarchy </td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1solv_1_1GhostCellRobinBcCoefs.html">SAMRAI::solv::GhostCellRobinBcCoefs</a></td><td class="indexvalue">A prefabricated Robin boundary condition coefficients for the case where cell-centered data is fixed at the first ghost-cell centers </td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1solv_1_1KINSOL__SAMRAIContext.html">SAMRAI::solv::KINSOL_SAMRAIContext</a></td><td class="indexvalue">Wraps the <a class="el" href="classSAMRAI_1_1solv_1_1KINSOLSolver.html">KINSOLSolver</a> C++ wrapper class so that KINSOL may be used in applications that require a nonlinear solver </td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1solv_1_1KINSOLAbstractFunctions.html">SAMRAI::solv::KINSOLAbstractFunctions</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1solv_1_1KINSOLSolver.html">SAMRAI::solv::KINSOLSolver</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1solv_1_1LocationIndexRobinBcCoefs.html">SAMRAI::solv::LocationIndexRobinBcCoefs</a></td><td class="indexvalue">A prefabricated Robin boundary condition coefficients for coefficients that are entirely specified by the boundary box location index </td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1solv_1_1NonlinearSolverStrategy.html">SAMRAI::solv::NonlinearSolverStrategy</a></td><td class="indexvalue">Abstract base class defining interface between an <a class="el" href="classSAMRAI_1_1algs_1_1ImplicitIntegrator.html">algs::ImplicitIntegrator</a> object and a nonlinear solver used to advance the solution in time </td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1solv_1_1PETSc__SAMRAIVectorReal.html">SAMRAI::solv::PETSc_SAMRAIVectorReal&lt; TYPE &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1solv_1_1PETScAbstractVectorReal.html">SAMRAI::solv::PETScAbstractVectorReal&lt; TYPE &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1solv_1_1PoissonSpecifications.html">SAMRAI::solv::PoissonSpecifications</a></td><td class="indexvalue">Light class holding specifications for cell-centered implementation of the scalar Poisson equation </td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1solv_1_1RobinBcCoefStrategy.html">SAMRAI::solv::RobinBcCoefStrategy</a></td><td class="indexvalue">Interface for specifying Robin boundary conditions </td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1solv_1_1SAMRAIVectorReal.html">SAMRAI::solv::SAMRAIVectorReal&lt; TYPE &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1solv_1_1SimpleCellRobinBcCoefs.html">SAMRAI::solv::SimpleCellRobinBcCoefs</a></td><td class="indexvalue">A prefabricated Robin boundary condition coefficients with an interface like the old Poisson solvers </td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1solv_1_1SNES__SAMRAIContext.html">SAMRAI::solv::SNES_SAMRAIContext</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1solv_1_1SNESAbstractFunctions.html">SAMRAI::solv::SNESAbstractFunctions</a></td><td class="indexvalue">Abstract base class that declares the functions to be used with the PETSc SNES nonlinear solver package </td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1solv_1_1Sundials__SAMRAIVector.html">SAMRAI::solv::Sundials_SAMRAIVector</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1solv_1_1SundialsAbstractVector.html">SAMRAI::solv::SundialsAbstractVector</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1tbox_1_1AbortAppender.html">SAMRAI::tbox::AbortAppender</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1tbox_1_1Array.html">SAMRAI::tbox::Array&lt; TYPE &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1tbox_1_1Array_1_1DoNotInitialize.html">SAMRAI::tbox::Array&lt; TYPE &gt;::DoNotInitialize</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1tbox_1_1AsyncCommGroup.html">SAMRAI::tbox::AsyncCommGroup</a></td><td class="indexvalue">Supports all-to-one and one-to-all asynchronous communication operations within a given group of processes by sending messages along the branches of a conceptual tree </td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1tbox_1_1AsyncCommPeer.html">SAMRAI::tbox::AsyncCommPeer&lt; TYPE &gt;</a></td><td class="indexvalue">Supports point-to-point asynchronous communication operations that can overlap other communcations using a <a class="el" href="classSAMRAI_1_1tbox_1_1AsyncCommStage.html">AsyncCommStage</a> </td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1tbox_1_1AsyncCommStage.html">SAMRAI::tbox::AsyncCommStage</a></td><td class="indexvalue">Stage multiple non-blocking MPI communications so that codes waiting for them to complete can advance as their respective MPI requests are completed </td></tr>
  <tr><td class="indexkey"><a class="el" href="structSAMRAI_1_1tbox_1_1AsyncCommStage_1_1Handler.html">SAMRAI::tbox::AsyncCommStage::Handler</a></td><td class="indexvalue">Optional object that can be attached to each <a class="el" href="structSAMRAI_1_1tbox_1_1AsyncCommStage_1_1Member.html">Member</a>, for use in determining what to do after the <a class="el" href="structSAMRAI_1_1tbox_1_1AsyncCommStage_1_1Member.html">Member</a> completes its communication </td></tr>
  <tr><td class="indexkey"><a class="el" href="structSAMRAI_1_1tbox_1_1AsyncCommStage_1_1Member.html">SAMRAI::tbox::AsyncCommStage::Member</a></td><td class="indexvalue">Something on a stage, using MPI requests and statuses provided by the stage </td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1tbox_1_1BalancedDepthFirstTree.html">SAMRAI::tbox::BalancedDepthFirstTree</a></td><td class="indexvalue">Implementation of <a class="el" href="classSAMRAI_1_1tbox_1_1RankTreeStrategy.html">RankTreeStrategy</a> aranging ranks in a balanced, depth-first tree </td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1tbox_1_1BreadthFirstRankTree.html">SAMRAI::tbox::BreadthFirstRankTree</a></td><td class="indexvalue">Implementation of <a class="el" href="classSAMRAI_1_1tbox_1_1RankTreeStrategy.html">RankTreeStrategy</a> aranging ranks in a breadth-first tree </td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1tbox_1_1CenteredRankTree.html">SAMRAI::tbox::CenteredRankTree</a></td><td class="indexvalue">Implementation of <a class="el" href="classSAMRAI_1_1tbox_1_1RankTreeStrategy.html">RankTreeStrategy</a> aranging ranks with the root at the center of its descendent ranks </td></tr>
  <tr><td class="indexkey"><a class="el" href="structSAMRAI_1_1tbox_1_1Clock.html">SAMRAI::tbox::Clock</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1tbox_1_1CommGraphWriter.html">SAMRAI::tbox::CommGraphWriter</a></td><td class="indexvalue">Collects data on distributed communication graphs and writes out for analysis </td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1tbox_1_1Database.html">SAMRAI::tbox::Database</a></td><td class="indexvalue">Class <a class="el" href="classSAMRAI_1_1tbox_1_1Database.html">Database</a> is an abstract base class for the input, restart, and visualization databases </td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1tbox_1_1DatabaseBox.html">SAMRAI::tbox::DatabaseBox</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structSAMRAI_1_1tbox_1_1DatabaseBox__POD.html">SAMRAI::tbox::DatabaseBox_POD</a></td><td class="indexvalue">POD data for class <a class="el" href="classSAMRAI_1_1tbox_1_1DatabaseBox.html">DatabaseBox</a> </td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1tbox_1_1DatabaseFactory.html">SAMRAI::tbox::DatabaseFactory</a></td><td class="indexvalue">Abstract base class factory used to build <a class="el" href="classSAMRAI_1_1tbox_1_1Database.html">Database</a> objects </td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1tbox_1_1DebugAppender.html">SAMRAI::tbox::DebugAppender</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1tbox_1_1Dimension.html">SAMRAI::tbox::Dimension</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1tbox_1_1HDFDatabase.html">SAMRAI::tbox::HDFDatabase</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1tbox_1_1HDFDatabaseFactory.html">SAMRAI::tbox::HDFDatabaseFactory</a></td><td class="indexvalue"><a class="el" href="classSAMRAI_1_1tbox_1_1HDFDatabase.html">HDFDatabase</a> factory </td></tr>
  <tr><td class="indexkey"><a class="el" href="structSAMRAI_1_1tbox_1_1IEEE.html">SAMRAI::tbox::IEEE</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1tbox_1_1InputManager.html">SAMRAI::tbox::InputManager</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1tbox_1_1Logger.html">SAMRAI::tbox::Logger</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1tbox_1_1Logger_1_1Appender.html">SAMRAI::tbox::Logger::Appender</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1tbox_1_1MathUtilities.html">SAMRAI::tbox::MathUtilities&lt; TYPE &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1tbox_1_1MemoryDatabase.html">SAMRAI::tbox::MemoryDatabase</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1tbox_1_1MemoryDatabaseFactory.html">SAMRAI::tbox::MemoryDatabaseFactory</a></td><td class="indexvalue"><a class="el" href="classSAMRAI_1_1tbox_1_1MemoryDatabase.html">MemoryDatabase</a> factory </td></tr>
  <tr><td class="indexkey"><a class="el" href="structSAMRAI_1_1tbox_1_1MemoryUtilities.html">SAMRAI::tbox::MemoryUtilities</a></td><td class="indexvalue">Class <a class="el" href="structSAMRAI_1_1tbox_1_1MemoryUtilities.html">MemoryUtilities</a> provides utility methods for memory usage and misc memory utilities </td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1tbox_1_1MessageStream.html">SAMRAI::tbox::MessageStream</a></td><td class="indexvalue">Class to provide buffers for communication of data </td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1tbox_1_1NullDatabase.html">SAMRAI::tbox::NullDatabase</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1tbox_1_1ParallelBuffer.html">SAMRAI::tbox::ParallelBuffer</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1tbox_1_1Parser.html">SAMRAI::tbox::Parser</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structSAMRAI_1_1tbox_1_1PIO.html">SAMRAI::tbox::PIO</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1tbox_1_1RankGroup.html">SAMRAI::tbox::RankGroup</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1tbox_1_1RankTreeStrategy.html">SAMRAI::tbox::RankTreeStrategy</a></td><td class="indexvalue">Strategy pattern for getting information on MPI ranks aranged on a user-defined tree </td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1tbox_1_1ReferenceCounter.html">SAMRAI::tbox::ReferenceCounter</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1tbox_1_1RestartManager.html">SAMRAI::tbox::RestartManager</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1tbox_1_1SAMRAI__MPI.html">SAMRAI::tbox::SAMRAI_MPI</a></td><td class="indexvalue">Provides C++ wrapper around MPI routines </td></tr>
  <tr><td class="indexkey"><a class="el" href="structSAMRAI_1_1tbox_1_1SAMRAI__MPI_1_1Status.html">SAMRAI::tbox::SAMRAI_MPI::Status</a></td><td class="indexvalue">Dummy definition of <a class="el" href="structSAMRAI_1_1tbox_1_1SAMRAI__MPI_1_1Status.html">Status</a> to match the MPI standard </td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1tbox_1_1SAMRAIManager.html">SAMRAI::tbox::SAMRAIManager</a></td><td class="indexvalue">Utility for managing startup and shutdown of <a class="el" href="namespaceSAMRAI.html">SAMRAI</a> objects and for managing the maximum number of patch data components allowed </td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1tbox_1_1Schedule.html">SAMRAI::tbox::Schedule</a></td><td class="indexvalue">Class <a class="el" href="classSAMRAI_1_1tbox_1_1Schedule.html">Schedule</a> is used to construct and execute a set of data communication transactions. Each transaction represents some data dependency and exchange between two processors, or locally involving a single processor </td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1tbox_1_1Serializable.html">SAMRAI::tbox::Serializable</a></td><td class="indexvalue">Class <a class="el" href="classSAMRAI_1_1tbox_1_1Serializable.html">Serializable</a> is an abstract base class to provide database serialization for objects </td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1tbox_1_1SiloDatabase.html">SAMRAI::tbox::SiloDatabase</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1tbox_1_1SiloDatabaseFactory.html">SAMRAI::tbox::SiloDatabaseFactory</a></td><td class="indexvalue"><a class="el" href="classSAMRAI_1_1tbox_1_1SiloDatabase.html">SiloDatabase</a> factory </td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1tbox_1_1StartupShutdownManager.html">SAMRAI::tbox::StartupShutdownManager</a></td><td class="indexvalue">Class <a class="el" href="classSAMRAI_1_1tbox_1_1StartupShutdownManager.html">StartupShutdownManager</a> is a utility for managing callbacks invoked at program and problem startup and completion </td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1tbox_1_1StartupShutdownManager_1_1AbstractHandler.html">SAMRAI::tbox::StartupShutdownManager::AbstractHandler</a></td><td class="indexvalue">Abstract base class for handler interface </td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1tbox_1_1StartupShutdownManager_1_1Handler.html">SAMRAI::tbox::StartupShutdownManager::Handler</a></td><td class="indexvalue">Standard implementation of a Startup/Shutdown handler </td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1tbox_1_1Statistic.html">SAMRAI::tbox::Statistic</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structSAMRAI_1_1tbox_1_1Statistic_1_1PatchStat.html">SAMRAI::tbox::Statistic::PatchStat</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structSAMRAI_1_1tbox_1_1Statistic_1_1PatchStatRecord.html">SAMRAI::tbox::Statistic::PatchStatRecord</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structSAMRAI_1_1tbox_1_1Statistic_1_1ProcStat.html">SAMRAI::tbox::Statistic::ProcStat</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1tbox_1_1Statistician.html">SAMRAI::tbox::Statistician</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1tbox_1_1StatisticRestartDatabase.html">SAMRAI::tbox::StatisticRestartDatabase</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1tbox_1_1StatTransaction.html">SAMRAI::tbox::StatTransaction</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1tbox_1_1Timer.html">SAMRAI::tbox::Timer</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1tbox_1_1TimerManager.html">SAMRAI::tbox::TimerManager</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1tbox_1_1Tracer.html">SAMRAI::tbox::Tracer</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1tbox_1_1Transaction.html">SAMRAI::tbox::Transaction</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structSAMRAI_1_1tbox_1_1Utilities.html">SAMRAI::tbox::Utilities</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1tbox_1_1WarningAppender.html">SAMRAI::tbox::WarningAppender</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1xfer_1_1BoxGeometryVariableFillPattern.html">SAMRAI::xfer::BoxGeometryVariableFillPattern</a></td><td class="indexvalue">Class <a class="el" href="classSAMRAI_1_1xfer_1_1BoxGeometryVariableFillPattern.html">BoxGeometryVariableFillPattern</a> is a default implementation of the abstract base class <a class="el" href="classSAMRAI_1_1xfer_1_1VariableFillPattern.html">VariableFillPattern</a> </td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1xfer_1_1CoarsenAlgorithm.html">SAMRAI::xfer::CoarsenAlgorithm</a></td><td class="indexvalue">Class <a class="el" href="classSAMRAI_1_1xfer_1_1CoarsenAlgorithm.html">CoarsenAlgorithm</a> encapsulates the AMR communication pattern to coarsen data from a finer level to any coarser level </td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1xfer_1_1CoarsenClasses.html">SAMRAI::xfer::CoarsenClasses</a></td><td class="indexvalue">Maintain a collection of coarsen items and organize them into equivalence classes </td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1xfer_1_1CoarsenClasses_1_1Data.html">SAMRAI::xfer::CoarsenClasses::Data</a></td><td class="indexvalue">Nested class used to describe a coarsening operation between patch data components on an AMR hierarchy </td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1xfer_1_1CoarsenCopyTransaction.html">SAMRAI::xfer::CoarsenCopyTransaction</a></td><td class="indexvalue">Class <a class="el" href="classSAMRAI_1_1xfer_1_1CoarsenCopyTransaction.html">CoarsenCopyTransaction</a> represents a single copy communication transaction between two processors or a local data copy for coaren schedules. Note that to there is an implicit hand-shaking between objects of this class and the <a class="el" href="classSAMRAI_1_1xfer_1_1CoarsenSchedule.html">CoarsenSchedule</a> object that constructs them. Following the coarsen schedule implementation, the source patch data index for a copy transaction always refers to the source data, and the destination patch data index for a copy transaction is always the destination data, all as defined in the <a class="el" href="classSAMRAI_1_1xfer_1_1CoarsenClasses.html">CoarsenClasses</a> class </td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1xfer_1_1CoarsenPatchStrategy.html">SAMRAI::xfer::CoarsenPatchStrategy</a></td><td class="indexvalue">Abstract base class for user-defined patch data coarsening operations </td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1xfer_1_1CoarsenSchedule.html">SAMRAI::xfer::CoarsenSchedule</a></td><td class="indexvalue">Class <a class="el" href="classSAMRAI_1_1xfer_1_1CoarsenSchedule.html">CoarsenSchedule</a> performs the communication operations to coarsen data from a finer level to a coarser level </td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1xfer_1_1CoarsenTransactionFactory.html">SAMRAI::xfer::CoarsenTransactionFactory</a></td><td class="indexvalue">Abstract base class defining the interface for all concrete transaction factory objects that generate data transaction objects used with a <a class="el" href="classSAMRAI_1_1xfer_1_1CoarsenSchedule.html">CoarsenSchedule</a> object. A concrete subclass will allocate new transaction objects. This class is an example of the ``Abstract Factory'' method described in the Design Patterns book by Gamma, et al </td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1xfer_1_1PatchInteriorVariableFillPattern.html">SAMRAI::xfer::PatchInteriorVariableFillPattern</a></td><td class="indexvalue">Class <a class="el" href="classSAMRAI_1_1xfer_1_1PatchInteriorVariableFillPattern.html">PatchInteriorVariableFillPattern</a> is an implementation of the abstract base class <a class="el" href="classSAMRAI_1_1xfer_1_1VariableFillPattern.html">VariableFillPattern</a> </td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1xfer_1_1PatchLevelBorderAndInteriorFillPattern.html">SAMRAI::xfer::PatchLevelBorderAndInteriorFillPattern</a></td><td class="indexvalue"><a class="el" href="classSAMRAI_1_1xfer_1_1PatchLevelFillPattern.html">PatchLevelFillPattern</a> implementation for filling at PatchLevel boundaries and interiors </td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1xfer_1_1PatchLevelBorderFillPattern.html">SAMRAI::xfer::PatchLevelBorderFillPattern</a></td><td class="indexvalue"><a class="el" href="classSAMRAI_1_1xfer_1_1PatchLevelFillPattern.html">PatchLevelFillPattern</a> implementation for filling at PatchLevel boundaries </td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1xfer_1_1PatchLevelEnhancedFillPattern.html">SAMRAI::xfer::PatchLevelEnhancedFillPattern</a></td><td class="indexvalue">Class <a class="el" href="classSAMRAI_1_1xfer_1_1PatchLevelEnhancedFillPattern.html">PatchLevelEnhancedFillPattern</a> is an implementation of the abstract base class <a class="el" href="classSAMRAI_1_1xfer_1_1PatchLevelFillPattern.html">PatchLevelFillPattern</a> </td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1xfer_1_1PatchLevelFillPattern.html">SAMRAI::xfer::PatchLevelFillPattern</a></td><td class="indexvalue">Abstract base class for defining regions to fill on a PatchLevel </td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1xfer_1_1PatchLevelFullFillPattern.html">SAMRAI::xfer::PatchLevelFullFillPattern</a></td><td class="indexvalue"><a class="el" href="classSAMRAI_1_1xfer_1_1PatchLevelFullFillPattern.html">PatchLevelFullFillPattern</a> is a <a class="el" href="classSAMRAI_1_1xfer_1_1PatchLevelFillPattern.html">PatchLevelFillPattern</a> that fills the entire region the destination level, both interior and ghost </td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1xfer_1_1PatchLevelInteriorFillPattern.html">SAMRAI::xfer::PatchLevelInteriorFillPattern</a></td><td class="indexvalue"><a class="el" href="classSAMRAI_1_1xfer_1_1PatchLevelFillPattern.html">PatchLevelFillPattern</a> implementation for patch interior filling </td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1xfer_1_1RefineAlgorithm.html">SAMRAI::xfer::RefineAlgorithm</a></td><td class="indexvalue">Class <a class="el" href="classSAMRAI_1_1xfer_1_1RefineAlgorithm.html">RefineAlgorithm</a> encapsulates the AMR communication pattern to refine data to, copy data to, or fill physical boundary data on any destination patch level </td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1xfer_1_1RefineClasses.html">SAMRAI::xfer::RefineClasses</a></td><td class="indexvalue">Maintain a collection of refine items and organize them into equivalence classes </td></tr>
  <tr><td class="indexkey"><a class="el" href="structSAMRAI_1_1xfer_1_1RefineClasses_1_1Data.html">SAMRAI::xfer::RefineClasses::Data</a></td><td class="indexvalue"><a class="el" href="structSAMRAI_1_1xfer_1_1RefineClasses_1_1Data.html">Data</a> structure used to describe a refinement operation between patch data components on an AMR hierarchy </td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1xfer_1_1RefineCopyTransaction.html">SAMRAI::xfer::RefineCopyTransaction</a></td><td class="indexvalue">Class <a class="el" href="classSAMRAI_1_1xfer_1_1RefineCopyTransaction.html">RefineCopyTransaction</a> represents a single copy communication transaction between two processors or a local data copy for refine schedules. Note that to there is an implicit hand-shaking between objects of this class and the <a class="el" href="classSAMRAI_1_1xfer_1_1RefineSchedule.html">RefineSchedule</a> object that constructs them. Following the refine schedule implementation, the source patch data index for a copy transaction always refers to the source data and the destination patch data index for a copy transaction is always the scratch data, all as defined in the <a class="el" href="classSAMRAI_1_1xfer_1_1RefineClasses.html">RefineClasses</a> class </td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1xfer_1_1RefinePatchStrategy.html">SAMRAI::xfer::RefinePatchStrategy</a></td><td class="indexvalue">Abstract base class for user-defined patch data refining operations and physical boundary filling operations </td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1xfer_1_1RefineSchedule.html">SAMRAI::xfer::RefineSchedule</a></td><td class="indexvalue">Class <a class="el" href="classSAMRAI_1_1xfer_1_1RefineSchedule.html">RefineSchedule</a> performs the communication operations that refine data to, copy data to, or fill physical boundary data on a destination patch level </td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1xfer_1_1RefineScheduleConnectorWidthRequestor.html">SAMRAI::xfer::RefineScheduleConnectorWidthRequestor</a></td><td class="indexvalue">Implementation of the strategy class <a class="el" href="classSAMRAI_1_1hier_1_1PatchHierarchy_1_1ConnectorWidthRequestorStrategy.html">hier::PatchHierarchy::ConnectorWidthRequestorStrategy</a> to tell the <a class="el" href="classSAMRAI_1_1hier_1_1PatchHierarchy.html">hier::PatchHierarchy</a> how wide <a class="el" href="classSAMRAI_1_1xfer_1_1RefineSchedule.html">RefineSchedule</a> needs Connectors between hierarchy levels to be </td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1xfer_1_1RefineTimeTransaction.html">SAMRAI::xfer::RefineTimeTransaction</a></td><td class="indexvalue">Class <a class="el" href="classSAMRAI_1_1xfer_1_1RefineTimeTransaction.html">RefineTimeTransaction</a> represents a single time interpolation communication transaction between two processors or a local data copy or refine schedules. Note that to there is an implicit hand-shaking between objects of this class and the <a class="el" href="classSAMRAI_1_1xfer_1_1RefineSchedule.html">RefineSchedule</a> object that constructs them. Following the refine schedule implementation, the source patch data indices for a time transaction are always refer to the old and new source data and the destination patch data index for a time transaction is always the scratch data, all as defined in the <a class="el" href="classSAMRAI_1_1xfer_1_1RefineClasses.html">RefineClasses</a> class. This transaction is used by the refine schedule </td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1xfer_1_1RefineTransactionFactory.html">SAMRAI::xfer::RefineTransactionFactory</a></td><td class="indexvalue">Abstract base class defining the interface for all concrete transaction factory objects that generate data transaction objects used with a <a class="el" href="classSAMRAI_1_1xfer_1_1RefineSchedule.html">RefineSchedule</a> object. A concrete subclass will allocate new transaction objects. This class is an example of the ``Abstract Factory'' method described in the Design Patterns book by Gamma, et al </td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1xfer_1_1SingularityPatchStrategy.html">SAMRAI::xfer::SingularityPatchStrategy</a></td><td class="indexvalue">Abstract base class for setting ghost data when refining at a multiblock singularity </td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1xfer_1_1StandardCoarsenTransactionFactory.html">SAMRAI::xfer::StandardCoarsenTransactionFactory</a></td><td class="indexvalue">Concrete subclass of <a class="el" href="classSAMRAI_1_1xfer_1_1CoarsenTransactionFactory.html">CoarsenTransactionFactory</a> base class that allocates <a class="el" href="classSAMRAI_1_1xfer_1_1CoarsenCopyTransaction.html">CoarsenCopyTransaction</a> objects for a <a class="el" href="classSAMRAI_1_1xfer_1_1CoarsenSchedule.html">CoarsenSchedule</a> object </td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1xfer_1_1StandardRefineTransactionFactory.html">SAMRAI::xfer::StandardRefineTransactionFactory</a></td><td class="indexvalue">Concrete subclass of <a class="el" href="classSAMRAI_1_1xfer_1_1RefineTransactionFactory.html">RefineTransactionFactory</a> base class that allocates <a class="el" href="classSAMRAI_1_1xfer_1_1RefineCopyTransaction.html">RefineCopyTransaction</a> and <a class="el" href="classSAMRAI_1_1xfer_1_1RefineTimeTransaction.html">RefineTimeTransaction</a> objects for a <a class="el" href="classSAMRAI_1_1xfer_1_1RefineSchedule.html">RefineSchedule</a> object </td></tr>
  <tr><td class="indexkey"><a class="el" href="classSAMRAI_1_1xfer_1_1VariableFillPattern.html">SAMRAI::xfer::VariableFillPattern</a></td><td class="indexvalue">Class <a class="el" href="classSAMRAI_1_1xfer_1_1VariableFillPattern.html">VariableFillPattern</a> is an abstract base class that provides an interface to create objects that can calculate overlaps which correspond to a specific stencil </td></tr>
  <tr><td class="indexkey"><a class="el" href="structyy__buffer__state.html">yy_buffer_state</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="unionyyalloc.html">yyalloc</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="unionYYSTYPE.html">YYSTYPE</a></td><td class="indexvalue"></td></tr>
</table>
<hr size="1"><address style="align: right;"><small>Generated on 5 Jul 2013 for SAMRAI by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.7 </small></address>
</body>
</html>
