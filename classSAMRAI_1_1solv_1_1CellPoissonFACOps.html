<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>SAMRAI: SAMRAI::solv::CellPoissonFACOps Class Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.7 -->
<div class="tabs">
  <ul>
    <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="namespaces.html"><span>Namespaces</span></a></li>
    <li id="current"><a href="annotated.html"><span>Classes</span></a></li>
    <li><a href="files.html"><span>Files</span></a></li>
    <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
  </ul></div>
<div class="tabs">
  <ul>
    <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
    <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
    <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
  </ul></div>
<div class="nav">
<a class="el" href="namespaceSAMRAI.html">SAMRAI</a>::<a class="el" href="namespaceSAMRAI_1_1solv.html">solv</a>::<a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonFACOps.html">CellPoissonFACOps</a></div>
<h1>SAMRAI::solv::CellPoissonFACOps Class Reference</h1><!-- doxytag: class="SAMRAI::solv::CellPoissonFACOps" --><!-- doxytag: inherits="SAMRAI::solv::FACOperatorStrategy" -->FAC operator class to solve Poisson's equation on a SAMR grid, using cell-centered, second-order finite-volume method, with Robin boundary conditions.  
<a href="#_details">More...</a>
<p>
<code>#include &lt;source/SAMRAI/solv/CellPoissonFACOps.h&gt;</code>
<p>
<p>Inheritance diagram for SAMRAI::solv::CellPoissonFACOps:
<p><center><img src="classSAMRAI_1_1solv_1_1CellPoissonFACOps.png" usemap="#SAMRAI::solv::CellPoissonFACOps_map" border="0" alt=""></center>
<map name="SAMRAI::solv::CellPoissonFACOps_map">
<area href="classSAMRAI_1_1solv_1_1FACOperatorStrategy.html" alt="SAMRAI::solv::FACOperatorStrategy" shape="rect" coords="0,0,219,24">
</map>
<a href="classSAMRAI_1_1solv_1_1CellPoissonFACOps-members.html">List of all members.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonFACOps.html#ee61404d3b33868e65c4327887d74e09">CellPoissonFACOps</a> (const <a class="el" href="classSAMRAI_1_1tbox_1_1Dimension.html">tbox::Dimension</a> &amp;dim, const std::string &amp;object_name=std::string(), const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Database.html">tbox::Database</a> &gt; &amp;database=boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Database.html">tbox::Database</a> &gt;())</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Constructor.  <a href="#ee61404d3b33868e65c4327887d74e09"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonFACOps.html#f68794b2e9ca3e0eedc662beb62e7f33">~CellPoissonFACOps</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Destructor.  <a href="#f68794b2e9ca3e0eedc662beb62e7f33"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonFACOps.html#364ae41c84a837644eb57e559b0b6d36">setPoissonSpecifications</a> (const <a class="el" href="classSAMRAI_1_1solv_1_1PoissonSpecifications.html">PoissonSpecifications</a> &amp;spec)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the scalar Poisson equation specifications.  <a href="#364ae41c84a837644eb57e559b0b6d36"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonFACOps.html#fcdcb45d56d266db88ed7ccbb809f6c4">enableLogging</a> (bool enable_logging)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Enable logging.  <a href="#fcdcb45d56d266db88ed7ccbb809f6c4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonFACOps.html#4c96a2b13dc4830c3b19b69588b050bd">setPhysicalBcCoefObject</a> (const <a class="el" href="classSAMRAI_1_1solv_1_1RobinBcCoefStrategy.html">RobinBcCoefStrategy</a> *physical_bc_coef)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Provide an implementation for getting the physical bc coefficients.  <a href="#4c96a2b13dc4830c3b19b69588b050bd"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonFACOps.html#5f6fd2fc3f7e31a800cf63a5671440e1">computeVectorWeights</a> (const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchHierarchy.html">hier::PatchHierarchy</a> &gt; &amp;hierarchy, int weight_id, int coarsest_ln=-1, int finest_ln=-1) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set weight appropriate for computing vector norms.  <a href="#5f6fd2fc3f7e31a800cf63a5671440e1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonFACOps.html#4755294a0ec68fa0e90f59b2d8725e71">setPreconditioner</a> (const <a class="el" href="classSAMRAI_1_1solv_1_1FACPreconditioner.html">FACPreconditioner</a> *preconditioner)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the FAC preconditioner that will be using this object.  <a href="#4755294a0ec68fa0e90f59b2d8725e71"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonFACOps.html#8276f889b6984293e562408856b506f5">computeFluxOnPatch</a> (const <a class="el" href="classSAMRAI_1_1hier_1_1Patch.html">hier::Patch</a> &amp;patch, const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a> &amp;ratio_to_coarser_level, const <a class="el" href="classSAMRAI_1_1pdat_1_1CellData.html">pdat::CellData</a>&lt; double &gt; &amp;w_data, <a class="el" href="classSAMRAI_1_1pdat_1_1SideData.html">pdat::SideData</a>&lt; double &gt; &amp;Dgradw_data) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">function to compute flux, using general diffusion coefficient data.  <a href="#8276f889b6984293e562408856b506f5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">const std::string &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonFACOps.html#c14fd20b7566614fa56cf135b2717e60">getObjectName</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the name of this object.  <a href="#c14fd20b7566614fa56cf135b2717e60"></a><br></td></tr>
<tr><td colspan="2"><div class="groupHeader">Functions for setting solver mathematic algorithm controls</div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonFACOps.html#bddbb3e978fbd851c37daadb71384cdd">setSmoothingChoice</a> (const std::string &amp;smoothing_choice)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the choice of smoothing algorithms.  <a href="#bddbb3e978fbd851c37daadb71384cdd"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonFACOps.html#4f97bfbb403f6389ac098382477906d2">setCoarsestLevelSolverChoice</a> (const std::string &amp;choice)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set coarse level solver.  <a href="#4f97bfbb403f6389ac098382477906d2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonFACOps.html#40cfa68fce513ed79d51c580053b8f2b">setCoarsestLevelSolverTolerance</a> (double tol)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set tolerance for coarse level solve.  <a href="#40cfa68fce513ed79d51c580053b8f2b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonFACOps.html#7a66e3136abac36523184b73d3555d84">setCoarsestLevelSolverMaxIterations</a> (int max_iterations)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set max iterations for coarse level solve.  <a href="#7a66e3136abac36523184b73d3555d84"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonFACOps.html#7b853e982526a76b049654668df07cfc">setCoarseFineDiscretization</a> (const std::string &amp;coarsefine_method)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the coarse-fine boundary discretization method.  <a href="#7b853e982526a76b049654668df07cfc"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonFACOps.html#0af08cba26ce97836f2454c23ff8ebad">setProlongationMethod</a> (const std::string &amp;prolongation_method)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the name of the prolongation method.  <a href="#0af08cba26ce97836f2454c23ff8ebad"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonFACOps.html#ed16b05874c74eb7e767e4207815ccf1">setUseSMG</a> (bool use_smg)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set whether to use Hypre's PFMG algorithm instead of the SMG algorithm.  <a href="#ed16b05874c74eb7e767e4207815ccf1"></a><br></td></tr>
<tr><td colspan="2"><div class="groupHeader">Functions for setting patch data indices and coefficients</div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonFACOps.html#c2a11e9c53e6e465b64e1aa9e998dc1a">setFluxId</a> (int flux_id)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the scratch patch data index for the flux.  <a href="#c2a11e9c53e6e465b64e1aa9e998dc1a"></a><br></td></tr>
<tr><td colspan="2"><div class="groupHeader">Functions for checking validity and correctness of state.</div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonFACOps.html#071ca86f3a36ddc704305cf62e2fb18e">checkInputPatchDataIndices</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Check validity and correctness of input patch data indices.  <a href="#071ca86f3a36ddc704305cf62e2fb18e"></a><br></td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonFACOps.html#9dae37b0144393116d0bc85105a66175">restrictSolution</a> (const <a class="el" href="classSAMRAI_1_1solv_1_1SAMRAIVectorReal.html">SAMRAIVectorReal</a>&lt; double &gt; &amp;source, <a class="el" href="classSAMRAI_1_1solv_1_1SAMRAIVectorReal.html">SAMRAIVectorReal</a>&lt; double &gt; &amp;dest, int dest_ln)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Restrict the solution quantity to the specified level from the next finer level.  <a href="#9dae37b0144393116d0bc85105a66175"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonFACOps.html#65fefa03bb3b1932c3bdc4f453124629">restrictResidual</a> (const <a class="el" href="classSAMRAI_1_1solv_1_1SAMRAIVectorReal.html">SAMRAIVectorReal</a>&lt; double &gt; &amp;source, <a class="el" href="classSAMRAI_1_1solv_1_1SAMRAIVectorReal.html">SAMRAIVectorReal</a>&lt; double &gt; &amp;dest, int dest_ln)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Restrict the residual quantity to the specified level from the next finer level.  <a href="#65fefa03bb3b1932c3bdc4f453124629"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonFACOps.html#4cd51fa373fd7e2931323f3613ac42c4">prolongErrorAndCorrect</a> (const <a class="el" href="classSAMRAI_1_1solv_1_1SAMRAIVectorReal.html">SAMRAIVectorReal</a>&lt; double &gt; &amp;source, <a class="el" href="classSAMRAI_1_1solv_1_1SAMRAIVectorReal.html">SAMRAIVectorReal</a>&lt; double &gt; &amp;dest, int dest_ln)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Prolong the error quantity to the specified level from the next coarser level and apply the correction to the fine-level error.  <a href="#4cd51fa373fd7e2931323f3613ac42c4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonFACOps.html#2455fd635c8fa8cabe26f32f7a489968">smoothError</a> (<a class="el" href="classSAMRAI_1_1solv_1_1SAMRAIVectorReal.html">SAMRAIVectorReal</a>&lt; double &gt; &amp;error, const <a class="el" href="classSAMRAI_1_1solv_1_1SAMRAIVectorReal.html">SAMRAIVectorReal</a>&lt; double &gt; &amp;residual, int ln, int num_sweeps)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Perform a given number of relaxations on the error.  <a href="#2455fd635c8fa8cabe26f32f7a489968"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonFACOps.html#5fe346279ed17b0916f78d3a13e72a7c">solveCoarsestLevel</a> (<a class="el" href="classSAMRAI_1_1solv_1_1SAMRAIVectorReal.html">SAMRAIVectorReal</a>&lt; double &gt; &amp;error, const <a class="el" href="classSAMRAI_1_1solv_1_1SAMRAIVectorReal.html">SAMRAIVectorReal</a>&lt; double &gt; &amp;residual, int coarsest_ln)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Solve the residual equation Ae=r on the coarsest level in the FAC iteration.  <a href="#5fe346279ed17b0916f78d3a13e72a7c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonFACOps.html#fa8593675924f56c22f30f6ba9481b3f">computeCompositeResidualOnLevel</a> (<a class="el" href="classSAMRAI_1_1solv_1_1SAMRAIVectorReal.html">SAMRAIVectorReal</a>&lt; double &gt; &amp;residual, const <a class="el" href="classSAMRAI_1_1solv_1_1SAMRAIVectorReal.html">SAMRAIVectorReal</a>&lt; double &gt; &amp;solution, const <a class="el" href="classSAMRAI_1_1solv_1_1SAMRAIVectorReal.html">SAMRAIVectorReal</a>&lt; double &gt; &amp;rhs, int ln, bool error_equation_indicator)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute composite grid residual on a single level.  <a href="#fa8593675924f56c22f30f6ba9481b3f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonFACOps.html#600efac0d1a09650e090b3fd78fd91bb">computeResidualNorm</a> (const <a class="el" href="classSAMRAI_1_1solv_1_1SAMRAIVectorReal.html">SAMRAIVectorReal</a>&lt; double &gt; &amp;residual, int fine_ln, int coarse_ln)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute the norm of the residual quantity.  <a href="#600efac0d1a09650e090b3fd78fd91bb"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonFACOps.html#de6b8fff6898f32c5b952b068cf43651">initializeOperatorState</a> (const <a class="el" href="classSAMRAI_1_1solv_1_1SAMRAIVectorReal.html">SAMRAIVectorReal</a>&lt; double &gt; &amp;solution, const <a class="el" href="classSAMRAI_1_1solv_1_1SAMRAIVectorReal.html">SAMRAIVectorReal</a>&lt; double &gt; &amp;rhs)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute hierarchy-dependent data if any is required.  <a href="#de6b8fff6898f32c5b952b068cf43651"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonFACOps.html#c5cabdad53ce01fd47d3b1b63e268c10">deallocateOperatorState</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Remove all hierarchy-dependent data.  <a href="#c5cabdad53ce01fd47d3b1b63e268c10"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonFACOps.html#dda1412142d5c70a223128be7a0dfcd1">postprocessOneCycle</a> (int fac_cycle_num, const <a class="el" href="classSAMRAI_1_1solv_1_1SAMRAIVectorReal.html">SAMRAIVectorReal</a>&lt; double &gt; &amp;current_soln, const <a class="el" href="classSAMRAI_1_1solv_1_1SAMRAIVectorReal.html">SAMRAIVectorReal</a>&lt; double &gt; &amp;residual)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Regular call back routine to be called after each FAC cycle.  <a href="#dda1412142d5c70a223128be7a0dfcd1"></a><br></td></tr>
</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
FAC operator class to solve Poisson's equation on a SAMR grid, using cell-centered, second-order finite-volume method, with Robin boundary conditions. 
<p>
This class provides operators that are used by the FAC preconditioner <a class="el" href="classSAMRAI_1_1solv_1_1FACPreconditioner.html">FACPreconditioner</a>. It is used to solve the scalar Poisson's equation using a cell-centered second-order finite-volume discretization. It is designed to provide all operations specific to the scalar Poisson's equation, <p class="formulaDsp">
<img class="formulaDsp" alt="\[ \nabla \cdot D \nabla u + C u = f \]" src="form_50.png">
<p>
 (see <a class="el" href="classSAMRAI_1_1solv_1_1PoissonSpecifications.html">PoissonSpecifications</a>) where<ul>
<li>C, D and f are indpendent of u</li><li>C is a cell-centered scalar field</li><li>D is the <em>diffusion</em> <em>coefficients</em>, stored on faces</li><li>f is a cell-centered scalar function</li></ul>
<p>
You are left to provide the source function, initial guess, etc., by specifying them in specific forms.<p>
This class provides:<ol type=1>
<li>5-point (second order), cell-centered stencil operations for the discrete Laplacian.</li><li>Red-black Gauss-Seidel smoothing.</li><li>Provisions for working Robin boundary conditions (see <a class="el" href="classSAMRAI_1_1solv_1_1RobinBcCoefStrategy.html">RobinBcCoefStrategy</a>).</li></ol>
<p>
This class is meant to provide the Poisson-specific operator used by the FAC preconditioner, <a class="el" href="classSAMRAI_1_1solv_1_1FACPreconditioner.html">FACPreconditioner</a>. To use the preconditioner with this class, you will have to provide:<ol type=1>
<li>The solution vector <a class="el" href="classSAMRAI_1_1solv_1_1SAMRAIVectorReal.html">SAMRAIVectorReal</a>, with appropriate norm weighting for the cell-centered AMR mesh. This class provides the function <a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonFACOps.html#5f6fd2fc3f7e31a800cf63a5671440e1">computeVectorWeights()</a> to help with computing the appropriate weights. Since this is for a scalar equation, only the first depth of the first component of the vectors are used. All other parts are ignored.</li><li>The source vector <a class="el" href="classSAMRAI_1_1solv_1_1SAMRAIVectorReal.html">SAMRAIVectorReal</a> for f.</li><li>A <a class="el" href="classSAMRAI_1_1solv_1_1PoissonSpecifications.html">PoissonSpecifications</a> objects to specify the cell-centered scalar field C and the side-centered diffusion coefficients D</li><li>The boundary condition specifications in terms of the coefficients <img class="formulaInl" alt="$ \alpha $" src="form_51.png">, <img class="formulaInl" alt="$ \beta $" src="form_52.png"> and <img class="formulaInl" alt="$ \gamma $" src="form_53.png"> in the Robin formula <img class="formulaInl" alt="$ \alpha u + \beta u_n = \gamma $" src="form_54.png"> applied on the boundary faces. See <a class="el" href="classSAMRAI_1_1solv_1_1RobinBcCoefStrategy.html">RobinBcCoefStrategy</a>.</li></ol>
<p>
This class allocates and deallocates only its own scratch data. Other data that it manipuates are passed in as function arguments. Hence, it owns none of the solution vectors, error vectors, diffusion coefficient data, or any such things.<p>
Input Examples <div class="fragment"><pre class="fragment"> * coarse_solver_choice = "hypre"    // see setCoarsestLevelSolverChoice()
 * coarse_solver_tolerance = 1e-14   // see setCoarsestLevelSolverTolerance()
 * coarse_solver_max_iterations = 10 // see setCoarsestLevelSolverMaxIterations()
 * smoothing_choice = "redblack"     // see setSmoothingChoice()
 * cf_discretization = "Ewing"       // see setCoarseFineDiscretization()
 * prolongation_method = "LINEAR_REFINE" // see setProlongationMethod()
 * hypre_solver = { ... }            // tbox::Database for initializing Hypre solver
 * </pre></div> 
<p>
<hr><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" name="ee61404d3b33868e65c4327887d74e09"></a><!-- doxytag: member="SAMRAI::solv::CellPoissonFACOps::CellPoissonFACOps" ref="ee61404d3b33868e65c4327887d74e09" args="(const tbox::Dimension &amp;dim, const std::string &amp;object_name=std::string(), const boost::shared_ptr&lt; tbox::Database &gt; &amp;database=boost::shared_ptr&lt; tbox::Database &gt;())" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SAMRAI::solv::CellPoissonFACOps::CellPoissonFACOps           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1tbox_1_1Dimension.html">tbox::Dimension</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>dim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>object_name</em> = <code>std::string()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Database.html">tbox::Database</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>database</em> = <code>boost::shared_ptr&lt;&nbsp;<a class="el" href="classSAMRAI_1_1tbox_1_1Database.html">tbox::Database</a>&nbsp;&gt;()</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Constructor. 
<p>
If you want standard output and logging, pass in valid pointers for those streams. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dim</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>object_name</em>&nbsp;</td><td>Ojbect name </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>database</em>&nbsp;</td><td>Input database </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="f68794b2e9ca3e0eedc662beb62e7f33"></a><!-- doxytag: member="SAMRAI::solv::CellPoissonFACOps::~CellPoissonFACOps" ref="f68794b2e9ca3e0eedc662beb62e7f33" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SAMRAI::solv::CellPoissonFACOps::~CellPoissonFACOps           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Destructor. 
<p>
Deallocate internal data. 
</div>
</div><p>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="364ae41c84a837644eb57e559b0b6d36"></a><!-- doxytag: member="SAMRAI::solv::CellPoissonFACOps::setPoissonSpecifications" ref="364ae41c84a837644eb57e559b0b6d36" args="(const PoissonSpecifications &amp;spec)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::solv::CellPoissonFACOps::setPoissonSpecifications           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1solv_1_1PoissonSpecifications.html">PoissonSpecifications</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>spec</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set the scalar Poisson equation specifications. 
<p>

</div>
</div><p>
<a class="anchor" name="fcdcb45d56d266db88ed7ccbb809f6c4"></a><!-- doxytag: member="SAMRAI::solv::CellPoissonFACOps::enableLogging" ref="fcdcb45d56d266db88ed7ccbb809f6c4" args="(bool enable_logging)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::solv::CellPoissonFACOps::enableLogging           </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>enable_logging</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Enable logging. 
<p>
By default, logging is disabled. The logging flag is propagated to the major components used by this class. 
</div>
</div><p>
<a class="anchor" name="bddbb3e978fbd851c37daadb71384cdd"></a><!-- doxytag: member="SAMRAI::solv::CellPoissonFACOps::setSmoothingChoice" ref="bddbb3e978fbd851c37daadb71384cdd" args="(const std::string &amp;smoothing_choice)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::solv::CellPoissonFACOps::setSmoothingChoice           </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>smoothing_choice</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set the choice of smoothing algorithms. 
<p>
Current smoothing choices are:<ul>
<li>"redblack": Red-black Gauss-Seidel smoothing. </li></ul>

</div>
</div><p>
<a class="anchor" name="4f97bfbb403f6389ac098382477906d2"></a><!-- doxytag: member="SAMRAI::solv::CellPoissonFACOps::setCoarsestLevelSolverChoice" ref="4f97bfbb403f6389ac098382477906d2" args="(const std::string &amp;choice)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::solv::CellPoissonFACOps::setCoarsestLevelSolverChoice           </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>choice</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set coarse level solver. 
<p>
Select from these:<ul>
<li><code>"redblack"</code> (red-black smoothing until convergence--very slow!)</li><li><code>"hypre"</code> (only if the HYPRE library is available). </li></ul>

</div>
</div><p>
<a class="anchor" name="40cfa68fce513ed79d51c580053b8f2b"></a><!-- doxytag: member="SAMRAI::solv::CellPoissonFACOps::setCoarsestLevelSolverTolerance" ref="40cfa68fce513ed79d51c580053b8f2b" args="(double tol)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::solv::CellPoissonFACOps::setCoarsestLevelSolverTolerance           </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>tol</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set tolerance for coarse level solve. 
<p>
If the coarse level solver requires a tolerance (currently, they all do), the specified value is used. 
</div>
</div><p>
<a class="anchor" name="7a66e3136abac36523184b73d3555d84"></a><!-- doxytag: member="SAMRAI::solv::CellPoissonFACOps::setCoarsestLevelSolverMaxIterations" ref="7a66e3136abac36523184b73d3555d84" args="(int max_iterations)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::solv::CellPoissonFACOps::setCoarsestLevelSolverMaxIterations           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>max_iterations</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set max iterations for coarse level solve. 
<p>
If the coarse level solver requires a max iteration limit (currently, they all do), the specified value is used. 
</div>
</div><p>
<a class="anchor" name="7b853e982526a76b049654668df07cfc"></a><!-- doxytag: member="SAMRAI::solv::CellPoissonFACOps::setCoarseFineDiscretization" ref="7b853e982526a76b049654668df07cfc" args="(const std::string &amp;coarsefine_method)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::solv::CellPoissonFACOps::setCoarseFineDiscretization           </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>coarsefine_method</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set the coarse-fine boundary discretization method. 
<p>
Specify the <code>op_name</code> std::string which will be passed to xfer::Geometry::lookupRefineOperator() to get the operator for setting fine grid ghost cells from the coarse grid. Note that chosing this operator implicitly choses the discretization method at the coarse-fine boundary.<p>
There is one important instance where this std::string is <em>not</em> passed to xfer::Geometry::lookupRefineOperator. If this variable is set to "Ewing", Ewing's coarse-fine discretization is used (a constant refinement is performed, and the flux is later corrected to result in Ewing's scheme). For a reference to Ewing's discretization method, see "Local Refinement Techniques for Elliptic Problems on Cell-Centered Grids, I. Error Analysis", Mathematics of Computation, Vol. 56, No. 194, April 1991, pp. 437-461.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>coarsefine_method</em>&nbsp;</td><td>String selecting the coarse-fine discretization method. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="0af08cba26ce97836f2454c23ff8ebad"></a><!-- doxytag: member="SAMRAI::solv::CellPoissonFACOps::setProlongationMethod" ref="0af08cba26ce97836f2454c23ff8ebad" args="(const std::string &amp;prolongation_method)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::solv::CellPoissonFACOps::setProlongationMethod           </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>prolongation_method</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set the name of the prolongation method. 
<p>
Specify the <code>op_name</code> std::string which will be passed to xfer::Geometry::lookupRefineOperator() to get the operator for prolonging the coarse-grid correction.<p>
By default, "CONSTANT_REFINE" is used. "LINEAR_REFINE" seems to to lead to faster convergence, but it does NOT satisfy the Galerkin condition.<p>
Prolonging using linear refinement requires a Robin bc coefficient implementation that is capable of delivering coefficients for non-hierarchy data, because linear refinement requires boundary conditions to be set on temporary levels.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>prolongation_method</em>&nbsp;</td><td>String selecting the coarse-fine discretization method. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="ed16b05874c74eb7e767e4207815ccf1"></a><!-- doxytag: member="SAMRAI::solv::CellPoissonFACOps::setUseSMG" ref="ed16b05874c74eb7e767e4207815ccf1" args="(bool use_smg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::solv::CellPoissonFACOps::setUseSMG           </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>use_smg</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set whether to use Hypre's PFMG algorithm instead of the SMG algorithm. 
<p>
This flag affects the Hypre solver (used to solve the coarsest level). The flag is used to select which of HYPRE's linear solver algorithms to use if true, the semicoarsening multigrid algorithm is used, and if false, the ``PF'' multigrid algorithm is used. By default, the SMG algorithm is used.<p>
This setting has effect only when Hypre is chosen for the coarsest level solver. See <a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonFACOps.html#4f97bfbb403f6389ac098382477906d2">setCoarsestLevelSolverChoice()</a>.<p>
Changing the algorithm must be done before initializing the solver state and must NOT be done while the state is initialized (the program will exit), as that would corrupt the state. 
</div>
</div><p>
<a class="anchor" name="c2a11e9c53e6e465b64e1aa9e998dc1a"></a><!-- doxytag: member="SAMRAI::solv::CellPoissonFACOps::setFluxId" ref="c2a11e9c53e6e465b64e1aa9e998dc1a" args="(int flux_id)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::solv::CellPoissonFACOps::setFluxId           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>flux_id</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set the scratch patch data index for the flux. 
<p>
The use of this function is optional. The patch data index should be a pdat::SideData&lt;DIM&gt; type of variable. If the flux id is -1 (the default initial value), scratch space for the flux is allocated as needed and immediately deallocated afterward, level by level. If you have space preallocated for flux and you would like that to be used, set flux id to the patch data index of that space. 
</div>
</div><p>
<a class="anchor" name="4c96a2b13dc4830c3b19b69588b050bd"></a><!-- doxytag: member="SAMRAI::solv::CellPoissonFACOps::setPhysicalBcCoefObject" ref="4c96a2b13dc4830c3b19b69588b050bd" args="(const RobinBcCoefStrategy *physical_bc_coef)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::solv::CellPoissonFACOps::setPhysicalBcCoefObject           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1solv_1_1RobinBcCoefStrategy.html">RobinBcCoefStrategy</a> *&nbsp;</td>
          <td class="paramname"> <em>physical_bc_coef</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Provide an implementation for getting the physical bc coefficients. 
<p>
If your solution is fixed at the physical boundary ghost cell centers AND those cells have the correct values before entering solveSystem(), you may use a <a class="el" href="classSAMRAI_1_1solv_1_1GhostCellRobinBcCoefs.html">GhostCellRobinBcCoefs</a> object.<p>
If your solution is <b>not</b> fixed at the ghost cell centers, the ghost cell values will change as the interior cell values change. In those cases, the flexible Robin boundary conditions are applied. You must call this function to provide the implementation for determining the boundary condition coefficients.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>physical_bc_coef</em>&nbsp;</td><td>Pointer to an object that can set the Robin bc coefficients. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="071ca86f3a36ddc704305cf62e2fb18e"></a><!-- doxytag: member="SAMRAI::solv::CellPoissonFACOps::checkInputPatchDataIndices" ref="071ca86f3a36ddc704305cf62e2fb18e" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::solv::CellPoissonFACOps::checkInputPatchDataIndices           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Check validity and correctness of input patch data indices. 
<p>
Descriptors checked:<ol type=1>
<li>Diffusion coefficient (see setDiffcoefId())</li><li>Flux (see <a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonFACOps.html#c2a11e9c53e6e465b64e1aa9e998dc1a">setFluxId()</a>)</li><li>Source (see setScalarFieldId()) </li></ol>

</div>
</div><p>
<a class="anchor" name="5f6fd2fc3f7e31a800cf63a5671440e1"></a><!-- doxytag: member="SAMRAI::solv::CellPoissonFACOps::computeVectorWeights" ref="5f6fd2fc3f7e31a800cf63a5671440e1" args="(const boost::shared_ptr&lt; hier::PatchHierarchy &gt; &amp;hierarchy, int weight_id, int coarsest_ln=-1, int finest_ln=-1) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::solv::CellPoissonFACOps::computeVectorWeights           </td>
          <td>(</td>
          <td class="paramtype">const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchHierarchy.html">hier::PatchHierarchy</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>hierarchy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>weight_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>coarsest_ln</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>finest_ln</em> = <code>-1</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set weight appropriate for computing vector norms. 
<p>
If you this function to set the weights used when you <a class="el" href="classSAMRAI_1_1solv_1_1SAMRAIVectorReal.html#17989b5ef04cddd6a4fa63138d8ff86c">SAMRAIVectorReal::addComponent</a>, you can use the vector norm functions of <a class="el" href="classSAMRAI_1_1solv_1_1SAMRAIVectorReal.html">SAMRAIVectorReal</a>, and the weights will be used to blank out coarse grid regions under fine grids.<p>
The weights computed are specific to the cell-centered discretization used by this class. The weight is equal to the cell volume if the cell has not been refined, and zero if it has.<p>
This function is state-independent. All inputs are in the argument list.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hierarchy</em>&nbsp;</td><td>Hierarchy configuration to compute weights for </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>weight_id</em>&nbsp;</td><td><a class="el" href="classSAMRAI_1_1hier_1_1Patch.html">hier::Patch</a> data index of the weight </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>coarsest_ln</em>&nbsp;</td><td>Coarsest level number. Must be included in hierarchy. Must not be greater than <code>finest_ln</code>. Default to 0. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>finest_ln</em>&nbsp;</td><td>Finest level number. Must be included in hierarchy. Must not be less than <code>coarsest_ln</code>. Default to finest level in <code>hierarchy</code>. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="4755294a0ec68fa0e90f59b2d8725e71"></a><!-- doxytag: member="SAMRAI::solv::CellPoissonFACOps::setPreconditioner" ref="4755294a0ec68fa0e90f59b2d8725e71" args="(const FACPreconditioner *preconditioner)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::solv::CellPoissonFACOps::setPreconditioner           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1solv_1_1FACPreconditioner.html">FACPreconditioner</a> *&nbsp;</td>
          <td class="paramname"> <em>preconditioner</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set the FAC preconditioner that will be using this object. 
<p>
The FAC preconditioner is accessed to get convergence data during the cycle postprocessing step. It is optional. 
</div>
</div><p>
<a class="anchor" name="8276f889b6984293e562408856b506f5"></a><!-- doxytag: member="SAMRAI::solv::CellPoissonFACOps::computeFluxOnPatch" ref="8276f889b6984293e562408856b506f5" args="(const hier::Patch &amp;patch, const hier::IntVector &amp;ratio_to_coarser_level, const pdat::CellData&lt; double &gt; &amp;w_data, pdat::SideData&lt; double &gt; &amp;Dgradw_data) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::solv::CellPoissonFACOps::computeFluxOnPatch           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1Patch.html">hier::Patch</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>patch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>ratio_to_coarser_level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1pdat_1_1CellData.html">pdat::CellData</a>&lt; double &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>w_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1pdat_1_1SideData.html">pdat::SideData</a>&lt; double &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>Dgradw_data</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
function to compute flux, using general diffusion coefficient data. 
<p>
Recall that this solver class discretizes the PDE <p class="formulaDsp">
<img class="formulaDsp" alt="\[ \nabla \cdot D \nabla u + C u = f \]" src="form_50.png">
<p>
 on an AMR grid. This member function allows users of this solver class to compute gradient terms, <p class="formulaDsp">
<img class="formulaDsp" alt="\[ D \nabla w \]" src="form_55.png">
<p>
, in their code in a manner consistent with the solver discretization. In particular, when solving PDE systems, it may be necessary to discretize the gradient operator appearing in equations not treated by the solver class in the same way as those treated by this class. These funtions allow users to do this easily. The divergence operator used in this solver is the standard sum of centered differences involving flux terms on the cell sides computed by these routines.<p>
Note that the patch must exist on a level in an AMR hierarchy so that the discretization can be computed properly at the coarse-fine interface. Poisson coefficients C and D must exist on the patch, if they are variable. Also, calling this function does not affect the internal solver state in any way. However, the solver must be fully initialized before it is called and care should be exercised to pass arguments so that the solver solution quantity and other internal solver quantities are not adversely affected.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>patch</em>&nbsp;</td><td>patch on which computation will take place </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ratio_to_coarser_level</em>&nbsp;</td><td>refinement ratio from coarser level to level on which patch lives; if current patch level is level zero, this is ignored </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>w_data</em>&nbsp;</td><td>cell-centered data </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Dgradw_data</em>&nbsp;</td><td>side-centered flux data (i.e., D (grad w)) </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="9dae37b0144393116d0bc85105a66175"></a><!-- doxytag: member="SAMRAI::solv::CellPoissonFACOps::restrictSolution" ref="9dae37b0144393116d0bc85105a66175" args="(const SAMRAIVectorReal&lt; double &gt; &amp;source, SAMRAIVectorReal&lt; double &gt; &amp;dest, int dest_ln)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::solv::CellPoissonFACOps::restrictSolution           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1solv_1_1SAMRAIVectorReal.html">SAMRAIVectorReal</a>&lt; double &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1solv_1_1SAMRAIVectorReal.html">SAMRAIVectorReal</a>&lt; double &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>dest_ln</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Restrict the solution quantity to the specified level from the next finer level. 
<p>
Restrict the residual data to level dest_ln in the destination vector d, from level dest_ln+1 in the source vector s.<p>
Can assume:<ol type=1>
<li>dest_ln is not the finest level in the range being solved.</li><li>corresponding solution has been computed on level dest_ln+1.</li><li>the source and destination residual vectors (s and d) may or may not be the same. (This function must work in either case.)</li></ol>
<p>
Upon return from this function, the solution on the refined region of the coarse level will represent the coarsened version of the fine solution in a manner that is consistent with the linear system approximation on the composite grid. This function must not change the solution values anywhere except on level dest_ln of the destination vector.<p>
The source and destination vectors may be the same.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>source</em>&nbsp;</td><td>source solution </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dest</em>&nbsp;</td><td>destination solution </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dest_ln</em>&nbsp;</td><td>destination level number </td></tr>
  </table>
</dl>

<p>
Implements <a class="el" href="classSAMRAI_1_1solv_1_1FACOperatorStrategy.html#5357d62fc9348343a000f716ac079058">SAMRAI::solv::FACOperatorStrategy</a>.
</div>
</div><p>
<a class="anchor" name="65fefa03bb3b1932c3bdc4f453124629"></a><!-- doxytag: member="SAMRAI::solv::CellPoissonFACOps::restrictResidual" ref="65fefa03bb3b1932c3bdc4f453124629" args="(const SAMRAIVectorReal&lt; double &gt; &amp;source, SAMRAIVectorReal&lt; double &gt; &amp;dest, int dest_ln)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::solv::CellPoissonFACOps::restrictResidual           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1solv_1_1SAMRAIVectorReal.html">SAMRAIVectorReal</a>&lt; double &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1solv_1_1SAMRAIVectorReal.html">SAMRAIVectorReal</a>&lt; double &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>dest_ln</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Restrict the residual quantity to the specified level from the next finer level. 
<p>
Restrict the residual data to level dest_ln in the destination vector d, from level dest_ln+1 in the source vector s.<p>
Can assume:<ol type=1>
<li>dest_ln is not the finest level in the range being solved.</li><li>correspnding residual has been computed on level dest_ln+1.</li><li>the source and destination residual vectors (s and d) may or may not be the same. (This function must work in either case.)</li></ol>
<p>
Upon return from this function, the residual on the refined region of the coarse level will represent the coarsened version of the fine residual in a manner that is consistent with the linear system approximation on the composite grid. This function must not change the residual values anywhere except on level dest_ln of the destination vector.<p>
The source and destination vectors may be the same.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>source</em>&nbsp;</td><td>source residual </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dest</em>&nbsp;</td><td>destination residual </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dest_ln</em>&nbsp;</td><td>destination level number </td></tr>
  </table>
</dl>

<p>
Implements <a class="el" href="classSAMRAI_1_1solv_1_1FACOperatorStrategy.html#28015218b96465d3fee296842c1cc180">SAMRAI::solv::FACOperatorStrategy</a>.
</div>
</div><p>
<a class="anchor" name="4cd51fa373fd7e2931323f3613ac42c4"></a><!-- doxytag: member="SAMRAI::solv::CellPoissonFACOps::prolongErrorAndCorrect" ref="4cd51fa373fd7e2931323f3613ac42c4" args="(const SAMRAIVectorReal&lt; double &gt; &amp;source, SAMRAIVectorReal&lt; double &gt; &amp;dest, int dest_ln)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::solv::CellPoissonFACOps::prolongErrorAndCorrect           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1solv_1_1SAMRAIVectorReal.html">SAMRAIVectorReal</a>&lt; double &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1solv_1_1SAMRAIVectorReal.html">SAMRAIVectorReal</a>&lt; double &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>dest_ln</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Prolong the error quantity to the specified level from the next coarser level and apply the correction to the fine-level error. 
<p>
On the part of the coarse level that does <em>not</em> overlap the fine level, the error is the corection to Au=f.<p>
On the part of the coarse level that <em>does</em> overlap the fine level, the error is the corection to Ae=r of the fine level.<p>
This function should apply the coarse-level correction to the fine level, that is <p class="formulaDsp">
<img class="formulaDsp" alt="\[ e^{fine} \leftarrow e^{fine} + I^{fine}_{coarse} e^{coarse} \]" src="form_58.png">
<p>
<p>
<b>Note:</b> You probably have to store the refined error in a temporary location before adding it to the current error.<p>
The array of boundary information contains a description of the coarse-fine level boundary for each patch on the level; the boundary information for patch N is obtained as the N-th element in the array, coarse_fine_boundary[N].<p>
Upon return from this function, the error on the fine level must represent the correction to the solution on that level. Also, this function must not change the error values on the coarse level.<p>
The source and destination vectors may be the same.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>source</em>&nbsp;</td><td>source error vector </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dest</em>&nbsp;</td><td>destination error vector </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dest_ln</em>&nbsp;</td><td>destination level number of data transfer </td></tr>
  </table>
</dl>

<p>
Implements <a class="el" href="classSAMRAI_1_1solv_1_1FACOperatorStrategy.html#34e0d01ffdfee29aedcb49dba4f84f69">SAMRAI::solv::FACOperatorStrategy</a>.
</div>
</div><p>
<a class="anchor" name="2455fd635c8fa8cabe26f32f7a489968"></a><!-- doxytag: member="SAMRAI::solv::CellPoissonFACOps::smoothError" ref="2455fd635c8fa8cabe26f32f7a489968" args="(SAMRAIVectorReal&lt; double &gt; &amp;error, const SAMRAIVectorReal&lt; double &gt; &amp;residual, int ln, int num_sweeps)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::solv::CellPoissonFACOps::smoothError           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1solv_1_1SAMRAIVectorReal.html">SAMRAIVectorReal</a>&lt; double &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>error</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1solv_1_1SAMRAIVectorReal.html">SAMRAIVectorReal</a>&lt; double &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>residual</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>ln</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>num_sweeps</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Perform a given number of relaxations on the error. 
<p>
Relax the residual equation Ae=r by applying the given number of smoothing sweeps on the specified level. The relaxation may ignore the possible existence of finer levels on a given level.<p>
The array of boundary information contains a description of the coarse-fine level boundary for each patch on the level; the boundary information for patch N is obtained as the N-th element in the array, coarse_fine_boundary[N].<p>
May assume:<ul>
<li>If intermediate data from level l+1 is needed (for example, to match flux at coarse-fine boundaries), that data is already computed and stored on level l+1.</li><li>The error in the next finer level has been computed and stored there.</li></ul>
<p>
Steps for each iteration.<ol type=1>
<li>Fill ghost boundaries</li><li>Compute intermediate data (if needed) and coarsen intermediate data stored in level l+1 (if needed).</li><li>Perform relaxation step (update e toward a better approximation).</li></ol>
<p>
Final step before leaving function.<ul>
<li>If needed, compute and store intermediate data for next coarser level l-1.</li></ul>
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>error</em>&nbsp;</td><td>error vector </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>residual</em>&nbsp;</td><td>residual vector </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ln</em>&nbsp;</td><td>level number </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>num_sweeps</em>&nbsp;</td><td>number of sweeps </td></tr>
  </table>
</dl>

<p>
Implements <a class="el" href="classSAMRAI_1_1solv_1_1FACOperatorStrategy.html#3d047f75517b2d149fd45738092c3078">SAMRAI::solv::FACOperatorStrategy</a>.
</div>
</div><p>
<a class="anchor" name="5fe346279ed17b0916f78d3a13e72a7c"></a><!-- doxytag: member="SAMRAI::solv::CellPoissonFACOps::solveCoarsestLevel" ref="5fe346279ed17b0916f78d3a13e72a7c" args="(SAMRAIVectorReal&lt; double &gt; &amp;error, const SAMRAIVectorReal&lt; double &gt; &amp;residual, int coarsest_ln)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int SAMRAI::solv::CellPoissonFACOps::solveCoarsestLevel           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1solv_1_1SAMRAIVectorReal.html">SAMRAIVectorReal</a>&lt; double &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>error</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1solv_1_1SAMRAIVectorReal.html">SAMRAIVectorReal</a>&lt; double &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>residual</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>coarsest_ln</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Solve the residual equation Ae=r on the coarsest level in the FAC iteration. 
<p>
Here e is the given error quantity and r is the given residual quantity. The array of boundary information contains a description of the coarse-fine level boundary for each patch on the level; the boundary information for patch N is obtained as the N-th element in the array, coarse_fine_boundary[N].<p>
This routine must fill boundary values for given solution quantity on all patches on the specified level before the solve is performed.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>error</em>&nbsp;</td><td>error vector </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>residual</em>&nbsp;</td><td>residual vector </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>coarsest_ln</em>&nbsp;</td><td>coarsest level number </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>0 if solver converged to specified level, nonzero otherwise. </dd></dl>

<p>
Implements <a class="el" href="classSAMRAI_1_1solv_1_1FACOperatorStrategy.html#f0a0942ac9d24c2341066f6db282476e">SAMRAI::solv::FACOperatorStrategy</a>.
</div>
</div><p>
<a class="anchor" name="fa8593675924f56c22f30f6ba9481b3f"></a><!-- doxytag: member="SAMRAI::solv::CellPoissonFACOps::computeCompositeResidualOnLevel" ref="fa8593675924f56c22f30f6ba9481b3f" args="(SAMRAIVectorReal&lt; double &gt; &amp;residual, const SAMRAIVectorReal&lt; double &gt; &amp;solution, const SAMRAIVectorReal&lt; double &gt; &amp;rhs, int ln, bool error_equation_indicator)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::solv::CellPoissonFACOps::computeCompositeResidualOnLevel           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1solv_1_1SAMRAIVectorReal.html">SAMRAIVectorReal</a>&lt; double &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>residual</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1solv_1_1SAMRAIVectorReal.html">SAMRAIVectorReal</a>&lt; double &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>solution</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1solv_1_1SAMRAIVectorReal.html">SAMRAIVectorReal</a>&lt; double &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>ln</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>error_equation_indicator</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Compute composite grid residual on a single level. 
<p>
For the specified level number ln, compute the <em>composite</em> residual r=f-Au, where f is the right hand side and u is the solution. Note that the composite residual is not a one-level residual. It must take into account the composite grid stencil around the coarse-fine grid interface.<p>
May assume:<ul>
<li>Composite residual on next finer level l+1, has been computed already.</li><li>If any intermediately computed data is needed from level l+1, it has been done and stored on that level.</li><li>Residual computations for the original equation and the error equations will not be intermingled within one FAC cycle.</li></ul>
<p>
Steps:<ol type=1>
<li>Fill boundary ghosts.</li><li>If needed, coarsen intermediate data from level l+1.</li><li>Compute residual <img class="formulaInl" alt="$ r^l \leftarrow f - A u^l $" src="form_59.png">.</li></ol>
<p>
Final step before leaving function:<ul>
<li>If any intermediately computed data is needed in at level l-1, it must be computed and stored before leaving this function.</li></ul>
<p>
<b>Important:</b> Do not restrict residual from finer levels. (However, you must write the function <a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonFACOps.html#65fefa03bb3b1932c3bdc4f453124629">restrictResidual()</a> to do this.)<p>
<b>Important:</b> This function must also work when the right-hand-side and the residual are identical. In that case, it should effectively do <img class="formulaInl" alt="$ r \leftarrow r - A u $" src="form_60.png">.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>residual</em>&nbsp;</td><td>residual vector </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>solution</em>&nbsp;</td><td>solution vector </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>rhs</em>&nbsp;</td><td>source (right hand side) vector </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ln</em>&nbsp;</td><td>level number </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>error_equation_indicator</em>&nbsp;</td><td>flag stating whether u is an error vector or a solution vector </td></tr>
  </table>
</dl>

<p>
Implements <a class="el" href="classSAMRAI_1_1solv_1_1FACOperatorStrategy.html#224cb5f215ca84fa18bb37a7a3c90074">SAMRAI::solv::FACOperatorStrategy</a>.
</div>
</div><p>
<a class="anchor" name="600efac0d1a09650e090b3fd78fd91bb"></a><!-- doxytag: member="SAMRAI::solv::CellPoissonFACOps::computeResidualNorm" ref="600efac0d1a09650e090b3fd78fd91bb" args="(const SAMRAIVectorReal&lt; double &gt; &amp;residual, int fine_ln, int coarse_ln)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double SAMRAI::solv::CellPoissonFACOps::computeResidualNorm           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1solv_1_1SAMRAIVectorReal.html">SAMRAIVectorReal</a>&lt; double &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>residual</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>fine_ln</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>coarse_ln</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Compute the norm of the residual quantity. 
<p>
Compute norm of the given residual on the given range of hierarchy levels. The residual vector is computed already and you should <b>not</b> change it. The only purpose of this function to allow you to choose how to define the norm.<p>
The norm value is used during the FAC iteration to determine convergence of the composite grid linear system.<p>
Residual values that lie under a finer level should not be counted.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>residual</em>&nbsp;</td><td>residual vector </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>fine_ln</em>&nbsp;</td><td>finest level number </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>coarse_ln</em>&nbsp;</td><td>coarsest level number</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>norm value of residual vector, which should be non-negative </dd></dl>

<p>
Implements <a class="el" href="classSAMRAI_1_1solv_1_1FACOperatorStrategy.html#d87ddb09cfe2c3aa4fb73ca0ba05d516">SAMRAI::solv::FACOperatorStrategy</a>.
</div>
</div><p>
<a class="anchor" name="de6b8fff6898f32c5b952b068cf43651"></a><!-- doxytag: member="SAMRAI::solv::CellPoissonFACOps::initializeOperatorState" ref="de6b8fff6898f32c5b952b068cf43651" args="(const SAMRAIVectorReal&lt; double &gt; &amp;solution, const SAMRAIVectorReal&lt; double &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::solv::CellPoissonFACOps::initializeOperatorState           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1solv_1_1SAMRAIVectorReal.html">SAMRAIVectorReal</a>&lt; double &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>solution</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1solv_1_1SAMRAIVectorReal.html">SAMRAIVectorReal</a>&lt; double &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Compute hierarchy-dependent data if any is required. 
<p>
This function is called when the hierarchy configuration changes. If you maintain any hierarchy-dependent data in your implementation (for example, caching communication schedules or computing coarse-fine boundaries), use this function to update that data.<p>
If you do not maintain such data, this function may be empty.<p>
Note that although the vector arguments given to other methods in this class may not necessarily be the same as those given to this method, there will be similarities, including:<ul>
<li>hierarchy configuration (hierarchy pointer and level range)</li><li>number, type and alignment of vector component data</li><li>ghost cell width of data in the solution (or solution-like) vector</li></ul>
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>solution</em>&nbsp;</td><td>solution vector u </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>rhs</em>&nbsp;</td><td>right hand side vector f</td></tr>
  </table>
</dl>
The default implementation does nothing. 
<p>
Implements <a class="el" href="classSAMRAI_1_1solv_1_1FACOperatorStrategy.html#2fb54d806fdf60549bcaada57a3694a7">SAMRAI::solv::FACOperatorStrategy</a>.
</div>
</div><p>
<a class="anchor" name="c5cabdad53ce01fd47d3b1b63e268c10"></a><!-- doxytag: member="SAMRAI::solv::CellPoissonFACOps::deallocateOperatorState" ref="c5cabdad53ce01fd47d3b1b63e268c10" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::solv::CellPoissonFACOps::deallocateOperatorState           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Remove all hierarchy-dependent data. 
<p>
Remove all hierarchy-dependent data set by <a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonFACOps.html#de6b8fff6898f32c5b952b068cf43651">initializeOperatorState()</a>.<p>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonFACOps.html#de6b8fff6898f32c5b952b068cf43651">initializeOperatorState</a> </dd></dl>

<p>
Reimplemented from <a class="el" href="classSAMRAI_1_1solv_1_1FACOperatorStrategy.html#cd3290e2ac8e3f53342c4997afcc0c43">SAMRAI::solv::FACOperatorStrategy</a>.
</div>
</div><p>
<a class="anchor" name="dda1412142d5c70a223128be7a0dfcd1"></a><!-- doxytag: member="SAMRAI::solv::CellPoissonFACOps::postprocessOneCycle" ref="dda1412142d5c70a223128be7a0dfcd1" args="(int fac_cycle_num, const SAMRAIVectorReal&lt; double &gt; &amp;current_soln, const SAMRAIVectorReal&lt; double &gt; &amp;residual)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::solv::CellPoissonFACOps::postprocessOneCycle           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>fac_cycle_num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1solv_1_1SAMRAIVectorReal.html">SAMRAIVectorReal</a>&lt; double &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>current_soln</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1solv_1_1SAMRAIVectorReal.html">SAMRAIVectorReal</a>&lt; double &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>residual</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Regular call back routine to be called after each FAC cycle. 
<p>
This function is called after each FAC cycle. It allows you to monitor the progress and do other things. You should <em>not</em> modify the solution vector in the argument.<p>
The default implementation does nothing.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>fac_cycle_num</em>&nbsp;</td><td>FAC cycle number completed </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>current_soln</em>&nbsp;</td><td>current solution </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>residual</em>&nbsp;</td><td>residual based on the current solution </td></tr>
  </table>
</dl>

<p>
Implements <a class="el" href="classSAMRAI_1_1solv_1_1FACOperatorStrategy.html#17f9d1fc4955fb151f09ab56ea02654b">SAMRAI::solv::FACOperatorStrategy</a>.
</div>
</div><p>
<a class="anchor" name="c14fd20b7566614fa56cf135b2717e60"></a><!-- doxytag: member="SAMRAI::solv::CellPoissonFACOps::getObjectName" ref="c14fd20b7566614fa56cf135b2717e60" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::string&amp; SAMRAI::solv::CellPoissonFACOps::getObjectName           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the name of this object. 
<p>
<dl compact><dt><b>Returns:</b></dt><dd>The name of this object. </dd></dl>

</div>
</div><p>
<hr>The documentation for this class was generated from the following files:<ul>
<li>source/SAMRAI/solv/<a class="el" href="CellPoissonFACOps_8h.html">CellPoissonFACOps.h</a><li>source/SAMRAI/solv/<a class="el" href="CellPoissonFACOps_8C.html">CellPoissonFACOps.C</a></ul>
<hr size="1"><address style="align: right;"><small>Generated on Thu Jun 21 13:42:58 2012 for SAMRAI by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.7 </small></address>
</body>
</html>
