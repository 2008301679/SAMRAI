<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>SAMRAI: SAMRAI::solv::CellPoissonFACOps Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath"><a class="el" href="namespaceSAMRAI.html">SAMRAI</a>::<a class="el" href="namespaceSAMRAI_1_1solv.html">solv</a>::<a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonFACOps.html">CellPoissonFACOps</a>
  </div>
</div>
<div class="contents">
<h1>SAMRAI::solv::CellPoissonFACOps Class Reference</h1><!-- doxytag: class="SAMRAI::solv::CellPoissonFACOps" --><!-- doxytag: inherits="SAMRAI::solv::FACOperatorStrategy" -->
<p>FAC operator class to solve Poisson's equation on a SAMR grid, using cell-centered, second-order finite-volume method, with Robin boundary conditions.  
<a href="#_details">More...</a></p>

<p><code>#include &lt;source/SAMRAI/solv/CellPoissonFACOps.h&gt;</code></p>
<div class="dynheader">
Inheritance diagram for SAMRAI::solv::CellPoissonFACOps:</div>
<div class="dynsection">
 <div class="center">
  <img src="classSAMRAI_1_1solv_1_1CellPoissonFACOps.gif" usemap="#SAMRAI::solv::CellPoissonFACOps_map" alt=""/>
  <map id="SAMRAI::solv::CellPoissonFACOps_map" name="SAMRAI::solv::CellPoissonFACOps_map">
<area href="classSAMRAI_1_1solv_1_1FACOperatorStrategy.html" alt="SAMRAI::solv::FACOperatorStrategy" shape="rect" coords="0,0,219,24"/>
</map>
 </div>
</div>

<p><a href="classSAMRAI_1_1solv_1_1CellPoissonFACOps-members.html">List of all members.</a></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonFACOps.html#a8f8e0a412d43fc9c919e181ea72798da">CellPoissonFACOps</a> (const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonHypreSolver.html">CellPoissonHypreSolver</a> &gt; &amp;hypre_solver, const <a class="el" href="classSAMRAI_1_1tbox_1_1Dimension.html">tbox::Dimension</a> &amp;dim, const std::string &amp;object_name=std::string(), const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Database.html">tbox::Database</a> &gt; &amp;input_db=boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Database.html">tbox::Database</a> &gt;())</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Constructor.  <a href="#a8f8e0a412d43fc9c919e181ea72798da"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonFACOps.html#aa5d3d2934019c449378e1af48fa74b1c">~CellPoissonFACOps</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Destructor.  <a href="#aa5d3d2934019c449378e1af48fa74b1c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonFACOps.html#a7cc580e6bfbffffdc9947492f53ee91a">setPoissonSpecifications</a> (const <a class="el" href="classSAMRAI_1_1solv_1_1PoissonSpecifications.html">PoissonSpecifications</a> &amp;spec)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the scalar Poisson equation specifications.  <a href="#a7cc580e6bfbffffdc9947492f53ee91a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonFACOps.html#abf5702f231b825e5bb32d69368033dc6">setPhysicalBcCoefObject</a> (const <a class="el" href="classSAMRAI_1_1solv_1_1RobinBcCoefStrategy.html">RobinBcCoefStrategy</a> *physical_bc_coef)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Provide an implementation for getting the physical bc coefficients.  <a href="#abf5702f231b825e5bb32d69368033dc6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonFACOps.html#aa3306861cf8355f9374e372dd8a96561">computeVectorWeights</a> (const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchHierarchy.html">hier::PatchHierarchy</a> &gt; &amp;hierarchy, int weight_id, int coarsest_ln=-1, int finest_ln=-1) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set weight appropriate for computing vector norms.  <a href="#aa3306861cf8355f9374e372dd8a96561"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonFACOps.html#aa3c056ef1fa85484aeeb4ae12539f78e">setPreconditioner</a> (const <a class="el" href="classSAMRAI_1_1solv_1_1FACPreconditioner.html">FACPreconditioner</a> *preconditioner)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the FAC preconditioner that will be using this object.  <a href="#aa3c056ef1fa85484aeeb4ae12539f78e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonFACOps.html#a84c366a3490f4eb173f1e3486bf8829a">computeFluxOnPatch</a> (const <a class="el" href="classSAMRAI_1_1hier_1_1Patch.html">hier::Patch</a> &amp;patch, const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a> &amp;ratio_to_coarser_level, const <a class="el" href="classSAMRAI_1_1pdat_1_1CellData.html">pdat::CellData</a>&lt; double &gt; &amp;w_data, <a class="el" href="classSAMRAI_1_1pdat_1_1SideData.html">pdat::SideData</a>&lt; double &gt; &amp;Dgradw_data) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">function to compute flux, using general diffusion coefficient data.  <a href="#a84c366a3490f4eb173f1e3486bf8829a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const std::string &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonFACOps.html#a5ba16397bffad8e27cff8c1e0ef5cb67">getObjectName</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the name of this object.  <a href="#a5ba16397bffad8e27cff8c1e0ef5cb67"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Functions for setting patch data indices and coefficients</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrp881e0e91c17b59efd6e046bc06433fab"></a> </p>
<br/><br/></div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonFACOps.html#acef5ec67daaf2695319721a75820a27b">setFluxId</a> (int flux_id)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the scratch patch data index for the flux.  <a href="#acef5ec67daaf2695319721a75820a27b"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Functions for checking validity and correctness of state.</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrp0c38d9cf23ed90ccb131be7843a68fbe"></a> </p>
<br/><br/></div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonFACOps.html#add6f2240f4c16d618288864b8a95b925">checkInputPatchDataIndices</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Check validity and correctness of input patch data indices.  <a href="#add6f2240f4c16d618288864b8a95b925"></a><br/></td></tr>
<tr><td colspan="2"><h2>Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonFACOps.html#a7ac920307882c4f0476b5eca670291c9">getFromInput</a> (const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Database.html">tbox::Database</a> &gt; &amp;input_db)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Read parameters from input database.  <a href="#a7ac920307882c4f0476b5eca670291c9"></a><br/></td></tr>
<tr><td colspan="2"><p><a class="anchor" id="amgrpd41d8cd98f00b204e9800998ecf8427e"></a> </p>
<br/><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonFACOps.html#a519af350efc4c727346d102c9de49c3a">restrictSolution</a> (const <a class="el" href="classSAMRAI_1_1solv_1_1SAMRAIVectorReal.html">SAMRAIVectorReal</a>&lt; double &gt; &amp;source, <a class="el" href="classSAMRAI_1_1solv_1_1SAMRAIVectorReal.html">SAMRAIVectorReal</a>&lt; double &gt; &amp;dest, int dest_ln)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Restrict the solution quantity to the specified level from the next finer level.  <a href="#a519af350efc4c727346d102c9de49c3a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonFACOps.html#a9a76c90308783470ee687e9a68777681">restrictResidual</a> (const <a class="el" href="classSAMRAI_1_1solv_1_1SAMRAIVectorReal.html">SAMRAIVectorReal</a>&lt; double &gt; &amp;source, <a class="el" href="classSAMRAI_1_1solv_1_1SAMRAIVectorReal.html">SAMRAIVectorReal</a>&lt; double &gt; &amp;dest, int dest_ln)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Restrict the residual quantity to the specified level from the next finer level.  <a href="#a9a76c90308783470ee687e9a68777681"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonFACOps.html#a039613b32f29f73b7f2e12f9d14080ac">prolongErrorAndCorrect</a> (const <a class="el" href="classSAMRAI_1_1solv_1_1SAMRAIVectorReal.html">SAMRAIVectorReal</a>&lt; double &gt; &amp;source, <a class="el" href="classSAMRAI_1_1solv_1_1SAMRAIVectorReal.html">SAMRAIVectorReal</a>&lt; double &gt; &amp;dest, int dest_ln)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Prolong the error quantity to the specified level from the next coarser level and apply the correction to the fine-level error.  <a href="#a039613b32f29f73b7f2e12f9d14080ac"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonFACOps.html#a83625dda387afc4b50a9359967990b96">smoothError</a> (<a class="el" href="classSAMRAI_1_1solv_1_1SAMRAIVectorReal.html">SAMRAIVectorReal</a>&lt; double &gt; &amp;error, const <a class="el" href="classSAMRAI_1_1solv_1_1SAMRAIVectorReal.html">SAMRAIVectorReal</a>&lt; double &gt; &amp;residual, int ln, int num_sweeps)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Perform a given number of relaxations on the error.  <a href="#a83625dda387afc4b50a9359967990b96"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonFACOps.html#af0def579f9a4ffa10dd39f89a4b63245">solveCoarsestLevel</a> (<a class="el" href="classSAMRAI_1_1solv_1_1SAMRAIVectorReal.html">SAMRAIVectorReal</a>&lt; double &gt; &amp;error, const <a class="el" href="classSAMRAI_1_1solv_1_1SAMRAIVectorReal.html">SAMRAIVectorReal</a>&lt; double &gt; &amp;residual, int coarsest_ln)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Solve the residual equation Ae=r on the coarsest level in the FAC iteration.  <a href="#af0def579f9a4ffa10dd39f89a4b63245"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonFACOps.html#a82e1606b80843a097c4d99763a41e232">computeCompositeResidualOnLevel</a> (<a class="el" href="classSAMRAI_1_1solv_1_1SAMRAIVectorReal.html">SAMRAIVectorReal</a>&lt; double &gt; &amp;residual, const <a class="el" href="classSAMRAI_1_1solv_1_1SAMRAIVectorReal.html">SAMRAIVectorReal</a>&lt; double &gt; &amp;solution, const <a class="el" href="classSAMRAI_1_1solv_1_1SAMRAIVectorReal.html">SAMRAIVectorReal</a>&lt; double &gt; &amp;rhs, int ln, bool error_equation_indicator)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute composite grid residual on a single level.  <a href="#a82e1606b80843a097c4d99763a41e232"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonFACOps.html#ab2091fb3e4e044ffdbf773918abcf9b7">computeResidualNorm</a> (const <a class="el" href="classSAMRAI_1_1solv_1_1SAMRAIVectorReal.html">SAMRAIVectorReal</a>&lt; double &gt; &amp;residual, int fine_ln, int coarse_ln)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute the norm of the residual quantity.  <a href="#ab2091fb3e4e044ffdbf773918abcf9b7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonFACOps.html#a2da31e44d1cf2f54f7a941b6623fd7be">initializeOperatorState</a> (const <a class="el" href="classSAMRAI_1_1solv_1_1SAMRAIVectorReal.html">SAMRAIVectorReal</a>&lt; double &gt; &amp;solution, const <a class="el" href="classSAMRAI_1_1solv_1_1SAMRAIVectorReal.html">SAMRAIVectorReal</a>&lt; double &gt; &amp;rhs)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute hierarchy-dependent data if any is required.  <a href="#a2da31e44d1cf2f54f7a941b6623fd7be"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonFACOps.html#af48e45974c427278215ae11ee7bba734">deallocateOperatorState</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Remove all hierarchy-dependent data.  <a href="#af48e45974c427278215ae11ee7bba734"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonFACOps.html#a554bf193dfb039a95c9a6e7f9af40d77">postprocessOneCycle</a> (int fac_cycle_num, const <a class="el" href="classSAMRAI_1_1solv_1_1SAMRAIVectorReal.html">SAMRAIVectorReal</a>&lt; double &gt; &amp;current_soln, const <a class="el" href="classSAMRAI_1_1solv_1_1SAMRAIVectorReal.html">SAMRAIVectorReal</a>&lt; double &gt; &amp;residual)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Regular call back routine to be called after each FAC cycle.  <a href="#a554bf193dfb039a95c9a6e7f9af40d77"></a><br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>FAC operator class to solve Poisson's equation on a SAMR grid, using cell-centered, second-order finite-volume method, with Robin boundary conditions. </p>
<p>This class provides operators that are used by the FAC preconditioner <a class="el" href="classSAMRAI_1_1solv_1_1FACPreconditioner.html" title="Implements the FAC iterative solution procedure for a linear system of equations...">FACPreconditioner</a>. It is used to solve the scalar Poisson's equation using a cell-centered second-order finite-volume discretization. It is designed to provide all operations specific to the scalar Poisson's equation, </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \nabla \cdot D \nabla u + C u = f \]" src="form_50.png"/>
</p>
<p> (see <a class="el" href="classSAMRAI_1_1solv_1_1PoissonSpecifications.html" title="Light class holding specifications for cell-centered implementation of the scalar...">PoissonSpecifications</a>) where</p>
<ul>
<li>C, D and f are indpendent of u</li>
<li>C is a cell-centered scalar field</li>
<li>D is the <em>diffusion</em> <em>coefficients</em>, stored on faces</li>
<li>f is a cell-centered scalar function</li>
</ul>
<p>You are left to provide the source function, initial guess, etc., by specifying them in specific forms.</p>
<p>This class provides:</p>
<ol type="1">
<li>5-point (second order), cell-centered stencil operations for the discrete Laplacian.</li>
<li>Red-black Gauss-Seidel smoothing.</li>
<li>Provisions for working Robin boundary conditions (see <a class="el" href="classSAMRAI_1_1solv_1_1RobinBcCoefStrategy.html" title="Interface for specifying Robin boundary conditions.">RobinBcCoefStrategy</a>).</li>
</ol>
<p>This class is meant to provide the Poisson-specific operator used by the FAC preconditioner, <a class="el" href="classSAMRAI_1_1solv_1_1FACPreconditioner.html" title="Implements the FAC iterative solution procedure for a linear system of equations...">FACPreconditioner</a>. To use the preconditioner with this class, you will have to provide:</p>
<ol type="1">
<li>The solution vector <a class="el" href="classSAMRAI_1_1solv_1_1SAMRAIVectorReal.html">SAMRAIVectorReal</a>, with appropriate norm weighting for the cell-centered AMR <a class="el" href="namespaceSAMRAI_1_1mesh.html">mesh</a>. This class provides the function <a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonFACOps.html#aa3306861cf8355f9374e372dd8a96561" title="Set weight appropriate for computing vector norms.">computeVectorWeights()</a> to help with computing the appropriate weights. Since this is for a scalar equation, only the first depth of the first component of the vectors are used. All other parts are ignored.</li>
<li>The source vector <a class="el" href="classSAMRAI_1_1solv_1_1SAMRAIVectorReal.html">SAMRAIVectorReal</a> for f.</li>
<li>A <a class="el" href="classSAMRAI_1_1solv_1_1PoissonSpecifications.html" title="Light class holding specifications for cell-centered implementation of the scalar...">PoissonSpecifications</a> objects to specify the cell-centered scalar field C and the side-centered diffusion coefficients D</li>
<li>The boundary condition specifications in terms of the coefficients <img class="formulaInl" alt="$ \alpha $" src="form_51.png"/>, <img class="formulaInl" alt="$ \beta $" src="form_52.png"/> and <img class="formulaInl" alt="$ \gamma $" src="form_53.png"/> in the Robin formula <img class="formulaInl" alt="$ \alpha u + \beta u_n = \gamma $" src="form_54.png"/> applied on the boundary faces. See <a class="el" href="classSAMRAI_1_1solv_1_1RobinBcCoefStrategy.html" title="Interface for specifying Robin boundary conditions.">RobinBcCoefStrategy</a>.</li>
</ol>
<p>This class allocates and deallocates only its own scratch data. Other data that it manipuates are passed in as function arguments. Hence, it owns none of the solution vectors, error vectors, diffusion coefficient data, or any such things.</p>
<p><b> Input Parameters </b></p>
<p><b> Definitions: </b></p>
<ul>
<li><b>coarse_solver_choice</b> </li>
</ul>
<ul>
<li><b>coarse_solver_tolerance</b> </li>
</ul>
<ul>
<li><b>coarse_solver_max_iterations</b> </li>
</ul>
<ul>
<li><b>cf_discretization</b> </li>
</ul>
<ul>
<li><b>prolongation_method</b> </li>
</ul>
<ul>
<li><b>enable_logging</b> </li>
</ul>
<p><b> Details:</b> <br/>
 </p>
<table border="1" cellspacing="3" cellpadding="3">
<tr>
<th><p>parameter </p>
</th><th><p>type </p>
</th><th><p>default </p>
</th><th><p>range </p>
</th><th><p>opt/req </p>
</th><th><p>behavior on restart  </p>
</th></tr>
<tr>
<td><p>coarse_solver_choice </p>
</td><td><p>string </p>
</td><td><p>"hypre" </p>
</td><td><p>"hypre", "redblack", "jacobi" </p>
</td><td><p>opt </p>
</td><td><p>Not written to restart. Value in input db used.  </p>
</td></tr>
<tr>
<td><p>coarse_solver_tolerance </p>
</td><td><p>double </p>
</td><td><p>1e-14 </p>
</td><td><p>&gt;0.0 </p>
</td><td><p>opt </p>
</td><td><p>Not written to restart. Value in input db used.  </p>
</td></tr>
<tr>
<td><p>coarse_solver_max_iterations </p>
</td><td><p>int </p>
</td><td><p>10 </p>
</td><td><p>&gt;=1 </p>
</td><td><p>opt </p>
</td><td><p>Not written to restart. Value in input db used.  </p>
</td></tr>
<tr>
<td><p>cf_discretization </p>
</td><td><p>string </p>
</td><td><p>"Ewing" </p>
</td><td><p>"Ewing", "CONSTANT_REFINE", "CONSERVATIVE_LINEAR_REFINE", "LINEAR_REFINE" </p>
</td><td><p>opt </p>
</td><td><p>Not written to restart. Value in input db used.  </p>
</td></tr>
<tr>
<td><p>prolongation_method </p>
</td><td><p>string </p>
</td><td><p>"LINEAR_REFINE" </p>
</td><td><p>"CONSTANT_REFINE", "CONSERVATIVE_LINEAR_REFINE", "LINEAR_REFINE" </p>
</td><td><p>opt </p>
</td><td><p>Not written to restart. Value in input db used.  </p>
</td></tr>
<tr>
<td><p>enable_logging </p>
</td><td><p>bool </p>
</td><td><p>FALSE </p>
</td><td><p>TRUE, FALSE </p>
</td><td><p>opt </p>
</td><td><p>Not written to restart. Value in input db used.  </p>
</td></tr>
</table>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a8f8e0a412d43fc9c919e181ea72798da"></a><!-- doxytag: member="SAMRAI::solv::CellPoissonFACOps::CellPoissonFACOps" ref="a8f8e0a412d43fc9c919e181ea72798da" args="(const boost::shared_ptr&lt; CellPoissonHypreSolver &gt; &amp;hypre_solver, const tbox::Dimension &amp;dim, const std::string &amp;object_name=std::string(), const boost::shared_ptr&lt; tbox::Database &gt; &amp;input_db=boost::shared_ptr&lt; tbox::Database &gt;())" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SAMRAI::solv::CellPoissonFACOps::CellPoissonFACOps </td>
          <td>(</td>
          <td class="paramtype">const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonHypreSolver.html">CellPoissonHypreSolver</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>hypre_solver</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1tbox_1_1Dimension.html">tbox::Dimension</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>dim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>object_name</em> = <code>std::string()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Database.html">tbox::Database</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>input_db</em> = <code>boost::shared_ptr&lt;&nbsp;<a class="el" href="classSAMRAI_1_1tbox_1_1Database.html">tbox::Database</a>&nbsp;&gt;()</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Constructor. </p>
<p>If you want standard output and logging, pass in valid pointers for those streams. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dim</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>object_name</em>&nbsp;</td><td>Object name </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>hypre_solver</em>&nbsp;</td><td>underlying hypre solver </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>input_db</em>&nbsp;</td><td>Input database </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa5d3d2934019c449378e1af48fa74b1c"></a><!-- doxytag: member="SAMRAI::solv::CellPoissonFACOps::~CellPoissonFACOps" ref="aa5d3d2934019c449378e1af48fa74b1c" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SAMRAI::solv::CellPoissonFACOps::~CellPoissonFACOps </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Destructor. </p>
<p>Deallocate internal data. </p>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a7cc580e6bfbffffdc9947492f53ee91a"></a><!-- doxytag: member="SAMRAI::solv::CellPoissonFACOps::setPoissonSpecifications" ref="a7cc580e6bfbffffdc9947492f53ee91a" args="(const PoissonSpecifications &amp;spec)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::solv::CellPoissonFACOps::setPoissonSpecifications </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1solv_1_1PoissonSpecifications.html">PoissonSpecifications</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>spec</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set the scalar Poisson equation specifications. </p>

</div>
</div>
<a class="anchor" id="acef5ec67daaf2695319721a75820a27b"></a><!-- doxytag: member="SAMRAI::solv::CellPoissonFACOps::setFluxId" ref="acef5ec67daaf2695319721a75820a27b" args="(int flux_id)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::solv::CellPoissonFACOps::setFluxId </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>flux_id</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set the scratch patch data index for the flux. </p>
<p>The use of this function is optional. The patch data index should be a pdat::SideData&lt;TYPE&gt; type of variable. If the flux id is -1 (the default initial value), scratch space for the flux is allocated as needed and immediately deallocated afterward, level by level. If you have space preallocated for flux and you would like that to be used, set flux id to the patch data index of that space. </p>

<p>References <a class="el" href="CellPoissonFACOps_8C_source.html#l02108">checkInputPatchDataIndices()</a>.</p>

</div>
</div>
<a class="anchor" id="abf5702f231b825e5bb32d69368033dc6"></a><!-- doxytag: member="SAMRAI::solv::CellPoissonFACOps::setPhysicalBcCoefObject" ref="abf5702f231b825e5bb32d69368033dc6" args="(const RobinBcCoefStrategy *physical_bc_coef)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::solv::CellPoissonFACOps::setPhysicalBcCoefObject </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1solv_1_1RobinBcCoefStrategy.html">RobinBcCoefStrategy</a> *&nbsp;</td>
          <td class="paramname"> <em>physical_bc_coef</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Provide an implementation for getting the physical bc coefficients. </p>
<p>If your solution is fixed at the physical boundary ghost cell centers AND those cells have the correct values before entering solveSystem(), you may use a <a class="el" href="classSAMRAI_1_1solv_1_1GhostCellRobinBcCoefs.html" title="A prefabricated Robin boundary condition coefficients for the case where cell-centered...">GhostCellRobinBcCoefs</a> object.</p>
<p>If your solution is <b>not</b> fixed at the ghost cell centers, the ghost cell values will change as the interior cell values change. In those cases, the flexible Robin boundary conditions are applied. You must call this function to provide the implementation for determining the boundary condition coefficients.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>physical_bc_coef</em>&nbsp;</td><td>Pointer to an object that can set the Robin bc coefficients. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="CartesianRobinBcHelper_8h_source.html#l00309">SAMRAI::solv::CartesianRobinBcHelper::setCoefImplementation()</a>.</p>

</div>
</div>
<a class="anchor" id="add6f2240f4c16d618288864b8a95b925"></a><!-- doxytag: member="SAMRAI::solv::CellPoissonFACOps::checkInputPatchDataIndices" ref="add6f2240f4c16d618288864b8a95b925" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::solv::CellPoissonFACOps::checkInputPatchDataIndices </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Check validity and correctness of input patch data indices. </p>
<p>Descriptors checked:</p>
<ol type="1">
<li>Diffusion coefficient (see setDiffcoefId())</li>
<li>Flux (see <a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonFACOps.html#acef5ec67daaf2695319721a75820a27b" title="Set the scratch patch data index for the flux.">setFluxId()</a>)</li>
<li>Source (see setScalarFieldId()) </li>
</ol>

<p>References <a class="el" href="Utilities_8h_source.html#l00149">BOOST_CAST</a>, <a class="el" href="PoissonSpecifications_8h_source.html#l00289">SAMRAI::solv::PoissonSpecifications::cIsConstant()</a>, <a class="el" href="PoissonSpecifications_8h_source.html#l00274">SAMRAI::solv::PoissonSpecifications::cIsZero()</a>, <a class="el" href="PoissonSpecifications_8h_source.html#l00146">SAMRAI::solv::PoissonSpecifications::dIsConstant()</a>, <a class="el" href="PoissonSpecifications_8h_source.html#l00304">SAMRAI::solv::PoissonSpecifications::getCPatchDataId()</a>, <a class="el" href="VariableDatabase_8C_source.html#l00044">SAMRAI::hier::VariableDatabase::getDatabase()</a>, <a class="el" href="PoissonSpecifications_8h_source.html#l00161">SAMRAI::solv::PoissonSpecifications::getDPatchDataId()</a>, <a class="el" href="VariableDatabase_8C_source.html#l00564">SAMRAI::hier::VariableDatabase::mapIndexToVariable()</a>, and <a class="el" href="Utilities_8h_source.html#l00110">TBOX_ASSERT</a>.</p>

<p>Referenced by <a class="el" href="CellPoissonFACOps_8C_source.html#l01789">computeCompositeResidualOnLevel()</a>, <a class="el" href="CellPoissonFACOps_8h_source.html#l00255">setFluxId()</a>, <a class="el" href="CellPoissonFACOps_8C_source.html#l01309">smoothError()</a>, and <a class="el" href="CellPoissonFACOps_8C_source.html#l01678">solveCoarsestLevel()</a>.</p>

</div>
</div>
<a class="anchor" id="aa3306861cf8355f9374e372dd8a96561"></a><!-- doxytag: member="SAMRAI::solv::CellPoissonFACOps::computeVectorWeights" ref="aa3306861cf8355f9374e372dd8a96561" args="(const boost::shared_ptr&lt; hier::PatchHierarchy &gt; &amp;hierarchy, int weight_id, int coarsest_ln=&#45;1, int finest_ln=&#45;1) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::solv::CellPoissonFACOps::computeVectorWeights </td>
          <td>(</td>
          <td class="paramtype">const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchHierarchy.html">hier::PatchHierarchy</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>hierarchy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>weight_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>coarsest_ln</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>finest_ln</em> = <code>-1</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set weight appropriate for computing vector norms. </p>
<p>If you this function to set the weights used when you <a class="el" href="classSAMRAI_1_1solv_1_1SAMRAIVectorReal.html#a61dc105aa13f6118d3c7890099329a96">SAMRAIVectorReal::addComponent</a>, you can use the vector norm functions of <a class="el" href="classSAMRAI_1_1solv_1_1SAMRAIVectorReal.html">SAMRAIVectorReal</a>, and the weights will be used to blank out coarse grid regions under fine grids.</p>
<p>The weights computed are specific to the cell-centered discretization used by this class. The weight is equal to the cell volume if the cell has not been refined, and zero if it has.</p>
<p>This function is state-independent. All inputs are in the argument list.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hierarchy</em>&nbsp;</td><td>Hierarchy configuration to compute weights for </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>weight_id</em>&nbsp;</td><td><a class="el" href="classSAMRAI_1_1hier_1_1Patch.html" title="A container for patch data objects defined over a box.">hier::Patch</a> data index of the weight </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>coarsest_ln</em>&nbsp;</td><td>Coarsest level number. Must be included in hierarchy. Must not be greater than <code>finest_ln</code>. Default to 0. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>finest_ln</em>&nbsp;</td><td>Finest level number. Must be included in hierarchy. Must not be less than <code>coarsest_ln</code>. Default to finest level in <code>hierarchy</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>hierarchy </dd>
<dd>
d_dim == hierarchy-&gt;getDim() </dd>
<dd>
finest_ln &gt;= coarsest_ln </dd></dl>

<p>References <a class="el" href="Utilities_8h_source.html#l00149">BOOST_CAST</a>, <a class="el" href="Box_8h_source.html#l00613">SAMRAI::hier::Box::empty()</a>, <a class="el" href="Utilities_8h_source.html#l00110">TBOX_ASSERT</a>, <a class="el" href="Utilities_8h_source.html#l00233">TBOX_ASSERT_DIM_OBJDIM_EQUALITY1</a>, and <a class="el" href="Utilities_8h_source.html#l00060">TBOX_ERROR</a>.</p>

</div>
</div>
<a class="anchor" id="aa3c056ef1fa85484aeeb4ae12539f78e"></a><!-- doxytag: member="SAMRAI::solv::CellPoissonFACOps::setPreconditioner" ref="aa3c056ef1fa85484aeeb4ae12539f78e" args="(const FACPreconditioner *preconditioner)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::solv::CellPoissonFACOps::setPreconditioner </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1solv_1_1FACPreconditioner.html">FACPreconditioner</a> *&nbsp;</td>
          <td class="paramname"> <em>preconditioner</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set the FAC preconditioner that will be using this object. </p>
<p>The FAC preconditioner is accessed to get convergence data during the cycle postprocessing step. It is optional. </p>

</div>
</div>
<a class="anchor" id="a84c366a3490f4eb173f1e3486bf8829a"></a><!-- doxytag: member="SAMRAI::solv::CellPoissonFACOps::computeFluxOnPatch" ref="a84c366a3490f4eb173f1e3486bf8829a" args="(const hier::Patch &amp;patch, const hier::IntVector &amp;ratio_to_coarser_level, const pdat::CellData&lt; double &gt; &amp;w_data, pdat::SideData&lt; double &gt; &amp;Dgradw_data) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::solv::CellPoissonFACOps::computeFluxOnPatch </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1Patch.html">hier::Patch</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>patch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>ratio_to_coarser_level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1pdat_1_1CellData.html">pdat::CellData</a>&lt; double &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>w_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1pdat_1_1SideData.html">pdat::SideData</a>&lt; double &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>Dgradw_data</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>function to compute flux, using general diffusion coefficient data. </p>
<p>Recall that this solver class discretizes the PDE </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \nabla \cdot D \nabla u + C u = f \]" src="form_50.png"/>
</p>
<p> on an AMR grid. This member function allows users of this solver class to compute gradient terms, </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ D \nabla w \]" src="form_55.png"/>
</p>
<p>, in their code in a manner consistent with the solver discretization. In particular, when solving PDE systems, it may be necessary to discretize the gradient operator appearing in equations not treated by the solver class in the same way as those treated by this class. These funtions allow users to do this easily. The divergence operator used in this solver is the standard sum of centered differences involving flux terms on the cell sides computed by these routines.</p>
<p>Note that the patch must exist on a level in an AMR hierarchy so that the discretization can be computed properly at the coarse-fine interface. Poisson coefficients C and D must exist on the patch, if they are variable. Also, calling this function does not affect the internal solver state in any way. However, the solver must be fully initialized before it is called and care should be exercised to pass arguments so that the solver solution quantity and other internal solver quantities are not adversely affected.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>patch</em>&nbsp;</td><td>patch on which computation will take place </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ratio_to_coarser_level</em>&nbsp;</td><td>refinement ratio from coarser level to level on which patch lives; if current patch level is level zero, this is ignored </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>w_data</em>&nbsp;</td><td>cell-centered data </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Dgradw_data</em>&nbsp;</td><td>side-centered flux data (i.e., D (grad w))</td></tr>
  </table>
  </dd>
</dl>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>(d_dim == patch.getDim()) &amp;&amp; (d_dim == ratio_to_coarser_level.getDim()) &amp;&amp; (d_dim == w_data.getDim()) &amp;&amp; (d_dim == Dgradw_data.getDim()) </dd>
<dd>
patch.inHierarchy() </dd>
<dd>
w_data.getGhostCellWidth() &gt;= <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html#a2d8aeb3c6ed3270611091ba13dab8f40" title="Return an IntVector of ones of the specified dimension.">hier::IntVector::getOne</a>(ratio_to_coarser_level.getDim()) </dd></dl>

<p>References <a class="el" href="Utilities_8h_source.html#l00149">BOOST_CAST</a>, <a class="el" href="PoissonSpecifications_8h_source.html#l00146">SAMRAI::solv::PoissonSpecifications::dIsConstant()</a>, <a class="el" href="Patch_8h_source.html#l00092">SAMRAI::hier::Patch::getBox()</a>, <a class="el" href="PoissonSpecifications_8h_source.html#l00181">SAMRAI::solv::PoissonSpecifications::getDConstant()</a>, <a class="el" href="IntVector_8h_source.html#l01118">SAMRAI::hier::IntVector::getDim()</a>, <a class="el" href="PoissonSpecifications_8h_source.html#l00161">SAMRAI::solv::PoissonSpecifications::getDPatchDataId()</a>, <a class="el" href="PatchData_8h_source.html#l00102">SAMRAI::hier::PatchData::getGhostCellWidth()</a>, <a class="el" href="IntVector_8h_source.html#l01143">SAMRAI::hier::IntVector::getOne()</a>, <a class="el" href="Patch_8h_source.html#l00156">SAMRAI::hier::Patch::getPatchData()</a>, <a class="el" href="Patch_8h_source.html#l00344">SAMRAI::hier::Patch::getPatchGeometry()</a>, <a class="el" href="Patch_8h_source.html#l00406">SAMRAI::hier::Patch::getPatchLevelNumber()</a>, <a class="el" href="CellData_8C_source.html#l00104">SAMRAI::pdat::CellData&lt; TYPE &gt;::getPointer()</a>, <a class="el" href="SideData_8C_source.html#l00106">SAMRAI::pdat::SideData&lt; TYPE &gt;::getPointer()</a>, <a class="el" href="Patch_8h_source.html#l00433">SAMRAI::hier::Patch::inHierarchy()</a>, <a class="el" href="Box_8h_source.html#l00495">SAMRAI::hier::Box::lower()</a>, <a class="el" href="CellPoissonFACOps_8C_source.html#l00069">SAMRAI::solv::SAMRAI_F77_FUNC()</a>, <a class="el" href="Utilities_8h_source.html#l00110">TBOX_ASSERT</a>, <a class="el" href="Utilities_8h_source.html#l00251">TBOX_ASSERT_DIM_OBJDIM_EQUALITY4</a>, and <a class="el" href="Box_8h_source.html#l00515">SAMRAI::hier::Box::upper()</a>.</p>

<p>Referenced by <a class="el" href="CellPoissonFACOps_8C_source.html#l01789">computeCompositeResidualOnLevel()</a>.</p>

</div>
</div>
<a class="anchor" id="a519af350efc4c727346d102c9de49c3a"></a><!-- doxytag: member="SAMRAI::solv::CellPoissonFACOps::restrictSolution" ref="a519af350efc4c727346d102c9de49c3a" args="(const SAMRAIVectorReal&lt; double &gt; &amp;source, SAMRAIVectorReal&lt; double &gt; &amp;dest, int dest_ln)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::solv::CellPoissonFACOps::restrictSolution </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1solv_1_1SAMRAIVectorReal.html">SAMRAIVectorReal</a>&lt; double &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1solv_1_1SAMRAIVectorReal.html">SAMRAIVectorReal</a>&lt; double &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>dest_ln</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Restrict the solution quantity to the specified level from the next finer level. </p>
<p>Restrict the residual data to level dest_ln in the destination vector d, from level dest_ln+1 in the source vector s.</p>
<p>Can assume:</p>
<ol type="1">
<li>dest_ln is not the finest level in the range being solved.</li>
<li>corresponding solution has been computed on level dest_ln+1.</li>
<li>the source and destination residual vectors may or may not be the same. (This method must work in either case.)</li>
</ol>
<p>Upon return from this function, the solution on the refined region of the coarse level will represent the coarsened version of the fine solution in a manner that is consistent with the linear system approximation on the composite grid. This function must not change the solution values anywhere except on level dest_ln of the destination vector.</p>
<p>The source and destination vectors may be the same.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>source</em>&nbsp;</td><td>source solution </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dest</em>&nbsp;</td><td>destination solution </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dest_ln</em>&nbsp;</td><td>destination level number </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classSAMRAI_1_1solv_1_1FACOperatorStrategy.html#a5030937d907996a88c7190d87e2fd89e">SAMRAI::solv::FACOperatorStrategy</a>.</p>

<p>References <a class="el" href="SAMRAIVectorReal_8C_source.html#l01106">SAMRAI::solv::SAMRAIVectorReal&lt; TYPE &gt;::getComponentDescriptorIndex()</a>, <a class="el" href="CartesianRobinBcHelper_8h_source.html#l00346">SAMRAI::solv::CartesianRobinBcHelper::setHomogeneousBc()</a>, and <a class="el" href="CartesianRobinBcHelper_8h_source.html#l00328">SAMRAI::solv::CartesianRobinBcHelper::setTargetDataId()</a>.</p>

</div>
</div>
<a class="anchor" id="a9a76c90308783470ee687e9a68777681"></a><!-- doxytag: member="SAMRAI::solv::CellPoissonFACOps::restrictResidual" ref="a9a76c90308783470ee687e9a68777681" args="(const SAMRAIVectorReal&lt; double &gt; &amp;source, SAMRAIVectorReal&lt; double &gt; &amp;dest, int dest_ln)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::solv::CellPoissonFACOps::restrictResidual </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1solv_1_1SAMRAIVectorReal.html">SAMRAIVectorReal</a>&lt; double &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1solv_1_1SAMRAIVectorReal.html">SAMRAIVectorReal</a>&lt; double &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>dest_ln</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Restrict the residual quantity to the specified level from the next finer level. </p>
<p>Restrict the residual data to level dest_ln in the destination vector d, from level dest_ln+1 in the source vector s.</p>
<p>Can assume:</p>
<ol type="1">
<li>dest_ln is not the finest level in the range being solved.</li>
<li>correspnding residual has been computed on level dest_ln+1.</li>
<li>the source and destination residual vectors may or may not be the same. (This method must work in either case.)</li>
</ol>
<p>Upon return from this function, the residual on the refined region of the coarse level will represent the coarsened version of the fine residual in a manner that is consistent with the linear system approximation on the composite grid. This function must not change the residual values anywhere except on level dest_ln of the destination vector.</p>
<p>The source and destination vectors may be the same.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>source</em>&nbsp;</td><td>source residual </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dest</em>&nbsp;</td><td>destination residual </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dest_ln</em>&nbsp;</td><td>destination level number </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classSAMRAI_1_1solv_1_1FACOperatorStrategy.html#a39ad805a6e850d759239166842d02be7">SAMRAI::solv::FACOperatorStrategy</a>.</p>

<p>References <a class="el" href="SAMRAIVectorReal_8C_source.html#l01106">SAMRAI::solv::SAMRAIVectorReal&lt; TYPE &gt;::getComponentDescriptorIndex()</a>.</p>

</div>
</div>
<a class="anchor" id="a039613b32f29f73b7f2e12f9d14080ac"></a><!-- doxytag: member="SAMRAI::solv::CellPoissonFACOps::prolongErrorAndCorrect" ref="a039613b32f29f73b7f2e12f9d14080ac" args="(const SAMRAIVectorReal&lt; double &gt; &amp;source, SAMRAIVectorReal&lt; double &gt; &amp;dest, int dest_ln)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::solv::CellPoissonFACOps::prolongErrorAndCorrect </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1solv_1_1SAMRAIVectorReal.html">SAMRAIVectorReal</a>&lt; double &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1solv_1_1SAMRAIVectorReal.html">SAMRAIVectorReal</a>&lt; double &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>dest_ln</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Prolong the error quantity to the specified level from the next coarser level and apply the correction to the fine-level error. </p>
<p>On the part of the coarse level that does <em>not</em> overlap the fine level, the error is the corection to Au=f.</p>
<p>On the part of the coarse level that <em>does</em> overlap the fine level, the error is the corection to Ae=r of the fine level.</p>
<p>This function should apply the coarse-level correction to the fine level, that is </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ e^{fine} \leftarrow e^{fine} + I^{fine}_{coarse} e^{coarse} \]" src="form_58.png"/>
</p>
<p><b>Note:</b> You probably have to store the refined error in a temporary location before adding it to the current error.</p>
<p>The array of boundary information contains a description of the coarse-fine level boundary for each patch on the level; the boundary information for patch N is obtained as the N-th element in the array, coarse_fine_boundary[N].</p>
<p>Upon return from this function, the error on the fine level must represent the correction to the solution on that level. Also, this function must not change the error values on the coarse level.</p>
<p>The source and destination vectors may be the same.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>source</em>&nbsp;</td><td>source error vector </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dest</em>&nbsp;</td><td>destination error vector </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dest_ln</em>&nbsp;</td><td>destination level number of data transfer </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classSAMRAI_1_1solv_1_1FACOperatorStrategy.html#a23e9def6e2f18a274a0636820e96f17a">SAMRAI::solv::FACOperatorStrategy</a>.</p>

<p>References <a class="el" href="HierarchyCellDataOpsReal_8C_source.html#l00329">SAMRAI::math::HierarchyCellDataOpsReal&lt; TYPE &gt;::add()</a>, <a class="el" href="SAMRAIVectorReal_8C_source.html#l01106">SAMRAI::solv::SAMRAIVectorReal&lt; TYPE &gt;::getComponentDescriptorIndex()</a>, <a class="el" href="SAMRAIVectorReal_8C_source.html#l01043">SAMRAI::solv::SAMRAIVectorReal&lt; TYPE &gt;::getPatchHierarchy()</a>, <a class="el" href="CartesianRobinBcHelper_8h_source.html#l00346">SAMRAI::solv::CartesianRobinBcHelper::setHomogeneousBc()</a>, <a class="el" href="CartesianRobinBcHelper_8h_source.html#l00328">SAMRAI::solv::CartesianRobinBcHelper::setTargetDataId()</a>, and <a class="el" href="Utilities_8h_source.html#l00060">TBOX_ERROR</a>.</p>

</div>
</div>
<a class="anchor" id="a83625dda387afc4b50a9359967990b96"></a><!-- doxytag: member="SAMRAI::solv::CellPoissonFACOps::smoothError" ref="a83625dda387afc4b50a9359967990b96" args="(SAMRAIVectorReal&lt; double &gt; &amp;error, const SAMRAIVectorReal&lt; double &gt; &amp;residual, int ln, int num_sweeps)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::solv::CellPoissonFACOps::smoothError </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1solv_1_1SAMRAIVectorReal.html">SAMRAIVectorReal</a>&lt; double &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>error</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1solv_1_1SAMRAIVectorReal.html">SAMRAIVectorReal</a>&lt; double &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>residual</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>ln</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>num_sweeps</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Perform a given number of relaxations on the error. </p>
<p>Relax the residual equation Ae=r by applying the given number of smoothing sweeps on the specified level. The relaxation may ignore the possible existence of finer levels on a given level.</p>
<p>The array of boundary information contains a description of the coarse-fine level boundary for each patch on the level; the boundary information for patch N is obtained as the N-th element in the array, coarse_fine_boundary[N].</p>
<p>May assume:</p>
<ul>
<li>If intermediate data from level l+1 is needed (for example, to match flux at coarse-fine boundaries), that data is already computed and stored on level l+1.</li>
<li>The error in the next finer level has been computed and stored there.</li>
</ul>
<p>Steps for each iteration.</p>
<ol type="1">
<li>Fill ghost boundaries</li>
<li>Compute intermediate data (if needed) and coarsen intermediate data stored in level l+1 (if needed).</li>
<li>Perform relaxation step (update e toward a better approximation).</li>
</ol>
<p>Final step before leaving function.</p>
<ul>
<li>If needed, compute and store intermediate data for next coarser level l-1.</li>
</ul>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>error</em>&nbsp;</td><td>error vector </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>residual</em>&nbsp;</td><td>residual vector </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ln</em>&nbsp;</td><td>level number </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>num_sweeps</em>&nbsp;</td><td>number of sweeps </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classSAMRAI_1_1solv_1_1FACOperatorStrategy.html#aefd99edc26ae9390c63a4f67d03fe280">SAMRAI::solv::FACOperatorStrategy</a>.</p>

<p>References <a class="el" href="CellPoissonFACOps_8C_source.html#l02108">checkInputPatchDataIndices()</a>.</p>

<p>Referenced by <a class="el" href="CellPoissonFACOps_8C_source.html#l01678">solveCoarsestLevel()</a>.</p>

</div>
</div>
<a class="anchor" id="af0def579f9a4ffa10dd39f89a4b63245"></a><!-- doxytag: member="SAMRAI::solv::CellPoissonFACOps::solveCoarsestLevel" ref="af0def579f9a4ffa10dd39f89a4b63245" args="(SAMRAIVectorReal&lt; double &gt; &amp;error, const SAMRAIVectorReal&lt; double &gt; &amp;residual, int coarsest_ln)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int SAMRAI::solv::CellPoissonFACOps::solveCoarsestLevel </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1solv_1_1SAMRAIVectorReal.html">SAMRAIVectorReal</a>&lt; double &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>error</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1solv_1_1SAMRAIVectorReal.html">SAMRAIVectorReal</a>&lt; double &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>residual</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>coarsest_ln</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Solve the residual equation Ae=r on the coarsest level in the FAC iteration. </p>
<p>Here e is the given error quantity and r is the given residual quantity. The array of boundary information contains a description of the coarse-fine level boundary for each patch on the level; the boundary information for patch N is obtained as the N-th element in the array, coarse_fine_boundary[N].</p>
<p>This routine must fill boundary values for given solution quantity on all patches on the specified level before the solve is performed.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>error</em>&nbsp;</td><td>error vector </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>residual</em>&nbsp;</td><td>residual vector </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>coarsest_ln</em>&nbsp;</td><td>coarsest level number </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 if solver converged to specified level, nonzero otherwise. </dd></dl>

<p>Implements <a class="el" href="classSAMRAI_1_1solv_1_1FACOperatorStrategy.html#a2a1b36e8d09e7639541c5bb05e3d33f9">SAMRAI::solv::FACOperatorStrategy</a>.</p>

<p>References <a class="el" href="CellPoissonFACOps_8C_source.html#l02108">checkInputPatchDataIndices()</a>, <a class="el" href="SAMRAIVectorReal_8C_source.html#l01106">SAMRAI::solv::SAMRAIVectorReal&lt; TYPE &gt;::getComponentDescriptorIndex()</a>, <a class="el" href="CellPoissonFACOps_8C_source.html#l01309">smoothError()</a>, and <a class="el" href="Utilities_8h_source.html#l00060">TBOX_ERROR</a>.</p>

</div>
</div>
<a class="anchor" id="a82e1606b80843a097c4d99763a41e232"></a><!-- doxytag: member="SAMRAI::solv::CellPoissonFACOps::computeCompositeResidualOnLevel" ref="a82e1606b80843a097c4d99763a41e232" args="(SAMRAIVectorReal&lt; double &gt; &amp;residual, const SAMRAIVectorReal&lt; double &gt; &amp;solution, const SAMRAIVectorReal&lt; double &gt; &amp;rhs, int ln, bool error_equation_indicator)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::solv::CellPoissonFACOps::computeCompositeResidualOnLevel </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1solv_1_1SAMRAIVectorReal.html">SAMRAIVectorReal</a>&lt; double &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>residual</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1solv_1_1SAMRAIVectorReal.html">SAMRAIVectorReal</a>&lt; double &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>solution</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1solv_1_1SAMRAIVectorReal.html">SAMRAIVectorReal</a>&lt; double &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>ln</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>error_equation_indicator</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compute composite grid residual on a single level. </p>
<p>For the specified level number ln, compute the <em>composite</em> residual r=f-Au, where f is the right hand side and u is the solution. Note that the composite residual is not a one-level residual. It must take into account the composite grid stencil around the coarse-fine grid interface.</p>
<p>May assume:</p>
<ul>
<li>Composite residual on next finer level l+1, has been computed already.</li>
<li>If any intermediately computed data is needed from level l+1, it has been done and stored on that level.</li>
<li>Residual computations for the original equation and the error equations will not be intermingled within one FAC cycle.</li>
</ul>
<p>Steps:</p>
<ol type="1">
<li>Fill boundary ghosts.</li>
<li>If needed, coarsen intermediate data from level l+1.</li>
<li>Compute residual <img class="formulaInl" alt="$ r^l \leftarrow f - A u^l $" src="form_59.png"/>.</li>
</ol>
<p>Final step before leaving function:</p>
<ul>
<li>If any intermediately computed data is needed in at level l-1, it must be computed and stored before leaving this function.</li>
</ul>
<p><b>Important:</b> Do not restrict residual from finer levels. (However, you must write the function <a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonFACOps.html#a9a76c90308783470ee687e9a68777681" title="Restrict the residual quantity to the specified level from the next finer level.">restrictResidual()</a> to do this.)</p>
<p><b>Important:</b> This function must also work when the right-hand-side and the residual are identical. In that case, it should effectively do <img class="formulaInl" alt="$ r \leftarrow r - A u $" src="form_60.png"/>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>residual</em>&nbsp;</td><td>residual vector </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>solution</em>&nbsp;</td><td>solution vector </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>rhs</em>&nbsp;</td><td>source (right hand side) vector </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ln</em>&nbsp;</td><td>level number </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>error_equation_indicator</em>&nbsp;</td><td>flag stating whether u is an error vector or a solution vector </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classSAMRAI_1_1solv_1_1FACOperatorStrategy.html#a6c5f405d18477a61e41e62d4d68af5c8">SAMRAI::solv::FACOperatorStrategy</a>.</p>

<p>References <a class="el" href="Utilities_8h_source.html#l00149">BOOST_CAST</a>, <a class="el" href="CellPoissonFACOps_8C_source.html#l02108">checkInputPatchDataIndices()</a>, <a class="el" href="CellPoissonFACOps_8C_source.html#l02154">computeFluxOnPatch()</a>, <a class="el" href="SAMRAIVectorReal_8C_source.html#l01106">SAMRAI::solv::SAMRAIVectorReal&lt; TYPE &gt;::getComponentDescriptorIndex()</a>, <a class="el" href="SAMRAIVectorReal_8C_source.html#l01071">SAMRAI::solv::SAMRAIVectorReal&lt; TYPE &gt;::getComponentPatchData()</a>, <a class="el" href="SAMRAIVectorReal_8C_source.html#l01043">SAMRAI::solv::SAMRAIVectorReal&lt; TYPE &gt;::getPatchHierarchy()</a>, <a class="el" href="CartesianRobinBcHelper_8h_source.html#l00346">SAMRAI::solv::CartesianRobinBcHelper::setHomogeneousBc()</a>, <a class="el" href="CartesianRobinBcHelper_8h_source.html#l00328">SAMRAI::solv::CartesianRobinBcHelper::setTargetDataId()</a>, <a class="el" href="Utilities_8h_source.html#l00110">TBOX_ASSERT</a>, and <a class="el" href="Utilities_8h_source.html#l00060">TBOX_ERROR</a>.</p>

</div>
</div>
<a class="anchor" id="ab2091fb3e4e044ffdbf773918abcf9b7"></a><!-- doxytag: member="SAMRAI::solv::CellPoissonFACOps::computeResidualNorm" ref="ab2091fb3e4e044ffdbf773918abcf9b7" args="(const SAMRAIVectorReal&lt; double &gt; &amp;residual, int fine_ln, int coarse_ln)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double SAMRAI::solv::CellPoissonFACOps::computeResidualNorm </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1solv_1_1SAMRAIVectorReal.html">SAMRAIVectorReal</a>&lt; double &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>residual</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>fine_ln</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>coarse_ln</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compute the norm of the residual quantity. </p>
<p>Compute norm of the given residual on the given range of hierarchy levels. The residual vector is computed already and you should <b>not</b> change it. The only purpose of this function to allow you to choose how to define the norm.</p>
<p>The norm value is used during the FAC iteration to determine convergence of the composite grid linear system.</p>
<p>Residual values that lie under a finer level should not be counted.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>residual</em>&nbsp;</td><td>residual vector </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>fine_ln</em>&nbsp;</td><td>finest level number </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>coarse_ln</em>&nbsp;</td><td>coarsest level number</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>norm value of residual vector, which should be non-negative </dd></dl>

<p>Implements <a class="el" href="classSAMRAI_1_1solv_1_1FACOperatorStrategy.html#abc03df2bcd01320f9d482aee213a684a">SAMRAI::solv::FACOperatorStrategy</a>.</p>

<p>References <a class="el" href="SAMRAIVectorReal_8C_source.html#l01050">SAMRAI::solv::SAMRAIVectorReal&lt; TYPE &gt;::getCoarsestLevelNumber()</a>, <a class="el" href="SAMRAIVectorReal_8C_source.html#l01057">SAMRAI::solv::SAMRAIVectorReal&lt; TYPE &gt;::getFinestLevelNumber()</a>, <a class="el" href="SAMRAIVectorReal_8C_source.html#l00819">SAMRAI::solv::SAMRAIVectorReal&lt; TYPE &gt;::RMSNorm()</a>, and <a class="el" href="Utilities_8h_source.html#l00060">TBOX_ERROR</a>.</p>

</div>
</div>
<a class="anchor" id="a2da31e44d1cf2f54f7a941b6623fd7be"></a><!-- doxytag: member="SAMRAI::solv::CellPoissonFACOps::initializeOperatorState" ref="a2da31e44d1cf2f54f7a941b6623fd7be" args="(const SAMRAIVectorReal&lt; double &gt; &amp;solution, const SAMRAIVectorReal&lt; double &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::solv::CellPoissonFACOps::initializeOperatorState </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1solv_1_1SAMRAIVectorReal.html">SAMRAIVectorReal</a>&lt; double &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>solution</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1solv_1_1SAMRAIVectorReal.html">SAMRAIVectorReal</a>&lt; double &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compute hierarchy-dependent data if any is required. </p>
<p>This function is called when the hierarchy configuration changes. If you maintain any hierarchy-dependent data in your implementation (for example, caching communication schedules or computing coarse-fine boundaries), use this function to update that data.</p>
<p>If you do not maintain such data, this function may be empty.</p>
<p>Note that although the vector arguments given to other methods in this class may not necessarily be the same as those given to this method, there will be similarities, including:</p>
<ul>
<li>hierarchy configuration (hierarchy pointer and level range)</li>
<li>number, type and alignment of vector component data</li>
<li>ghost cell width of data in the solution (or solution-like) vector</li>
</ul>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>solution</em>&nbsp;</td><td>solution vector u </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>rhs</em>&nbsp;</td><td>right hand side vector f</td></tr>
  </table>
  </dd>
</dl>
<p>The default implementation does nothing. </p>

<p>Implements <a class="el" href="classSAMRAI_1_1solv_1_1FACOperatorStrategy.html#adfa77ec960a1855561aa7bfe7fe3ae4c">SAMRAI::solv::FACOperatorStrategy</a>.</p>

<p>References <a class="el" href="Utilities_8h_source.html#l00149">BOOST_CAST</a>, <a class="el" href="CellPoissonFACOps_8C_source.html#l01114">deallocateOperatorState()</a>, <a class="el" href="SAMRAIVectorReal_8C_source.html#l01050">SAMRAI::solv::SAMRAIVectorReal&lt; TYPE &gt;::getCoarsestLevelNumber()</a>, <a class="el" href="SAMRAIVectorReal_8C_source.html#l01106">SAMRAI::solv::SAMRAIVectorReal&lt; TYPE &gt;::getComponentDescriptorIndex()</a>, <a class="el" href="VariableDatabase_8C_source.html#l00044">SAMRAI::hier::VariableDatabase::getDatabase()</a>, <a class="el" href="SAMRAIVectorReal_8C_source.html#l01057">SAMRAI::solv::SAMRAIVectorReal&lt; TYPE &gt;::getFinestLevelNumber()</a>, <a class="el" href="SAMRAIVectorReal_8C_source.html#l01064">SAMRAI::solv::SAMRAIVectorReal&lt; TYPE &gt;::getNumberOfComponents()</a>, <a class="el" href="IntVector_8h_source.html#l01143">SAMRAI::hier::IntVector::getOne()</a>, <a class="el" href="Patch_8h_source.html#l00156">SAMRAI::hier::Patch::getPatchData()</a>, <a class="el" href="SAMRAIVectorReal_8C_source.html#l01043">SAMRAI::solv::SAMRAIVectorReal&lt; TYPE &gt;::getPatchHierarchy()</a>, <a class="el" href="VariableDatabase_8C_source.html#l00564">SAMRAI::hier::VariableDatabase::mapIndexToVariable()</a>, <a class="el" href="Utilities_8h_source.html#l00110">TBOX_ASSERT</a>, <a class="el" href="Utilities_8h_source.html#l00060">TBOX_ERROR</a>, and <a class="el" href="Utilities_8h_source.html#l00070">TBOX_WARNING</a>.</p>

</div>
</div>
<a class="anchor" id="af48e45974c427278215ae11ee7bba734"></a><!-- doxytag: member="SAMRAI::solv::CellPoissonFACOps::deallocateOperatorState" ref="af48e45974c427278215ae11ee7bba734" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::solv::CellPoissonFACOps::deallocateOperatorState </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Remove all hierarchy-dependent data. </p>
<p>Remove all hierarchy-dependent data set by <a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonFACOps.html#a2da31e44d1cf2f54f7a941b6623fd7be" title="Compute hierarchy-dependent data if any is required.">initializeOperatorState()</a>.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonFACOps.html#a2da31e44d1cf2f54f7a941b6623fd7be" title="Compute hierarchy-dependent data if any is required.">initializeOperatorState</a> </dd></dl>

<p>Reimplemented from <a class="el" href="classSAMRAI_1_1solv_1_1FACOperatorStrategy.html#ab1a9e2eef933ee70d5aed9e7a0274a1a">SAMRAI::solv::FACOperatorStrategy</a>.</p>

<p>Referenced by <a class="el" href="CellPoissonFACOps_8C_source.html#l00748">initializeOperatorState()</a>.</p>

</div>
</div>
<a class="anchor" id="a554bf193dfb039a95c9a6e7f9af40d77"></a><!-- doxytag: member="SAMRAI::solv::CellPoissonFACOps::postprocessOneCycle" ref="a554bf193dfb039a95c9a6e7f9af40d77" args="(int fac_cycle_num, const SAMRAIVectorReal&lt; double &gt; &amp;current_soln, const SAMRAIVectorReal&lt; double &gt; &amp;residual)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::solv::CellPoissonFACOps::postprocessOneCycle </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>fac_cycle_num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1solv_1_1SAMRAIVectorReal.html">SAMRAIVectorReal</a>&lt; double &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>current_soln</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1solv_1_1SAMRAIVectorReal.html">SAMRAIVectorReal</a>&lt; double &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>residual</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Regular call back routine to be called after each FAC cycle. </p>
<p>This function is called after each FAC cycle. It allows you to monitor the progress and do other things. You should <em>not</em> modify the solution vector in the argument.</p>
<p>The default implementation does nothing.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>fac_cycle_num</em>&nbsp;</td><td>FAC cycle number completed </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>current_soln</em>&nbsp;</td><td>current solution </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>residual</em>&nbsp;</td><td>residual based on the current solution </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classSAMRAI_1_1solv_1_1FACOperatorStrategy.html#a8bbf9cd1d5417272cfaa20c68f8f90d4">SAMRAI::solv::FACOperatorStrategy</a>.</p>

<p>References <a class="el" href="FACPreconditioner_8h_source.html#l00397">SAMRAI::solv::FACPreconditioner::getAvgConvergenceFactor()</a>, <a class="el" href="FACPreconditioner_8h_source.html#l00349">SAMRAI::solv::FACPreconditioner::getConvergenceFactors()</a>, <a class="el" href="FACPreconditioner_8h_source.html#l00375">SAMRAI::solv::FACPreconditioner::getNetConvergenceFactor()</a>, <a class="el" href="FACPreconditioner_8h_source.html#l00439">SAMRAI::solv::FACPreconditioner::getResidualNorm()</a>, <a class="el" href="Utilities_8h_source.html#l00050">NULL_USE</a>, and <a class="el" href="namespaceSAMRAI_1_1tbox.html#ab84041705493761fb17a8127e3a2dca2">SAMRAI::tbox::plog</a>.</p>

</div>
</div>
<a class="anchor" id="a5ba16397bffad8e27cff8c1e0ef5cb67"></a><!-- doxytag: member="SAMRAI::solv::CellPoissonFACOps::getObjectName" ref="a5ba16397bffad8e27cff8c1e0ef5cb67" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::string&amp; SAMRAI::solv::CellPoissonFACOps::getObjectName </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the name of this object. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>The name of this object. </dd></dl>

</div>
</div>
<a class="anchor" id="a7ac920307882c4f0476b5eca670291c9"></a><!-- doxytag: member="SAMRAI::solv::CellPoissonFACOps::getFromInput" ref="a7ac920307882c4f0476b5eca670291c9" args="(const boost::shared_ptr&lt; tbox::Database &gt; &amp;input_db)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::solv::CellPoissonFACOps::getFromInput </td>
          <td>(</td>
          <td class="paramtype">const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Database.html">tbox::Database</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>input_db</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Read parameters from input database. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>input_db</em>&nbsp;</td><td>Input Database. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="Database_8h_source.html#l00026">INPUT_RANGE_ERROR</a>, and <a class="el" href="Database_8h_source.html#l00030">INPUT_VALUE_ERROR</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>source/SAMRAI/solv/<a class="el" href="CellPoissonFACOps_8h.html">CellPoissonFACOps.h</a></li>
<li>source/SAMRAI/solv/<a class="el" href="CellPoissonFACOps_8C.html">CellPoissonFACOps.C</a></li>
</ul>
</div>
<hr size="1"/><address style="text-align: right;"><small>Generated on 5 Jun 2015 for SAMRAI by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.1 </small></address>
</body>
</html>
