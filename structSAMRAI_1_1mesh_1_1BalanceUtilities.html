<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>SAMRAI: SAMRAI::mesh::BalanceUtilities Struct Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.7 -->
<div class="tabs">
  <ul>
    <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="namespaces.html"><span>Namespaces</span></a></li>
    <li id="current"><a href="annotated.html"><span>Classes</span></a></li>
    <li><a href="files.html"><span>Files</span></a></li>
    <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
  </ul></div>
<div class="tabs">
  <ul>
    <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
    <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
    <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
  </ul></div>
<div class="nav">
<a class="el" href="namespaceSAMRAI.html">SAMRAI</a>::<a class="el" href="namespaceSAMRAI_1_1mesh.html">mesh</a>::<a class="el" href="structSAMRAI_1_1mesh_1_1BalanceUtilities.html">BalanceUtilities</a></div>
<h1>SAMRAI::mesh::BalanceUtilities Struct Reference</h1><!-- doxytag: class="SAMRAI::mesh::BalanceUtilities" -->Utility class <a class="el" href="structSAMRAI_1_1mesh_1_1BalanceUtilities.html">BalanceUtilities</a> provides several functions useful in various load balancing operations. These utilities include bin packing operations, box chopping by recursive bisection, and computation of effective processor layouts for boxes.  
<a href="#_details">More...</a>
<p>
<code>#include &lt;source/SAMRAI/mesh/BalanceUtilities.h&gt;</code>
<p>
<a href="structSAMRAI_1_1mesh_1_1BalanceUtilities-members.html">List of all members.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Static Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSAMRAI_1_1mesh_1_1BalanceUtilities.html#9cf29c89fc3719cb605055c75d03cb48">binPack</a> (<a class="el" href="classSAMRAI_1_1hier_1_1ProcessorMapping.html">hier::ProcessorMapping</a> &amp;mapping, std::vector&lt; double &gt; &amp;weights, int nproc)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">static double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSAMRAI_1_1mesh_1_1BalanceUtilities.html#2f830e0fe5db6e51f868fafacdd65ad8">spatialBinPack</a> (<a class="el" href="classSAMRAI_1_1hier_1_1ProcessorMapping.html">hier::ProcessorMapping</a> &amp;mapping, std::vector&lt; double &gt; &amp;weights, <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">hier::BoxContainer</a> &amp;boxes, const int nproc)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSAMRAI_1_1mesh_1_1BalanceUtilities.html#f5c89c6c3e18619fec4ea501598b535f">recursiveBisectionUniform</a> (<a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">hier::BoxContainer</a> &amp;out_boxes, std::list&lt; double &gt; &amp;out_workloads, const <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">hier::BoxContainer</a> &amp;in_boxes, double ideal_workload, const double workload_tolerance, const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a> &amp;min_size, const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a> &amp;cut_factor, const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a> &amp;bad_interval, const <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">hier::BoxContainer</a> &amp;physical_domain)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSAMRAI_1_1mesh_1_1BalanceUtilities.html#91743b7dae52696baf20837ad5df2dbf">recursiveBisectionNonuniform</a> (<a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">hier::BoxContainer</a> &amp;out_boxes, std::list&lt; double &gt; &amp;out_workloads, const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchLevel.html">hier::PatchLevel</a> &gt; &amp;in_level, int work_id, double ideal_workload, const double workload_tolerance, const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a> &amp;min_size, const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a> &amp;cut_factor, const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a> &amp;bad_interval, const <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">hier::BoxContainer</a> &amp;physical_domain)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSAMRAI_1_1mesh_1_1BalanceUtilities.html#96a40c7af2adca69a5a77261e30ce5cd">computeDomainDependentProcessorLayout</a> (<a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a> &amp;proc_dist, int num_procs, const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">hier::Box</a> &amp;box)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSAMRAI_1_1mesh_1_1BalanceUtilities.html#0daffa849931598823d3f8a4f6be32c0">computeDomainIndependentProcessorLayout</a> (<a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a> &amp;proc_dist, int num_procs, const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">hier::Box</a> &amp;box)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSAMRAI_1_1mesh_1_1BalanceUtilities.html#1df6f03ad8e5a3b8bc1d5f36986d160a">sortDescendingBoxWorkloads</a> (<a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">hier::BoxContainer</a> &amp;boxes, std::vector&lt; double &gt; &amp;workload)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">static double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSAMRAI_1_1mesh_1_1BalanceUtilities.html#60465fbe335ac50e582163db963f2994">computeNonUniformWorkload</a> (const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1hier_1_1Patch.html">hier::Patch</a> &gt; &amp;patch, int wrk_indx, const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">hier::Box</a> &amp;box)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">static double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSAMRAI_1_1mesh_1_1BalanceUtilities.html#05fb541a77a1274dbf2cbb886eae3b2d">computeLoadBalanceEfficiency</a> (const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchLevel.html">hier::PatchLevel</a> &gt; &amp;level, std::ostream &amp;os, int workload_data_id=-1)</td></tr>

<tr><td colspan="2"><div class="groupHeader">Load balance reporting.</div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSAMRAI_1_1mesh_1_1BalanceUtilities.html#054d9a59baad0fe26c7cc310cf27999d">gatherAndReportLoadBalance</a> (double local_workload, const <a class="el" href="classSAMRAI_1_1tbox_1_1SAMRAI__MPI.html">tbox::SAMRAI_MPI</a> &amp;mpi, std::ostream &amp;output_stream=<a class="el" href="namespaceSAMRAI_1_1tbox.html#b84041705493761fb17a8127e3a2dca2">tbox::plog</a>)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gather workloads in an MPI group and write out a summary of load balance efficiency.  <a href="#054d9a59baad0fe26c7cc310cf27999d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSAMRAI_1_1mesh_1_1BalanceUtilities.html#58e2e65bfc260d9a27d4ebe66cf44c72">gatherAndReportLoadBalance</a> (const std::vector&lt; double &gt; &amp;local_loads, const <a class="el" href="classSAMRAI_1_1tbox_1_1SAMRAI__MPI.html">tbox::SAMRAI_MPI</a> &amp;mpi, std::ostream &amp;output_stream=<a class="el" href="namespaceSAMRAI_1_1tbox.html#b84041705493761fb17a8127e3a2dca2">tbox::plog</a>)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gather a sequence of workloads in an MPI group and write out a summary of load balance efficiency.  <a href="#58e2e65bfc260d9a27d4ebe66cf44c72"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSAMRAI_1_1mesh_1_1BalanceUtilities.html#20bee7295a9ef124f2616cd0da52c4de">reportLoadBalance</a> (const std::vector&lt; double &gt; &amp;workloads, std::ostream &amp;output_stream)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Write out a short report of how well load is balanced.  <a href="#20bee7295a9ef124f2616cd0da52c4de"></a><br></td></tr>
</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
Utility class <a class="el" href="structSAMRAI_1_1mesh_1_1BalanceUtilities.html">BalanceUtilities</a> provides several functions useful in various load balancing operations. These utilities include bin packing operations, box chopping by recursive bisection, and computation of effective processor layouts for boxes. 
<p>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="9cf29c89fc3719cb605055c75d03cb48"></a><!-- doxytag: member="SAMRAI::mesh::BalanceUtilities::binPack" ref="9cf29c89fc3719cb605055c75d03cb48" args="(hier::ProcessorMapping &amp;mapping, std::vector&lt; double &gt; &amp;weights, int nproc)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double SAMRAI::mesh::BalanceUtilities::binPack           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1hier_1_1ProcessorMapping.html">hier::ProcessorMapping</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>weights</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>nproc</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Assign workloads to processors using a greedy algorithm that attempts to distribute the sum of weights on each processor evenly across the given number of processors.<p>
<dl compact><dt><b>Returns:</b></dt><dd>double-valued estimate of the load balance efficiency (ranges from zero to one hundred percent)</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>mapping</em>&nbsp;</td><td>Output processor mapping. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>weights</em>&nbsp;</td><td>std::vector of double-valued weights to distribute. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nproc</em>&nbsp;</td><td>Integer number of processors, must be &gt; 0.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Precondition:</b></dt><dd>nproc &gt; 0 <p>
for each memeber of weights, w, w &gt;=0 </dd></dl>

</div>
</div><p>
<a class="anchor" name="2f830e0fe5db6e51f868fafacdd65ad8"></a><!-- doxytag: member="SAMRAI::mesh::BalanceUtilities::spatialBinPack" ref="2f830e0fe5db6e51f868fafacdd65ad8" args="(hier::ProcessorMapping &amp;mapping, std::vector&lt; double &gt; &amp;weights, hier::BoxContainer &amp;boxes, const int nproc)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double SAMRAI::mesh::BalanceUtilities::spatialBinPack           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1hier_1_1ProcessorMapping.html">hier::ProcessorMapping</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>weights</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">hier::BoxContainer</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>boxes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>nproc</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Assign boxes to processors so that boxes spatially near each other are likely to be assigned to processors near each other (assuming that processor ordering is reflected in processor rank) and so that the workload is approximately evenly distributed among the processors. The routine uses a Morton space-filling curve algorithm.<p>
Note that this routine potentially reorders the boxes passed in to achieve the first goal.<p>
<dl compact><dt><b>Returns:</b></dt><dd>Double-valued estimate of the load balance efficiency (ranges from zero to one hundred percent)</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>mapping</em>&nbsp;</td><td>Output processor mapping. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>weights</em>&nbsp;</td><td>std::vector of double-valued box weights to distribute. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>boxes</em>&nbsp;</td><td><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">hier::BoxContainer</a> of boxes to distribute to processors. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nproc</em>&nbsp;</td><td>Integer number of processors, must be &gt; 0.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Precondition:</b></dt><dd>nproc &gt; 0 <p>
weights.size() == boxes.size() </dd></dl>

</div>
</div><p>
<a class="anchor" name="f5c89c6c3e18619fec4ea501598b535f"></a><!-- doxytag: member="SAMRAI::mesh::BalanceUtilities::recursiveBisectionUniform" ref="f5c89c6c3e18619fec4ea501598b535f" args="(hier::BoxContainer &amp;out_boxes, std::list&lt; double &gt; &amp;out_workloads, const hier::BoxContainer &amp;in_boxes, double ideal_workload, const double workload_tolerance, const hier::IntVector &amp;min_size, const hier::IntVector &amp;cut_factor, const hier::IntVector &amp;bad_interval, const hier::BoxContainer &amp;physical_domain)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::mesh::BalanceUtilities::recursiveBisectionUniform           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">hier::BoxContainer</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>out_boxes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::list&lt; double &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>out_workloads</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">hier::BoxContainer</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>in_boxes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>ideal_workload</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>workload_tolerance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>min_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>cut_factor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>bad_interval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">hier::BoxContainer</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>physical_domain</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Recursively chop chops boxes in input boxlist until each box has a workload less than the prescribed ideal workload or no more more chopping is allowed by the given constraints. A spatially-uniform workload is assumed; i.e., all cells are weighted equally. This routine attempts to create as many boxes as possible with loads equal to or slightly less than the ideal workload value so that they can be mapped to processors effectively.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>out_boxes</em>&nbsp;</td><td>Output box list. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>out_workloads</em>&nbsp;</td><td>Output list of box workloads. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>in_boxes</em>&nbsp;</td><td>Input boxlist for chopping. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ideal_workload</em>&nbsp;</td><td>Input double ideal box workload, must be &gt; 0. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>workload_tolerance</em>&nbsp;</td><td>Input double workload tolerance, must be &gt;= 0 and &lt; 1.0 </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>min_size</em>&nbsp;</td><td>Input integer vector of minimum sizes for output boxes. All entries must be &gt; 0. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>cut_factor</em>&nbsp;</td><td>Input integer vector used to create boxes with correct sizes. The box size in each direction will be an integer multiple of the corresponding cut factor vector entry. All vector entries must be &gt; 0. See <a class="el" href="structSAMRAI_1_1hier_1_1BoxUtilities.html">hier::BoxUtilities</a> documentation for more details. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>bad_interval</em>&nbsp;</td><td>Input integer vector used to create boxes near physical domain boundary with sufficient number of cells. No box face will be closer to the boundary than the corresponding interval of cells to the boundary (the corresponding value is given by the normal direction of the box face) unless the face coincides with the boundary itself. The point of this argument is to have no patch live within a certain ghost cell width of the boundary if its boundary does not coincide with that boundary . That is, all ghost cells along a face will be either in the domain interior or outside the domain. All entries must be &gt;= 0. See <a class="el" href="structSAMRAI_1_1hier_1_1BoxUtilities.html">hier::BoxUtilities</a> documentation for more details. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>physical_domain</em>&nbsp;</td><td><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">hier::BoxContainer</a> of boxes describing the physical extent of the index space associated with the in_boxes. This box array cannot be empty.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Precondition:</b></dt><dd>(min_size.getDim() == cut_factor.getDim()) &amp;&amp; (min_size.getDim() == bad_interval.getDim()) <p>
ideal_workload &gt; 0 <p>
(workload_tolerance &gt;= 0) &amp;&amp; (workload_tolerance &lt; 1.0) <p>
min_size &gt; <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html#178dc4477a52ff09e80a2c3e86944e7f">hier::IntVector::getZero</a>(min_size.getDim()) <p>
cut_factor &gt; <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html#178dc4477a52ff09e80a2c3e86944e7f">hier::IntVector::getZero</a>(min_size.getDim()) <p>
bad_interval &gt;= <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html#178dc4477a52ff09e80a2c3e86944e7f">hier::IntVector::getZero</a>(min_size.getDim()) <p>
!physical_domain.isEmpty() </dd></dl>

</div>
</div><p>
<a class="anchor" name="91743b7dae52696baf20837ad5df2dbf"></a><!-- doxytag: member="SAMRAI::mesh::BalanceUtilities::recursiveBisectionNonuniform" ref="91743b7dae52696baf20837ad5df2dbf" args="(hier::BoxContainer &amp;out_boxes, std::list&lt; double &gt; &amp;out_workloads, const boost::shared_ptr&lt; hier::PatchLevel &gt; &amp;in_level, int work_id, double ideal_workload, const double workload_tolerance, const hier::IntVector &amp;min_size, const hier::IntVector &amp;cut_factor, const hier::IntVector &amp;bad_interval, const hier::BoxContainer &amp;physical_domain)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::mesh::BalanceUtilities::recursiveBisectionNonuniform           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">hier::BoxContainer</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>out_boxes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::list&lt; double &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>out_workloads</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchLevel.html">hier::PatchLevel</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>in_level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>work_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>ideal_workload</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>workload_tolerance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>min_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>cut_factor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>bad_interval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">hier::BoxContainer</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>physical_domain</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Recursively chops boxes given by patches on input patch level until each box has a workload less than the prescribed ideal workload or no more more chopping is allowed by the given constraints. A spatially-nonuniform workload is assumed. Cell weights must be given bydata defined by the given patch data id on the given patch level. This routine attempts to create as many boxes as possible with loads equal to or slightly less than the ideal workload value so that they can be mapped to processors effectively.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>out_boxes</em>&nbsp;</td><td>Output box list. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>out_workloads</em>&nbsp;</td><td>Output list of box workloads. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>in_level</em>&nbsp;</td><td>Input patch level whose patches describe input box regions and whose patch data contain workload estimate for each cell. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>work_id</em>&nbsp;</td><td>Input integer patch data id for cell-centered double work estimate for each cell. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ideal_workload</em>&nbsp;</td><td>Input double ideal box workload, must be &gt; 0. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>workload_tolerance</em>&nbsp;</td><td>Input double workload tolerance, must be &gt;= 0 and &lt; 1.0 </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>min_size</em>&nbsp;</td><td>Input integer vector of minimum sizes for output boxes. All entries must be &gt; 0. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>cut_factor</em>&nbsp;</td><td>Input integer vector used to create boxes with correct sizes. The box size in each direction will be an integer multiple of the corresponding cut factor vector entry. All vector entries must be &gt; 0. See <a class="el" href="structSAMRAI_1_1hier_1_1BoxUtilities.html">hier::BoxUtilities</a> documentation for more details. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>bad_interval</em>&nbsp;</td><td>Input integer vector used to create boxes near physical domain boundary with sufficient number of cells. No box face will be closer to the boundary than the corresponding interval of cells to the boundary (the corresponding value is given by the normal direction of the box face) unless the face coincides with the boundary itself. The point of this argument is to have no patch live within a certain ghost cell width of the boundary if its boundary does not coincide with that boundary . That is, all ghost cells along a face will be either in the domain interior or outside the domain. All entries must be &gt;= 0. See <a class="el" href="structSAMRAI_1_1hier_1_1BoxUtilities.html">hier::BoxUtilities</a> documentation for more details. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>physical_domain</em>&nbsp;</td><td><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">hier::BoxContainer</a> of boxes describing the physical extent of the index space associated with the in_boxes. This box array cannot be empty.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Precondition:</b></dt><dd>(min_size.getDim() == cut_factor.getDim()) &amp;&amp; (min_size.getDim() == bad_interval.getDim()) <p>
ideal_workload &gt; 0 <p>
(workload_tolerance &gt;= 0) &amp;&amp; (workload_tolerance &lt; 1.0) <p>
min_size &gt; <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html#178dc4477a52ff09e80a2c3e86944e7f">hier::IntVector::getZero</a>(min_size.getDim()) <p>
cut_factor &gt; <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html#178dc4477a52ff09e80a2c3e86944e7f">hier::IntVector::getZero</a>(min_size.getDim()) <p>
bad_interval &gt;= <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html#178dc4477a52ff09e80a2c3e86944e7f">hier::IntVector::getZero</a>(min_size.getDim()) <p>
!physical_domain.isEmpty() </dd></dl>

</div>
</div><p>
<a class="anchor" name="96a40c7af2adca69a5a77261e30ce5cd"></a><!-- doxytag: member="SAMRAI::mesh::BalanceUtilities::computeDomainDependentProcessorLayout" ref="96a40c7af2adca69a5a77261e30ce5cd" args="(hier::IntVector &amp;proc_dist, int num_procs, const hier::Box &amp;box)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::mesh::BalanceUtilities::computeDomainDependentProcessorLayout           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>proc_dist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>num_procs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">hier::Box</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>box</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Compute factorization of processors corresponding to size of given box.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>proc_dist</em>&nbsp;</td><td>Output number of processors for each coordinate direction. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>num_procs</em>&nbsp;</td><td>Input integer number of processors, must be &gt; 0. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>box</em>&nbsp;</td><td>Input box to be distributed.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Precondition:</b></dt><dd>proc_dist.getDim() == box.getDim() <p>
num_procs &gt; 0 <p>
for each dimension, i, box.numberCells(i) &gt; 0 </dd></dl>

</div>
</div><p>
<a class="anchor" name="0daffa849931598823d3f8a4f6be32c0"></a><!-- doxytag: member="SAMRAI::mesh::BalanceUtilities::computeDomainIndependentProcessorLayout" ref="0daffa849931598823d3f8a4f6be32c0" args="(hier::IntVector &amp;proc_dist, int num_procs, const hier::Box &amp;box)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::mesh::BalanceUtilities::computeDomainIndependentProcessorLayout           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>proc_dist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>num_procs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">hier::Box</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>box</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Compute a factorization of processors that does NOT necessarily correspond to the dimensions of the supplied box. For example, the processor distribution in each direction may simply be a square root (cube root in 3D) of the number of processors. The box information is used simply to determine a maximum number of processors in each coordinate direction.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>proc_dist</em>&nbsp;</td><td>Output number of processors for each coordinate direction. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>num_procs</em>&nbsp;</td><td>Input integer number of processors, must be &gt; 0. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>box</em>&nbsp;</td><td>Input box to be distributed.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Precondition:</b></dt><dd>proc_dist.getDim() == box.getDim() <p>
num_procs &gt; 0 <p>
for each dimension, i, box.numberCells(i) &gt; 0 </dd></dl>

</div>
</div><p>
<a class="anchor" name="1df6f03ad8e5a3b8bc1d5f36986d160a"></a><!-- doxytag: member="SAMRAI::mesh::BalanceUtilities::sortDescendingBoxWorkloads" ref="1df6f03ad8e5a3b8bc1d5f36986d160a" args="(hier::BoxContainer &amp;boxes, std::vector&lt; double &gt; &amp;workload)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::mesh::BalanceUtilities::sortDescendingBoxWorkloads           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">hier::BoxContainer</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>boxes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>workload</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sort box array in descending order of workload according to the workload array. Both the box array and the work array will be sorted on return.<p>
Note that if you simply want to sort boxes based on their size, see <a class="el" href="structSAMRAI_1_1hier_1_1BoxUtilities.html">hier::BoxUtilities</a>.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>boxes</em>&nbsp;</td><td>Boxes to be sorted based on workload array. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>workload</em>&nbsp;</td><td>Workloads to use for sorting boxes.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Precondition:</b></dt><dd>boxes.size() == workload.size() </dd></dl>

</div>
</div><p>
<a class="anchor" name="60465fbe335ac50e582163db963f2994"></a><!-- doxytag: member="SAMRAI::mesh::BalanceUtilities::computeNonUniformWorkload" ref="60465fbe335ac50e582163db963f2994" args="(const boost::shared_ptr&lt; hier::Patch &gt; &amp;patch, int wrk_indx, const hier::Box &amp;box)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double SAMRAI::mesh::BalanceUtilities::computeNonUniformWorkload           </td>
          <td>(</td>
          <td class="paramtype">const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1hier_1_1Patch.html">hier::Patch</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>patch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>wrk_indx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">hier::Box</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>box</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Compute total workload in region of argument box based on patch data defined by given integer index. The sum is computed on the intersection of argument box and box over which data associated with workload is defined.<p>
<dl compact><dt><b>Returns:</b></dt><dd>Double-valued sum of workload values in box region.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>patch</em>&nbsp;</td><td>Input patch on which workload data is defined. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>wrk_indx</em>&nbsp;</td><td>Input integer patch data identifier for work data. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>box</em>&nbsp;</td><td>Input box region</td></tr>
  </table>
</dl>
Note that wrk_indx must refer to a valid cell-centered patch data entry.<p>
<dl compact><dt><b>Precondition:</b></dt><dd>param <p>
param-&gt;getDim() == box.getDim() </dd></dl>

</div>
</div><p>
<a class="anchor" name="05fb541a77a1274dbf2cbb886eae3b2d"></a><!-- doxytag: member="SAMRAI::mesh::BalanceUtilities::computeLoadBalanceEfficiency" ref="05fb541a77a1274dbf2cbb886eae3b2d" args="(const boost::shared_ptr&lt; hier::PatchLevel &gt; &amp;level, std::ostream &amp;os, int workload_data_id=-1)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double SAMRAI::mesh::BalanceUtilities::computeLoadBalanceEfficiency           </td>
          <td>(</td>
          <td class="paramtype">const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchLevel.html">hier::PatchLevel</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;&nbsp;</td>
          <td class="paramname"> <em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>workload_data_id</em> = <code>-1</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Compute and return load balance efficiency for a level.<p>
<dl compact><dt><b>Returns:</b></dt><dd>Double-valued estimate of the load balance efficiency (ranges from zero to one hundred percent)</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>level</em>&nbsp;</td><td>Input patch level to consider, can't be null. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>os</em>&nbsp;</td><td>Output stream for reporting load balance details. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>workload_data_id</em>&nbsp;</td><td>(Optional) Input integer id for workload data on level. If no value is given, the calculation assumes spatially-uniform load.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Precondition:</b></dt><dd>level </dd></dl>

</div>
</div><p>
<a class="anchor" name="054d9a59baad0fe26c7cc310cf27999d"></a><!-- doxytag: member="SAMRAI::mesh::BalanceUtilities::gatherAndReportLoadBalance" ref="054d9a59baad0fe26c7cc310cf27999d" args="(double local_workload, const tbox::SAMRAI_MPI &amp;mpi, std::ostream &amp;output_stream=tbox::plog)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::mesh::BalanceUtilities::gatherAndReportLoadBalance           </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>local_workload</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1tbox_1_1SAMRAI__MPI.html">tbox::SAMRAI_MPI</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>mpi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;&nbsp;</td>
          <td class="paramname"> <em>output_stream</em> = <code><a class="el" href="namespaceSAMRAI_1_1tbox.html#b84041705493761fb17a8127e3a2dca2">tbox::plog</a></code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Gather workloads in an MPI group and write out a summary of load balance efficiency. 
<p>
To be used for performance evaluation. Not recommended for general use.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>local_workload</em>&nbsp;</td><td>Workload of the local process</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>mpi</em>&nbsp;</td><td>Represents all processes involved in the load balancing.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>output_stream</em>&nbsp;</td><td></td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="58e2e65bfc260d9a27d4ebe66cf44c72"></a><!-- doxytag: member="SAMRAI::mesh::BalanceUtilities::gatherAndReportLoadBalance" ref="58e2e65bfc260d9a27d4ebe66cf44c72" args="(const std::vector&lt; double &gt; &amp;local_loads, const tbox::SAMRAI_MPI &amp;mpi, std::ostream &amp;output_stream=tbox::plog)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::mesh::BalanceUtilities::gatherAndReportLoadBalance           </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>local_loads</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1tbox_1_1SAMRAI__MPI.html">tbox::SAMRAI_MPI</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>mpi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;&nbsp;</td>
          <td class="paramname"> <em>output_stream</em> = <code><a class="el" href="namespaceSAMRAI_1_1tbox.html#b84041705493761fb17a8127e3a2dca2">tbox::plog</a></code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Gather a sequence of workloads in an MPI group and write out a summary of load balance efficiency. 
<p>
Each value in the sequence of workloads represent a certain load the local process had over a sequence of load balancings.<p>
To be used for performance evaluation. Not recommended for general use.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>local_loads</em>&nbsp;</td><td>Sequence of workloads of the local process. The size of <code>local_loads</code> is the number times load balancing has been used. It must be the same across all processors in <code>mpi</code>.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>mpi</em>&nbsp;</td><td>Represents all processes involved in the load balancing.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>output_stream</em>&nbsp;</td><td></td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="20bee7295a9ef124f2616cd0da52c4de"></a><!-- doxytag: member="SAMRAI::mesh::BalanceUtilities::reportLoadBalance" ref="20bee7295a9ef124f2616cd0da52c4de" args="(const std::vector&lt; double &gt; &amp;workloads, std::ostream &amp;output_stream)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::mesh::BalanceUtilities::reportLoadBalance           </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>workloads</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;&nbsp;</td>
          <td class="paramname"> <em>output_stream</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Write out a short report of how well load is balanced. 
<p>
Given the workloads of a number of processes, format and write out a brief report for assessing how well balanced the workloads are.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>workloads</em>&nbsp;</td><td>One value for each process. The number of processes is taken to be the size of this container.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>output_stream</em>&nbsp;</td><td></td></tr>
  </table>
</dl>
<dl compact><dt><b>Precondition:</b></dt><dd>workloads.size() == <a class="el" href="classSAMRAI_1_1tbox_1_1SAMRAI__MPI.html#b77c546bbc19ae9bae5c6480fba8c53a">tbox::SAMRAI_MPI::getSAMRAIWorld()</a>.getSize() </dd></dl>

</div>
</div><p>
<hr>The documentation for this struct was generated from the following files:<ul>
<li>source/SAMRAI/mesh/<a class="el" href="BalanceUtilities_8h.html">BalanceUtilities.h</a><li>source/SAMRAI/mesh/<a class="el" href="BalanceUtilities_8C.html">BalanceUtilities.C</a></ul>
<hr size="1"><address style="align: right;"><small>Generated on 6 Feb 2014 for SAMRAI by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.7 </small></address>
</body>
</html>
