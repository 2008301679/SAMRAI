<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>SAMRAI: SAMRAI::mesh::BalanceUtilities Struct Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.7 -->
<div class="tabs">
  <ul>
    <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="namespaces.html"><span>Namespaces</span></a></li>
    <li id="current"><a href="annotated.html"><span>Classes</span></a></li>
    <li><a href="files.html"><span>Files</span></a></li>
    <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
  </ul></div>
<div class="tabs">
  <ul>
    <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
    <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
    <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
  </ul></div>
<div class="nav">
<a class="el" href="namespaceSAMRAI.html">SAMRAI</a>::<a class="el" href="namespaceSAMRAI_1_1mesh.html">mesh</a>::<a class="el" href="structSAMRAI_1_1mesh_1_1BalanceUtilities.html">BalanceUtilities</a></div>
<h1>SAMRAI::mesh::BalanceUtilities Struct Reference</h1><!-- doxytag: class="SAMRAI::mesh::BalanceUtilities" -->Utility class <a class="el" href="structSAMRAI_1_1mesh_1_1BalanceUtilities.html">BalanceUtilities</a> provides several functions useful in various load balancing operations. These utilities include bin packing operations, box chopping by recursive bisection, and computation of effective processor layouts for boxes.  
<a href="#_details">More...</a>
<p>
<code>#include &lt;source/SAMRAI/mesh/BalanceUtilities.h&gt;</code>
<p>
<a href="structSAMRAI_1_1mesh_1_1BalanceUtilities-members.html">List of all members.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Static Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSAMRAI_1_1mesh_1_1BalanceUtilities.html#9cf29c89fc3719cb605055c75d03cb48">binPack</a> (<a class="el" href="classSAMRAI_1_1hier_1_1ProcessorMapping.html">hier::ProcessorMapping</a> &amp;mapping, std::vector&lt; double &gt; &amp;weights, int nproc)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">static double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSAMRAI_1_1mesh_1_1BalanceUtilities.html#2f830e0fe5db6e51f868fafacdd65ad8">spatialBinPack</a> (<a class="el" href="classSAMRAI_1_1hier_1_1ProcessorMapping.html">hier::ProcessorMapping</a> &amp;mapping, std::vector&lt; double &gt; &amp;weights, <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">hier::BoxContainer</a> &amp;boxes, const int nproc)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSAMRAI_1_1mesh_1_1BalanceUtilities.html#f5c89c6c3e18619fec4ea501598b535f">recursiveBisectionUniform</a> (<a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">hier::BoxContainer</a> &amp;out_boxes, std::list&lt; double &gt; &amp;out_workloads, const <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">hier::BoxContainer</a> &amp;in_boxes, double ideal_workload, const double workload_tolerance, const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a> &amp;min_size, const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a> &amp;cut_factor, const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a> &amp;bad_interval, const <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">hier::BoxContainer</a> &amp;physical_domain)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSAMRAI_1_1mesh_1_1BalanceUtilities.html#91743b7dae52696baf20837ad5df2dbf">recursiveBisectionNonuniform</a> (<a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">hier::BoxContainer</a> &amp;out_boxes, std::list&lt; double &gt; &amp;out_workloads, const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchLevel.html">hier::PatchLevel</a> &gt; &amp;in_level, int work_id, double ideal_workload, const double workload_tolerance, const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a> &amp;min_size, const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a> &amp;cut_factor, const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a> &amp;bad_interval, const <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">hier::BoxContainer</a> &amp;physical_domain)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSAMRAI_1_1mesh_1_1BalanceUtilities.html#96a40c7af2adca69a5a77261e30ce5cd">computeDomainDependentProcessorLayout</a> (<a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a> &amp;proc_dist, int num_procs, const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">hier::Box</a> &amp;box)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSAMRAI_1_1mesh_1_1BalanceUtilities.html#0daffa849931598823d3f8a4f6be32c0">computeDomainIndependentProcessorLayout</a> (<a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a> &amp;proc_dist, int num_procs, const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">hier::Box</a> &amp;box)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSAMRAI_1_1mesh_1_1BalanceUtilities.html#1df6f03ad8e5a3b8bc1d5f36986d160a">sortDescendingBoxWorkloads</a> (<a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">hier::BoxContainer</a> &amp;boxes, std::vector&lt; double &gt; &amp;workload)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">static double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSAMRAI_1_1mesh_1_1BalanceUtilities.html#60465fbe335ac50e582163db963f2994">computeNonUniformWorkload</a> (const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1hier_1_1Patch.html">hier::Patch</a> &gt; &amp;patch, int wrk_indx, const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">hier::Box</a> &amp;box)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSAMRAI_1_1mesh_1_1BalanceUtilities.html#080df275619b7acb4544858bbed78ab7">findSmallBoxesInPostbalance</a> (std::ostream &amp;co, const std::string &amp;border, const <a class="el" href="classSAMRAI_1_1hier_1_1MappingConnector.html">hier::MappingConnector</a> &amp;post_to_pre, const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a> &amp;min_width, size_t min_vol)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Find small boxes in a post-balance BoxLevel that are not in a pre-balance BoxLevel.  <a href="#080df275619b7acb4544858bbed78ab7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSAMRAI_1_1mesh_1_1BalanceUtilities.html#8061561064f2f3065dfee4495fcc6894">findSmallBoxesInPostbalance</a> (std::ostream &amp;co, const std::string &amp;border, const <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">hier::BoxLevel</a> &amp;pre, const <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">hier::BoxLevel</a> &amp;post, const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a> &amp;min_width, size_t min_vol)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Find small boxes in a post-balance BoxLevel that are not in a pre-balance BoxLevel.  <a href="#8061561064f2f3065dfee4495fcc6894"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSAMRAI_1_1mesh_1_1BalanceUtilities.html#727df1a3a6776b897ca0a76c0e0205d1">compareLoads</a> (int flags[], double current_load, double new_load, double ideal_load, double low_load, double high_load, const <a class="el" href="classSAMRAI_1_1mesh_1_1PartitioningParams.html">PartitioningParams</a> &amp;pparams)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Evaluate whether a new load is an improvement over a current load based on their proximity to an ideal value or range of acceptable values.  <a href="#727df1a3a6776b897ca0a76c0e0205d1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSAMRAI_1_1mesh_1_1BalanceUtilities.html#05fb541a77a1274dbf2cbb886eae3b2d">computeLoadBalanceEfficiency</a> (const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchLevel.html">hier::PatchLevel</a> &gt; &amp;level, std::ostream &amp;os, int workload_data_id=-1)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSAMRAI_1_1mesh_1_1BalanceUtilities.html#b769d7080e3c73dacd83521ec598e9b0">constrainMaxBoxSizes</a> (<a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">hier::BoxLevel</a> &amp;box_level, <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">hier::Connector</a> *anchor_to_level, const <a class="el" href="classSAMRAI_1_1mesh_1_1PartitioningParams.html">PartitioningParams</a> &amp;pparams)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSAMRAI_1_1mesh_1_1BalanceUtilities.html#e86ce230485c42da007e8003ddf75edf">prebalanceBoxLevel</a> (<a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">hier::BoxLevel</a> &amp;balance_box_level, <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">hier::Connector</a> *balance_to_anchor, const <a class="el" href="classSAMRAI_1_1tbox_1_1RankGroup.html">tbox::RankGroup</a> &amp;rank_group)</td></tr>

<tr><td colspan="2"><div class="groupHeader">Load balance reporting.</div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSAMRAI_1_1mesh_1_1BalanceUtilities.html#f35d39c4f2c79ea9fe32b1623c4e8ae9">reduceAndReportLoadBalance</a> (const std::vector&lt; double &gt; &amp;local_loads, const <a class="el" href="classSAMRAI_1_1tbox_1_1SAMRAI__MPI.html">tbox::SAMRAI_MPI</a> &amp;mpi, std::ostream &amp;output_stream=<a class="el" href="namespaceSAMRAI_1_1tbox.html#b84041705493761fb17a8127e3a2dca2">tbox::plog</a>)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Globally reduce a sequence of workloads in an MPI group and write out a summary of load balance efficiency.  <a href="#f35d39c4f2c79ea9fe32b1623c4e8ae9"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Static Public Attributes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static const int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSAMRAI_1_1mesh_1_1BalanceUtilities.html#4c3a6051043afc497fcdfc3a978e2631">BalanceUtilities_PREBALANCE0</a> = 5</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">static const int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSAMRAI_1_1mesh_1_1BalanceUtilities.html#e20a69522f8e4d46f96b7df8e0a04e69">BalanceUtilities_PREBALANCE1</a> = 6</td></tr>

</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
Utility class <a class="el" href="structSAMRAI_1_1mesh_1_1BalanceUtilities.html">BalanceUtilities</a> provides several functions useful in various load balancing operations. These utilities include bin packing operations, box chopping by recursive bisection, and computation of effective processor layouts for boxes. 
<p>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="9cf29c89fc3719cb605055c75d03cb48"></a><!-- doxytag: member="SAMRAI::mesh::BalanceUtilities::binPack" ref="9cf29c89fc3719cb605055c75d03cb48" args="(hier::ProcessorMapping &amp;mapping, std::vector&lt; double &gt; &amp;weights, int nproc)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double SAMRAI::mesh::BalanceUtilities::binPack           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1hier_1_1ProcessorMapping.html">hier::ProcessorMapping</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>weights</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>nproc</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Assign workloads to processors using a greedy algorithm that attempts to distribute the sum of weights on each processor evenly across the given number of processors.<p>
<dl compact><dt><b>Returns:</b></dt><dd>double-valued estimate of the load balance efficiency (ranges from zero to one hundred percent)</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>mapping</em>&nbsp;</td><td>Output processor mapping. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>weights</em>&nbsp;</td><td>std::vector of double-valued weights to distribute. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nproc</em>&nbsp;</td><td>Integer number of processors, must be &gt; 0.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Precondition:</b></dt><dd>nproc &gt; 0 <p>
for each memeber of weights, w, w &gt;=0 </dd></dl>

</div>
</div><p>
<a class="anchor" name="2f830e0fe5db6e51f868fafacdd65ad8"></a><!-- doxytag: member="SAMRAI::mesh::BalanceUtilities::spatialBinPack" ref="2f830e0fe5db6e51f868fafacdd65ad8" args="(hier::ProcessorMapping &amp;mapping, std::vector&lt; double &gt; &amp;weights, hier::BoxContainer &amp;boxes, const int nproc)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double SAMRAI::mesh::BalanceUtilities::spatialBinPack           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1hier_1_1ProcessorMapping.html">hier::ProcessorMapping</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>weights</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">hier::BoxContainer</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>boxes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>nproc</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Assign boxes to processors so that boxes spatially near each other are likely to be assigned to processors near each other (assuming that processor ordering is reflected in processor rank) and so that the workload is approximately evenly distributed among the processors. The routine uses a Morton space-filling curve algorithm.<p>
Note that this routine potentially reorders the boxes passed in to achieve the first goal.<p>
<dl compact><dt><b>Returns:</b></dt><dd>Double-valued estimate of the load balance efficiency (ranges from zero to one hundred percent)</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>mapping</em>&nbsp;</td><td>Output processor mapping. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>weights</em>&nbsp;</td><td>std::vector of double-valued box weights to distribute. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>boxes</em>&nbsp;</td><td><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">hier::BoxContainer</a> of boxes to distribute to processors. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nproc</em>&nbsp;</td><td>Integer number of processors, must be &gt; 0.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Precondition:</b></dt><dd>nproc &gt; 0 <p>
weights.size() == boxes.size() </dd></dl>

</div>
</div><p>
<a class="anchor" name="f5c89c6c3e18619fec4ea501598b535f"></a><!-- doxytag: member="SAMRAI::mesh::BalanceUtilities::recursiveBisectionUniform" ref="f5c89c6c3e18619fec4ea501598b535f" args="(hier::BoxContainer &amp;out_boxes, std::list&lt; double &gt; &amp;out_workloads, const hier::BoxContainer &amp;in_boxes, double ideal_workload, const double workload_tolerance, const hier::IntVector &amp;min_size, const hier::IntVector &amp;cut_factor, const hier::IntVector &amp;bad_interval, const hier::BoxContainer &amp;physical_domain)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::mesh::BalanceUtilities::recursiveBisectionUniform           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">hier::BoxContainer</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>out_boxes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::list&lt; double &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>out_workloads</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">hier::BoxContainer</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>in_boxes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>ideal_workload</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>workload_tolerance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>min_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>cut_factor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>bad_interval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">hier::BoxContainer</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>physical_domain</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Recursively chop chops boxes in input boxlist until each box has a workload less than the prescribed ideal workload or no more more chopping is allowed by the given constraints. A spatially-uniform workload is assumed; i.e., all cells are weighted equally. This routine attempts to create as many boxes as possible with loads equal to or slightly less than the ideal workload value so that they can be mapped to processors effectively.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>out_boxes</em>&nbsp;</td><td>Output box list. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>out_workloads</em>&nbsp;</td><td>Output list of box workloads. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>in_boxes</em>&nbsp;</td><td>Input boxlist for chopping. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ideal_workload</em>&nbsp;</td><td>Input double ideal box workload, must be &gt; 0. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>workload_tolerance</em>&nbsp;</td><td>Input double workload tolerance, must be &gt;= 0 and &lt; 1.0 </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>min_size</em>&nbsp;</td><td>Input integer vector of minimum sizes for output boxes. All entries must be &gt; 0. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>cut_factor</em>&nbsp;</td><td>Input integer vector used to create boxes with correct sizes. The box size in each direction will be an integer multiple of the corresponding cut factor vector entry. All vector entries must be &gt; 0. See <a class="el" href="structSAMRAI_1_1hier_1_1BoxUtilities.html">hier::BoxUtilities</a> documentation for more details. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>bad_interval</em>&nbsp;</td><td>Input integer vector used to create boxes near physical domain boundary with sufficient number of cells. No box face will be closer to the boundary than the corresponding interval of cells to the boundary (the corresponding value is given by the normal direction of the box face) unless the face coincides with the boundary itself. The point of this argument is to have no patch live within a certain ghost cell width of the boundary if its boundary does not coincide with that boundary . That is, all ghost cells along a face will be either in the domain interior or outside the domain. All entries must be &gt;= 0. See <a class="el" href="structSAMRAI_1_1hier_1_1BoxUtilities.html">hier::BoxUtilities</a> documentation for more details. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>physical_domain</em>&nbsp;</td><td><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">hier::BoxContainer</a> of boxes describing the physical extent of the index space associated with the in_boxes. This box array cannot be empty.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Precondition:</b></dt><dd>(min_size.getDim() == cut_factor.getDim()) &amp;&amp; (min_size.getDim() == bad_interval.getDim()) <p>
ideal_workload &gt; 0 <p>
(workload_tolerance &gt;= 0) &amp;&amp; (workload_tolerance &lt; 1.0) <p>
min_size &gt; <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html#178dc4477a52ff09e80a2c3e86944e7f">hier::IntVector::getZero</a>(min_size.getDim()) <p>
cut_factor &gt; <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html#178dc4477a52ff09e80a2c3e86944e7f">hier::IntVector::getZero</a>(min_size.getDim()) <p>
bad_interval &gt;= <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html#178dc4477a52ff09e80a2c3e86944e7f">hier::IntVector::getZero</a>(min_size.getDim()) <p>
!physical_domain.empty() </dd></dl>

</div>
</div><p>
<a class="anchor" name="91743b7dae52696baf20837ad5df2dbf"></a><!-- doxytag: member="SAMRAI::mesh::BalanceUtilities::recursiveBisectionNonuniform" ref="91743b7dae52696baf20837ad5df2dbf" args="(hier::BoxContainer &amp;out_boxes, std::list&lt; double &gt; &amp;out_workloads, const boost::shared_ptr&lt; hier::PatchLevel &gt; &amp;in_level, int work_id, double ideal_workload, const double workload_tolerance, const hier::IntVector &amp;min_size, const hier::IntVector &amp;cut_factor, const hier::IntVector &amp;bad_interval, const hier::BoxContainer &amp;physical_domain)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::mesh::BalanceUtilities::recursiveBisectionNonuniform           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">hier::BoxContainer</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>out_boxes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::list&lt; double &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>out_workloads</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchLevel.html">hier::PatchLevel</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>in_level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>work_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>ideal_workload</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>workload_tolerance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>min_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>cut_factor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>bad_interval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">hier::BoxContainer</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>physical_domain</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Recursively chops boxes given by patches on input patch level until each box has a workload less than the prescribed ideal workload or no more more chopping is allowed by the given constraints. A spatially-nonuniform workload is assumed. Cell weights must be given bydata defined by the given patch data id on the given patch level. This routine attempts to create as many boxes as possible with loads equal to or slightly less than the ideal workload value so that they can be mapped to processors effectively.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>out_boxes</em>&nbsp;</td><td>Output box list. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>out_workloads</em>&nbsp;</td><td>Output list of box workloads. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>in_level</em>&nbsp;</td><td>Input patch level whose patches describe input box regions and whose patch data contain workload estimate for each cell. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>work_id</em>&nbsp;</td><td>Input integer patch data id for cell-centered double work estimate for each cell. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ideal_workload</em>&nbsp;</td><td>Input double ideal box workload, must be &gt; 0. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>workload_tolerance</em>&nbsp;</td><td>Input double workload tolerance, must be &gt;= 0 and &lt; 1.0 </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>min_size</em>&nbsp;</td><td>Input integer vector of minimum sizes for output boxes. All entries must be &gt; 0. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>cut_factor</em>&nbsp;</td><td>Input integer vector used to create boxes with correct sizes. The box size in each direction will be an integer multiple of the corresponding cut factor vector entry. All vector entries must be &gt; 0. See <a class="el" href="structSAMRAI_1_1hier_1_1BoxUtilities.html">hier::BoxUtilities</a> documentation for more details. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>bad_interval</em>&nbsp;</td><td>Input integer vector used to create boxes near physical domain boundary with sufficient number of cells. No box face will be closer to the boundary than the corresponding interval of cells to the boundary (the corresponding value is given by the normal direction of the box face) unless the face coincides with the boundary itself. The point of this argument is to have no patch live within a certain ghost cell width of the boundary if its boundary does not coincide with that boundary . That is, all ghost cells along a face will be either in the domain interior or outside the domain. All entries must be &gt;= 0. See <a class="el" href="structSAMRAI_1_1hier_1_1BoxUtilities.html">hier::BoxUtilities</a> documentation for more details. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>physical_domain</em>&nbsp;</td><td><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">hier::BoxContainer</a> of boxes describing the physical extent of the index space associated with the in_boxes. This box array cannot be empty.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Precondition:</b></dt><dd>(min_size.getDim() == cut_factor.getDim()) &amp;&amp; (min_size.getDim() == bad_interval.getDim()) <p>
ideal_workload &gt; 0 <p>
(workload_tolerance &gt;= 0) &amp;&amp; (workload_tolerance &lt; 1.0) <p>
min_size &gt; <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html#178dc4477a52ff09e80a2c3e86944e7f">hier::IntVector::getZero</a>(min_size.getDim()) <p>
cut_factor &gt; <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html#178dc4477a52ff09e80a2c3e86944e7f">hier::IntVector::getZero</a>(min_size.getDim()) <p>
bad_interval &gt;= <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html#178dc4477a52ff09e80a2c3e86944e7f">hier::IntVector::getZero</a>(min_size.getDim()) <p>
!physical_domain.empty() </dd></dl>

</div>
</div><p>
<a class="anchor" name="96a40c7af2adca69a5a77261e30ce5cd"></a><!-- doxytag: member="SAMRAI::mesh::BalanceUtilities::computeDomainDependentProcessorLayout" ref="96a40c7af2adca69a5a77261e30ce5cd" args="(hier::IntVector &amp;proc_dist, int num_procs, const hier::Box &amp;box)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::mesh::BalanceUtilities::computeDomainDependentProcessorLayout           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>proc_dist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>num_procs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">hier::Box</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>box</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Compute factorization of processors corresponding to size of given box.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>proc_dist</em>&nbsp;</td><td>Output number of processors for each coordinate direction. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>num_procs</em>&nbsp;</td><td>Input integer number of processors, must be &gt; 0. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>box</em>&nbsp;</td><td>Input box to be distributed.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Precondition:</b></dt><dd>proc_dist.getDim() == box.getDim() <p>
num_procs &gt; 0 <p>
for each dimension, i, box.numberCells(i) &gt; 0 </dd></dl>

</div>
</div><p>
<a class="anchor" name="0daffa849931598823d3f8a4f6be32c0"></a><!-- doxytag: member="SAMRAI::mesh::BalanceUtilities::computeDomainIndependentProcessorLayout" ref="0daffa849931598823d3f8a4f6be32c0" args="(hier::IntVector &amp;proc_dist, int num_procs, const hier::Box &amp;box)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::mesh::BalanceUtilities::computeDomainIndependentProcessorLayout           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>proc_dist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>num_procs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">hier::Box</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>box</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Compute a factorization of processors that does NOT necessarily correspond to the dimensions of the supplied box. For example, the processor distribution in each direction may simply be a square root (cube root in 3D) of the number of processors. The box information is used simply to determine a maximum number of processors in each coordinate direction.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>proc_dist</em>&nbsp;</td><td>Output number of processors for each coordinate direction. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>num_procs</em>&nbsp;</td><td>Input integer number of processors, must be &gt; 0. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>box</em>&nbsp;</td><td>Input box to be distributed.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Precondition:</b></dt><dd>proc_dist.getDim() == box.getDim() <p>
num_procs &gt; 0 <p>
for each dimension, i, box.numberCells(i) &gt; 0 </dd></dl>

</div>
</div><p>
<a class="anchor" name="1df6f03ad8e5a3b8bc1d5f36986d160a"></a><!-- doxytag: member="SAMRAI::mesh::BalanceUtilities::sortDescendingBoxWorkloads" ref="1df6f03ad8e5a3b8bc1d5f36986d160a" args="(hier::BoxContainer &amp;boxes, std::vector&lt; double &gt; &amp;workload)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::mesh::BalanceUtilities::sortDescendingBoxWorkloads           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">hier::BoxContainer</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>boxes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>workload</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sort box array in descending order of workload according to the workload array. Both the box array and the work array will be sorted on return.<p>
Note that if you simply want to sort boxes based on their size, see <a class="el" href="structSAMRAI_1_1hier_1_1BoxUtilities.html">hier::BoxUtilities</a>.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>boxes</em>&nbsp;</td><td>Boxes to be sorted based on workload array. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>workload</em>&nbsp;</td><td>Workloads to use for sorting boxes.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Precondition:</b></dt><dd>boxes.size() == workload.size() </dd></dl>

</div>
</div><p>
<a class="anchor" name="60465fbe335ac50e582163db963f2994"></a><!-- doxytag: member="SAMRAI::mesh::BalanceUtilities::computeNonUniformWorkload" ref="60465fbe335ac50e582163db963f2994" args="(const boost::shared_ptr&lt; hier::Patch &gt; &amp;patch, int wrk_indx, const hier::Box &amp;box)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double SAMRAI::mesh::BalanceUtilities::computeNonUniformWorkload           </td>
          <td>(</td>
          <td class="paramtype">const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1hier_1_1Patch.html">hier::Patch</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>patch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>wrk_indx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">hier::Box</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>box</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Compute total workload in region of argument box based on patch data defined by given integer index. The sum is computed on the intersection of argument box and box over which data associated with workload is defined.<p>
<dl compact><dt><b>Returns:</b></dt><dd>Double-valued sum of workload values in box region.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>patch</em>&nbsp;</td><td>Input patch on which workload data is defined. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>wrk_indx</em>&nbsp;</td><td>Input integer patch data identifier for work data. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>box</em>&nbsp;</td><td>Input box region</td></tr>
  </table>
</dl>
Note that wrk_indx must refer to a valid cell-centered patch data entry.<p>
<dl compact><dt><b>Precondition:</b></dt><dd>param <p>
param-&gt;getDim() == box.getDim() </dd></dl>

</div>
</div><p>
<a class="anchor" name="080df275619b7acb4544858bbed78ab7"></a><!-- doxytag: member="SAMRAI::mesh::BalanceUtilities::findSmallBoxesInPostbalance" ref="080df275619b7acb4544858bbed78ab7" args="(std::ostream &amp;co, const std::string &amp;border, const hier::MappingConnector &amp;post_to_pre, const hier::IntVector &amp;min_width, size_t min_vol)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::mesh::BalanceUtilities::findSmallBoxesInPostbalance           </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&nbsp;</td>
          <td class="paramname"> <em>co</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>border</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1MappingConnector.html">hier::MappingConnector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>post_to_pre</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>min_width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>min_vol</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Find small boxes in a post-balance BoxLevel that are not in a pre-balance BoxLevel. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>co</em>&nbsp;</td><td>Stream to report findings</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>border</em>&nbsp;</td><td>Left border in report output</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>post_to_pre</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>min_width</em>&nbsp;</td><td>Report post-balance boxes smaller than min_width in any direction.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>min_vol</em>&nbsp;</td><td>Report post-balance boxes with fewer cells than this. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="8061561064f2f3065dfee4495fcc6894"></a><!-- doxytag: member="SAMRAI::mesh::BalanceUtilities::findSmallBoxesInPostbalance" ref="8061561064f2f3065dfee4495fcc6894" args="(std::ostream &amp;co, const std::string &amp;border, const hier::BoxLevel &amp;pre, const hier::BoxLevel &amp;post, const hier::IntVector &amp;min_width, size_t min_vol)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::mesh::BalanceUtilities::findSmallBoxesInPostbalance           </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&nbsp;</td>
          <td class="paramname"> <em>co</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>border</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">hier::BoxLevel</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>pre</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">hier::BoxLevel</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>post</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>min_width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>min_vol</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Find small boxes in a post-balance BoxLevel that are not in a pre-balance BoxLevel. 
<p>
This method does not scale. It acquires and processes globalized data.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>co</em>&nbsp;</td><td>Stream to report findings</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>border</em>&nbsp;</td><td>Left border in report output</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>pre</em>&nbsp;</td><td>Pre-balance BoxLevel</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>post</em>&nbsp;</td><td>Post-balance BoxLevel</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>min_width</em>&nbsp;</td><td>Report post-balance boxes smaller than min_width in any direction.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>min_vol</em>&nbsp;</td><td>Report post-balance boxes with fewer cells than this. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="727df1a3a6776b897ca0a76c0e0205d1"></a><!-- doxytag: member="SAMRAI::mesh::BalanceUtilities::compareLoads" ref="727df1a3a6776b897ca0a76c0e0205d1" args="(int flags[], double current_load, double new_load, double ideal_load, double low_load, double high_load, const PartitioningParams &amp;pparams)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SAMRAI::mesh::BalanceUtilities::compareLoads           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>flags</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>current_load</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>new_load</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>ideal_load</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>low_load</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>high_load</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1mesh_1_1PartitioningParams.html">PartitioningParams</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>pparams</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Evaluate whether a new load is an improvement over a current load based on their proximity to an ideal value or range of acceptable values. 
<p>
There is a slight bias toward current load. The new_load is better only if it improves by at least pparams.getLoadComparisonTol().<p>
Return values in flags:<ul>
<li>[0]: -1, 0 or 1: degrades, leave-alone or improves in-range</li><li>[1]: -1, 0 or 1: degrades, leave-alone or improves balance</li><li>[2]: -1, 0 or 1: degrades, leave-alone or improves overall</li><li>[3]: 0 or 1: whether new_load is within the range of [low, high]</li></ul>
<p>
Return whether new_load is an improvement over current_load. 
</div>
</div><p>
<a class="anchor" name="05fb541a77a1274dbf2cbb886eae3b2d"></a><!-- doxytag: member="SAMRAI::mesh::BalanceUtilities::computeLoadBalanceEfficiency" ref="05fb541a77a1274dbf2cbb886eae3b2d" args="(const boost::shared_ptr&lt; hier::PatchLevel &gt; &amp;level, std::ostream &amp;os, int workload_data_id=-1)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double SAMRAI::mesh::BalanceUtilities::computeLoadBalanceEfficiency           </td>
          <td>(</td>
          <td class="paramtype">const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchLevel.html">hier::PatchLevel</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;&nbsp;</td>
          <td class="paramname"> <em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>workload_data_id</em> = <code>-1</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Compute and return load balance efficiency for a level.<p>
<dl compact><dt><b>Returns:</b></dt><dd>Double-valued estimate of the load balance efficiency (ranges from zero to one hundred percent)</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>level</em>&nbsp;</td><td>Input patch level to consider, can't be null. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>os</em>&nbsp;</td><td>Output stream for reporting load balance details. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>workload_data_id</em>&nbsp;</td><td>(Optional) Input integer id for workload data on level. If no value is given, the calculation assumes spatially-uniform load.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Precondition:</b></dt><dd>level </dd></dl>

</div>
</div><p>
<a class="anchor" name="f35d39c4f2c79ea9fe32b1623c4e8ae9"></a><!-- doxytag: member="SAMRAI::mesh::BalanceUtilities::reduceAndReportLoadBalance" ref="f35d39c4f2c79ea9fe32b1623c4e8ae9" args="(const std::vector&lt; double &gt; &amp;local_loads, const tbox::SAMRAI_MPI &amp;mpi, std::ostream &amp;output_stream=tbox::plog)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::mesh::BalanceUtilities::reduceAndReportLoadBalance           </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>local_loads</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1tbox_1_1SAMRAI__MPI.html">tbox::SAMRAI_MPI</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>mpi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;&nbsp;</td>
          <td class="paramname"> <em>output_stream</em> = <code><a class="el" href="namespaceSAMRAI_1_1tbox.html#b84041705493761fb17a8127e3a2dca2">tbox::plog</a></code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Globally reduce a sequence of workloads in an MPI group and write out a summary of load balance efficiency. 
<p>
Each value in the sequence of workloads represent a certain load the local process had over a sequence of load balancings.<p>
To be used for performance evaluation. Not recommended for general use.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>local_loads</em>&nbsp;</td><td>Sequence of workloads of the local process. The size of <code>local_loads</code> is the number times load balancing has been used. It must be the same across all processors in <code>mpi</code>.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>mpi</em>&nbsp;</td><td>Represents all processes involved in the load balancing.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>output_stream</em>&nbsp;</td><td></td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="b769d7080e3c73dacd83521ec598e9b0"></a><!-- doxytag: member="SAMRAI::mesh::BalanceUtilities::constrainMaxBoxSizes" ref="b769d7080e3c73dacd83521ec598e9b0" args="(hier::BoxLevel &amp;box_level, hier::Connector *anchor_to_level, const PartitioningParams &amp;pparams)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::mesh::BalanceUtilities::constrainMaxBoxSizes           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">hier::BoxLevel</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>box_level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">hier::Connector</a> *&nbsp;</td>
          <td class="paramname"> <em>anchor_to_level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1mesh_1_1PartitioningParams.html">PartitioningParams</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>pparams</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="e86ce230485c42da007e8003ddf75edf"></a><!-- doxytag: member="SAMRAI::mesh::BalanceUtilities::prebalanceBoxLevel" ref="e86ce230485c42da007e8003ddf75edf" args="(hier::BoxLevel &amp;balance_box_level, hier::Connector *balance_to_anchor, const tbox::RankGroup &amp;rank_group)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::mesh::BalanceUtilities::prebalanceBoxLevel           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1hier_1_1BoxLevel.html">hier::BoxLevel</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>balance_box_level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">hier::Connector</a> *&nbsp;</td>
          <td class="paramname"> <em>balance_to_anchor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1tbox_1_1RankGroup.html">tbox::RankGroup</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>rank_group</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Move Boxes in balance_box_level from ranks outside of rank_group to ranks inside rank_group. Modify the given connectors to make them correct following this moving of boxes.<p>
<dl compact><dt><b>Precondition:</b></dt><dd>!balance_to_anchor || balance_to_anchor-&gt;hasTranspose() <p>
!balance_to_anchor || (balance_to_anchor-&gt;getTranspose().checkTransposeCorrectness(*balance_to_anchor) == 0) <p>
!balance_to_anchor || (balance_to_anchor-&gt;checkTransposeCorrectness(balance_to_anchor-&gt;getTranspose()) == 0) </dd></dl>

</div>
</div><p>
<hr><h2>Member Data Documentation</h2>
<a class="anchor" name="4c3a6051043afc497fcdfc3a978e2631"></a><!-- doxytag: member="SAMRAI::mesh::BalanceUtilities::BalanceUtilities_PREBALANCE0" ref="4c3a6051043afc497fcdfc3a978e2631" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int <a class="el" href="structSAMRAI_1_1mesh_1_1BalanceUtilities.html#4c3a6051043afc497fcdfc3a978e2631">SAMRAI::mesh::BalanceUtilities::BalanceUtilities_PREBALANCE0</a> = 5<code> [static]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="e20a69522f8e4d46f96b7df8e0a04e69"></a><!-- doxytag: member="SAMRAI::mesh::BalanceUtilities::BalanceUtilities_PREBALANCE1" ref="e20a69522f8e4d46f96b7df8e0a04e69" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int <a class="el" href="structSAMRAI_1_1mesh_1_1BalanceUtilities.html#e20a69522f8e4d46f96b7df8e0a04e69">SAMRAI::mesh::BalanceUtilities::BalanceUtilities_PREBALANCE1</a> = 6<code> [static]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<hr>The documentation for this struct was generated from the following files:<ul>
<li>source/SAMRAI/mesh/<a class="el" href="BalanceUtilities_8h.html">BalanceUtilities.h</a><li>source/SAMRAI/mesh/<a class="el" href="BalanceUtilities_8C.html">BalanceUtilities.C</a></ul>
<hr size="1"><address style="align: right;"><small>Generated on 3 Mar 2015 for SAMRAI by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.7 </small></address>
</body>
</html>
