<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>SAMRAI: SAMRAI::algs::MethodOfLinesIntegrator Class Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.7 -->
<div class="tabs">
  <ul>
    <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="namespaces.html"><span>Namespaces</span></a></li>
    <li id="current"><a href="annotated.html"><span>Classes</span></a></li>
    <li><a href="files.html"><span>Files</span></a></li>
    <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
  </ul></div>
<div class="tabs">
  <ul>
    <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
    <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
    <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
  </ul></div>
<div class="nav">
<a class="el" href="namespaceSAMRAI.html">SAMRAI</a>::<a class="el" href="namespaceSAMRAI_1_1algs.html">algs</a>::<a class="el" href="classSAMRAI_1_1algs_1_1MethodOfLinesIntegrator.html">MethodOfLinesIntegrator</a></div>
<h1>SAMRAI::algs::MethodOfLinesIntegrator Class Reference</h1><!-- doxytag: class="SAMRAI::algs::MethodOfLinesIntegrator" --><!-- doxytag: inherits="SAMRAI::tbox::Serializable,SAMRAI::mesh::StandardTagAndInitStrategy" -->Class <a class="el" href="classSAMRAI_1_1algs_1_1MethodOfLinesIntegrator.html">MethodOfLinesIntegrator</a> implements a spatially adaptive version of the Strong Stability Preserving (SSP) Runge-Kutta time integration algorithm.  
<a href="#_details">More...</a>
<p>
<code>#include &lt;source/SAMRAI/algs/MethodOfLinesIntegrator.h&gt;</code>
<p>
<p>Inheritance diagram for SAMRAI::algs::MethodOfLinesIntegrator:
<p><center><img src="classSAMRAI_1_1algs_1_1MethodOfLinesIntegrator.png" usemap="#SAMRAI::algs::MethodOfLinesIntegrator_map" border="0" alt=""></center>
<map name="SAMRAI::algs::MethodOfLinesIntegrator_map">
<area href="classSAMRAI_1_1tbox_1_1Serializable.html" alt="SAMRAI::tbox::Serializable" shape="rect" coords="0,0,259,24">
<area href="classSAMRAI_1_1mesh_1_1StandardTagAndInitStrategy.html" alt="SAMRAI::mesh::StandardTagAndInitStrategy" shape="rect" coords="269,0,528,24">
</map>
<a href="classSAMRAI_1_1algs_1_1MethodOfLinesIntegrator-members.html">List of all members.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Types</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1algs_1_1MethodOfLinesIntegrator.html#4a95e922ac9692cefd58905930e16c55e41bc45c095fbc064c18b57579eb2eed">SOLN</a> = 0</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1algs_1_1MethodOfLinesIntegrator.html#4a95e922ac9692cefd58905930e16c55f328b2dbd2cb10a2698014f4f2278e84">RHS</a> = 1</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1algs_1_1MethodOfLinesIntegrator.html#4a95e922ac9692cefd58905930e16c55">MOL_VAR_TYPE</a> { <a class="el" href="classSAMRAI_1_1algs_1_1MethodOfLinesIntegrator.html#4a95e922ac9692cefd58905930e16c55e41bc45c095fbc064c18b57579eb2eed">SOLN</a> =  0, 
<a class="el" href="classSAMRAI_1_1algs_1_1MethodOfLinesIntegrator.html#4a95e922ac9692cefd58905930e16c55f328b2dbd2cb10a2698014f4f2278e84">RHS</a> =  1
 }</td></tr>

<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1algs_1_1MethodOfLinesIntegrator.html#b6cf6532c97d1f05e8bbfdab4dabfb87">MethodOfLinesIntegrator</a> (const std::string &amp;object_name, const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Database.html">tbox::Database</a> &gt; &amp;input_db, <a class="el" href="classSAMRAI_1_1algs_1_1MethodOfLinesPatchStrategy.html">MethodOfLinesPatchStrategy</a> *patch_strategy, bool register_for_restart=true)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1algs_1_1MethodOfLinesIntegrator.html#5d6ab79320741e0b09187cbcd90e7f18">~MethodOfLinesIntegrator</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1algs_1_1MethodOfLinesIntegrator.html#8c41d03cc73687d09c0d76dea5659952">initializeIntegrator</a> (const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1mesh_1_1GriddingAlgorithm.html">mesh::GriddingAlgorithm</a> &gt; &amp;gridding_alg)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1algs_1_1MethodOfLinesIntegrator.html#7f2173fd4bfbe51c978b28a100c7d1b9">getTimestep</a> (const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchHierarchy.html">hier::PatchHierarchy</a> &gt; &amp;hierarchy, const double time) const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1algs_1_1MethodOfLinesIntegrator.html#df6f79d0893f5ae89aed4f196c84ea64">advanceHierarchy</a> (const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchHierarchy.html">hier::PatchHierarchy</a> &gt; &amp;hierarchy, const double time, const double dt)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1algs_1_1MethodOfLinesIntegrator.html#df9e494270964a2ec6d162bb6b7f8e4b">registerVariable</a> (const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1hier_1_1Variable.html">hier::Variable</a> &gt; &amp;variable, const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a> &amp;ghosts, const <a class="el" href="classSAMRAI_1_1algs_1_1MethodOfLinesIntegrator.html#4a95e922ac9692cefd58905930e16c55">MOL_VAR_TYPE</a> m_v_type, const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1hier_1_1BaseGridGeometry.html">hier::BaseGridGeometry</a> &gt; &amp;transfer_geom, const std::string &amp;coarsen_name=std::string(), const std::string &amp;refine_name=std::string())</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1algs_1_1MethodOfLinesIntegrator.html#84753dd2f1959d799046f56cc2331466">printClassData</a> (std::ostream &amp;os) const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1algs_1_1MethodOfLinesIntegrator.html#77bc795610af359bb4bbacd61734d8db">initializeLevelData</a> (const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchHierarchy.html">hier::PatchHierarchy</a> &gt; &amp;hierarchy, const int level_number, const double init_time, const bool can_be_refined, const bool initial_time, const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchLevel.html">hier::PatchLevel</a> &gt; &amp;old_level=boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchLevel.html">hier::PatchLevel</a> &gt;(), const bool allocate_data=true)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1algs_1_1MethodOfLinesIntegrator.html#b543769192d85b7b97863e7e9c93f08b">resetHierarchyConfiguration</a> (const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchHierarchy.html">hier::PatchHierarchy</a> &gt; &amp;hierarchy, const int coarsest_level, const int finest_level)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1algs_1_1MethodOfLinesIntegrator.html#9c4f23ddff32c34cb64107cba91154be">applyGradientDetector</a> (const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchHierarchy.html">hier::PatchHierarchy</a> &gt; &amp;hierarchy, const int level_number, const double time, const int tag_index, const bool initial_time, const bool uses_richardson_extrapolation_too)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1algs_1_1MethodOfLinesIntegrator.html#0106ce68c8e81702001d1ed6ded5d686">putToDatabase</a> (const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Database.html">tbox::Database</a> &gt; &amp;db) const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">const std::string &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1algs_1_1MethodOfLinesIntegrator.html#216da353c4cb6b07570308d272f8658a">getObjectName</a> () const </td></tr>

</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
Class <a class="el" href="classSAMRAI_1_1algs_1_1MethodOfLinesIntegrator.html">MethodOfLinesIntegrator</a> implements a spatially adaptive version of the Strong Stability Preserving (SSP) Runge-Kutta time integration algorithm. 
<p>
The original non-adaptive version of the algorithm is described in S. Gottlieb, C.W. Shu, E. Tadmor, SIAM Review, Vol. 43, No. 1, pp. 89-112. The <a class="el" href="classSAMRAI_1_1algs_1_1MethodOfLinesIntegrator.html#df6f79d0893f5ae89aed4f196c84ea64">advanceHierarchy()</a> method integrates all levels of an AMR hierarchy through a specified timestep. See this method for details of the time-stepping process. Application-specific numerical routines that are necessary for these operations are provided by the <a class="el" href="classSAMRAI_1_1algs_1_1MethodOfLinesPatchStrategy.html">MethodOfLinesPatchStrategy</a> data member. The collaboration between this class and the patch strategy follows the the Strategy design pattern. A concrete patch strategy object is derived from the base class to provide those routines for a specific problem.<p>
This class is derived from the <a class="el" href="classSAMRAI_1_1mesh_1_1StandardTagAndInitStrategy.html">mesh::StandardTagAndInitStrategy</a> abstract base class which defines an interface for routines required by the dynamic adaptive mesh refinement routines in the <a class="el" href="classSAMRAI_1_1mesh_1_1GriddingAlgorithm.html">mesh::GriddingAlgorithm</a> class. This collaboration also follows the Strategy design pattern.<p>
Initialization of an <a class="el" href="classSAMRAI_1_1algs_1_1MethodOfLinesIntegrator.html">MethodOfLinesIntegrator</a> object is performed by first setting default values, then reading from input. All input values may override values read from restart. Data read from input is summarized as follows:<p>
Required input keys and data types: NONE<p>
Optional input keys, data types, and defaults:<p>
<ul>
<li><b>order</b> integer value specifying order of Runge-Kutta scheme. If no input value is given, third order (i.e. order = 3) is used.</li></ul>
<p>
<ul>
<li><b>alpha_1</b> </li><li><b>alpha_2</b> </li><li><b>beta</b> arrays of double values (length = order) specifying the coeffients used in the multi-step Strong Stability Preserving (SSP) Runge-Kutta algorithm. If no input is supplied, the default alpha_1, alpha_2, and beta values are automatically set to correspond to the specified order.</li></ul>
<p>
The following represents a sample input entry:<p>
<div class="fragment"><pre class="fragment"> *  MethodOfLinesIntegrator{
 *     order                 = 3
 *     alpha_1               = 1., 0.75, 0.33333
 *     alpha_2               = 0., 0.25, 0.66666
 *     beta                  = 1., 0.25, 0.66666
 *  }
 *  </pre></div><p>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classSAMRAI_1_1mesh_1_1StandardTagAndInitStrategy.html">mesh::StandardTagAndInitStrategy</a> </dd></dl>

<p>
<hr><h2>Member Enumeration Documentation</h2>
<a class="anchor" name="4a95e922ac9692cefd58905930e16c55"></a><!-- doxytag: member="SAMRAI::algs::MethodOfLinesIntegrator::MOL_VAR_TYPE" ref="4a95e922ac9692cefd58905930e16c55" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classSAMRAI_1_1algs_1_1MethodOfLinesIntegrator.html#4a95e922ac9692cefd58905930e16c55">SAMRAI::algs::MethodOfLinesIntegrator::MOL_VAR_TYPE</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Enumerated type for the different categories of variable quantities allowed by the method of lines integration algorithm. See registerVariable(...) function for more details.<p>
<ul>
<li><b>SOLN</b> {Solution quantity for time-dependent ODE problem solved by RK time-stepping algorithm.}</li><li><b>RHS</b> {Right-hand-side of ODE problem solved; i.e., du/dt = RHS.} </li></ul>
<dl compact><dt><b>Enumerator: </b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" name="4a95e922ac9692cefd58905930e16c55e41bc45c095fbc064c18b57579eb2eed"></a><!-- doxytag: member="SOLN" ref="4a95e922ac9692cefd58905930e16c55e41bc45c095fbc064c18b57579eb2eed" args="" -->SOLN</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" name="4a95e922ac9692cefd58905930e16c55f328b2dbd2cb10a2698014f4f2278e84"></a><!-- doxytag: member="RHS" ref="4a95e922ac9692cefd58905930e16c55f328b2dbd2cb10a2698014f4f2278e84" args="" -->RHS</em>&nbsp;</td><td>
</td></tr>
</table>
</dl>

</div>
</div><p>
<hr><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" name="b6cf6532c97d1f05e8bbfdab4dabfb87"></a><!-- doxytag: member="SAMRAI::algs::MethodOfLinesIntegrator::MethodOfLinesIntegrator" ref="b6cf6532c97d1f05e8bbfdab4dabfb87" args="(const std::string &amp;object_name, const boost::shared_ptr&lt; tbox::Database &gt; &amp;input_db, MethodOfLinesPatchStrategy *patch_strategy, bool register_for_restart=true)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SAMRAI::algs::MethodOfLinesIntegrator::MethodOfLinesIntegrator           </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>object_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Database.html">tbox::Database</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>input_db</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1algs_1_1MethodOfLinesPatchStrategy.html">MethodOfLinesPatchStrategy</a> *&nbsp;</td>
          <td class="paramname"> <em>patch_strategy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>register_for_restart</em> = <code>true</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The constructor for <a class="el" href="classSAMRAI_1_1algs_1_1MethodOfLinesIntegrator.html">MethodOfLinesIntegrator</a> configures the method of lines integration algorithm with the concrete patch strategy object (containing problem-specific numerical routines) and initializes integration algorithm parameters provided in the specified input database and in the restart database corresponding to the specified object_name. The constructor also registers this object for restart using the specified object name when the boolean argument is true. Whether object will write its state to restart files during program execution is determined by this argument. Note that it has a default state of true.<p>
When assertion checking is active, passing in any null pointer or an empty std::string will result in an unrecoverable assertion. 
</div>
</div><p>
<a class="anchor" name="5d6ab79320741e0b09187cbcd90e7f18"></a><!-- doxytag: member="SAMRAI::algs::MethodOfLinesIntegrator::~MethodOfLinesIntegrator" ref="5d6ab79320741e0b09187cbcd90e7f18" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SAMRAI::algs::MethodOfLinesIntegrator::~MethodOfLinesIntegrator           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The destructor for <a class="el" href="classSAMRAI_1_1algs_1_1MethodOfLinesIntegrator.html">MethodOfLinesIntegrator</a> unregisters the integrator object with the restart manager when so registered. 
</div>
</div><p>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="8c41d03cc73687d09c0d76dea5659952"></a><!-- doxytag: member="SAMRAI::algs::MethodOfLinesIntegrator::initializeIntegrator" ref="8c41d03cc73687d09c0d76dea5659952" args="(const boost::shared_ptr&lt; mesh::GriddingAlgorithm &gt; &amp;gridding_alg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::algs::MethodOfLinesIntegrator::initializeIntegrator           </td>
          <td>(</td>
          <td class="paramtype">const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1mesh_1_1GriddingAlgorithm.html">mesh::GriddingAlgorithm</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>gridding_alg</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Initialize integrator by setting the number of time levels of data needed based on specifications of the gridding algorithm.<p>
This routine also invokes variable registration in the patch strategy. 
</div>
</div><p>
<a class="anchor" name="7f2173fd4bfbe51c978b28a100c7d1b9"></a><!-- doxytag: member="SAMRAI::algs::MethodOfLinesIntegrator::getTimestep" ref="7f2173fd4bfbe51c978b28a100c7d1b9" args="(const boost::shared_ptr&lt; hier::PatchHierarchy &gt; &amp;hierarchy, const double time) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double SAMRAI::algs::MethodOfLinesIntegrator::getTimestep           </td>
          <td>(</td>
          <td class="paramtype">const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchHierarchy.html">hier::PatchHierarchy</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>hierarchy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>time</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return a suitable time increment over which to integrate the ODE problem. A minimum is taken over the increment computed on each patch in the hierarchy. 
</div>
</div><p>
<a class="anchor" name="df6f79d0893f5ae89aed4f196c84ea64"></a><!-- doxytag: member="SAMRAI::algs::MethodOfLinesIntegrator::advanceHierarchy" ref="df6f79d0893f5ae89aed4f196c84ea64" args="(const boost::shared_ptr&lt; hier::PatchHierarchy &gt; &amp;hierarchy, const double time, const double dt)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::algs::MethodOfLinesIntegrator::advanceHierarchy           </td>
          <td>(</td>
          <td class="paramtype">const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchHierarchy.html">hier::PatchHierarchy</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>hierarchy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>dt</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Advance the solution through the specified dt, which is assumed for the problem and state of the solution. Advances all patches in the hierarchy passed in. 
</div>
</div><p>
<a class="anchor" name="df9e494270964a2ec6d162bb6b7f8e4b"></a><!-- doxytag: member="SAMRAI::algs::MethodOfLinesIntegrator::registerVariable" ref="df9e494270964a2ec6d162bb6b7f8e4b" args="(const boost::shared_ptr&lt; hier::Variable &gt; &amp;variable, const hier::IntVector &amp;ghosts, const MOL_VAR_TYPE m_v_type, const boost::shared_ptr&lt; hier::BaseGridGeometry &gt; &amp;transfer_geom, const std::string &amp;coarsen_name=std::string(), const std::string &amp;refine_name=std::string())" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::algs::MethodOfLinesIntegrator::registerVariable           </td>
          <td>(</td>
          <td class="paramtype">const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1hier_1_1Variable.html">hier::Variable</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>variable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>ghosts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1algs_1_1MethodOfLinesIntegrator.html#4a95e922ac9692cefd58905930e16c55">MOL_VAR_TYPE</a>&nbsp;</td>
          <td class="paramname"> <em>m_v_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1hier_1_1BaseGridGeometry.html">hier::BaseGridGeometry</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>transfer_geom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>coarsen_name</em> = <code>std::string()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>refine_name</em> = <code>std::string()</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Register variable quantity defined in the patch strategy with the method of lines integrator which manipulates its storage. 
</div>
</div><p>
<a class="anchor" name="84753dd2f1959d799046f56cc2331466"></a><!-- doxytag: member="SAMRAI::algs::MethodOfLinesIntegrator::printClassData" ref="84753dd2f1959d799046f56cc2331466" args="(std::ostream &amp;os) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::algs::MethodOfLinesIntegrator::printClassData           </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&nbsp;</td>
          <td class="paramname"> <em>os</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Print all data members of <a class="el" href="classSAMRAI_1_1algs_1_1MethodOfLinesIntegrator.html">MethodOfLinesIntegrator</a> object. 
</div>
</div><p>
<a class="anchor" name="77bc795610af359bb4bbacd61734d8db"></a><!-- doxytag: member="SAMRAI::algs::MethodOfLinesIntegrator::initializeLevelData" ref="77bc795610af359bb4bbacd61734d8db" args="(const boost::shared_ptr&lt; hier::PatchHierarchy &gt; &amp;hierarchy, const int level_number, const double init_time, const bool can_be_refined, const bool initial_time, const boost::shared_ptr&lt; hier::PatchLevel &gt; &amp;old_level=boost::shared_ptr&lt; hier::PatchLevel &gt;(), const bool allocate_data=true)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::algs::MethodOfLinesIntegrator::initializeLevelData           </td>
          <td>(</td>
          <td class="paramtype">const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchHierarchy.html">hier::PatchHierarchy</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>hierarchy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>level_number</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>init_time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&nbsp;</td>
          <td class="paramname"> <em>can_be_refined</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&nbsp;</td>
          <td class="paramname"> <em>initial_time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchLevel.html">hier::PatchLevel</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>old_level</em> = <code>boost::shared_ptr&lt;&nbsp;<a class="el" href="classSAMRAI_1_1hier_1_1PatchLevel.html">hier::PatchLevel</a>&nbsp;&gt;()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&nbsp;</td>
          <td class="paramname"> <em>allocate_data</em> = <code>true</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Initialize data on a new level after it is inserted into an AMR patch hierarchy by the gridding algorithm. The level number indicates that of the new level. The old_level pointer corresponds to the level that resided in the hierarchy before the level with the specified number was introduced. If the pointer is NULL, there was no level in the hierarchy prior to the call and the level data is set based on the user routines and the simulation time. Otherwise, the specified level replaces the old level and the new level receives data from the old level appropriately before it is destroyed.<p>
Typically, when data is set, it is interpolated from coarser levels in the hierarchy. If the data is to be set, the level number must match that of the old level, if non-NULL. If the old level is non-NULL, then data is copied from the old level to the new level on regions of intersection between those levels before interpolation occurs. Then, user-supplied patch routines are called to further initialize the data if needed. The boolean argument after_regrid is passed into the user's routines.<p>
The boolean argument initial_time indicates whether the integration time corresponds to the initial simulation time. If true, the level should be initialized with initial simulation values. Otherwise, it should be assumed that the simulation time is at some point after the start of the simulation. This information is provided since the initialization of the data on a patch may be different in each of those circumstances. The can_be_refined boolean argument indicates whether the level is the finest allowable level in the hierarchy.<p>
Note: This function is overloaded from the base class <a class="el" href="classSAMRAI_1_1mesh_1_1StandardTagAndInitStrategy.html">mesh::StandardTagAndInitStrategy</a>. 
<p>
Implements <a class="el" href="classSAMRAI_1_1mesh_1_1StandardTagAndInitStrategy.html#43aab4033b5be85ecee18f52c8e4980c">SAMRAI::mesh::StandardTagAndInitStrategy</a>.
</div>
</div><p>
<a class="anchor" name="b543769192d85b7b97863e7e9c93f08b"></a><!-- doxytag: member="SAMRAI::algs::MethodOfLinesIntegrator::resetHierarchyConfiguration" ref="b543769192d85b7b97863e7e9c93f08b" args="(const boost::shared_ptr&lt; hier::PatchHierarchy &gt; &amp;hierarchy, const int coarsest_level, const int finest_level)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::algs::MethodOfLinesIntegrator::resetHierarchyConfiguration           </td>
          <td>(</td>
          <td class="paramtype">const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchHierarchy.html">hier::PatchHierarchy</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>hierarchy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>coarsest_level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>finest_level</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Reset cached communication schedules after the hierarchy has changed (due to regridding, for example) and the data has been initialized on the new levels. The intent is that the cost of data movement on the hierarchy will be amortized across multiple communication cycles, if possible. Note, that whenever this routine is called, communication schedules are updated for every level finer than and including that indexed by coarsest_level.<p>
Note: This function is overloaded from the base class <a class="el" href="classSAMRAI_1_1mesh_1_1StandardTagAndInitStrategy.html">mesh::StandardTagAndInitStrategy</a>. 
<p>
Implements <a class="el" href="classSAMRAI_1_1mesh_1_1StandardTagAndInitStrategy.html#fe20d86963726d6aa8fa80cf0417c27c">SAMRAI::mesh::StandardTagAndInitStrategy</a>.
</div>
</div><p>
<a class="anchor" name="9c4f23ddff32c34cb64107cba91154be"></a><!-- doxytag: member="SAMRAI::algs::MethodOfLinesIntegrator::applyGradientDetector" ref="9c4f23ddff32c34cb64107cba91154be" args="(const boost::shared_ptr&lt; hier::PatchHierarchy &gt; &amp;hierarchy, const int level_number, const double time, const int tag_index, const bool initial_time, const bool uses_richardson_extrapolation_too)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::algs::MethodOfLinesIntegrator::applyGradientDetector           </td>
          <td>(</td>
          <td class="paramtype">const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchHierarchy.html">hier::PatchHierarchy</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>hierarchy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>level_number</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>tag_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&nbsp;</td>
          <td class="paramname"> <em>initial_time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&nbsp;</td>
          <td class="paramname"> <em>uses_richardson_extrapolation_too</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set integer tags to "one" on the given level where refinement of that level should occur using the user-supplied gradient detector. The boolean argument initial_time is true when the level is being subject to error estimation at initialization time. If it is false, the error estimation process is being invoked at some later time after the AMR hierarchy was initially constructed. The boolean argument uses_richardson_extrapolation_too is true when Richardson extrapolation error estimation is used in addition to the gradient detector, and false otherwise. This argument helps the user to manage multiple regridding criteria. This information is passed along to the user's patch data tagging routines since the application of the error estimator may be different in each of those circumstances.<p>
Note: This function is overloaded from the base class <a class="el" href="classSAMRAI_1_1mesh_1_1StandardTagAndInitStrategy.html">mesh::StandardTagAndInitStrategy</a>. 
<p>
Reimplemented from <a class="el" href="classSAMRAI_1_1mesh_1_1StandardTagAndInitStrategy.html#9d335c20033ca83646f72980d5d7715b">SAMRAI::mesh::StandardTagAndInitStrategy</a>.
</div>
</div><p>
<a class="anchor" name="0106ce68c8e81702001d1ed6ded5d686"></a><!-- doxytag: member="SAMRAI::algs::MethodOfLinesIntegrator::putToDatabase" ref="0106ce68c8e81702001d1ed6ded5d686" args="(const boost::shared_ptr&lt; tbox::Database &gt; &amp;db) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::algs::MethodOfLinesIntegrator::putToDatabase           </td>
          <td>(</td>
          <td class="paramtype">const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Database.html">tbox::Database</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>db</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Writes object state out to the given database.<p>
When assertion checking is enabled, the database pointer must be non-null. 
</div>
</div><p>
<a class="anchor" name="216da353c4cb6b07570308d272f8658a"></a><!-- doxytag: member="SAMRAI::algs::MethodOfLinesIntegrator::getObjectName" ref="216da353c4cb6b07570308d272f8658a" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::string&amp; SAMRAI::algs::MethodOfLinesIntegrator::getObjectName           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the object name. 
</div>
</div><p>
<hr>The documentation for this class was generated from the following files:<ul>
<li>source/SAMRAI/algs/<a class="el" href="MethodOfLinesIntegrator_8h.html">MethodOfLinesIntegrator.h</a><li>source/SAMRAI/algs/<a class="el" href="MethodOfLinesIntegrator_8C.html">MethodOfLinesIntegrator.C</a></ul>
<hr size="1"><address style="align: right;"><small>Generated on Thu Jun 21 13:42:56 2012 for SAMRAI by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.7 </small></address>
</body>
</html>
