<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>SAMRAI: SAMRAI::algs::MethodOfLinesIntegrator Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath"><a class="el" href="namespaceSAMRAI.html">SAMRAI</a>::<a class="el" href="namespaceSAMRAI_1_1algs.html">algs</a>::<a class="el" href="classSAMRAI_1_1algs_1_1MethodOfLinesIntegrator.html">MethodOfLinesIntegrator</a>
  </div>
</div>
<div class="contents">
<h1>SAMRAI::algs::MethodOfLinesIntegrator Class Reference</h1><!-- doxytag: class="SAMRAI::algs::MethodOfLinesIntegrator" --><!-- doxytag: inherits="SAMRAI::tbox::Serializable,SAMRAI::mesh::StandardTagAndInitStrategy" -->
<p>Class <a class="el" href="classSAMRAI_1_1algs_1_1MethodOfLinesIntegrator.html" title="Class MethodOfLinesIntegrator implements a spatially adaptive version of the Strong...">MethodOfLinesIntegrator</a> implements a spatially adaptive version of the Strong Stability Preserving (SSP) Runge-Kutta time integration algorithm.  
<a href="#_details">More...</a></p>

<p><code>#include &lt;source/SAMRAI/algs/MethodOfLinesIntegrator.h&gt;</code></p>
<div class="dynheader">
Inheritance diagram for SAMRAI::algs::MethodOfLinesIntegrator:</div>
<div class="dynsection">
 <div class="center">
  <img src="classSAMRAI_1_1algs_1_1MethodOfLinesIntegrator.gif" usemap="#SAMRAI::algs::MethodOfLinesIntegrator_map" alt=""/>
  <map id="SAMRAI::algs::MethodOfLinesIntegrator_map" name="SAMRAI::algs::MethodOfLinesIntegrator_map">
<area href="classSAMRAI_1_1tbox_1_1Serializable.html" alt="SAMRAI::tbox::Serializable" shape="rect" coords="0,0,259,24"/>
<area href="classSAMRAI_1_1mesh_1_1StandardTagAndInitStrategy.html" alt="SAMRAI::mesh::StandardTagAndInitStrategy" shape="rect" coords="269,0,528,24"/>
</map>
 </div>
</div>

<p><a href="classSAMRAI_1_1algs_1_1MethodOfLinesIntegrator-members.html">List of all members.</a></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Public Types</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1algs_1_1MethodOfLinesIntegrator.html#a25ed25ae080357a46aaac785496e1775">MOL_VAR_TYPE</a> { <a class="el" href="classSAMRAI_1_1algs_1_1MethodOfLinesIntegrator.html#a25ed25ae080357a46aaac785496e1775a10c156c3215dfc4bbff06ec8eb25d053">SOLN</a> =  0, 
<a class="el" href="classSAMRAI_1_1algs_1_1MethodOfLinesIntegrator.html#a25ed25ae080357a46aaac785496e1775a7e0bc60a9247f08d98d861c39d520594">RHS</a> =  1
 }</td></tr>
<tr><td colspan="2"><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1algs_1_1MethodOfLinesIntegrator.html#a19aae3600496759725acfc08bd0dd72d">MethodOfLinesIntegrator</a> (const std::string &amp;object_name, const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Database.html">tbox::Database</a> &gt; &amp;input_db, <a class="el" href="classSAMRAI_1_1algs_1_1MethodOfLinesPatchStrategy.html">MethodOfLinesPatchStrategy</a> *patch_strategy)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1algs_1_1MethodOfLinesIntegrator.html#a313ebec84e01ccd5939bbf6c858c33f5">~MethodOfLinesIntegrator</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1algs_1_1MethodOfLinesIntegrator.html#acb5424717b932bbfd7191bae8bbae004">initializeIntegrator</a> (const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1mesh_1_1GriddingAlgorithm.html">mesh::GriddingAlgorithm</a> &gt; &amp;gridding_alg)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1algs_1_1MethodOfLinesIntegrator.html#a686d7d7e5b350150950f73dc17de202f">getTimestep</a> (const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchHierarchy.html">hier::PatchHierarchy</a> &gt; &amp;hierarchy, const double time) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1algs_1_1MethodOfLinesIntegrator.html#ab15c0df323f82747232cabb1490671a7">advanceHierarchy</a> (const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchHierarchy.html">hier::PatchHierarchy</a> &gt; &amp;hierarchy, const double time, const double dt)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1algs_1_1MethodOfLinesIntegrator.html#a33923f2cf98de20eb3effac6888f41d5">registerVariable</a> (const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1hier_1_1Variable.html">hier::Variable</a> &gt; &amp;variable, const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a> &amp;ghosts, const <a class="el" href="classSAMRAI_1_1algs_1_1MethodOfLinesIntegrator.html#a25ed25ae080357a46aaac785496e1775">MOL_VAR_TYPE</a> m_v_type, const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1hier_1_1BaseGridGeometry.html">hier::BaseGridGeometry</a> &gt; &amp;transfer_geom, const std::string &amp;coarsen_name=std::string(), const std::string &amp;refine_name=std::string())</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1algs_1_1MethodOfLinesIntegrator.html#a6e6a7b029afd818fc75f9ce19b25c556">printClassData</a> (std::ostream &amp;os) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1algs_1_1MethodOfLinesIntegrator.html#ade065cc3ed6bd4936b72dcc88df07580">initializeLevelData</a> (const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchHierarchy.html">hier::PatchHierarchy</a> &gt; &amp;hierarchy, const int level_number, const double init_time, const bool can_be_refined, const bool initial_time, const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchLevel.html">hier::PatchLevel</a> &gt; &amp;old_level=boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchLevel.html">hier::PatchLevel</a> &gt;(), const bool allocate_data=true)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1algs_1_1MethodOfLinesIntegrator.html#a97a0d8a66c02d0c4c39701747aa61fac">resetHierarchyConfiguration</a> (const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchHierarchy.html">hier::PatchHierarchy</a> &gt; &amp;hierarchy, const int coarsest_level, const int finest_level)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1algs_1_1MethodOfLinesIntegrator.html#aa8cc336004d00cc179e9b6c4978dd4f3">applyGradientDetector</a> (const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchHierarchy.html">hier::PatchHierarchy</a> &gt; &amp;hierarchy, const int level_number, const double time, const int tag_index, const bool initial_time, const bool uses_richardson_extrapolation_too)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1algs_1_1MethodOfLinesIntegrator.html#ad2b76a8dadb25206a3b8e9e7e260ddd2">putToRestart</a> (const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Database.html">tbox::Database</a> &gt; &amp;restart_db) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const std::string &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1algs_1_1MethodOfLinesIntegrator.html#a490ecd121d71da22b6928c640454cf69">getObjectName</a> () const </td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>Class <a class="el" href="classSAMRAI_1_1algs_1_1MethodOfLinesIntegrator.html" title="Class MethodOfLinesIntegrator implements a spatially adaptive version of the Strong...">MethodOfLinesIntegrator</a> implements a spatially adaptive version of the Strong Stability Preserving (SSP) Runge-Kutta time integration algorithm. </p>
<p>The original non-adaptive version of the algorithm is described in S. Gottlieb, C.W. Shu, E. Tadmor, SIAM Review, Vol. 43, No. 1, pp. 89-112. The <a class="el" href="classSAMRAI_1_1algs_1_1MethodOfLinesIntegrator.html#ab15c0df323f82747232cabb1490671a7">advanceHierarchy()</a> method integrates all levels of an AMR hierarchy through a specified timestep. See this method for details of the time-stepping process. Application-specific numerical routines that are necessary for these operations are provided by the <a class="el" href="classSAMRAI_1_1algs_1_1MethodOfLinesPatchStrategy.html">MethodOfLinesPatchStrategy</a> data member. The collaboration between this class and the patch strategy follows the the Strategy design pattern. A concrete patch strategy object is derived from the base class to provide those routines for a specific problem.</p>
<p>This class is derived from the <a class="el" href="classSAMRAI_1_1mesh_1_1StandardTagAndInitStrategy.html">mesh::StandardTagAndInitStrategy</a> abstract base class which defines an interface for routines required by the dynamic adaptive <a class="el" href="namespaceSAMRAI_1_1mesh.html">mesh</a> refinement routines in the <a class="el" href="classSAMRAI_1_1mesh_1_1GriddingAlgorithm.html" title="Class GriddingAlgorithm manages AMR patch hierarchy construction operations in SAMRAI...">mesh::GriddingAlgorithm</a> class. This collaboration also follows the Strategy design pattern.</p>
<p>Initialization of an <a class="el" href="classSAMRAI_1_1algs_1_1MethodOfLinesIntegrator.html" title="Class MethodOfLinesIntegrator implements a spatially adaptive version of the Strong...">MethodOfLinesIntegrator</a> object is performed by first setting default values, then reading from input. All input values may override values read from restart. Data read from input is summarized as follows:</p>
<p><b> Input Parameters </b></p>
<p><b> Definitions: </b></p>
<ul>
<li><b>alpha_1</b> </li>
<li><b>alpha_2</b> </li>
<li><b>beta</b> <br/>
 arrays of double values (length = order) specifying the coeffients used in the multi-step Strong Stability Preserving (SSP) Runge-Kutta algorithm.</li>
</ul>
<p>Note that when continuing from restart, the input parameters in the input database override all values read in from the restart database.</p>
<p><b> Details: </b> <br/>
 </p>
<table border="1" cellspacing="3" cellpadding="3">
<tr>
<th><p>parameter </p>
</th><th><p>type </p>
</th><th><p>default </p>
</th><th><p>range </p>
</th><th><p>opt/req </p>
</th><th><p>behavior on restart  </p>
</th></tr>
<tr>
<td><p>alpha_1 </p>
</td><td><p>array of doubles </p>
</td><td><p>[1.0, 0.75, 2.0/3.0] </p>
</td><td><p>any doubles but no more than 3 of them </p>
</td><td><p>opt </p>
</td><td><p>Parameter read from restart db may be overridden by input db  </p>
</td></tr>
<tr>
<td><p>alpha_2 </p>
</td><td><p>array of doubles </p>
</td><td><p>[0.0, 0.25, 2.0/3.0] </p>
</td><td><p>any doubles but no more than 3 of them </p>
</td><td><p>opt </p>
</td><td><p>Parameter read from restart db may be overridden by input db  </p>
</td></tr>
<tr>
<td><p>beta </p>
</td><td><p>array of doubles </p>
</td><td><p>[1.0, 0.25, 2.0/3.0] </p>
</td><td><p>any doubles but no more than 3 of them </p>
</td><td><p>opt </p>
</td><td><p>Parameter read from restart db may be overridden by input db  </p>
</td></tr>
</table>
<p>The following represents a sample input entry:</p>
<div class="fragment"><pre class="fragment">  <a class="code" href="classSAMRAI_1_1algs_1_1MethodOfLinesIntegrator.html#a19aae3600496759725acfc08bd0dd72d">MethodOfLinesIntegrator</a>{
     alpha_1               = 1., 0.75, 0.33333
     alpha_2               = 0., 0.25, 0.66666
     beta                  = 1., 0.25, 0.66666
  }
</pre></div><dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classSAMRAI_1_1mesh_1_1StandardTagAndInitStrategy.html">mesh::StandardTagAndInitStrategy</a> </dd></dl>
<hr/><h2>Member Enumeration Documentation</h2>
<a class="anchor" id="a25ed25ae080357a46aaac785496e1775"></a><!-- doxytag: member="SAMRAI::algs::MethodOfLinesIntegrator::MOL_VAR_TYPE" ref="a25ed25ae080357a46aaac785496e1775" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classSAMRAI_1_1algs_1_1MethodOfLinesIntegrator.html#a25ed25ae080357a46aaac785496e1775">SAMRAI::algs::MethodOfLinesIntegrator::MOL_VAR_TYPE</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Enumerated type for the different categories of variable quantities allowed by the method of lines integration algorithm. See registerVariable(...) function for more details.</p>
<ul>
<li><b>SOLN</b> {Solution quantity for time-dependent ODE problem solved by RK time-stepping algorithm.}</li>
<li><b>RHS</b> {Right-hand-side of ODE problem solved; i.e., du/dt = RHS.} </li>
</ul>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="a25ed25ae080357a46aaac785496e1775a10c156c3215dfc4bbff06ec8eb25d053"></a><!-- doxytag: member="SOLN" ref="a25ed25ae080357a46aaac785496e1775a10c156c3215dfc4bbff06ec8eb25d053" args="" -->SOLN</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a25ed25ae080357a46aaac785496e1775a7e0bc60a9247f08d98d861c39d520594"></a><!-- doxytag: member="RHS" ref="a25ed25ae080357a46aaac785496e1775a7e0bc60a9247f08d98d861c39d520594" args="" -->RHS</em>&nbsp;</td><td>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a19aae3600496759725acfc08bd0dd72d"></a><!-- doxytag: member="SAMRAI::algs::MethodOfLinesIntegrator::MethodOfLinesIntegrator" ref="a19aae3600496759725acfc08bd0dd72d" args="(const std::string &amp;object_name, const boost::shared_ptr&lt; tbox::Database &gt; &amp;input_db, MethodOfLinesPatchStrategy *patch_strategy)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SAMRAI::algs::MethodOfLinesIntegrator::MethodOfLinesIntegrator </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>object_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Database.html">tbox::Database</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>input_db</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1algs_1_1MethodOfLinesPatchStrategy.html">MethodOfLinesPatchStrategy</a> *&nbsp;</td>
          <td class="paramname"> <em>patch_strategy</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>The constructor for <a class="el" href="classSAMRAI_1_1algs_1_1MethodOfLinesIntegrator.html" title="Class MethodOfLinesIntegrator implements a spatially adaptive version of the Strong...">MethodOfLinesIntegrator</a> configures the method of lines integration algorithm with the concrete patch strategy object (containing problem-specific numerical routines) and initializes integration algorithm parameters provided in the specified input database and in the restart database corresponding to the specified object_name.</p>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>!object_name.empty() </dd>
<dd>
patch_strategy != 0 </dd></dl>

<p>References <a class="el" href="RestartManager_8C_source.html#l00047">SAMRAI::tbox::RestartManager::getManager()</a>, <a class="el" href="MethodOfLinesPatchStrategy_8h_source.html#l00168">SAMRAI::algs::MethodOfLinesPatchStrategy::setInteriorContext()</a>, <a class="el" href="MethodOfLinesPatchStrategy_8h_source.html#l00158">SAMRAI::algs::MethodOfLinesPatchStrategy::setInteriorWithGhostsContext()</a>, and <a class="el" href="Utilities_8h_source.html#l00110">TBOX_ASSERT</a>.</p>

</div>
</div>
<a class="anchor" id="a313ebec84e01ccd5939bbf6c858c33f5"></a><!-- doxytag: member="SAMRAI::algs::MethodOfLinesIntegrator::~MethodOfLinesIntegrator" ref="a313ebec84e01ccd5939bbf6c858c33f5" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SAMRAI::algs::MethodOfLinesIntegrator::~MethodOfLinesIntegrator </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>The destructor for <a class="el" href="classSAMRAI_1_1algs_1_1MethodOfLinesIntegrator.html" title="Class MethodOfLinesIntegrator implements a spatially adaptive version of the Strong...">MethodOfLinesIntegrator</a> unregisters the integrator object with the restart manager. </p>

<p>References <a class="el" href="RestartManager_8C_source.html#l00047">SAMRAI::tbox::RestartManager::getManager()</a>.</p>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="acb5424717b932bbfd7191bae8bbae004"></a><!-- doxytag: member="SAMRAI::algs::MethodOfLinesIntegrator::initializeIntegrator" ref="acb5424717b932bbfd7191bae8bbae004" args="(const boost::shared_ptr&lt; mesh::GriddingAlgorithm &gt; &amp;gridding_alg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::algs::MethodOfLinesIntegrator::initializeIntegrator </td>
          <td>(</td>
          <td class="paramtype">const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1mesh_1_1GriddingAlgorithm.html">mesh::GriddingAlgorithm</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>gridding_alg</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Initialize integrator by setting the number of time levels of data needed based on specifications of the gridding algorithm.</p>
<p>This routine also invokes variable registration in the patch strategy.</p>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>gridding_alg </dd></dl>

<p>References <a class="el" href="Utilities_8h_source.html#l00050">NULL_USE</a>, <a class="el" href="classSAMRAI_1_1algs_1_1MethodOfLinesPatchStrategy.html#aff8f6ef934a337a2e4f86f000233851c">SAMRAI::algs::MethodOfLinesPatchStrategy::registerModelVariables()</a>, and <a class="el" href="Utilities_8h_source.html#l00110">TBOX_ASSERT</a>.</p>

</div>
</div>
<a class="anchor" id="a686d7d7e5b350150950f73dc17de202f"></a><!-- doxytag: member="SAMRAI::algs::MethodOfLinesIntegrator::getTimestep" ref="a686d7d7e5b350150950f73dc17de202f" args="(const boost::shared_ptr&lt; hier::PatchHierarchy &gt; &amp;hierarchy, const double time) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double SAMRAI::algs::MethodOfLinesIntegrator::getTimestep </td>
          <td>(</td>
          <td class="paramtype">const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchHierarchy.html">hier::PatchHierarchy</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>hierarchy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>time</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a suitable time increment over which to integrate the ODE problem. A minimum is taken over the increment computed on each patch in the hierarchy.</p>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>hierarchy </dd></dl>

<p>References <a class="el" href="classSAMRAI_1_1algs_1_1MethodOfLinesPatchStrategy.html#a68c086922e74ae0f8cba318573df1c41">SAMRAI::algs::MethodOfLinesPatchStrategy::computeStableDtOnPatch()</a>, <a class="el" href="SAMRAI__MPI_8h_source.html#l00059">MPI_MIN</a>, and <a class="el" href="Utilities_8h_source.html#l00110">TBOX_ASSERT</a>.</p>

</div>
</div>
<a class="anchor" id="ab15c0df323f82747232cabb1490671a7"></a><!-- doxytag: member="SAMRAI::algs::MethodOfLinesIntegrator::advanceHierarchy" ref="ab15c0df323f82747232cabb1490671a7" args="(const boost::shared_ptr&lt; hier::PatchHierarchy &gt; &amp;hierarchy, const double time, const double dt)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::algs::MethodOfLinesIntegrator::advanceHierarchy </td>
          <td>(</td>
          <td class="paramtype">const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchHierarchy.html">hier::PatchHierarchy</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>hierarchy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>dt</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Advance the solution through the specified dt, which is assumed for the problem and state of the solution. Advances all patches in the hierarchy passed in.</p>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>hierarchy </dd></dl>

<p>References <a class="el" href="classSAMRAI_1_1algs_1_1MethodOfLinesPatchStrategy.html#a3163b0a1c4d2e11d74f12591aad59e95">SAMRAI::algs::MethodOfLinesPatchStrategy::singleStep()</a>, and <a class="el" href="Utilities_8h_source.html#l00110">TBOX_ASSERT</a>.</p>

</div>
</div>
<a class="anchor" id="a33923f2cf98de20eb3effac6888f41d5"></a><!-- doxytag: member="SAMRAI::algs::MethodOfLinesIntegrator::registerVariable" ref="a33923f2cf98de20eb3effac6888f41d5" args="(const boost::shared_ptr&lt; hier::Variable &gt; &amp;variable, const hier::IntVector &amp;ghosts, const MOL_VAR_TYPE m_v_type, const boost::shared_ptr&lt; hier::BaseGridGeometry &gt; &amp;transfer_geom, const std::string &amp;coarsen_name=std::string(), const std::string &amp;refine_name=std::string())" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::algs::MethodOfLinesIntegrator::registerVariable </td>
          <td>(</td>
          <td class="paramtype">const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1hier_1_1Variable.html">hier::Variable</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>variable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>ghosts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1algs_1_1MethodOfLinesIntegrator.html#a25ed25ae080357a46aaac785496e1775">MOL_VAR_TYPE</a>&nbsp;</td>
          <td class="paramname"> <em>m_v_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1hier_1_1BaseGridGeometry.html">hier::BaseGridGeometry</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>transfer_geom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>coarsen_name</em> = <code>std::string()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>refine_name</em> = <code>std::string()</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Register variable quantity defined in the patch strategy with the method of lines integrator which manipulates its storage.</p>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>variable </dd>
<dd>
transfer_geom </dd>
<dd>
variable-&gt;getDim() == ghosts.getDim() </dd></dl>

<p>References <a class="el" href="VariableDatabase_8C_source.html#l00044">SAMRAI::hier::VariableDatabase::getDatabase()</a>, <a class="el" href="IntVector_8h_source.html#l01118">SAMRAI::hier::IntVector::getDim()</a>, <a class="el" href="PatchDataRestartManager_8C_source.html#l00036">SAMRAI::hier::PatchDataRestartManager::getManager()</a>, <a class="el" href="VariableDatabase_8C_source.html#l00502">SAMRAI::hier::VariableDatabase::registerVariableAndContext()</a>, <a class="el" href="MethodOfLinesIntegrator_8h_source.html#l00148">RHS</a>, <a class="el" href="ComponentSelector_8h_source.html#l00195">SAMRAI::hier::ComponentSelector::setFlag()</a>, <a class="el" href="MethodOfLinesIntegrator_8h_source.html#l00147">SOLN</a>, <a class="el" href="Utilities_8h_source.html#l00110">TBOX_ASSERT</a>, <a class="el" href="Utilities_8h_source.html#l00182">TBOX_ASSERT_OBJDIM_EQUALITY2</a>, and <a class="el" href="Utilities_8h_source.html#l00060">TBOX_ERROR</a>.</p>

</div>
</div>
<a class="anchor" id="a6e6a7b029afd818fc75f9ce19b25c556"></a><!-- doxytag: member="SAMRAI::algs::MethodOfLinesIntegrator::printClassData" ref="a6e6a7b029afd818fc75f9ce19b25c556" args="(std::ostream &amp;os) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::algs::MethodOfLinesIntegrator::printClassData </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&nbsp;</td>
          <td class="paramname"> <em>os</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Print all data members of <a class="el" href="classSAMRAI_1_1algs_1_1MethodOfLinesIntegrator.html" title="Class MethodOfLinesIntegrator implements a spatially adaptive version of the Strong...">MethodOfLinesIntegrator</a> object. </p>

</div>
</div>
<a class="anchor" id="ade065cc3ed6bd4936b72dcc88df07580"></a><!-- doxytag: member="SAMRAI::algs::MethodOfLinesIntegrator::initializeLevelData" ref="ade065cc3ed6bd4936b72dcc88df07580" args="(const boost::shared_ptr&lt; hier::PatchHierarchy &gt; &amp;hierarchy, const int level_number, const double init_time, const bool can_be_refined, const bool initial_time, const boost::shared_ptr&lt; hier::PatchLevel &gt; &amp;old_level=boost::shared_ptr&lt; hier::PatchLevel &gt;(), const bool allocate_data=true)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::algs::MethodOfLinesIntegrator::initializeLevelData </td>
          <td>(</td>
          <td class="paramtype">const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchHierarchy.html">hier::PatchHierarchy</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>hierarchy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>level_number</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>init_time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&nbsp;</td>
          <td class="paramname"> <em>can_be_refined</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&nbsp;</td>
          <td class="paramname"> <em>initial_time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchLevel.html">hier::PatchLevel</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>old_level</em> = <code>boost::shared_ptr&lt;<a class="el" href="classSAMRAI_1_1hier_1_1PatchLevel.html">hier::PatchLevel</a>&gt;()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&nbsp;</td>
          <td class="paramname"> <em>allocate_data</em> = <code>true</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Initialize data on a new level after it is inserted into an AMR patch hierarchy by the gridding algorithm. The level number indicates that of the new level. The old_level pointer corresponds to the level that resided in the hierarchy before the level with the specified number was introduced. If the pointer is NULL, there was no level in the hierarchy prior to the call and the level data is set based on the user routines and the simulation time. Otherwise, the specified level replaces the old level and the new level receives data from the old level appropriately before it is destroyed.</p>
<p>Typically, when data is set, it is interpolated from coarser levels in the hierarchy. If the data is to be set, the level number must match that of the old level, if non-NULL. If the old level is non-NULL, then data is copied from the old level to the new level on regions of intersection between those levels before interpolation occurs. Then, user-supplied patch routines are called to further initialize the data if needed. The boolean argument after_regrid is passed into the user's routines.</p>
<p>The boolean argument initial_time indicates whether the integration time corresponds to the initial simulation time. If true, the level should be initialized with initial simulation values. Otherwise, it should be assumed that the simulation time is at some point after the start of the simulation. This information is provided since the initialization of the data on a patch may be different in each of those circumstances. The can_be_refined boolean argument indicates whether the level is the finest allowable level in the hierarchy.</p>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>hierarchy </dd>
<dd>
level_number &gt;= 0 </dd>
<dd>
hierarchy-&gt;getPatchLevel(level_number) </dd>
<dd>
!old_level || (level_number == old_level-&gt;getLevelNumber()) </dd>
<dd>
!old_level || (hierarchy-&gt;getDim() == old_level-&gt;getDim()) </dd></dl>

<p>Implements <a class="el" href="classSAMRAI_1_1mesh_1_1StandardTagAndInitStrategy.html#acc3f40925b2fe51dbd5742b2a24b2471">SAMRAI::mesh::StandardTagAndInitStrategy</a>.</p>

<p>References <a class="el" href="classSAMRAI_1_1algs_1_1MethodOfLinesPatchStrategy.html#ae4e0d2e3309dbb5be78158c84212db05">SAMRAI::algs::MethodOfLinesPatchStrategy::initializeDataOnPatch()</a>, <a class="el" href="Utilities_8h_source.html#l00050">NULL_USE</a>, <a class="el" href="Utilities_8h_source.html#l00110">TBOX_ASSERT</a>, and <a class="el" href="Utilities_8h_source.html#l00182">TBOX_ASSERT_OBJDIM_EQUALITY2</a>.</p>

</div>
</div>
<a class="anchor" id="a97a0d8a66c02d0c4c39701747aa61fac"></a><!-- doxytag: member="SAMRAI::algs::MethodOfLinesIntegrator::resetHierarchyConfiguration" ref="a97a0d8a66c02d0c4c39701747aa61fac" args="(const boost::shared_ptr&lt; hier::PatchHierarchy &gt; &amp;hierarchy, const int coarsest_level, const int finest_level)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::algs::MethodOfLinesIntegrator::resetHierarchyConfiguration </td>
          <td>(</td>
          <td class="paramtype">const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchHierarchy.html">hier::PatchHierarchy</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>hierarchy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>coarsest_level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>finest_level</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Reset cached communication schedules after the hierarchy has changed (due to regridding, for example) and the data has been initialized on the new levels. The intent is that the cost of data movement on the hierarchy will be amortized across multiple communication cycles, if possible. Note, that whenever this routine is called, communication schedules are updated for every level finer than and including that indexed by coarsest_level.</p>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>hierarchy </dd>
<dd>
(coarsest_level &gt;= 0) &amp;&amp; (coarsest_level &lt;= finest_level) &amp;&amp; (finest_level &lt;= hierarchy-&gt;getFinestLevelNumber()) </dd></dl>

<p>Implements <a class="el" href="classSAMRAI_1_1mesh_1_1StandardTagAndInitStrategy.html#a13d73fc9054fdc7830ebd81c372a2492">SAMRAI::mesh::StandardTagAndInitStrategy</a>.</p>

<p>References <a class="el" href="Utilities_8h_source.html#l00050">NULL_USE</a>, and <a class="el" href="Utilities_8h_source.html#l00110">TBOX_ASSERT</a>.</p>

</div>
</div>
<a class="anchor" id="aa8cc336004d00cc179e9b6c4978dd4f3"></a><!-- doxytag: member="SAMRAI::algs::MethodOfLinesIntegrator::applyGradientDetector" ref="aa8cc336004d00cc179e9b6c4978dd4f3" args="(const boost::shared_ptr&lt; hier::PatchHierarchy &gt; &amp;hierarchy, const int level_number, const double time, const int tag_index, const bool initial_time, const bool uses_richardson_extrapolation_too)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::algs::MethodOfLinesIntegrator::applyGradientDetector </td>
          <td>(</td>
          <td class="paramtype">const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchHierarchy.html">hier::PatchHierarchy</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>hierarchy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>level_number</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>tag_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&nbsp;</td>
          <td class="paramname"> <em>initial_time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&nbsp;</td>
          <td class="paramname"> <em>uses_richardson_extrapolation_too</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Set integer tags to "one" on the given level where refinement of that level should occur using the user-supplied gradient detector. The boolean argument initial_time is true when the level is being subject to error estimation at initialization time. If it is false, the error estimation process is being invoked at some later time after the AMR hierarchy was initially constructed. The boolean argument uses_richardson_extrapolation_too is true when Richardson extrapolation error estimation is used in addition to the gradient detector, and false otherwise. This argument helps the user to manage multiple regridding criteria. This information is passed along to the user's patch data tagging routines since the application of the error estimator may be different in each of those circumstances.</p>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>hierarchy </dd>
<dd>
hierarchy-&gt;getPatchLevel(level_number) </dd></dl>

<p>Reimplemented from <a class="el" href="classSAMRAI_1_1mesh_1_1StandardTagAndInitStrategy.html#a3f9be742dabb8dfc770ba0f8a6f8d30c">SAMRAI::mesh::StandardTagAndInitStrategy</a>.</p>

<p>References <a class="el" href="classSAMRAI_1_1algs_1_1MethodOfLinesPatchStrategy.html#ac799539cc1d417aae811743a6f4c8a84">SAMRAI::algs::MethodOfLinesPatchStrategy::tagGradientDetectorCells()</a>, and <a class="el" href="Utilities_8h_source.html#l00110">TBOX_ASSERT</a>.</p>

</div>
</div>
<a class="anchor" id="ad2b76a8dadb25206a3b8e9e7e260ddd2"></a><!-- doxytag: member="SAMRAI::algs::MethodOfLinesIntegrator::putToRestart" ref="ad2b76a8dadb25206a3b8e9e7e260ddd2" args="(const boost::shared_ptr&lt; tbox::Database &gt; &amp;restart_db) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::algs::MethodOfLinesIntegrator::putToRestart </td>
          <td>(</td>
          <td class="paramtype">const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Database.html">tbox::Database</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>restart_db</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Writes object state out to the given restart database.</p>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>restart_db </dd></dl>

<p>References <a class="el" href="Utilities_8h_source.html#l00110">TBOX_ASSERT</a>.</p>

</div>
</div>
<a class="anchor" id="a490ecd121d71da22b6928c640454cf69"></a><!-- doxytag: member="SAMRAI::algs::MethodOfLinesIntegrator::getObjectName" ref="a490ecd121d71da22b6928c640454cf69" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::string&amp; SAMRAI::algs::MethodOfLinesIntegrator::getObjectName </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns the object name. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>source/SAMRAI/algs/<a class="el" href="MethodOfLinesIntegrator_8h.html">MethodOfLinesIntegrator.h</a></li>
<li>source/SAMRAI/algs/<a class="el" href="MethodOfLinesIntegrator_8C.html">MethodOfLinesIntegrator.C</a></li>
</ul>
</div>
<hr size="1"/><address style="text-align: right;"><small>Generated on 5 Jun 2015 for SAMRAI by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.1 </small></address>
</body>
</html>
