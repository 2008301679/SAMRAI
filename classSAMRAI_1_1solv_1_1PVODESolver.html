<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>SAMRAI: SAMRAI::solv::PVODESolver Class Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.2 -->
<div class="qindex"><a class="qindex" href="main.html">Main&nbsp;Page</a> | <a class="qindex" href="namespaces.html">Namespace List</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="namespacemembers.html">Namespace&nbsp;Members</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a> | <a class="qindex" href="globals.html">File&nbsp;Members</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a></div>
<div class="nav">
<a class="el" href="namespaceSAMRAI.html">SAMRAI</a>::<a class="el" href="namespaceSAMRAI_1_1solv.html">solv</a>::<a class="el" href="classSAMRAI_1_1solv_1_1PVODESolver.html">PVODESolver</a></div>
<h1>SAMRAI::solv::PVODESolver Class Reference</h1>Class <a class="el" href="classSAMRAI_1_1solv_1_1PVODESolver.html">PVODESolver</a> serves as a C++ wrapper for the PVODE ordinary differential equation solver package.  
<a href="#_details">More...</a>
<p>
<code>#include &lt;source/solvers/packages/pvode_trio/pvode/wrapper/PVODESolver.h&gt;</code>
<p>
<a href="classSAMRAI_1_1solv_1_1PVODESolver-members.html">List of all members.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1PVODESolver.html#a0">PVODESolver</a> (const string &amp;object_name, <a class="el" href="classSAMRAI_1_1solv_1_1PVODEAbstractFunctions.html">PVODEAbstractFunctions</a> *my_functions, const bool uses_preconditioner)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1PVODESolver.html#a1">~PVODESolver</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1PVODESolver.html#a2">initialize</a> (<a class="el" href="classSAMRAI_1_1solv_1_1PVodeTrioAbstractVector.html">PVodeTrioAbstractVector</a> *solution)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1PVODESolver.html#a3">solve</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1PVODESolver.html#a4">setLogFileData</a> (const string &amp;log_fname=string())</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1PVODESolver.html#a5">setPVODEFunctions</a> (<a class="el" href="classSAMRAI_1_1solv_1_1PVODEAbstractFunctions.html">PVODEAbstractFunctions</a> *my_functions, const bool uses_preconditioner)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classSAMRAI_1_1solv_1_1PVODEAbstractFunctions.html">PVODEAbstractFunctions</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1PVODESolver.html#a6">getPVODEFunctions</a> () const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1PVODESolver.html#a7">setNumberOfEquations</a> (int neq)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1PVODESolver.html#a8">setLinearMultistepMethod</a> (int linear_multistep_method)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1PVODESolver.html#a9">setIterationType</a> (int iteration_type)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1PVODESolver.html#a10">setToleranceType</a> (int tolerance_type)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1PVODESolver.html#a11">setRelativeTolerance</a> (double relative_tolerance)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1PVODESolver.html#a12">setAbsoluteTolerance</a> (double absolute_tolerance)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1PVODESolver.html#a13">setAbsoluteTolerance</a> (<a class="el" href="classSAMRAI_1_1solv_1_1PVodeTrioAbstractVector.html">PVodeTrioAbstractVector</a> *absolute_tolerance)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1PVODESolver.html#a14">setSteppingMethod</a> (int stepping_method)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1PVODESolver.html#a15">setInitialValueOfIndependentVariable</a> (double t_0)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1PVODESolver.html#a16">setFinalValueOfIndependentVariable</a> (double t_f, bool pvode_needs_initialization)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1PVODESolver.html#a17">setInitialConditionVector</a> (<a class="el" href="classSAMRAI_1_1solv_1_1PVodeTrioAbstractVector.html">PVodeTrioAbstractVector</a> *ic_vector)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1PVODESolver.html#a18">setMaximumLinearMultistepMethodOrder</a> (int max_order)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1PVODESolver.html#a19">setMaximumNumberOfInternalSteps</a> (int max_num_internal_steps)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1PVODESolver.html#a20">setMaximumNumberOfNilStepWarnings</a> (int max_num_warnings)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1PVODESolver.html#a21">setInitialStepSize</a> (double init_step_size)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1PVODESolver.html#a22">setMaximumAbsoluteStepSize</a> (double max_step_size)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1PVODESolver.html#a23">setMinimumAbsoluteStepSize</a> (double min_step_size)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1PVODESolver.html#a24">setPreconditioningType</a> (int precondition_type)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1PVODESolver.html#a25">setGramSchmidtType</a> (int gs_type)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1PVODESolver.html#a26">setMaxKrylovDimension</a> (int max_krylov_dim)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1PVODESolver.html#a27">setCVSpgmrToleranceScaleFactor</a> (double tol_scale_factor)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classSAMRAI_1_1solv_1_1PVodeTrioAbstractVector.html">PVodeTrioAbstractVector</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1PVODESolver.html#a28">getSolutionVector</a> () const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1PVODESolver.html#a29">getDkyVector</a> (double t, int k, <a class="el" href="classSAMRAI_1_1solv_1_1PVodeTrioAbstractVector.html">PVodeTrioAbstractVector</a> *dky) const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1PVODESolver.html#a30">getActualFinalValueOfIndependentVariable</a> () const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1PVODESolver.html#a31">turnOnPVODEStatisticsCollection</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1PVODESolver.html#a32">printStatistics</a> (ostream &amp;os) const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1PVODESolver.html#a33">printPVODEStatistics</a> (ostream &amp;os) const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1PVODESolver.html#a34">getNumberOfInternalStepsTaken</a> () const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1PVODESolver.html#a35">getNumberOfRHSFunctionCalls</a> () const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1PVODESolver.html#a36">getNumberOfLinearSolverSetupCalls</a> () const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1PVODESolver.html#a37">getNumberOfNewtonIterations</a> () const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1PVODESolver.html#a38">getNumberOfNonlinearConvergenceFailures</a> () const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1PVODESolver.html#a39">getNumberOfLocalErrorTestFailures</a> () const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1PVODESolver.html#a40">getOrderUsedDuringLastInternalStep</a> () const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1PVODESolver.html#a41">getOrderToBeUsedDuringNextInternalStep</a> () const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1PVODESolver.html#a42">getPVODEMemoryUsageForDoubles</a> () const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1PVODESolver.html#a43">getPVODEMemoryUsageForIntegers</a> () const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1PVODESolver.html#a44">getStepSizeForLastInternalStep</a> () const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1PVODESolver.html#a45">getStepSizeForNextInternalStep</a> () const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1PVODESolver.html#a46">getCurrentInternalValueOfIndependentVariable</a> () const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1PVODESolver.html#a47">getPVODESuggestedToleranceScalingFactor</a> () const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1PVODESolver.html#a48">printCVSpgmrStatistics</a> (ostream &amp;os) const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1PVODESolver.html#a49">getNumberOfPreconditionerEvaluations</a> () const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1PVODESolver.html#a50">getNumberOfLinearIterations</a> () const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1PVODESolver.html#a51">getNumberOfPrecondSolveCalls</a> () const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1PVODESolver.html#a52">getNumberOfLinearConvergenceFailures</a> () const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1PVODESolver.html#a53">getCVSpgmrMemoryUsageForDoubles</a> () const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1PVODESolver.html#a54">getCVSpgmrMemoryUsageForIntegers</a> () const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1PVODESolver.html#a55">printClassData</a> (ostream &amp;os) const </td></tr>

</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
Class <a class="el" href="classSAMRAI_1_1solv_1_1PVODESolver.html">PVODESolver</a> serves as a C++ wrapper for the PVODE ordinary differential equation solver package. 
<p>
It is intended to be sufficiently generic to be used independently of the <a class="el" href="namespaceSAMRAI.html">SAMRAI</a> framework. This class declares one private static member function to link the user-defined routine for right-hand side function evaluation and two private statice member functions to link the user-defined preconditioner setup and solve routines. The implementation of these functions is defined by the user in a subclass of the abstract base class <a class="el" href="classSAMRAI_1_1solv_1_1PVODEAbstractFunctions.html">PVODEAbstractFunctions</a>. The vector objects used within the solver are given in a subclass of the abstract class <a class="el" href="classSAMRAI_1_1solv_1_1PVodeTrioAbstractVector.html">PVodeTrioAbstractVector</a>. The <a class="el" href="classSAMRAI_1_1solv_1_1PVodeTrioAbstractVector.html">PVodeTrioAbstractVector</a> class defines the vector kernel operations required by the PVODE package so that they may be easily supplied by a user who opts not to use the vector kernel supplied by the PVODE package. (It should be noted that the vector kernel used by PVODE is the same as the one used by the other packages in the PVodeTrio of solvers).<p>
Note that this class provides no input or restart capabilities and relies on PVODE for output reporting.<p>
<a class="el" href="classSAMRAI_1_1solv_1_1PVODESolver.html">PVODESolver</a> Usage:<p>
<ul>
<li>In order to use the <a class="el" href="classSAMRAI_1_1solv_1_1PVODESolver.html">PVODESolver</a>, the user must provide a concrete subclass of <a class="el" href="classSAMRAI_1_1solv_1_1PVODEAbstractFunctions.html">PVODEAbstractFunctions</a> abstract base class which defines the evaluateRHSFunction(), CVSpgmrPrecondSet(), and CVSpgmrPrecondSolve() methods.</li></ul>
<p>
<ul>
<li>Solving a system of ODEs using this PVODE C++ interface requires four main stages. First, a <a class="el" href="classSAMRAI_1_1solv_1_1PVODESolver.html">PVODESolver</a> object is created with a user-specified name and <a class="el" href="classSAMRAI_1_1solv_1_1PVODEAbstractFunctions.html">PVODEAbstractFunctions</a> object. Second, the user must specify the integration parameters that s/he wishes to use. Next, the user must call the <a class="el" href="classSAMRAI_1_1solv_1_1PVODESolver.html">PVODESolver</a> method initialize(solution_vector) with the <a class="el" href="classSAMRAI_1_1solv_1_1PVodeTrioAbstractVector.html">PVodeTrioAbstractVector</a> that s/he wants to put the solution in. Finally, the <a class="el" href="classSAMRAI_1_1solv_1_1PVODESolver.html#a3">solve()</a> method is invoked to solve the system of ODEs to the specified value of the independent variable.</li></ul>
<p>
<ul>
<li>The following is a list of integration parameters that must be specified by the user before calling the <a class="el" href="classSAMRAI_1_1solv_1_1PVODESolver.html#a3">solve()</a> method:</li></ul>
<p>
<ul>
<li>Number of equations - setNumberOfEquations(neq)</li></ul>
<p>
<ul>
<li>Either relative or absolute tolerance must be set - setRelativeTolerance(relative_tolerance), setAbsoluteTolerance(absolute_tolerance)</li></ul>
<p>
<ul>
<li>Initial value of independent variable - setInitialValueOfIndependentVariable(init_time)</li><li>Final value of independent variable - setFinalValueOfIndependentVariable(final_time pvode_needs_initialization)</li><li>Initial condition vector - setInitialConditionVector(ic_vector)</li></ul>
<p>
<ul>
<li>The following is a list of default values for integration parameters:</li></ul>
<p>
<ul>
<li><b>Linear</b> Multistep Method BDF</li></ul>
<p>
<ul>
<li><b>Iteration</b> Type FUNCTIONAL</li></ul>
<p>
<ul>
<li><b>Tolerance</b> Type SS (scalar relative and scalar absolute tolerances)</li></ul>
<p>
<ul>
<li><b>Relative</b> Tolerance 0.0</li></ul>
<p>
<ul>
<li><b>Scalar</b> Absolute Tolerance 0.0</li></ul>
<p>
<ul>
<li><b>Vector</b> Absolute Tolerance NULL</li></ul>
<p>
<ul>
<li><b>Stepping</b> Method NORMAL</li></ul>
<p>
<ul>
<li><b>Maximum</b> Order for Multistep Method 12 for ADAMS, 5 for BDF</li></ul>
<p>
<ul>
<li><b>Maximum</b> Number of Internal Steps 500</li></ul>
<p>
<ul>
<li><b>Maximum</b> Number of NIL Step Warnings 10</li></ul>
<p>
<ul>
<li><b>Initial</b> Step Size determined by PVODE</li></ul>
<p>
<ul>
<li><b>Maximum</b> Absolute Value of Step Size infinity</li></ul>
<p>
<ul>
<li><b>Minimum</b> Absolute Value of Step Size 0.0</li></ul>
<p>
<ul>
<li><b>CVSpgmr</b> Preconditioning Type NONE</li></ul>
<p>
<ul>
<li><b>CVSpgmr</b> Gram Schmidt Algorithm MODIFIED_GS</li></ul>
<p>
<ul>
<li><b>CVSpgmr</b> Maximum Krylov Dimension MIN(num_equations, CVSPGMR_MAXL=5)</li></ul>
<p>
<ul>
<li><b>CVSpgmr</b> Tolerance Scale Factor CVSPGMR_DELT = 0.05.</li></ul>
<p>
PVODE was developed in the Center for Applied Scientific Computing (CASC) at Lawrence Livermore National Laboratory (LLNL). Many of the comments in this class were taken verbatim from PVODE header files. For more information about PVODE and a complete description of the operations and data structures used by this class, see S.D. Cohen and A.C. Hindmarsh, "PVODE User Guide", UCRL-MA-118618, Lawrence Livermore National Laboratory, 1994.<p>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classSAMRAI_1_1solv_1_1PVODEAbstractFunctions.html">solv::PVODEAbstractFunctions</a> <p>
<a class="el" href="classSAMRAI_1_1solv_1_1PVodeTrioAbstractVector.html">solv::PVodeTrioAbstractVector</a> </dd></dl>

<p>
<hr><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" name="a0" doxytag="SAMRAI::solv::PVODESolver::PVODESolver"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">SAMRAI::solv::PVODESolver::PVODESolver           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const string &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>object_name</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="classSAMRAI_1_1solv_1_1PVODEAbstractFunctions.html">PVODEAbstractFunctions</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>my_functions</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const bool&nbsp;</td>
          <td class="mdname" nowrap> <em>uses_preconditioner</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Constructor for <a class="el" href="classSAMRAI_1_1solv_1_1PVODESolver.html">PVODESolver</a> sets default PVODE parameters and initializes the solver package with user-supplied functions <a class="el" href="classSAMRAI_1_1solv_1_1PVODESolver.html">PVODESolver</a> parameters may be changed later using member functions described below.<p>
Notes:<p>
<ul>
<li>The solution vector is not passed into the constructor. Before the solver can be used, the <a class="el" href="classSAMRAI_1_1solv_1_1PVODESolver.html#a2">initialize()</a> function must be called.</li></ul>
<p>
Assertion checks:<p>
<ul>
<li>my_functions must not be null</li></ul>
<p>
<ul>
<li>object_name must not be empty. </li></ul>
    </td>
  </tr>
</table>
<a class="anchor" name="a1" doxytag="SAMRAI::solv::PVODESolver::~PVODESolver"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">SAMRAI::solv::PVODESolver::~PVODESolver           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Virtual destructor for <a class="el" href="classSAMRAI_1_1solv_1_1PVODESolver.html">PVODESolver</a> closes the PVODE log file and frees the memory allocated for the PVODE memory record.     </td>
  </tr>
</table>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="a2" doxytag="SAMRAI::solv::PVODESolver::initialize"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void SAMRAI::solv::PVODESolver::initialize           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="classSAMRAI_1_1solv_1_1PVodeTrioAbstractVector.html">PVodeTrioAbstractVector</a> *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>solution</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Initialize solver with solution vector. The solution vector is required to initialize the memory record used internally within PVODE. This routine must be called before the solver can be used.<p>
Assertion checks:<p>
<ul>
<li>the solution vector must not be null</li></ul>
<p>
<ul>
<li>the solution vector must not have already been set </li></ul>
    </td>
  </tr>
</table>
<a class="anchor" name="a3" doxytag="SAMRAI::solv::PVODESolver::solve"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int SAMRAI::solv::PVODESolver::solve           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Integrate ODE system specified t_f. The integer return value is a termination code defined by PVODE. The following is a table of termination codes and a brief description of their meanings.<p>
PVODE Termination Codes:<p>
<ul>
<li><b>SUCCESS</b> (=0) CVode succeeded.</li></ul>
<p>
<ul>
<li><b>PVODE_NO_MEM</b> (=-1) The cvode_mem argument was NULL.</li></ul>
<p>
<ul>
<li><b>ILL_INPUT</b> (=-2) One of the inputs to CVode is illegal. This includes the situation when a component of the error weight vectors becomes &lt; 0 during internal time-stepping. The ILL_INPUT flag will also be returned if the linear solver routine CV--- (called by the user after calling CVodeMalloc) failed to set one of the linear solver-related fields in cvode_mem or if the linear solver's init routine failed. In any case, the user should see the printed error message for more details.</li></ul>
<p>
<ul>
<li><b>TOO_MUCH_WORK</b> (=-3) The solver took maxstep internal steps but could not reach t_f. The default value for mxstep is MXSTEP_DEFAULT = 500.</li></ul>
<p>
<ul>
<li><b>TOO_MUCH_ACC</b> (=-4) The solver could not satisfy the accuracy demanded by the user for some internal step.</li></ul>
<p>
<ul>
<li><b>ERR_FAILURE</b> (=-5) Error test failures occurred too many times (= MXNEF = 7) during one internal time step or occurred with |h| = hmin.</li></ul>
<p>
<ul>
<li><b>CONV_FAILURE</b> (=-6) Convergence test failures occurred too many times (= MXNCF = 10) during one internal time step or occurred with |h| = hmin.</li></ul>
<p>
<ul>
<li><b>SETUP_FAILURE</b> (=-7) The linear solver's setup routine failed in an unrecoverable manner.</li></ul>
<p>
<ul>
<li><b>SOLVE_FAILURE</b> (=-8) The linear solver's solve routine failed in an unrecoverable manner.</li></ul>
<p>
See <a class="el" href="solv__cartesianrobinbchelper3d_8f.html#a25">cvode.h</a> header file for more information about return values.<p>
If PVODE or CVSpgmr requires re-initialization, it is automatically done before the solve. This may be required if any of the PVODE or CVSpgmr data parameters have changed since the last call to the solver.<p>
Assertion checks:<p>
<ul>
<li>The user specified final value for the independent variable t must be greater than the specified initial value. </li></ul>
    </td>
  </tr>
</table>
<a class="anchor" name="a4" doxytag="SAMRAI::solv::PVODESolver::setLogFileData"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void SAMRAI::solv::PVODESolver::setLogFileData           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const string &amp;&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>log_fname</em> = <code>string()</code>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Accessor function for setting PVODE output log file name and output printing options. Output file name and options may be changed throughout run as desired.<p>
If the file name string is empty the default file name "cvode.log" is used.     </td>
  </tr>
</table>
<a class="anchor" name="a5" doxytag="SAMRAI::solv::PVODESolver::setPVODEFunctions"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void SAMRAI::solv::PVODESolver::setPVODEFunctions           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="classSAMRAI_1_1solv_1_1PVODEAbstractFunctions.html">PVODEAbstractFunctions</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>my_functions</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const bool&nbsp;</td>
          <td class="mdname" nowrap> <em>uses_preconditioner</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Set <a class="el" href="classSAMRAI_1_1solv_1_1PVODESolver.html">PVODESolver</a> to use my_functions as the concrete subclass of the <a class="el" href="classSAMRAI_1_1solv_1_1PVODEAbstractFunctions.html">PVODEAbstractFunctions</a> class that defines the right-hand side evaluation and preconditioner functions. The uses_preconditioner argument indicates whether or not the the user has defined preconditioner routines in their concrete subclass of the <a class="el" href="classSAMRAI_1_1solv_1_1PVODEAbstractFunctions.html">PVODEAbstractFunctions</a> class.<p>
Assertion checks:<p>
<ul>
<li>my_function must not be a null pointer </li></ul>
    </td>
  </tr>
</table>
<a class="anchor" name="a6" doxytag="SAMRAI::solv::PVODESolver::getPVODEFunctions"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="classSAMRAI_1_1solv_1_1PVODEAbstractFunctions.html">PVODEAbstractFunctions</a> * SAMRAI::solv::PVODESolver::getPVODEFunctions           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const</td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Return pointer to object that provides user-defined functions for PVODE and CVSpgmr.     </td>
  </tr>
</table>
<a class="anchor" name="a7" doxytag="SAMRAI::solv::PVODESolver::setNumberOfEquations"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void SAMRAI::solv::PVODESolver::setNumberOfEquations           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">int&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>neq</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Set number of equations in system of ODEs to be solved.<p>
Assertion checks:<p>
<ul>
<li>neq must be positive </li></ul>
    </td>
  </tr>
</table>
<a class="anchor" name="a8" doxytag="SAMRAI::solv::PVODESolver::setLinearMultistepMethod"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void SAMRAI::solv::PVODESolver::setLinearMultistepMethod           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">int&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>linear_multistep_method</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Set linear multistep method. The user can specify either ADAMS or BDF (backward differentiation formula) methods The BDF method is recommended for stiff problems, and the ADAMS method is recommended for nonstiff problems.<p>
Assertion checks:<p>
<ul>
<li>linear_multistep_method must be one of ADAMS or BDF.</li></ul>
<p>
Note: the enumeration constants ADAMS and BDF are defined in <a class="el" href="solv__cartesianrobinbchelper3d_8f.html#a25">cvode.h</a>.     </td>
  </tr>
</table>
<a class="anchor" name="a9" doxytag="SAMRAI::solv::PVODESolver::setIterationType"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void SAMRAI::solv::PVODESolver::setIterationType           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">int&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>iteration_type</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Set iteration type. The user can specify either FUNCTIONAL iteration, which does not require linear algebra, or a NEWTON iteration, which requires the solution of linear systems. In the NEWTON case, the user must also specify a PVODE linear solver. NEWTON is recommended in case of stiff problems.<p>
Assertion checks:<p>
<ul>
<li>iteration_type must be one of FUNCTIONAL or NEWTON</li></ul>
<p>
Note: the enumeration constants FUNCTIONAL and NEWTON are defined in <a class="el" href="solv__cartesianrobinbchelper3d_8f.html#a25">cvode.h</a>.     </td>
  </tr>
</table>
<a class="anchor" name="a10" doxytag="SAMRAI::solv::PVODESolver::setToleranceType"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void SAMRAI::solv::PVODESolver::setToleranceType           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">int&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>tolerance_type</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Set tolerance type. This parameter specifies the relative and absolute tolerance types to be used. The SS tolerance type means a scalar relative and absolute tolerance, while the SV tolerance type means a scalar relative tolerance and a vector absolute tolerance (a potentially different absolute tolerance for each vector component).<p>
Assertion checks:<p>
<ul>
<li>tolerance_type must be one of SS or SV</li></ul>
<p>
Note: the enumeration constants SS and SV are defined in <a class="el" href="solv__cartesianrobinbchelper3d_8f.html#a25">cvode.h</a>.     </td>
  </tr>
</table>
<a class="anchor" name="a11" doxytag="SAMRAI::solv::PVODESolver::setRelativeTolerance"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void SAMRAI::solv::PVODESolver::setRelativeTolerance           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">double&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>relative_tolerance</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Set the relative tolerance level.<p>
Assertion checks:<p>
<ul>
<li>relative_tolerance must be greater than or equal to 0.0</li></ul>
<p>
Note that pure absolute tolerance can be used by setting the relative tolerance to 0. However, it is an error to simultaneously set relative and absolute tolerances to 0.     </td>
  </tr>
</table>
<a class="anchor" name="a12" doxytag="SAMRAI::solv::PVODESolver::setAbsoluteTolerance"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void SAMRAI::solv::PVODESolver::setAbsoluteTolerance           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">double&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>absolute_tolerance</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Set the scalar absolute tolerance level.<p>
Assertion checks:<p>
<ul>
<li>absolute_tolerance must be greater than or equal to 0.0</li></ul>
<p>
Note that pure relative tolerance can be used by setting the absolute tolerance to 0. However, it is an error to simultaneously set relative and absolute tolerances to 0.     </td>
  </tr>
</table>
<a class="anchor" name="a13" doxytag="SAMRAI::solv::PVODESolver::setAbsoluteTolerance"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void SAMRAI::solv::PVODESolver::setAbsoluteTolerance           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="classSAMRAI_1_1solv_1_1PVodeTrioAbstractVector.html">PVodeTrioAbstractVector</a> *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>absolute_tolerance</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Set the vector absolute tolerance level.<p>
Assertion checks:<p>
<ul>
<li>absolute_tolerance must not be a null pointer</li></ul>
<p>
<ul>
<li>each component of absolute_tolerance must be greater than or equal to 0.0</li></ul>
<p>
Note that pure relative tolerance can be used by setting the absolute tolerance to 0. However, it is an error to simultaneously set relative and absolute tolerances to 0.     </td>
  </tr>
</table>
<a class="anchor" name="a14" doxytag="SAMRAI::solv::PVODESolver::setSteppingMethod"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void SAMRAI::solv::PVODESolver::setSteppingMethod           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">int&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>stepping_method</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Set stepping method to use for integration. There are stepping methods: NORMAL and ONE_STEP. The NORMAL method has the solver take internal steps until it has reached or just passed the user specified t_f parameter. The solver then interpolates in order to return an approximate value of y(t_f). The ONE_STEP option tells the solver to just take one internal step and return the solution at the point reached by that step.<p>
Assertion checks:<p>
<ul>
<li>stepping_method must be one of NORMAL or ONE_STEP</li></ul>
<p>
Note: the enumeration constants NORMAL and ONE_STEP are defined in <a class="el" href="solv__cartesianrobinbchelper3d_8f.html#a25">cvode.h</a>.     </td>
  </tr>
</table>
<a class="anchor" name="a15" doxytag="SAMRAI::solv::PVODESolver::setInitialValueOfIndependentVariable"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void SAMRAI::solv::PVODESolver::setInitialValueOfIndependentVariable           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">double&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>t_0</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Set initial value for independent variable.     </td>
  </tr>
</table>
<a class="anchor" name="a16" doxytag="SAMRAI::solv::PVODESolver::setFinalValueOfIndependentVariable"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void SAMRAI::solv::PVODESolver::setFinalValueOfIndependentVariable           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">double&nbsp;</td>
          <td class="mdname" nowrap> <em>t_f</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>bool&nbsp;</td>
          <td class="mdname" nowrap> <em>pvode_needs_initialization</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Set final value for independent variable (i.e. the value of independent variable to integrate the system to). The boolean argument specifies whether PVODE should be re-initialized (i.e. on first step) or if we are taking subsequent steps in a sequence, in which case it is not initialized.     </td>
  </tr>
</table>
<a class="anchor" name="a17" doxytag="SAMRAI::solv::PVODESolver::setInitialConditionVector"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void SAMRAI::solv::PVODESolver::setInitialConditionVector           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="classSAMRAI_1_1solv_1_1PVodeTrioAbstractVector.html">PVodeTrioAbstractVector</a> *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>ic_vector</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Set initial condition vector.<p>
Assertion checks:<p>
<ul>
<li>ic_vector must not be null </li></ul>
    </td>
  </tr>
</table>
<a class="anchor" name="a18" doxytag="SAMRAI::solv::PVODESolver::setMaximumLinearMultistepMethodOrder"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void SAMRAI::solv::PVODESolver::setMaximumLinearMultistepMethodOrder           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">int&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>max_order</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Set maximum order for the linear multistep method. By default, this is set to 12 for ADAMS methods and 5 for BDF methods.<p>
Assertion checks:<p>
<ul>
<li>max_order must be greater than or equal to 0 </li></ul>
    </td>
  </tr>
</table>
<a class="anchor" name="a19" doxytag="SAMRAI::solv::PVODESolver::setMaximumNumberOfInternalSteps"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void SAMRAI::solv::PVODESolver::setMaximumNumberOfInternalSteps           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">int&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>max_num_internal_steps</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Set maximum number of internal steps to be taken by the solver in its attempt to reach t_f. By default, this is set to 500.<p>
Assertion checks:<p>
<ul>
<li>max_num_internal_steps must be greater than or equal to 0 </li></ul>
    </td>
  </tr>
</table>
<a class="anchor" name="a20" doxytag="SAMRAI::solv::PVODESolver::setMaximumNumberOfNilStepWarnings"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void SAMRAI::solv::PVODESolver::setMaximumNumberOfNilStepWarnings           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">int&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>max_num_warnings</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Set maximum number of warning messages issued by the solver that (t + h == t) on the next internal step. By default, this is set to 10.<p>
Assertion checks:<p>
<ul>
<li>max_num_warnings must be greater than or equal to 0 </li></ul>
    </td>
  </tr>
</table>
<a class="anchor" name="a21" doxytag="SAMRAI::solv::PVODESolver::setInitialStepSize"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void SAMRAI::solv::PVODESolver::setInitialStepSize           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">double&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>init_step_size</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Set initial step size.<p>
Assertion checks:<p>
<ul>
<li>init_step_size must be greater than or equal to 0.0 </li></ul>
    </td>
  </tr>
</table>
<a class="anchor" name="a22" doxytag="SAMRAI::solv::PVODESolver::setMaximumAbsoluteStepSize"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void SAMRAI::solv::PVODESolver::setMaximumAbsoluteStepSize           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">double&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>max_step_size</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Set maximum absolute value of step size allowed. By default, there is no upper bound on the absolute value of step size.<p>
Assertion checks:<p>
<ul>
<li>max_step_size must be greater than or equal to 0.0 </li></ul>
    </td>
  </tr>
</table>
<a class="anchor" name="a23" doxytag="SAMRAI::solv::PVODESolver::setMinimumAbsoluteStepSize"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void SAMRAI::solv::PVODESolver::setMinimumAbsoluteStepSize           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">double&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>min_step_size</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Set minimum absolute value of step size allowed. By default, this is set to 0.0.<p>
Assertion checks:<p>
<ul>
<li>min_step_size must be greater than or equal to 0.0 </li></ul>
    </td>
  </tr>
</table>
<a class="anchor" name="a24" doxytag="SAMRAI::solv::PVODESolver::setPreconditioningType"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void SAMRAI::solv::PVODESolver::setPreconditioningType           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">int&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>precondition_type</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Set the preconditioning type to be used by CVSpgmr. This must be one of the four enumeration constants NONE, LEFT, RIGHT, or BOTH defined in <a class="el" href="solv__cartesianrobinbchelper3d_8f.html#a25">iterativ.h</a>. These correspond to no preconditioning, left preconditioning only, right preconditioning only, and both left and right preconditioning, respectively.<p>
Assertion Checks:<p>
<ul>
<li>precondition_type must be one of NONE, LEFT, RIGHT, or BOTH. </li></ul>
    </td>
  </tr>
</table>
<a class="anchor" name="a25" doxytag="SAMRAI::solv::PVODESolver::setGramSchmidtType"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void SAMRAI::solv::PVODESolver::setGramSchmidtType           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">int&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>gs_type</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Set the Gram-Schmidt orthogonalization type to be used by CVSpgmr. This must be one of the two enumeration constants MODIFIED_GS or CLASSICAL_GS defined in <a class="el" href="solv__cartesianrobinbchelper3d_8f.html#a25">iterativ.h</a>. These correspond to using modified Gram-Schmidt and classical Gram-Schmidt, respectively.<p>
Assertion Checks:<p>
<ul>
<li>gs_type must be one of CLASSICAL_GS or MODIFIED_GS. </li></ul>
    </td>
  </tr>
</table>
<a class="anchor" name="a26" doxytag="SAMRAI::solv::PVODESolver::setMaxKrylovDimension"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void SAMRAI::solv::PVODESolver::setMaxKrylovDimension           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">int&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>max_krylov_dim</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Set the maximum Krylov dimension to be used by CVSpgmr. This is an optional input to the CVSPGMR solver. Pass 0 to use the default value MIN(num_equations, CVSPGMR_MAXL=5).<p>
Assertion Checks:<p>
<ul>
<li>max_krylov_dim must be nonnegative </li></ul>
    </td>
  </tr>
</table>
<a class="anchor" name="a27" doxytag="SAMRAI::solv::PVODESolver::setCVSpgmrToleranceScaleFactor"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void SAMRAI::solv::PVODESolver::setCVSpgmrToleranceScaleFactor           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">double&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>tol_scale_factor</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Set the factor by which the tolerance on the nonlinear iteration is multiplied to get a tolerance on the linear iteration. This is an optional input to the CVSPGMR solver. Pass 0 to use the default value CVSPGMR_DELT = 0.05.<p>
Assertion Checks:<p>
<ul>
<li>tol_scale_factor must be nonnegative </li></ul>
    </td>
  </tr>
</table>
<a class="anchor" name="a28" doxytag="SAMRAI::solv::PVODESolver::getSolutionVector"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="classSAMRAI_1_1solv_1_1PVodeTrioAbstractVector.html">PVodeTrioAbstractVector</a> * SAMRAI::solv::PVODESolver::getSolutionVector           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const</td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Get solution vector.     </td>
  </tr>
</table>
<a class="anchor" name="a29" doxytag="SAMRAI::solv::PVODESolver::getDkyVector"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int SAMRAI::solv::PVODESolver::getDkyVector           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">double&nbsp;</td>
          <td class="mdname" nowrap> <em>t</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>k</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="classSAMRAI_1_1solv_1_1PVodeTrioAbstractVector.html">PVodeTrioAbstractVector</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>dky</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"> const</td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Get k-th derivative vector at the specified value of the independent variable, t. The integer return value is return code the PVODE CVodeDky() function. The following is a table of termination codes and a brief description of their meanings.<p>
CVodeDky Return Codes:<p>
<ul>
<li><b>OKAY</b> (=0) CVodeDky succeeded.</li></ul>
<p>
<ul>
<li><b>BAD_K</b> (=-1)</li></ul>
<p>
<ul>
<li><b>BAD_T</b> (=-2)</li></ul>
<p>
<ul>
<li><b>BAD_DKY</b> (=-3)</li></ul>
<p>
<ul>
<li><b>DKY_NO_MEM</b> (=-4)</li></ul>
<p>
Important Notes:<p>
<ul>
<li>t must lie in the interval [t_cur - h, t_cur] where t_cur is the current internal time reached and h is the last internal step size successfully used by the solver.</li></ul>
<p>
<ul>
<li>k may take on value 0, 1, . . . q where q is the order of the current linear multistep method being used.</li></ul>
<p>
<ul>
<li>the dky vector must be allocated by the user.</li></ul>
<p>
<ul>
<li>it is only leagal to call this method after a successful return from the <a class="el" href="classSAMRAI_1_1solv_1_1PVODESolver.html#a3">solve()</a> method. </li></ul>
    </td>
  </tr>
</table>
<a class="anchor" name="a30" doxytag="SAMRAI::solv::PVODESolver::getActualFinalValueOfIndependentVariable"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">double SAMRAI::solv::PVODESolver::getActualFinalValueOfIndependentVariable           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const</td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Get actual value of the independent variable that PVODE integrated to (i.e. the value of t that actually corresponds to the solution vector y).     </td>
  </tr>
</table>
<a class="anchor" name="a31" doxytag="SAMRAI::solv::PVODESolver::turnOnPVODEStatisticsCollection"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void SAMRAI::solv::PVODESolver::turnOnPVODEStatisticsCollection           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Set PVODE to collect statistics. This must be called before <a class="el" href="classSAMRAI_1_1solv_1_1PVODESolver.html#a3">solve()</a> is invoked.     </td>
  </tr>
</table>
<a class="anchor" name="a32" doxytag="SAMRAI::solv::PVODESolver::printStatistics"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void SAMRAI::solv::PVODESolver::printStatistics           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">ostream &amp;&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>os</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const</td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Print PVODE and CVSpgmr statistics.     </td>
  </tr>
</table>
<a class="anchor" name="a33" doxytag="SAMRAI::solv::PVODESolver::printPVODEStatistics"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void SAMRAI::solv::PVODESolver::printPVODEStatistics           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">ostream &amp;&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>os</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const</td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Print PVODE statistics to the stream.<p>
The abbreviations printed out refer to the following quantities:<p>
<ul>
<li><b>lenrw</b> size (in double words) of memory used for doubles</li></ul>
<p>
<ul>
<li><b>leniw</b> size (in integer words) of memory used for integers</li></ul>
<p>
<ul>
<li><b>nst</b> cumulative number of internal steps taken by solver</li></ul>
<p>
<ul>
<li><b>nfe</b> number of right-hand side function evaluations</li></ul>
<p>
<ul>
<li><b>nni</b> number of NEWTON iterations performed</li></ul>
<p>
<ul>
<li><b>nsetups</b> number of calls made to linear solver's setup routine</li></ul>
<p>
<ul>
<li><b>netf</b> number of local error test failures</li></ul>
<p>
<ul>
<li><b>ncfn</b> number of nonlinear convergence failures</li></ul>
<p>
<ul>
<li><b>qu</b> order used during the last internal step</li></ul>
<p>
<ul>
<li><b>qcur</b> order to be used on the next internal step</li></ul>
<p>
<ul>
<li><b>hu</b> step size for the last internal step</li></ul>
<p>
<ul>
<li><b>hcur</b> step size to be attempted on the next internal step</li></ul>
<p>
<ul>
<li><b>tcur</b> current internal value of t reached by the solver</li></ul>
<p>
<ul>
<li><b>tolsf</b> suggested tolerance scaling factor </li></ul>
    </td>
  </tr>
</table>
<a class="anchor" name="a34" doxytag="SAMRAI::solv::PVODESolver::getNumberOfInternalStepsTaken"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int SAMRAI::solv::PVODESolver::getNumberOfInternalStepsTaken           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const</td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Return the cumulative number of internal steps taken by the solver.<p>
Note: if the solver was not set to collect statistics, a value of -1 is returned.     </td>
  </tr>
</table>
<a class="anchor" name="a35" doxytag="SAMRAI::solv::PVODESolver::getNumberOfRHSFunctionCalls"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int SAMRAI::solv::PVODESolver::getNumberOfRHSFunctionCalls           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const</td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Return the number of calls to the right-hand side function.<p>
Note: if the solver was not set to collect statistics, a value of -1 is returned.     </td>
  </tr>
</table>
<a class="anchor" name="a36" doxytag="SAMRAI::solv::PVODESolver::getNumberOfLinearSolverSetupCalls"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int SAMRAI::solv::PVODESolver::getNumberOfLinearSolverSetupCalls           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const</td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Return the number of calls made to linear solver setup routines.<p>
Note: if the solver was not set to collect statistics, a value of -1 is returned.     </td>
  </tr>
</table>
<a class="anchor" name="a37" doxytag="SAMRAI::solv::PVODESolver::getNumberOfNewtonIterations"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int SAMRAI::solv::PVODESolver::getNumberOfNewtonIterations           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const</td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Return the number of NEWTON iterations performed.<p>
Note: if the solver was not set to collect statistics, a value of -1 is returned.     </td>
  </tr>
</table>
<a class="anchor" name="a38" doxytag="SAMRAI::solv::PVODESolver::getNumberOfNonlinearConvergenceFailures"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int SAMRAI::solv::PVODESolver::getNumberOfNonlinearConvergenceFailures           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const</td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Return the number of nonlinear convergence failures that have occurred.<p>
Note: if the solver was not set to collect statistics, a value of -1 is returned.     </td>
  </tr>
</table>
<a class="anchor" name="a39" doxytag="SAMRAI::solv::PVODESolver::getNumberOfLocalErrorTestFailures"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int SAMRAI::solv::PVODESolver::getNumberOfLocalErrorTestFailures           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const</td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Return the number of local error test failures.<p>
Note: if the solver was not set to collect statistics, a value of -1 is returned.     </td>
  </tr>
</table>
<a class="anchor" name="a40" doxytag="SAMRAI::solv::PVODESolver::getOrderUsedDuringLastInternalStep"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int SAMRAI::solv::PVODESolver::getOrderUsedDuringLastInternalStep           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const</td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Return the order of the linear multistep method used during the last internal step.<p>
Note: if the solver was not set to collect statistics, a value of -1 is returned.     </td>
  </tr>
</table>
<a class="anchor" name="a41" doxytag="SAMRAI::solv::PVODESolver::getOrderToBeUsedDuringNextInternalStep"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int SAMRAI::solv::PVODESolver::getOrderToBeUsedDuringNextInternalStep           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const</td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Return the order of the linear multistep method to be used during the next internal step.<p>
Note: if the solver was not set to collect statistics, a value of -1 is returned.     </td>
  </tr>
</table>
<a class="anchor" name="a42" doxytag="SAMRAI::solv::PVODESolver::getPVODEMemoryUsageForDoubles"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int SAMRAI::solv::PVODESolver::getPVODEMemoryUsageForDoubles           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const</td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Return the size (in LLNL_REAL words) of memory used for LLNL_REALS.<p>
Note: if the solver was not set to collect statistics, a value of -1 is returned.     </td>
  </tr>
</table>
<a class="anchor" name="a43" doxytag="SAMRAI::solv::PVODESolver::getPVODEMemoryUsageForIntegers"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int SAMRAI::solv::PVODESolver::getPVODEMemoryUsageForIntegers           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const</td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Return the size (in integer words) of memory used for integers.<p>
Note: if the solver was not set to collect statistics, a value of -1 is returned.     </td>
  </tr>
</table>
<a class="anchor" name="a44" doxytag="SAMRAI::solv::PVODESolver::getStepSizeForLastInternalStep"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">double SAMRAI::solv::PVODESolver::getStepSizeForLastInternalStep           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const</td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Return the step size for the last internal step.<p>
Note: if the solver was not set to collect statistics, a value of -1 is returned.     </td>
  </tr>
</table>
<a class="anchor" name="a45" doxytag="SAMRAI::solv::PVODESolver::getStepSizeForNextInternalStep"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">double SAMRAI::solv::PVODESolver::getStepSizeForNextInternalStep           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const</td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Return the step size to be used in the next internal step.<p>
Note: if the solver was not set to collect statistics, a value of -1 is returned.     </td>
  </tr>
</table>
<a class="anchor" name="a46" doxytag="SAMRAI::solv::PVODESolver::getCurrentInternalValueOfIndependentVariable"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">double SAMRAI::solv::PVODESolver::getCurrentInternalValueOfIndependentVariable           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const</td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Return the current internal value of the independent variable reached by the solver.<p>
Note: if the solver was not set to collect statistics, the minimum double value (as defined in <a class="el" href="solv__cartesianrobinbchelper3d_8f.html#a25">float.h</a>) is returned.     </td>
  </tr>
</table>
<a class="anchor" name="a47" doxytag="SAMRAI::solv::PVODESolver::getPVODESuggestedToleranceScalingFactor"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">double SAMRAI::solv::PVODESolver::getPVODESuggestedToleranceScalingFactor           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const</td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Return the suggested tolerance scaling factor.<p>
Note: if the solver was not set to collect statistics, a value of -1 is returned.     </td>
  </tr>
</table>
<a class="anchor" name="a48" doxytag="SAMRAI::solv::PVODESolver::printCVSpgmrStatistics"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void SAMRAI::solv::PVODESolver::printCVSpgmrStatistics           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">ostream &amp;&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>os</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const</td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Print CVSpgmr statistics to the stream.<p>
The abbreviations printed out refer to the following quantities:<p>
<ul>
<li><b>spgmr_lrw</b> size (in double words) of memory used for doubles</li></ul>
<p>
<ul>
<li><b>spgmr_liw</b> size (in integer words) of memory used for integers</li></ul>
<p>
<ul>
<li><b>nli</b> number of linear iterations</li></ul>
<p>
<ul>
<li><b>ncfl</b> number of linear convergence failures</li></ul>
<p>
<ul>
<li><b>npe</b> number of preconditioner evaluations</li></ul>
<p>
<ul>
<li><b>nps</b> number of calls to CVSpgmrPrecondSolve() </li></ul>
    </td>
  </tr>
</table>
<a class="anchor" name="a49" doxytag="SAMRAI::solv::PVODESolver::getNumberOfPreconditionerEvaluations"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int SAMRAI::solv::PVODESolver::getNumberOfPreconditionerEvaluations           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const</td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Return the number of preconditioner evaluations.     </td>
  </tr>
</table>
<a class="anchor" name="a50" doxytag="SAMRAI::solv::PVODESolver::getNumberOfLinearIterations"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int SAMRAI::solv::PVODESolver::getNumberOfLinearIterations           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const</td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Return the number of linear iterations.     </td>
  </tr>
</table>
<a class="anchor" name="a51" doxytag="SAMRAI::solv::PVODESolver::getNumberOfPrecondSolveCalls"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int SAMRAI::solv::PVODESolver::getNumberOfPrecondSolveCalls           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const</td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Return the number of CVSpgmrPrecondSolve() calls.     </td>
  </tr>
</table>
<a class="anchor" name="a52" doxytag="SAMRAI::solv::PVODESolver::getNumberOfLinearConvergenceFailures"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int SAMRAI::solv::PVODESolver::getNumberOfLinearConvergenceFailures           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const</td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Return the number of linear convergence failures.     </td>
  </tr>
</table>
<a class="anchor" name="a53" doxytag="SAMRAI::solv::PVODESolver::getCVSpgmrMemoryUsageForDoubles"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int SAMRAI::solv::PVODESolver::getCVSpgmrMemoryUsageForDoubles           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const</td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Return the size (in double words) of memory used for doubles.     </td>
  </tr>
</table>
<a class="anchor" name="a54" doxytag="SAMRAI::solv::PVODESolver::getCVSpgmrMemoryUsageForIntegers"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int SAMRAI::solv::PVODESolver::getCVSpgmrMemoryUsageForIntegers           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const</td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Return the size (in integer words) of memory used for integers.     </td>
  </tr>
</table>
<a class="anchor" name="a55" doxytag="SAMRAI::solv::PVODESolver::printClassData"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void SAMRAI::solv::PVODESolver::printClassData           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">ostream &amp;&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>os</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const</td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Print out all data members for this object.     </td>
  </tr>
</table>
<hr>The documentation for this class was generated from the following files:<ul>
<li>source/solvers/packages/pvode_trio/pvode/wrapper/<a class="el" href="PVODESolver_8h.html">PVODESolver.h</a><li>source/solvers/packages/pvode_trio/pvode/wrapper/<a class="el" href="PVODESolver_8C.html">PVODESolver.C</a></ul>
<hr size="1"><address style="align: right;"><small>Generated on Fri Dec 2 11:30:30 2005 for SAMRAI by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.2 </small></address>
</body>
</html>
