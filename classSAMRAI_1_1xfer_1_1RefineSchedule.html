<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>SAMRAI: SAMRAI::xfer::RefineSchedule Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath"><a class="el" href="namespaceSAMRAI.html">SAMRAI</a>::<a class="el" href="namespaceSAMRAI_1_1xfer.html">xfer</a>::<a class="el" href="classSAMRAI_1_1xfer_1_1RefineSchedule.html">RefineSchedule</a>
  </div>
</div>
<div class="contents">
<h1>SAMRAI::xfer::RefineSchedule Class Reference</h1><!-- doxytag: class="SAMRAI::xfer::RefineSchedule" -->
<p>Class <a class="el" href="classSAMRAI_1_1xfer_1_1RefineSchedule.html" title="Class RefineSchedule performs the communication operations that refine data to, copy...">RefineSchedule</a> performs the communication operations that refine data to, copy data to, or fill physical boundary data on a destination patch level.  
<a href="#_details">More...</a></p>

<p><code>#include &lt;source/SAMRAI/xfer/RefineSchedule.h&gt;</code></p>

<p><a href="classSAMRAI_1_1xfer_1_1RefineSchedule-members.html">List of all members.</a></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1xfer_1_1RefineSchedule.html#a33c17b76b1ca3e709872dc8104fe8013">RefineSchedule</a> (const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1PatchLevelFillPattern.html">PatchLevelFillPattern</a> &gt; &amp;dst_level_fill_pattern, const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchLevel.html">hier::PatchLevel</a> &gt; &amp;dst_level, const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchLevel.html">hier::PatchLevel</a> &gt; &amp;src_level, const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1RefineClasses.html">RefineClasses</a> &gt; &amp;refine_classes, const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1RefineTransactionFactory.html">RefineTransactionFactory</a> &gt; &amp;transaction_factory, <a class="el" href="classSAMRAI_1_1xfer_1_1RefinePatchStrategy.html">RefinePatchStrategy</a> *patch_strategy, bool use_time_interpolation=false)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Constructor that creates a refine schedule to copy data from the interiors of the source patch data on the source level into the interiors and ghosts of destination patch data on the destination level.  <a href="#a33c17b76b1ca3e709872dc8104fe8013"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1xfer_1_1RefineSchedule.html#a535d9f97821d0cb410ebcc6a90e8ffcb">RefineSchedule</a> (const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1PatchLevelFillPattern.html">PatchLevelFillPattern</a> &gt; &amp;dst_level_fill_pattern, const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchLevel.html">hier::PatchLevel</a> &gt; &amp;dst_level, const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchLevel.html">hier::PatchLevel</a> &gt; &amp;src_level, int next_coarser_level, const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchHierarchy.html">hier::PatchHierarchy</a> &gt; &amp;hierarchy, const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1RefineClasses.html">RefineClasses</a> &gt; &amp;refine_classes, const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1RefineTransactionFactory.html">RefineTransactionFactory</a> &gt; &amp;transaction_factory, <a class="el" href="classSAMRAI_1_1xfer_1_1RefinePatchStrategy.html">RefinePatchStrategy</a> *patch_strategy, bool use_time_refinement=false)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Constructor that creates a refine schedule to fill destination patch data on the destination level from source patch data on the source level as well as interpolated data from coarser levels.  <a href="#a535d9f97821d0cb410ebcc6a90e8ffcb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1xfer_1_1RefineSchedule.html#a538729ccd7a5aeff75dde0aa18fae725">~RefineSchedule</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1xfer_1_1RefineSchedule.html#a9ba836fc9d2192bc38511cada20b9d84">reset</a> (const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1RefineClasses.html">RefineClasses</a> &gt; &amp;refine_classes)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Reset this refine schedule to perform data transfers asssociated with refine class items in function argument.  <a href="#a9ba836fc9d2192bc38511cada20b9d84"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1xfer_1_1RefineSchedule.html#a9dc2ddd00c0bfe78e4e03db68ea8b4ca">fillData</a> (double fill_time, bool do_physical_boundary_fill=true) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Execute the stored communication schedule and perform the data movement.  <a href="#a9dc2ddd00c0bfe78e4e03db68ea8b4ca"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const boost::shared_ptr<br class="typebreak"/>
&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1RefineClasses.html">RefineClasses</a> &gt; &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1xfer_1_1RefineSchedule.html#a98fb046275b4195453ab0d1f787032da">getEquivalenceClasses</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return refine equivalence classes.  <a href="#a98fb046275b4195453ab0d1f787032da"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1xfer_1_1RefineSchedule.html#a2a6f6489a81ea053e52a5bfa737bd538">setDeterministicUnpackOrderingFlag</a> (bool flag)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set whether to unpack messages in a deterministic order.  <a href="#a2a6f6489a81ea053e52a5bfa737bd538"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1xfer_1_1RefineSchedule.html#aade71fc26d30b523133cbdca65af8c39">printClassData</a> (std::ostream &amp;stream) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Print the refine schedule data to the specified data stream.  <a href="#aade71fc26d30b523133cbdca65af8c39"></a><br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>Class <a class="el" href="classSAMRAI_1_1xfer_1_1RefineSchedule.html" title="Class RefineSchedule performs the communication operations that refine data to, copy...">RefineSchedule</a> performs the communication operations that refine data to, copy data to, or fill physical boundary data on a destination patch level. </p>
<p>Source data is copied into the provided scratch space for temporary processing. The scratch space must contain sufficient ghost cells to accommodate the stencil width of the given interpolation operators and any physical boundary data that must be filled. The scratch data is copied into the destination space at the end of the process. The communication schedule is executed by calling member function <a class="el" href="classSAMRAI_1_1xfer_1_1RefineSchedule.html#a9dc2ddd00c0bfe78e4e03db68ea8b4ca" title="Execute the stored communication schedule and perform the data movement.">fillData()</a>.</p>
<p>Each schedule object is typically created by a refine algorithm and represents the communication dependencies for a particular configuration of the AMR hierarchy. The communication schedule is only valid for that particular configuration and must be regenerated when the AMR patch hierarchy changes. However, as long as the patch levels involved in the creation of the schedule remain unchanged, the schedule may be used for multiple communication cycles. For more information about creating refine schedules, see the <a class="el" href="classSAMRAI_1_1xfer_1_1RefineAlgorithm.html" title="Class RefineAlgorithm encapsulates the AMR communication pattern to refine data to...">RefineAlgorithm</a> header file.</p>
<p>Some constructors accept the argument <code>dst_level_fill_pattern</code>. This is a <a class="el" href="classSAMRAI_1_1xfer_1_1PatchLevelFillPattern.html" title="Abstract base class for defining regions to fill on a PatchLevel.">PatchLevelFillPattern</a> which controls which types of cells are filled and which are omitted from the filling process. Concrete implementations of <a class="el" href="classSAMRAI_1_1xfer_1_1PatchLevelFillPattern.html" title="Abstract base class for defining regions to fill on a PatchLevel.">PatchLevelFillPattern</a> are:</p>
<ul>
<li><code><a class="el" href="classSAMRAI_1_1xfer_1_1PatchLevelFullFillPattern.html" title="PatchLevelFullFillPattern is a PatchLevelFillPattern that fills the entire region...">PatchLevelFullFillPattern</a></code> - Fill interior and ghost cells.</li>
<li><code><a class="el" href="classSAMRAI_1_1xfer_1_1PatchLevelInteriorFillPattern.html" title="PatchLevelFillPattern implementation for patch interior filling.">PatchLevelInteriorFillPattern</a></code> - Fill interior cells only.</li>
<li><code><a class="el" href="classSAMRAI_1_1xfer_1_1PatchLevelBorderFillPattern.html" title="PatchLevelFillPattern implementation for filling at PatchLevel boundaries.">PatchLevelBorderFillPattern</a></code> - Fill ghosts on level borders only.</li>
<li><code><a class="el" href="classSAMRAI_1_1xfer_1_1PatchLevelBorderAndInteriorFillPattern.html" title="PatchLevelFillPattern implementation for filling at PatchLevel boundaries and interiors...">PatchLevelBorderAndInteriorFillPattern</a></code> - Fill interior and ghosts on level borders.</li>
</ul>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classSAMRAI_1_1xfer_1_1RefineAlgorithm.html" title="Class RefineAlgorithm encapsulates the AMR communication pattern to refine data to...">RefineAlgorithm</a> </dd>
<dd>
<a class="el" href="classSAMRAI_1_1xfer_1_1RefinePatchStrategy.html" title="Abstract base class for user-defined patch data refining operations and physical...">RefinePatchStrategy</a> </dd>
<dd>
<a class="el" href="classSAMRAI_1_1xfer_1_1RefineClasses.html" title="Maintain a collection of refine items and organize them into equivalence classes...">RefineClasses</a> </dd></dl>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a33c17b76b1ca3e709872dc8104fe8013"></a><!-- doxytag: member="SAMRAI::xfer::RefineSchedule::RefineSchedule" ref="a33c17b76b1ca3e709872dc8104fe8013" args="(const boost::shared_ptr&lt; PatchLevelFillPattern &gt; &amp;dst_level_fill_pattern, const boost::shared_ptr&lt; hier::PatchLevel &gt; &amp;dst_level, const boost::shared_ptr&lt; hier::PatchLevel &gt; &amp;src_level, const boost::shared_ptr&lt; RefineClasses &gt; &amp;refine_classes, const boost::shared_ptr&lt; RefineTransactionFactory &gt; &amp;transaction_factory, RefinePatchStrategy *patch_strategy, bool use_time_interpolation=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SAMRAI::xfer::RefineSchedule::RefineSchedule </td>
          <td>(</td>
          <td class="paramtype">const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1PatchLevelFillPattern.html">PatchLevelFillPattern</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>dst_level_fill_pattern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchLevel.html">hier::PatchLevel</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>dst_level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchLevel.html">hier::PatchLevel</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>src_level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1RefineClasses.html">RefineClasses</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>refine_classes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1RefineTransactionFactory.html">RefineTransactionFactory</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>transaction_factory</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1xfer_1_1RefinePatchStrategy.html">RefinePatchStrategy</a> *&nbsp;</td>
          <td class="paramname"> <em>patch_strategy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>use_time_interpolation</em> = <code>false</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Constructor that creates a refine schedule to copy data from the interiors of the source patch data on the source level into the interiors and ghosts of destination patch data on the destination level. </p>
<p>The fill pattern supplied may restrict the data that will be copied.</p>
<p>Only data on the intersection of the source and destination patch data will be copied; no interpolation from coarser levels will be done. The source and destination patch levels must reside in the same index space. However, the levels do not have to be in the same AMR patch hierarchy. Generally, this constructor is called by a <a class="el" href="classSAMRAI_1_1xfer_1_1RefineAlgorithm.html" title="Class RefineAlgorithm encapsulates the AMR communication pattern to refine data to...">RefineAlgorithm</a> object.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>dst_level_fill_pattern</em>&nbsp;</td><td>Indicates which parts of the destination level to fill. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>dst_level</em>&nbsp;</td><td>boost::shared_ptr to destination patch level. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>src_level</em>&nbsp;</td><td>boost::shared_ptr to source patch level. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>refine_classes</em>&nbsp;</td><td>boost::shared_ptr to structure containing patch data and operator information. In general, this is constructed by the calling <a class="el" href="classSAMRAI_1_1xfer_1_1RefineAlgorithm.html" title="Class RefineAlgorithm encapsulates the AMR communication pattern to refine data to...">RefineAlgorithm</a> object. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>transaction_factory</em>&nbsp;</td><td>boost::shared_ptr to a factory object that will create data transactions. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>patch_strategy</em>&nbsp;</td><td>Pointer to a refine patch strategy object that provides user-defined physical boundary filling operations. This pointer may be null, in which case no boundary filling operations will occur. If your <a class="el" href="namespaceSAMRAI_1_1mesh.html">mesh</a> has a singularity, the object this points to should have also inherited from <a class="el" href="classSAMRAI_1_1xfer_1_1SingularityPatchStrategy.html" title="Abstract base class for setting ghost data when refining at a multiblock singularity...">SingularityPatchStrategy</a>. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>use_time_interpolation</em>&nbsp;</td><td>Boolean flag indicating whether to use time interpolation when setting data on the destination level. Default is no time interpolation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>dst_level </dd>
<dd>
src_level </dd>
<dd>
refine_classes </dd>
<dd>
transaction_factory </dd>
<dd>
dst_level-&gt;getDim() == src_level-&gt;getDim() </dd>
<dd>
dst_level-&gt;getGridGeometry()-&gt;getNumberOfBlockSingularities() == 0 || d_singularity_patch_strategy </dd></dl>

<p>References <a class="el" href="Connector_8C_source.html#l02156">SAMRAI::hier::Connector::assertOverlapCorrectness()</a>, <a class="el" href="PersistentOverlapConnectors_8h_source.html#l00028">SAMRAI::hier::CONNECTOR_IMPLICIT_CREATION_RULE</a>, <a class="el" href="Connector_8C_source.html#l01395">SAMRAI::hier::Connector::convertHeadWidthToBase()</a>, <a class="el" href="Connector_8h_source.html#l00753">SAMRAI::hier::Connector::getBase()</a>, <a class="el" href="Connector_8h_source.html#l00981">SAMRAI::hier::Connector::getConnectorWidth()</a>, <a class="el" href="Connector_8h_source.html#l00780">SAMRAI::hier::Connector::getHead()</a>, <a class="el" href="Connector_8h_source.html#l01147">SAMRAI::hier::Connector::getTranspose()</a>, <a class="el" href="Utilities_8h_source.html#l00110">TBOX_ASSERT</a>, <a class="el" href="Utilities_8h_source.html#l00182">TBOX_ASSERT_OBJDIM_EQUALITY2</a>, and <a class="el" href="Utilities_8h_source.html#l00060">TBOX_ERROR</a>.</p>

</div>
</div>
<a class="anchor" id="a535d9f97821d0cb410ebcc6a90e8ffcb"></a><!-- doxytag: member="SAMRAI::xfer::RefineSchedule::RefineSchedule" ref="a535d9f97821d0cb410ebcc6a90e8ffcb" args="(const boost::shared_ptr&lt; PatchLevelFillPattern &gt; &amp;dst_level_fill_pattern, const boost::shared_ptr&lt; hier::PatchLevel &gt; &amp;dst_level, const boost::shared_ptr&lt; hier::PatchLevel &gt; &amp;src_level, int next_coarser_level, const boost::shared_ptr&lt; hier::PatchHierarchy &gt; &amp;hierarchy, const boost::shared_ptr&lt; RefineClasses &gt; &amp;refine_classes, const boost::shared_ptr&lt; RefineTransactionFactory &gt; &amp;transaction_factory, RefinePatchStrategy *patch_strategy, bool use_time_refinement=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SAMRAI::xfer::RefineSchedule::RefineSchedule </td>
          <td>(</td>
          <td class="paramtype">const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1PatchLevelFillPattern.html">PatchLevelFillPattern</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>dst_level_fill_pattern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchLevel.html">hier::PatchLevel</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>dst_level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchLevel.html">hier::PatchLevel</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>src_level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>next_coarser_level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchHierarchy.html">hier::PatchHierarchy</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>hierarchy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1RefineClasses.html">RefineClasses</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>refine_classes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1RefineTransactionFactory.html">RefineTransactionFactory</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>transaction_factory</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1xfer_1_1RefinePatchStrategy.html">RefinePatchStrategy</a> *&nbsp;</td>
          <td class="paramname"> <em>patch_strategy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>use_time_refinement</em> = <code>false</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Constructor that creates a refine schedule to fill destination patch data on the destination level from source patch data on the source level as well as interpolated data from coarser levels. </p>
<p>The fill pattern supplied may restrict the data that will be copied.</p>
<p>Only data on the intersection of the source and destination patch data will be copied. If portions of the destination level remain unfilled, then the algorithm recursively fills those unfilled portions by interpolating source data from coarser levels in the AMR hierarchy. The source and destination patch levels must reside in the same index space. However, the levels do not have to be in the same AMR patch hierarchy. In general, this constructor is called by a <a class="el" href="classSAMRAI_1_1xfer_1_1RefineAlgorithm.html" title="Class RefineAlgorithm encapsulates the AMR communication pattern to refine data to...">RefineAlgorithm</a> object.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>dst_level_fill_pattern</em>&nbsp;</td><td>Indicates which parts of the destination level to fill. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>dst_level</em>&nbsp;</td><td>boost::shared_ptr to destination patch level. This level may be a level on the hierarchy or a coarsened version. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>src_level</em>&nbsp;</td><td>boost::shared_ptr to source patch level; must be in same index space as destination level. This pointer may be null, in which case the destination level will be filled only using data interpolated from coarser levels in the AMR hierarchy. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>next_coarser_level</em>&nbsp;</td><td>Level number of next coarser level in AMR patch hierarchy relative to the destination level. Note that when the destination level has number zero (i.e., the coarsest level), this value should be less than zero. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>hierarchy</em>&nbsp;</td><td>boost::shared_ptr to patch hierarchy. This pointer may be null only if the next_coarser_level value is &lt; 0, indicating that there is no level in the hierarchy coarser than the destination level. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>refine_classes</em>&nbsp;</td><td>boost::shared_ptr to structure containing patch data and operator information. In general, this is constructed by the calling <a class="el" href="classSAMRAI_1_1xfer_1_1RefineAlgorithm.html" title="Class RefineAlgorithm encapsulates the AMR communication pattern to refine data to...">RefineAlgorithm</a> object. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>transaction_factory</em>&nbsp;</td><td>boost::shared_ptr to a factory object that will create data transactions. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>patch_strategy</em>&nbsp;</td><td>Pointer to a refine patch strategy object that provides user-defined physical boundary filling operations. This pointer may be null, in which case no boundary filling or user-defined refine operations will occur. If your <a class="el" href="namespaceSAMRAI_1_1mesh.html">mesh</a> has a singularity, the object this points to should have also inherited from <a class="el" href="classSAMRAI_1_1xfer_1_1SingularityPatchStrategy.html" title="Abstract base class for setting ghost data when refining at a multiblock singularity...">SingularityPatchStrategy</a>. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>use_time_refinement</em>&nbsp;</td><td>Boolean flag indicating whether to use time interpolation when setting data on the destination level. Default is no time interpolation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>dst_level </dd>
<dd>
(next_coarser_level == -1) || hierarchy </dd>
<dd>
refine_classes </dd>
<dd>
!src_level || (dst_level-&gt;getDim() == src_level.getDim()) </dd>
<dd>
!hierarchy || (dst_level-&gt;getDim() == hierarchy.getDim()) </dd>
<dd>
dst_level-&gt;getGridGeometry()-&gt;getNumberOfBlockSingularities() == 0 || d_singularity_patch_strategy </dd></dl>

<p>References <a class="el" href="RefineScheduleConnectorWidthRequestor_8C_source.html#l00140">SAMRAI::xfer::RefineScheduleConnectorWidthRequestor::computeRequiredFineConnectorWidthsForRecursiveRefinement()</a>, <a class="el" href="PersistentOverlapConnectors_8h_source.html#l00028">SAMRAI::hier::CONNECTOR_IMPLICIT_CREATION_RULE</a>, <a class="el" href="Connector_8C_source.html#l01395">SAMRAI::hier::Connector::convertHeadWidthToBase()</a>, <a class="el" href="IntVector_8h_source.html#l00214">SAMRAI::hier::IntVector::getNumBlocks()</a>, <a class="el" href="namespaceSAMRAI_1_1tbox.html#ad72fd66574b63c87061563d2c66b5475">SAMRAI::tbox::perr</a>, <a class="el" href="RefineScheduleConnectorWidthRequestor_8C_source.html#l00051">SAMRAI::xfer::RefineScheduleConnectorWidthRequestor::setGhostCellWidthFactor()</a>, <a class="el" href="Utilities_8h_source.html#l00110">TBOX_ASSERT</a>, <a class="el" href="Utilities_8h_source.html#l00182">TBOX_ASSERT_OBJDIM_EQUALITY2</a>, and <a class="el" href="Utilities_8h_source.html#l00060">TBOX_ERROR</a>.</p>

</div>
</div>
<a class="anchor" id="a538729ccd7a5aeff75dde0aa18fae725"></a><!-- doxytag: member="SAMRAI::xfer::RefineSchedule::~RefineSchedule" ref="a538729ccd7a5aeff75dde0aa18fae725" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SAMRAI::xfer::RefineSchedule::~RefineSchedule </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Destructor for the schedule releases all internal storage. </p>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a9ba836fc9d2192bc38511cada20b9d84"></a><!-- doxytag: member="SAMRAI::xfer::RefineSchedule::reset" ref="a9ba836fc9d2192bc38511cada20b9d84" args="(const boost::shared_ptr&lt; RefineClasses &gt; &amp;refine_classes)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::xfer::RefineSchedule::reset </td>
          <td>(</td>
          <td class="paramtype">const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1xfer_1_1RefineClasses.html">RefineClasses</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>refine_classes</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reset this refine schedule to perform data transfers asssociated with refine class items in function argument. </p>
<p>In general, this function is called by a <a class="el" href="classSAMRAI_1_1xfer_1_1RefineAlgorithm.html" title="Class RefineAlgorithm encapsulates the AMR communication pattern to refine data to...">RefineAlgorithm</a> object, which first checks that the refine_classes parameter is in a state consistent with the <a class="el" href="classSAMRAI_1_1xfer_1_1RefineSchedule.html" title="Class RefineSchedule performs the communication operations that refine data to, copy...">RefineSchedule</a> object.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>refine_classes</em>&nbsp;</td><td>boost::shared_ptr to structure containing patch data and operator information. In general, this is constructed by the calling <a class="el" href="classSAMRAI_1_1xfer_1_1RefineAlgorithm.html" title="Class RefineAlgorithm encapsulates the AMR communication pattern to refine data to...">RefineAlgorithm</a> object. This pointer must be non-null.</td></tr>
  </table>
  </dd>
</dl>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>refine_classes </dd></dl>

<p>References <a class="el" href="Utilities_8h_source.html#l00110">TBOX_ASSERT</a>.</p>

</div>
</div>
<a class="anchor" id="a9dc2ddd00c0bfe78e4e03db68ea8b4ca"></a><!-- doxytag: member="SAMRAI::xfer::RefineSchedule::fillData" ref="a9dc2ddd00c0bfe78e4e03db68ea8b4ca" args="(double fill_time, bool do_physical_boundary_fill=true) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::xfer::RefineSchedule::fillData </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>fill_time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>do_physical_boundary_fill</em> = <code>true</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Execute the stored communication schedule and perform the data movement. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>fill_time</em>&nbsp;</td><td>Time for filling operation. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>do_physical_boundary_fill</em>&nbsp;</td><td>Boolean flag that can be used to bypass the physical boundary data filling operations on the destination level. The default value is true indicating that boundary data will be filled (assuming a non-null refine patch strategy pointer was passed to the createSchedule() function. Note that even when the value is false, boundary routines may be called on levels coarser than the destination level if such data is needed for proper interpolation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a98fb046275b4195453ab0d1f787032da"></a><!-- doxytag: member="SAMRAI::xfer::RefineSchedule::getEquivalenceClasses" ref="a98fb046275b4195453ab0d1f787032da" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const boost::shared_ptr&lt;<a class="el" href="classSAMRAI_1_1xfer_1_1RefineClasses.html">RefineClasses</a>&gt;&amp; SAMRAI::xfer::RefineSchedule::getEquivalenceClasses </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return refine equivalence classes. </p>
<p>The equivalence class information is used in schedule classes. </p>

</div>
</div>
<a class="anchor" id="a2a6f6489a81ea053e52a5bfa737bd538"></a><!-- doxytag: member="SAMRAI::xfer::RefineSchedule::setDeterministicUnpackOrderingFlag" ref="a2a6f6489a81ea053e52a5bfa737bd538" args="(bool flag)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::xfer::RefineSchedule::setDeterministicUnpackOrderingFlag </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>flag</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set whether to unpack messages in a deterministic order. </p>
<p>By default message unpacking is ordered by receive time, which is not deterministic. If your results are dependent on unpack ordering and you want deterministic results, set this flag to true.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>flag</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aade71fc26d30b523133cbdca65af8c39"></a><!-- doxytag: member="SAMRAI::xfer::RefineSchedule::printClassData" ref="aade71fc26d30b523133cbdca65af8c39" args="(std::ostream &amp;stream) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::xfer::RefineSchedule::printClassData </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&nbsp;</td>
          <td class="paramname"> <em>stream</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Print the refine schedule data to the specified data stream. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>stream</em>&nbsp;</td><td>Output data stream. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>source/SAMRAI/xfer/<a class="el" href="RefineSchedule_8h.html">RefineSchedule.h</a></li>
<li>source/SAMRAI/xfer/<a class="el" href="RefineSchedule_8C.html">RefineSchedule.C</a></li>
</ul>
</div>
<hr size="1"/><address style="text-align: right;"><small>Generated on 5 Jun 2015 for SAMRAI by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.1 </small></address>
</body>
</html>
