<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>SAMRAI: SAMRAI::math::ArrayDataMiscellaneousOpsReal&lt; TYPE &gt; Class Template Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.7 -->
<div class="tabs">
  <ul>
    <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="namespaces.html"><span>Namespaces</span></a></li>
    <li id="current"><a href="annotated.html"><span>Classes</span></a></li>
    <li><a href="files.html"><span>Files</span></a></li>
    <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
  </ul></div>
<div class="tabs">
  <ul>
    <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
    <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
    <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
  </ul></div>
<div class="nav">
<a class="el" href="namespaceSAMRAI.html">SAMRAI</a>::<a class="el" href="namespaceSAMRAI_1_1math.html">math</a>::<a class="el" href="classSAMRAI_1_1math_1_1ArrayDataMiscellaneousOpsReal.html">ArrayDataMiscellaneousOpsReal</a></div>
<h1>SAMRAI::math::ArrayDataMiscellaneousOpsReal&lt; TYPE &gt; Class Template Reference</h1><!-- doxytag: class="SAMRAI::math::ArrayDataMiscellaneousOpsReal" --><code>#include &lt;source/SAMRAI/math/ArrayDataMiscellaneousOpsReal.h&gt;</code>
<p>
<a href="classSAMRAI_1_1math_1_1ArrayDataMiscellaneousOpsReal-members.html">List of all members.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1math_1_1ArrayDataMiscellaneousOpsReal.html#8afb4bc162190381a1ddfc8513f824fc">ArrayDataMiscellaneousOpsReal</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1math_1_1ArrayDataMiscellaneousOpsReal.html#7126b516c75b80524497f6c7504e98de">~ArrayDataMiscellaneousOpsReal</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1math_1_1ArrayDataMiscellaneousOpsReal.html#7d80fd3527bc65df14b6911d5c2547f4">computeConstrProdPosWithControlVolume</a> (const <a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html">pdat::ArrayData</a>&lt; TYPE &gt; &amp;data1, const <a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html">pdat::ArrayData</a>&lt; TYPE &gt; &amp;data2, const <a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html">pdat::ArrayData</a>&lt; double &gt; &amp;cvol, const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">hier::Box</a> &amp;box) const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1math_1_1ArrayDataMiscellaneousOpsReal.html#bb8668ea1808d6daee793bdd27b63f23">computeConstrProdPos</a> (const <a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html">pdat::ArrayData</a>&lt; TYPE &gt; &amp;data1, const <a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html">pdat::ArrayData</a>&lt; TYPE &gt; &amp;data2, const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">hier::Box</a> &amp;box) const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1math_1_1ArrayDataMiscellaneousOpsReal.html#a4ed0f1f416fdd0534b8a96b18ae4a18">compareToScalarWithControlVolume</a> (<a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html">pdat::ArrayData</a>&lt; TYPE &gt; &amp;dst, const <a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html">pdat::ArrayData</a>&lt; TYPE &gt; &amp;src, const TYPE &amp;alpha, const <a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html">pdat::ArrayData</a>&lt; double &gt; &amp;cvol, const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">hier::Box</a> &amp;box) const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1math_1_1ArrayDataMiscellaneousOpsReal.html#24f4c37c152e72eb26c9a6d920370a0c">compareToScalar</a> (<a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html">pdat::ArrayData</a>&lt; TYPE &gt; &amp;dst, const <a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html">pdat::ArrayData</a>&lt; TYPE &gt; &amp;src, const TYPE &amp;alpha, const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">hier::Box</a> &amp;box) const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1math_1_1ArrayDataMiscellaneousOpsReal.html#e23a8dc1b58293491f4e1c2bab7d75c8">testReciprocalWithControlVolume</a> (<a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html">pdat::ArrayData</a>&lt; TYPE &gt; &amp;dst, const <a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html">pdat::ArrayData</a>&lt; TYPE &gt; &amp;src, const <a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html">pdat::ArrayData</a>&lt; double &gt; &amp;cvol, const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">hier::Box</a> &amp;box) const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1math_1_1ArrayDataMiscellaneousOpsReal.html#fbd6a522c3bf69780841bb023548a884">testReciprocal</a> (<a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html">pdat::ArrayData</a>&lt; TYPE &gt; &amp;dst, const <a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html">pdat::ArrayData</a>&lt; TYPE &gt; &amp;src, const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">hier::Box</a> &amp;box) const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">TYPE&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1math_1_1ArrayDataMiscellaneousOpsReal.html#7ecfdf4a66455982509b499b93bf916e">maxPointwiseDivide</a> (const <a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html">pdat::ArrayData</a>&lt; TYPE &gt; &amp;numer, const <a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html">pdat::ArrayData</a>&lt; TYPE &gt; &amp;denom, const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">hier::Box</a> &amp;box) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute max of "conditional" quotients of two arrays.  <a href="#7ecfdf4a66455982509b499b93bf916e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">TYPE&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1math_1_1ArrayDataMiscellaneousOpsReal.html#e27cc5efc59f06f7c6b5d47c8cc34c6d">minPointwiseDivide</a> (const <a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html">pdat::ArrayData</a>&lt; TYPE &gt; &amp;numer, const <a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html">pdat::ArrayData</a>&lt; TYPE &gt; &amp;denom, const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">hier::Box</a> &amp;box) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute min of quotients of two arrays.  <a href="#e27cc5efc59f06f7c6b5d47c8cc34c6d"></a><br></td></tr>
</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
<h3>template&lt;class TYPE&gt;<br>
 class SAMRAI::math::ArrayDataMiscellaneousOpsReal&lt; TYPE &gt;</h3>

Class <a class="el" href="classSAMRAI_1_1math_1_1ArrayDataMiscellaneousOpsReal.html">ArrayDataMiscellaneousOpsReal</a> provides various operations that may be applied to arrays of real (double and float) numerical data values maintained using pdat::ArrayData&lt;TYPE&gt; objects. These operations are sufficiently different from basic arithmetic and norm operations that we chose to implement them in a separate class. However, as in the case of the more common operations, the intent of this class is to provide a single implementation of the operations as they are needed by objects that manipulate standard array-based patch data types (i.e., cell-centered, face-centered, node-centered). Each operation is implemented in two different ways. The choice of operation is based on whether control volume information is to be used to weight the contribution of each data entry to the calculation. The use of control volumes is important when these operations are used in vector kernels where the data resides over multiple levels of spatial resolution in an AMR hierarchy. The actual index region on which each operation occurs is the intersection of this box and the boxes of all the pdat::ArrayData&lt;TYPE&gt; objects involved.<p>
Since these operations are used only by the vector kernels for the KINSOL and CVODE solver packages at this time, they are intended to be instantiated for the standard built-in types double and float (since those solvers only treat double and float data). To extend this class to other data types or to include other operations, the member functions must be specialized or the new operations must be added.<p>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html">pdat::ArrayData</a> </dd></dl>

<p>
<hr><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" name="8afb4bc162190381a1ddfc8513f824fc"></a><!-- doxytag: member="SAMRAI::math::ArrayDataMiscellaneousOpsReal::ArrayDataMiscellaneousOpsReal" ref="8afb4bc162190381a1ddfc8513f824fc" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSAMRAI_1_1math_1_1ArrayDataMiscellaneousOpsReal.html">SAMRAI::math::ArrayDataMiscellaneousOpsReal</a>&lt; TYPE &gt;::<a class="el" href="classSAMRAI_1_1math_1_1ArrayDataMiscellaneousOpsReal.html">ArrayDataMiscellaneousOpsReal</a>           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Empty constructor and destructor. 
</div>
</div><p>
<a class="anchor" name="7126b516c75b80524497f6c7504e98de"></a><!-- doxytag: member="SAMRAI::math::ArrayDataMiscellaneousOpsReal::~ArrayDataMiscellaneousOpsReal" ref="7126b516c75b80524497f6c7504e98de" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSAMRAI_1_1math_1_1ArrayDataMiscellaneousOpsReal.html">SAMRAI::math::ArrayDataMiscellaneousOpsReal</a>&lt; TYPE &gt;::~<a class="el" href="classSAMRAI_1_1math_1_1ArrayDataMiscellaneousOpsReal.html">ArrayDataMiscellaneousOpsReal</a>           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="7d80fd3527bc65df14b6911d5c2547f4"></a><!-- doxytag: member="SAMRAI::math::ArrayDataMiscellaneousOpsReal::computeConstrProdPosWithControlVolume" ref="7d80fd3527bc65df14b6911d5c2547f4" args="(const pdat::ArrayData&lt; TYPE &gt; &amp;data1, const pdat::ArrayData&lt; TYPE &gt; &amp;data2, const pdat::ArrayData&lt; double &gt; &amp;cvol, const hier::Box &amp;box) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classSAMRAI_1_1math_1_1ArrayDataMiscellaneousOpsReal.html">SAMRAI::math::ArrayDataMiscellaneousOpsReal</a>&lt; TYPE &gt;::computeConstrProdPosWithControlVolume           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html">pdat::ArrayData</a>&lt; TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>data1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html">pdat::ArrayData</a>&lt; TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>data2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html">pdat::ArrayData</a>&lt; double &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>cvol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">hier::Box</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>box</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return 1 if <img class="formulaInl" alt="$\|data2_i\| > 0$" src="form_6.png"> and <img class="formulaInl" alt="$data1_i * data2_i \leq 0$" src="form_7.png">, for any <img class="formulaInl" alt="$i$" src="form_8.png"> in the index region, where <img class="formulaInl" alt="$cvol_i > 0$" src="form_9.png">. Otherwise return 0. <dl compact><dt><b>Precondition:</b></dt><dd>(data1.getDim() == data2.getDim()) &amp;&amp; (data1.getDim() == cvol.getDim()) &amp;&amp; (data1.getDim() == box.getDim()) <p>
data1.getDepth() == data2.getDepth() </dd></dl>

</div>
</div><p>
<a class="anchor" name="bb8668ea1808d6daee793bdd27b63f23"></a><!-- doxytag: member="SAMRAI::math::ArrayDataMiscellaneousOpsReal::computeConstrProdPos" ref="bb8668ea1808d6daee793bdd27b63f23" args="(const pdat::ArrayData&lt; TYPE &gt; &amp;data1, const pdat::ArrayData&lt; TYPE &gt; &amp;data2, const hier::Box &amp;box) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classSAMRAI_1_1math_1_1ArrayDataMiscellaneousOpsReal.html">SAMRAI::math::ArrayDataMiscellaneousOpsReal</a>&lt; TYPE &gt;::computeConstrProdPos           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html">pdat::ArrayData</a>&lt; TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>data1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html">pdat::ArrayData</a>&lt; TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>data2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">hier::Box</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>box</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return 1 if <img class="formulaInl" alt="$\|data2_i\| > 0$" src="form_6.png"> and <img class="formulaInl" alt="$data1_i * data2_i \leq 0$" src="form_7.png">, for any <img class="formulaInl" alt="$i$" src="form_8.png"> in the index region. Otherwise return 0. <dl compact><dt><b>Precondition:</b></dt><dd>(data1.getDim() == data2.getDim()) &amp;&amp; (data1.getDim() == box.getDim()) <p>
data1.getDepth() == data2.getDepth() </dd></dl>

</div>
</div><p>
<a class="anchor" name="a4ed0f1f416fdd0534b8a96b18ae4a18"></a><!-- doxytag: member="SAMRAI::math::ArrayDataMiscellaneousOpsReal::compareToScalarWithControlVolume" ref="a4ed0f1f416fdd0534b8a96b18ae4a18" args="(pdat::ArrayData&lt; TYPE &gt; &amp;dst, const pdat::ArrayData&lt; TYPE &gt; &amp;src, const TYPE &amp;alpha, const pdat::ArrayData&lt; double &gt; &amp;cvol, const hier::Box &amp;box) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSAMRAI_1_1math_1_1ArrayDataMiscellaneousOpsReal.html">SAMRAI::math::ArrayDataMiscellaneousOpsReal</a>&lt; TYPE &gt;::compareToScalarWithControlVolume           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html">pdat::ArrayData</a>&lt; TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html">pdat::ArrayData</a>&lt; TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TYPE &amp;&nbsp;</td>
          <td class="paramname"> <em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html">pdat::ArrayData</a>&lt; double &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>cvol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">hier::Box</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>box</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Wherever <img class="formulaInl" alt="$cvol_i > 0$" src="form_9.png"> in the index region, set <img class="formulaInl" alt="$dst_i = 1$" src="form_10.png"> if <img class="formulaInl" alt="$\|src_i\| > \alpha$" src="form_11.png">, and <img class="formulaInl" alt="$dst_i = 0$" src="form_12.png"> otherwise.<p>
<dl compact><dt><b>Precondition:</b></dt><dd>(dst.getDim() == src.getDim()) &amp;&amp; (dst.getDim() == cvol.getDim()) &amp;&amp; (dst.getDim() == box.getDim()) <p>
dst.getDepth() == src.getDepth() </dd></dl>

</div>
</div><p>
<a class="anchor" name="24f4c37c152e72eb26c9a6d920370a0c"></a><!-- doxytag: member="SAMRAI::math::ArrayDataMiscellaneousOpsReal::compareToScalar" ref="24f4c37c152e72eb26c9a6d920370a0c" args="(pdat::ArrayData&lt; TYPE &gt; &amp;dst, const pdat::ArrayData&lt; TYPE &gt; &amp;src, const TYPE &amp;alpha, const hier::Box &amp;box) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSAMRAI_1_1math_1_1ArrayDataMiscellaneousOpsReal.html">SAMRAI::math::ArrayDataMiscellaneousOpsReal</a>&lt; TYPE &gt;::compareToScalar           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html">pdat::ArrayData</a>&lt; TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html">pdat::ArrayData</a>&lt; TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TYPE &amp;&nbsp;</td>
          <td class="paramname"> <em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">hier::Box</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>box</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set <img class="formulaInl" alt="$dst_i = 1$" src="form_10.png"> if <img class="formulaInl" alt="$\|src_i\| > \alpha$" src="form_11.png">, and <img class="formulaInl" alt="$dst_i = 0$" src="form_12.png"> otherwise.<p>
<dl compact><dt><b>Precondition:</b></dt><dd>(dst.getDim() == src.getDim()) &amp;&amp; (dst.getDim() == box.getDim()) <p>
dst.getDepth() == src.getDepth() </dd></dl>

</div>
</div><p>
<a class="anchor" name="e23a8dc1b58293491f4e1c2bab7d75c8"></a><!-- doxytag: member="SAMRAI::math::ArrayDataMiscellaneousOpsReal::testReciprocalWithControlVolume" ref="e23a8dc1b58293491f4e1c2bab7d75c8" args="(pdat::ArrayData&lt; TYPE &gt; &amp;dst, const pdat::ArrayData&lt; TYPE &gt; &amp;src, const pdat::ArrayData&lt; double &gt; &amp;cvol, const hier::Box &amp;box) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classSAMRAI_1_1math_1_1ArrayDataMiscellaneousOpsReal.html">SAMRAI::math::ArrayDataMiscellaneousOpsReal</a>&lt; TYPE &gt;::testReciprocalWithControlVolume           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html">pdat::ArrayData</a>&lt; TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html">pdat::ArrayData</a>&lt; TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html">pdat::ArrayData</a>&lt; double &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>cvol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">hier::Box</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>box</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Wherever <img class="formulaInl" alt="$cvol_i > 0$" src="form_9.png"> in the index region, set <img class="formulaInl" alt="$dst_i = 1/src_i$" src="form_13.png"> if <img class="formulaInl" alt="$src_i \neq 0$" src="form_14.png">, and <img class="formulaInl" alt="$dst_i = 0$" src="form_12.png"> otherwise. If <img class="formulaInl" alt="$dst_i = 0$" src="form_12.png"> anywhere, 0 is the return value. Otherwise 1 is returned.<p>
<dl compact><dt><b>Precondition:</b></dt><dd>(dst.getDim() == src.getDim()) &amp;&amp; (dst.getDim() == cvol.getDim()) &amp;&amp; (dst.getDim() == box.getDim()) <p>
dst.getDepth() == src.getDepth() </dd></dl>

</div>
</div><p>
<a class="anchor" name="fbd6a522c3bf69780841bb023548a884"></a><!-- doxytag: member="SAMRAI::math::ArrayDataMiscellaneousOpsReal::testReciprocal" ref="fbd6a522c3bf69780841bb023548a884" args="(pdat::ArrayData&lt; TYPE &gt; &amp;dst, const pdat::ArrayData&lt; TYPE &gt; &amp;src, const hier::Box &amp;box) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classSAMRAI_1_1math_1_1ArrayDataMiscellaneousOpsReal.html">SAMRAI::math::ArrayDataMiscellaneousOpsReal</a>&lt; TYPE &gt;::testReciprocal           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html">pdat::ArrayData</a>&lt; TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html">pdat::ArrayData</a>&lt; TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">hier::Box</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>box</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set <img class="formulaInl" alt="$dst_i = 1/src_i$" src="form_13.png"> if <img class="formulaInl" alt="$src_i \neq 0$" src="form_14.png">, and <img class="formulaInl" alt="$dst_i = 0$" src="form_12.png"> otherwise. If <img class="formulaInl" alt="$dst_i = 0$" src="form_12.png"> anywhere, 0 is the return value. Otherwise 1 is returned.<p>
<dl compact><dt><b>Precondition:</b></dt><dd>(dst.getDim() == src.getDim()) &amp;&amp; (dst.getDim() == box.getDim()) <p>
dst.getDepth() == src.getDepth() </dd></dl>

</div>
</div><p>
<a class="anchor" name="7ecfdf4a66455982509b499b93bf916e"></a><!-- doxytag: member="SAMRAI::math::ArrayDataMiscellaneousOpsReal::maxPointwiseDivide" ref="7ecfdf4a66455982509b499b93bf916e" args="(const pdat::ArrayData&lt; TYPE &gt; &amp;numer, const pdat::ArrayData&lt; TYPE &gt; &amp;denom, const hier::Box &amp;box) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">TYPE <a class="el" href="classSAMRAI_1_1math_1_1ArrayDataMiscellaneousOpsReal.html">SAMRAI::math::ArrayDataMiscellaneousOpsReal</a>&lt; TYPE &gt;::maxPointwiseDivide           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html">pdat::ArrayData</a>&lt; TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>numer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html">pdat::ArrayData</a>&lt; TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>denom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">hier::Box</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>box</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Compute max of "conditional" quotients of two arrays. 
<p>
Return the maximum of pointwise "conditional" quotients of the numerator and denominator.<p>
The "conditional" quotient is defined as |numerator/denominator| where the denominator is nonzero. Otherwise, it is defined as |numerator|.<p>
<b>Note:</b> This method is currently intended to support the PETSc-2.1.6 vector wrapper only. Please do not use it!<p>
<dl compact><dt><b>Precondition:</b></dt><dd>(numer.getDim() == denom.getDim()) &amp;&amp; (numer.getDim() == box.getDim()) <p>
numer.getDepth() == denom.getDepth() </dd></dl>

</div>
</div><p>
<a class="anchor" name="e27cc5efc59f06f7c6b5d47c8cc34c6d"></a><!-- doxytag: member="SAMRAI::math::ArrayDataMiscellaneousOpsReal::minPointwiseDivide" ref="e27cc5efc59f06f7c6b5d47c8cc34c6d" args="(const pdat::ArrayData&lt; TYPE &gt; &amp;numer, const pdat::ArrayData&lt; TYPE &gt; &amp;denom, const hier::Box &amp;box) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">TYPE <a class="el" href="classSAMRAI_1_1math_1_1ArrayDataMiscellaneousOpsReal.html">SAMRAI::math::ArrayDataMiscellaneousOpsReal</a>&lt; TYPE &gt;::minPointwiseDivide           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html">pdat::ArrayData</a>&lt; TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>numer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1pdat_1_1ArrayData.html">pdat::ArrayData</a>&lt; TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>denom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">hier::Box</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>box</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Compute min of quotients of two arrays. 
<p>
Return the minimum of pointwise quotients of the numerator and denominator.<p>
The quotient is defined as (numerator/denominator) where the denominator is nonzero. When the denominator is zero, the entry is skipped. If the denominator is always zero, the value of tbox::IEEE::getDBL_MAX() is returned (see <a class="el" href="structSAMRAI_1_1tbox_1_1IEEE.html">SAMRAI::tbox::IEEE</a>).<p>
<b>Note:</b> This method is currently intended to support the SUNDIALS vector wrapper only. Please do not use it!<p>
<dl compact><dt><b>Precondition:</b></dt><dd>(numer.getDim() == denom.getDim()) &amp;&amp; (numer.getDim() == box.getDim()) <p>
numer.getDepth() == denom.getDepth() </dd></dl>

</div>
</div><p>
<hr>The documentation for this class was generated from the following files:<ul>
<li>source/SAMRAI/math/<a class="el" href="ArrayDataMiscellaneousOpsReal_8h.html">ArrayDataMiscellaneousOpsReal.h</a><li>source/SAMRAI/math/<a class="el" href="ArrayDataMiscellaneousOpsReal_8C.html">ArrayDataMiscellaneousOpsReal.C</a></ul>
<hr size="1"><address style="align: right;"><small>Generated on 10 Jan 2014 for SAMRAI by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.7 </small></address>
</body>
</html>
