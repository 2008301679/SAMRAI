<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>SAMRAI: SAMRAI::mesh::GriddingAlgorithm Class Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.7 -->
<div class="tabs">
  <ul>
    <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="namespaces.html"><span>Namespaces</span></a></li>
    <li id="current"><a href="annotated.html"><span>Classes</span></a></li>
    <li><a href="files.html"><span>Files</span></a></li>
    <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
  </ul></div>
<div class="tabs">
  <ul>
    <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
    <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
    <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
  </ul></div>
<div class="nav">
<a class="el" href="namespaceSAMRAI.html">SAMRAI</a>::<a class="el" href="namespaceSAMRAI_1_1mesh.html">mesh</a>::<a class="el" href="classSAMRAI_1_1mesh_1_1GriddingAlgorithm.html">GriddingAlgorithm</a></div>
<h1>SAMRAI::mesh::GriddingAlgorithm Class Reference</h1><!-- doxytag: class="SAMRAI::mesh::GriddingAlgorithm" --><!-- doxytag: inherits="SAMRAI::mesh::GriddingAlgorithmStrategy,SAMRAI::tbox::Serializable" -->Class <a class="el" href="classSAMRAI_1_1mesh_1_1GriddingAlgorithm.html">GriddingAlgorithm</a> manages AMR patch hierarchy construction operations in <a class="el" href="namespaceSAMRAI.html">SAMRAI</a>. Specifically, it provides AMR patch hierarchy generation and regridding routines that may be used with a variety of AMR solution algorithms and application codes.  
<a href="#_details">More...</a>
<p>
<code>#include &lt;source/SAMRAI/mesh/GriddingAlgorithm.h&gt;</code>
<p>
<p>Inheritance diagram for SAMRAI::mesh::GriddingAlgorithm:
<p><center><img src="classSAMRAI_1_1mesh_1_1GriddingAlgorithm.png" usemap="#SAMRAI::mesh::GriddingAlgorithm_map" border="0" alt=""></center>
<map name="SAMRAI::mesh::GriddingAlgorithm_map">
<area href="classSAMRAI_1_1mesh_1_1GriddingAlgorithmStrategy.html" alt="SAMRAI::mesh::GriddingAlgorithmStrategy" shape="rect" coords="0,56,249,80">
<area href="classSAMRAI_1_1tbox_1_1Serializable.html" alt="SAMRAI::tbox::Serializable" shape="rect" coords="259,56,508,80">
<area href="classtbox_1_1DescribedClass.html" alt="DescribedClass" shape="rect" coords="259,0,508,24">
</map>
<a href="classSAMRAI_1_1mesh_1_1GriddingAlgorithm-members.html">List of all members.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1mesh_1_1GriddingAlgorithm.html#0be1a5923a05bb72a8f7fae6698a1dc7">GriddingAlgorithm</a> (const <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchHierarchy.html">hier::PatchHierarchy</a> &gt; &amp;hierarchy, const std::string &amp;object_name, <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Database.html">tbox::Database</a> &gt; input_db, <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1mesh_1_1TagAndInitializeStrategy.html">TagAndInitializeStrategy</a> &gt; level_strategy, <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1mesh_1_1BoxGeneratorStrategy.html">BoxGeneratorStrategy</a> &gt; generator, <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1mesh_1_1LoadBalanceStrategy.html">LoadBalanceStrategy</a> &gt; balancer, <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1mesh_1_1LoadBalanceStrategy.html">LoadBalanceStrategy</a> &gt; balancer_zero=<a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1mesh_1_1LoadBalanceStrategy.html">LoadBalanceStrategy</a> &gt;(NULL), bool register_for_restart=true)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The constructor for <a class="el" href="classSAMRAI_1_1mesh_1_1GriddingAlgorithm.html">GriddingAlgorithm</a> configures the gridding algorithm with the patch hierarchy and concrete algorithm strategy objects in the argument list.  <a href="#0be1a5923a05bb72a8f7fae6698a1dc7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1mesh_1_1GriddingAlgorithm.html#d564619fa83f3ec37d0349a31a7c0a30">~GriddingAlgorithm</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Destructor.  <a href="#d564619fa83f3ec37d0349a31a7c0a30"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1mesh_1_1GriddingAlgorithm.html#d1846e119aeff11f5f40c7dd2aa2e7f5">makeCoarsestLevel</a> (const double level_time)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create or rebalance the coarsest level.  <a href="#d1846e119aeff11f5f40c7dd2aa2e7f5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1mesh_1_1GriddingAlgorithm.html#56901ef8299000705e5aa47e190b2a9e">makeFinerLevel</a> (const double level_time, const bool initial_time, const int tag_buffer, const double regrid_start_time=0.0)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Attempt to create a new level in the hierarchy finer than the finest level currently residing in the hierarchy.  <a href="#56901ef8299000705e5aa47e190b2a9e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1mesh_1_1GriddingAlgorithm.html#5d2ef5face4b4c3b40ba814906916089">regridAllFinerLevels</a> (const int level_number, const double regrid_time, const <a class="el" href="classSAMRAI_1_1tbox_1_1Array.html">tbox::Array</a>&lt; int &gt; &amp;tag_buffer, <a class="el" href="classSAMRAI_1_1tbox_1_1Array.html">tbox::Array</a>&lt; double &gt; regrid_start_time=<a class="el" href="classSAMRAI_1_1tbox_1_1Array.html">tbox::Array</a>&lt; double &gt;(), const bool level_is_coarsest_to_sync=true)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Attempt to regrid each level in the PatchHierarchy that is finer than the specified level.  <a href="#5d2ef5face4b4c3b40ba814906916089"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1mesh_1_1TagAndInitializeStrategy.html">TagAndInitializeStrategy</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1mesh_1_1GriddingAlgorithm.html#d1f0fc38f40da4490b226fec0de54bb7">getTagAndInitializeStrategy</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return pointer to level gridding strategy data member.  <a href="#d1f0fc38f40da4490b226fec0de54bb7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1mesh_1_1LoadBalanceStrategy.html">LoadBalanceStrategy</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1mesh_1_1GriddingAlgorithm.html#40d3fb9125b7352b97a3a380818d6e84">getLoadBalanceStrategy</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return pointer to load balance strategy data member.  <a href="#40d3fb9125b7352b97a3a380818d6e84"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1mesh_1_1LoadBalanceStrategy.html">LoadBalanceStrategy</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1mesh_1_1GriddingAlgorithm.html#c4fe554dc5b0daaca35fb5dec098f72b">getLoadBalanceStrategyZero</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return pointer to load balance strategy specialized for balancing level zero.  <a href="#c4fe554dc5b0daaca35fb5dec098f72b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1mesh_1_1GriddingAlgorithm.html#eb02272242cae556e6cf1d30bb7dc51c">setEfficiencyTolerance</a> (const double efficiency_tolerance, const int level_number)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set efficiency tolerance for clustering tags on level.  <a href="#eb02272242cae556e6cf1d30bb7dc51c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1mesh_1_1GriddingAlgorithm.html#d358b372179521cacb81f431d4e28f03">getEfficiencyTolerance</a> (const int level_number) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return efficiency tolerance for clustering tags on level.  <a href="#d358b372179521cacb81f431d4e28f03"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1mesh_1_1GriddingAlgorithm.html#73e212c91812d1a433ca0793576fc2da">setCombineEfficiency</a> (const double combine_efficiency, const int level_number)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set combine efficiency for clustering tags on level.  <a href="#73e212c91812d1a433ca0793576fc2da"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1mesh_1_1GriddingAlgorithm.html#2eeb7aef9d8cbca616a02f8ba70e3d6f">getCombineEfficiency</a> (const int level_number) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return combine efficiency for clustering tags on level.  <a href="#2eeb7aef9d8cbca616a02f8ba70e3d6f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1mesh_1_1GriddingAlgorithm.html#8f18dca77480c966b2253020162a31c0">printClassData</a> (std::ostream &amp;os) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Print all data members of the class instance to given output stream.  <a href="#8f18dca77480c966b2253020162a31c0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1mesh_1_1GriddingAlgorithm.html#0f1c520afe49b00e2458c63ecf1582a6">putToDatabase</a> (<a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Database.html">tbox::Database</a> &gt; db)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Write object state out to the gien database.  <a href="#0f1c520afe49b00e2458c63ecf1582a6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1mesh_1_1GriddingAlgorithm.html#b412d10052255cff13ffa3f104dd8a09">printStatistics</a> (std::ostream &amp;s=<a class="el" href="namespaceSAMRAI_1_1tbox.html#48a363c43ec1479b41d6c9c560ba446d">tbox::plog</a>) const </td></tr>

</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
Class <a class="el" href="classSAMRAI_1_1mesh_1_1GriddingAlgorithm.html">GriddingAlgorithm</a> manages AMR patch hierarchy construction operations in <a class="el" href="namespaceSAMRAI.html">SAMRAI</a>. Specifically, it provides AMR patch hierarchy generation and regridding routines that may be used with a variety of AMR solution algorithms and application codes. 
<p>
The three main functions provided by this class are:<ul>
<li><b><a class="el" href="classSAMRAI_1_1mesh_1_1GriddingAlgorithm.html#d1846e119aeff11f5f40c7dd2aa2e7f5">makeCoarsestLevel()</a></b> This routine constructs or repartitions the coarsest hierarchy level (level 0).</li></ul>
<p>
<ul>
<li><b><a class="el" href="classSAMRAI_1_1mesh_1_1GriddingAlgorithm.html#56901ef8299000705e5aa47e190b2a9e">makeFinerLevel()</a></b> This routine will attempt to add a new finest level to the hierarchy if the maximum number of levels allows it and cells on the current finest level are tagged for refinement.</li></ul>
<p>
<ul>
<li><b><a class="el" href="classSAMRAI_1_1mesh_1_1GriddingAlgorithm.html#5d2ef5face4b4c3b40ba814906916089">regridAllFinerLevels()</a></b> This routine will regrid all levels finer than some specified level based on cells that are tagged for refinement on each level finer than and including the given level. This routine may add a new finest hierarchy level if the maximum number of levels allows it and cells on the current finest level are tagged for refinement. Levels may also be removed from the hierarchy if no cells are tagged.</li></ul>
<p>
These basic AMR operations are used to generate levels in the AMR patch hierarchy at the beginning of a simulation, and regridding collections of levels during an adaptive calculation. More details are found in the comments accompanying each member function below.<p>
Other objects passed to the constructor provide the gridding algorithm with particular operations needed during meshing operations. Operations that tag cells for refinement on a patch level and initialize data on new levels are provided by the <a class="el" href="classSAMRAI_1_1mesh_1_1TagAndInitializeStrategy.html">TagAndInitializeStrategy</a> argument. Operations that cluster tagged cells into a boxes are provided by the <a class="el" href="classSAMRAI_1_1mesh_1_1BoxGeneratorStrategy.html">BoxGeneratorStrategy</a> argument. Routines that load balance patches on a level are provided by the <a class="el" href="classSAMRAI_1_1mesh_1_1LoadBalanceStrategy.html">LoadBalanceStrategy</a> constructor argument.<p>
Initialization of a <a class="el" href="classSAMRAI_1_1mesh_1_1GriddingAlgorithm.html">GriddingAlgorithm</a> object is performed via a combination of default parameters and values read from an input database. Data read from input is summarized as follows:<p>
Optional input keys, data types, and defaults:<p>
<ul>
<li><b>efficiency_tolerance</b> An array of double values, each of which specifies the minimum fraction of tagged cells to total cells in boxes used to construct patches on a new level. If the ratio is below the tolerance value, the box may be split into smaller boxes and pieces removed until the ratio becomes greater than or equal to the tolerance. This tolerance helps users control the amount of extra refined cells created (beyond those tagged explicitly) that is typical in patch-based AMR computations. If no input values are given, a default of 0.8 is used. See sample input below for input file format. The index of the value in the array corresponds to the number of the level to which the tolerance value applies. If more values are given than the maximum number of levels allowed in the hierarchy, extra values will be ignored. If fewer values are given, then the last value given will be used for each level without a specified input value. For example, if only a single value is specified, then that value will be used on all levels.</li></ul>
<p>
<ul>
<li><b>combine_efficiency</b> An array of double values, each of which serves as a threshold for the ratio of the total number of cells in two boxes into which a box may be split and the number of cells in the original box. If that ratio is greater than the combine efficiency, the box will not be split. This tolerance helps users avoids splitting up portions of the domain into into very small patches which can increase the overhead of AMR operations. If no input values are given, a default of 0.8 is used. See sample input below for input file format. Multiple values in the array are handled similar to efficiency_tolerance.</li></ul>
<p>
<ul>
<li><b>check_nonnesting_user_boxes</b> A flag to control how user-specified refinement boxes that violate proper nesting are handled. Set to one of these strings: <b>"IGNORE"</b> - nesting violations will be quietly disregarded. <b>"WARN"</b> - nesting violations will cause a warning but the code will continue anyway. <b>"ERROR"</b> - nesting violations will cause an unrecoverable assertion. The default is "ERROR". We highly recommend making nesting violation an error. The code may work anyway, but there are no guarantees.</li></ul>
<p>
<ul>
<li><b>check_boundary_proximity_violation</b> A flag to control how to resolve refinement boxes that violate boundary proximity (are less than the max ghost cell width of physical boundaries without touching the boundary). Set to one of these strings: <b>"IGNORE"</b> - violations will be quietly disregarded. <b>"WARN"</b> - violations will cause a warning but the code will continue anyway. <b>"ERROR"</b> - violations will cause an unrecoverable assertion. The default is "ERROR". We highly recommend making boundary proximity violation an error. The code may work anyway, but there are no guarantees.</li></ul>
<p>
<ul>
<li><b>check_nonrefined_tags</b> A flag to control how to resolve user-specified tags that violate proper nesting.</li></ul>
<p>
If a tag violates the nesting requirements, its location in index space will not be refined when creating the finer level. This flag allows the user to determine what to do when this occurs<p>
Set to one of these strings: <b>"IGNORE"</b> - violating tags will be quietly disregarded. <b>"WARN"</b> - violating tags will cause a warning and be disregarded. <b>"ERROR"</b> - violating tags will cause an unrecoverable assertion. The default is "WARN". It is fastest to ignore non-nesting tags because no checking has to be done.<p>
<ul>
<li><b>check_overlapping_patches</b> A flag to control checking for overlapping patches on a new level. Set to one of these strings: <b>"IGNORE"</b> - there is no check for overlapping patches, and they will be quietly disregarded. <b>"WARN"</b> - overlapping patches will cause a warning and be disregarded. <b>"ERROR"</b> - violating tags will cause an unrecoverable assertion. The default is "WARN". The check for overlapping patches may be and should be bypassed by application that can tolerate overlaps. To prevent the creation of levels with overlapping patches, see the input flag "allow_patches_smaller_than_minimum_size_to_prevent_overlaps"</li></ul>
<p>
<ul>
<li><b>sequentialize_patch_indices</b> A flag to specify whether patch indices will be globally sequentialized. This is not scalable, but is required for writing correct VisIt files. Due to the current VisIt requirement, this is currently true by default. It will evetually be set back to false after we remove the VisIt requirement.</li></ul>
<p>
Note that when continuing from restart, the input values in the input file override all values read in from the restart database.<p>
The following represents sample input data for a three-level problem:<p>
<div class="fragment"><pre class="fragment"> *
 *   // Optional input: different efficiency tolerance for each coarser level
 *   efficiency_tolerance = 0.80e0, 0.85e0, 0.90e0
 *
 *   // Optional input: combine efficiency is same for all levels.
 *   combine_efficiency = 0.95e0
 *
 * </pre></div><p>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classSAMRAI_1_1mesh_1_1TagAndInitializeStrategy.html">mesh::TagAndInitializeStrategy</a> <p>
<a class="el" href="classSAMRAI_1_1mesh_1_1LoadBalanceStrategy.html">mesh::LoadBalanceStrategy</a> <p>
<a class="el" href="classSAMRAI_1_1mesh_1_1BoxGeneratorStrategy.html">mesh::BoxGeneratorStrategy</a> </dd></dl>

<p>
<hr><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" name="0be1a5923a05bb72a8f7fae6698a1dc7"></a><!-- doxytag: member="SAMRAI::mesh::GriddingAlgorithm::GriddingAlgorithm" ref="0be1a5923a05bb72a8f7fae6698a1dc7" args="(const tbox::Pointer&lt; hier::PatchHierarchy &gt; &amp;hierarchy, const std::string &amp;object_name, tbox::Pointer&lt; tbox::Database &gt; input_db, tbox::Pointer&lt; TagAndInitializeStrategy &gt; level_strategy, tbox::Pointer&lt; BoxGeneratorStrategy &gt; generator, tbox::Pointer&lt; LoadBalanceStrategy &gt; balancer, tbox::Pointer&lt; LoadBalanceStrategy &gt; balancer_zero=tbox::Pointer&lt; LoadBalanceStrategy &gt;(NULL), bool register_for_restart=true)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SAMRAI::mesh::GriddingAlgorithm::GriddingAlgorithm           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchHierarchy.html">hier::PatchHierarchy</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>hierarchy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>object_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Database.html">tbox::Database</a> &gt;&nbsp;</td>
          <td class="paramname"> <em>input_db</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1mesh_1_1TagAndInitializeStrategy.html">TagAndInitializeStrategy</a> &gt;&nbsp;</td>
          <td class="paramname"> <em>level_strategy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1mesh_1_1BoxGeneratorStrategy.html">BoxGeneratorStrategy</a> &gt;&nbsp;</td>
          <td class="paramname"> <em>generator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1mesh_1_1LoadBalanceStrategy.html">LoadBalanceStrategy</a> &gt;&nbsp;</td>
          <td class="paramname"> <em>balancer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1mesh_1_1LoadBalanceStrategy.html">LoadBalanceStrategy</a> &gt;&nbsp;</td>
          <td class="paramname"> <em>balancer_zero</em> = <code><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt;&nbsp;<a class="el" href="classSAMRAI_1_1mesh_1_1LoadBalanceStrategy.html">LoadBalanceStrategy</a>&nbsp;&gt;(NULL)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>register_for_restart</em> = <code>true</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The constructor for <a class="el" href="classSAMRAI_1_1mesh_1_1GriddingAlgorithm.html">GriddingAlgorithm</a> configures the gridding algorithm with the patch hierarchy and concrete algorithm strategy objects in the argument list. 
<p>
Gridding parameters are initialized from values provided in the specified input and in the restart database corresponding to the specified object_name argument. The constructor also registers this object for restart using the specified object name when the boolean argument is true (default).<p>
If assertion checking is turned on, an unrecoverable assertion will result if any of the required pointer arguments is null. Assertions may also be thrown if any checks for consistency among input parameters fail.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>hierarchy</em>&nbsp;</td><td>The hierarchy that this <a class="el" href="classSAMRAI_1_1mesh_1_1GriddingAlgorithm.html">GriddingAlgorithm</a> will work on. The pointer is cached. All hierarchy operations will be on this hierarchy.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>object_name</em>&nbsp;</td><td>For registering the object in the restart database.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>input_db</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>level_strategy</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>generator</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>balancer</em>&nbsp;</td><td>Load balancer</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>balancer_zero</em>&nbsp;</td><td>Special load balancer to use for level zero. If omitted, will use <code>balancer</code> instead.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>register_for_restart</em>&nbsp;</td><td></td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="d564619fa83f3ec37d0349a31a7c0a30"></a><!-- doxytag: member="SAMRAI::mesh::GriddingAlgorithm::~GriddingAlgorithm" ref="d564619fa83f3ec37d0349a31a7c0a30" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SAMRAI::mesh::GriddingAlgorithm::~GriddingAlgorithm           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Destructor. 
<p>

</div>
</div><p>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="d1846e119aeff11f5f40c7dd2aa2e7f5"></a><!-- doxytag: member="SAMRAI::mesh::GriddingAlgorithm::makeCoarsestLevel" ref="d1846e119aeff11f5f40c7dd2aa2e7f5" args="(const double level_time)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::mesh::GriddingAlgorithm::makeCoarsestLevel           </td>
          <td>(</td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>level_time</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Create or rebalance the coarsest level. 
<p>
This is an implementation of interface defined in <a class="el" href="classSAMRAI_1_1mesh_1_1GriddingAlgorithmStrategy.html">GriddingAlgorithmStrategy</a>.<p>
This routine will attempt to construct the coarsest level in the AMR patch hierarchy (i.e., level 0). If level 0 does not already exist, then the domain specification is checked against the constraints of the grid generation procedures. Recall that the domain specification is maintained by the grid geometry object associated with the hierarchy. Generally, an unrecoverable assertion will result if the constraints are not satisfied.<p>
If level 0 already exists in the hierarchy, then the routine will generate a new level zero by re-applying the load balancing procedure to the existing level. Data will be moved from the old level to the new level and the pre-existing level 0 will be discarded. Note that this routine is different than the routine <a class="el" href="classSAMRAI_1_1mesh_1_1GriddingAlgorithm.html#56901ef8299000705e5aa47e190b2a9e">makeFinerLevel()</a> below, which is used to construct levels finer than level zero. In particular, this routine does not select cells for refinement, whereas the other routine does.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>level_time</em>&nbsp;</td><td>Simulation time. </td></tr>
  </table>
</dl>

<p>
Implements <a class="el" href="classSAMRAI_1_1mesh_1_1GriddingAlgorithmStrategy.html#719a01e9347f418653d860d1460762da">SAMRAI::mesh::GriddingAlgorithmStrategy</a>.
</div>
</div><p>
<a class="anchor" name="56901ef8299000705e5aa47e190b2a9e"></a><!-- doxytag: member="SAMRAI::mesh::GriddingAlgorithm::makeFinerLevel" ref="56901ef8299000705e5aa47e190b2a9e" args="(const double level_time, const bool initial_time, const int tag_buffer, const double regrid_start_time=0.0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::mesh::GriddingAlgorithm::makeFinerLevel           </td>
          <td>(</td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>level_time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&nbsp;</td>
          <td class="paramname"> <em>initial_time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>tag_buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>regrid_start_time</em> = <code>0.0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Attempt to create a new level in the hierarchy finer than the finest level currently residing in the hierarchy. 
<p>
This is an implementation of interface method <a class="el" href="classSAMRAI_1_1mesh_1_1GriddingAlgorithmStrategy.html#25a60c233136dcd8f62af4724b7b824a">GriddingAlgorithmStrategy::makeFinerLevel()</a>.<p>
The tag buffer indicates the number of cells by which cells selected for refinement should be buffered before new finer level boxes are constructed. All tagged cells should be refined except where refinement would violate proper nesting. The buffer is meant to keep phenomena of interest on refined regions of the mesh until adaptive regridding occurs next. Callers of this method should take into account how the simulation may evolve before regridding occurs (e.g., number of timesteps taken) when calculating the tag_buffer.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>level_time</em>&nbsp;</td><td>See above text.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>initial_time</em>&nbsp;</td><td>See above text.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>tag_buffer</em>&nbsp;</td><td>See above text.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>regrid_start_time[in]</em>&nbsp;</td><td>The simulation time when the regridding operation began (this parameter is ignored except when using Richardson extrapolation) </td></tr>
  </table>
</dl>

<p>
Implements <a class="el" href="classSAMRAI_1_1mesh_1_1GriddingAlgorithmStrategy.html#25a60c233136dcd8f62af4724b7b824a">SAMRAI::mesh::GriddingAlgorithmStrategy</a>.
</div>
</div><p>
<a class="anchor" name="5d2ef5face4b4c3b40ba814906916089"></a><!-- doxytag: member="SAMRAI::mesh::GriddingAlgorithm::regridAllFinerLevels" ref="5d2ef5face4b4c3b40ba814906916089" args="(const int level_number, const double regrid_time, const tbox::Array&lt; int &gt; &amp;tag_buffer, tbox::Array&lt; double &gt; regrid_start_time=tbox::Array&lt; double &gt;(), const bool level_is_coarsest_to_sync=true)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::mesh::GriddingAlgorithm::regridAllFinerLevels           </td>
          <td>(</td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>level_number</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>regrid_time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1tbox_1_1Array.html">tbox::Array</a>&lt; int &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>tag_buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1tbox_1_1Array.html">tbox::Array</a>&lt; double &gt;&nbsp;</td>
          <td class="paramname"> <em>regrid_start_time</em> = <code><a class="el" href="classSAMRAI_1_1tbox_1_1Array.html">tbox::Array</a>&lt;&nbsp;double&nbsp;&gt;()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&nbsp;</td>
          <td class="paramname"> <em>level_is_coarsest_to_sync</em> = <code>true</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Attempt to regrid each level in the PatchHierarchy that is finer than the specified level. 
<p>
This method implements the virtual interface <a class="el" href="classSAMRAI_1_1mesh_1_1GriddingAlgorithmStrategy.html#2ca0e474cc71e77856d09344e1566cb7">GriddingAlgorithmStrategy::regridAllFinerLevels()</a>.<p>
Note that the current algorithm permits at most one new finest level to be added to the hierarchy with each invocation of the regridding process. This constraint, though seemingly restrictive makes the process of maintaining properly nested levels much easier.<p>
Note that the current algorithm permits at most one new finest level to be added to the hierarchy with each call to this method. This constraint, though seemingly restrictive makes the process of maintaining properly nested levels much easier.<p>
Important note: If assertion checking is activated, several checks are applied to the functions arguments. If any check is violated, an unrecoverable assertion will result. In particular, the given level number must match that of of some level in the hierarchy. Also, the tag buffer array must contain a positive value for each level in the hierarchy.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>level_number</em>&nbsp;</td><td>Coarsest level on which cells will be tagged for refinement</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>regrid_time</em>&nbsp;</td><td>Simulaition time when regridding occurs</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>tag_buffer</em>&nbsp;</td><td>Size of buffer on each level around tagged cells that will be covered by the next finer level</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>regrid_start_time</em>&nbsp;</td><td>The simulation time when the regridding operation began on each level (this parameter is ignored except when using Richardson extrapolation)</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>level_is_coarsest_to_sync</em>&nbsp;</td><td>Level is the coarsest to sync </td></tr>
  </table>
</dl>

<p>
Implements <a class="el" href="classSAMRAI_1_1mesh_1_1GriddingAlgorithmStrategy.html#2ca0e474cc71e77856d09344e1566cb7">SAMRAI::mesh::GriddingAlgorithmStrategy</a>.
</div>
</div><p>
<a class="anchor" name="d1f0fc38f40da4490b226fec0de54bb7"></a><!-- doxytag: member="SAMRAI::mesh::GriddingAlgorithm::getTagAndInitializeStrategy" ref="d1f0fc38f40da4490b226fec0de54bb7" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SAMRAI_INLINE_KEYWORD <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1mesh_1_1TagAndInitializeStrategy.html">TagAndInitializeStrategy</a> &gt; SAMRAI::mesh::GriddingAlgorithm::getTagAndInitializeStrategy           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return pointer to level gridding strategy data member. 
<p>
Access to this member is useful when an integrator implementation needs to know if the error estimator uses time integration.<p>
<dl compact><dt><b>Returns:</b></dt><dd>pointer to <a class="el" href="classSAMRAI_1_1mesh_1_1TagAndInitializeStrategy.html">TagAndInitializeStrategy</a> data member. </dd></dl>

<p>
Implements <a class="el" href="classSAMRAI_1_1mesh_1_1GriddingAlgorithmStrategy.html#1ef20da31b373f91a2876f6b3e495ae9">SAMRAI::mesh::GriddingAlgorithmStrategy</a>.
</div>
</div><p>
<a class="anchor" name="40d3fb9125b7352b97a3a380818d6e84"></a><!-- doxytag: member="SAMRAI::mesh::GriddingAlgorithm::getLoadBalanceStrategy" ref="40d3fb9125b7352b97a3a380818d6e84" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SAMRAI_INLINE_KEYWORD <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1mesh_1_1LoadBalanceStrategy.html">LoadBalanceStrategy</a> &gt; SAMRAI::mesh::GriddingAlgorithm::getLoadBalanceStrategy           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return pointer to load balance strategy data member. 
<p>

</div>
</div><p>
<a class="anchor" name="c4fe554dc5b0daaca35fb5dec098f72b"></a><!-- doxytag: member="SAMRAI::mesh::GriddingAlgorithm::getLoadBalanceStrategyZero" ref="c4fe554dc5b0daaca35fb5dec098f72b" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SAMRAI_INLINE_KEYWORD <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1mesh_1_1LoadBalanceStrategy.html">LoadBalanceStrategy</a> &gt; SAMRAI::mesh::GriddingAlgorithm::getLoadBalanceStrategyZero           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return pointer to load balance strategy specialized for balancing level zero. 
<p>
<dl compact><dt><b>Returns:</b></dt><dd>pointer to load balance strategy specialized for the case where one processor owns all the initial loads. </dd></dl>

</div>
</div><p>
<a class="anchor" name="eb02272242cae556e6cf1d30bb7dc51c"></a><!-- doxytag: member="SAMRAI::mesh::GriddingAlgorithm::setEfficiencyTolerance" ref="eb02272242cae556e6cf1d30bb7dc51c" args="(const double efficiency_tolerance, const int level_number)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SAMRAI_INLINE_KEYWORD void SAMRAI::mesh::GriddingAlgorithm::setEfficiencyTolerance           </td>
          <td>(</td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>efficiency_tolerance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>level_number</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set efficiency tolerance for clustering tags on level. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>efficiency_tolerance</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>level_number</em>&nbsp;</td><td></td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="d358b372179521cacb81f431d4e28f03"></a><!-- doxytag: member="SAMRAI::mesh::GriddingAlgorithm::getEfficiencyTolerance" ref="d358b372179521cacb81f431d4e28f03" args="(const int level_number) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SAMRAI_INLINE_KEYWORD double SAMRAI::mesh::GriddingAlgorithm::getEfficiencyTolerance           </td>
          <td>(</td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>level_number</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return efficiency tolerance for clustering tags on level. 
<p>
<dl compact><dt><b>Returns:</b></dt><dd>efficiency tolerance for clustering tags on level. </dd></dl>

</div>
</div><p>
<a class="anchor" name="73e212c91812d1a433ca0793576fc2da"></a><!-- doxytag: member="SAMRAI::mesh::GriddingAlgorithm::setCombineEfficiency" ref="73e212c91812d1a433ca0793576fc2da" args="(const double combine_efficiency, const int level_number)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SAMRAI_INLINE_KEYWORD void SAMRAI::mesh::GriddingAlgorithm::setCombineEfficiency           </td>
          <td>(</td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>combine_efficiency</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>level_number</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set combine efficiency for clustering tags on level. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>combine_efficiency</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>level_number</em>&nbsp;</td><td></td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="2eeb7aef9d8cbca616a02f8ba70e3d6f"></a><!-- doxytag: member="SAMRAI::mesh::GriddingAlgorithm::getCombineEfficiency" ref="2eeb7aef9d8cbca616a02f8ba70e3d6f" args="(const int level_number) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SAMRAI_INLINE_KEYWORD double SAMRAI::mesh::GriddingAlgorithm::getCombineEfficiency           </td>
          <td>(</td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>level_number</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return combine efficiency for clustering tags on level. 
<p>
<dl compact><dt><b>Returns:</b></dt><dd>combine efficiency for clustering tags on level. </dd></dl>

</div>
</div><p>
<a class="anchor" name="8f18dca77480c966b2253020162a31c0"></a><!-- doxytag: member="SAMRAI::mesh::GriddingAlgorithm::printClassData" ref="8f18dca77480c966b2253020162a31c0" args="(std::ostream &amp;os) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::mesh::GriddingAlgorithm::printClassData           </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&nbsp;</td>
          <td class="paramname"> <em>os</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Print all data members of the class instance to given output stream. 
<p>

</div>
</div><p>
<a class="anchor" name="0f1c520afe49b00e2458c63ecf1582a6"></a><!-- doxytag: member="SAMRAI::mesh::GriddingAlgorithm::putToDatabase" ref="0f1c520afe49b00e2458c63ecf1582a6" args="(tbox::Pointer&lt; tbox::Database &gt; db)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::mesh::GriddingAlgorithm::putToDatabase           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Database.html">tbox::Database</a> &gt;&nbsp;</td>
          <td class="paramname"> <em>db</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Write object state out to the gien database. 
<p>
When assertion checking is active, the database pointer must be non-null. 
<p>
Implements <a class="el" href="classSAMRAI_1_1tbox_1_1Serializable.html#b6a4bd6fd7a9046bd2f60ad716c21293">SAMRAI::tbox::Serializable</a>.
</div>
</div><p>
<a class="anchor" name="b412d10052255cff13ffa3f104dd8a09"></a><!-- doxytag: member="SAMRAI::mesh::GriddingAlgorithm::printStatistics" ref="b412d10052255cff13ffa3f104dd8a09" args="(std::ostream &amp;s=tbox::plog) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::mesh::GriddingAlgorithm::printStatistics           </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&nbsp;</td>
          <td class="paramname"> <em>s</em> = <code><a class="el" href="namespaceSAMRAI_1_1tbox.html#48a363c43ec1479b41d6c9c560ba446d">tbox::plog</a></code>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<hr>The documentation for this class was generated from the following files:<ul>
<li>source/SAMRAI/mesh/<a class="el" href="GriddingAlgorithm_8h.html">GriddingAlgorithm.h</a><li>source/SAMRAI/mesh/<a class="el" href="GriddingAlgorithm_8C.html">GriddingAlgorithm.C</a><li>source/SAMRAI/mesh/<a class="el" href="GriddingAlgorithm_8I.html">GriddingAlgorithm.I</a></ul>
<hr size="1"><address style="align: right;"><small>Generated on Wed Jan 18 16:05:17 2012 for SAMRAI by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.7 </small></address>
</body>
</html>
