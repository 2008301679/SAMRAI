<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>SAMRAI: SAMRAI::mesh::GriddingAlgorithm Class Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.7 -->
<div class="tabs">
  <ul>
    <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="namespaces.html"><span>Namespaces</span></a></li>
    <li id="current"><a href="annotated.html"><span>Classes</span></a></li>
    <li><a href="files.html"><span>Files</span></a></li>
    <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
  </ul></div>
<div class="tabs">
  <ul>
    <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
    <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
    <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
  </ul></div>
<div class="nav">
<a class="el" href="namespaceSAMRAI.html">SAMRAI</a>::<a class="el" href="namespaceSAMRAI_1_1mesh.html">mesh</a>::<a class="el" href="classSAMRAI_1_1mesh_1_1GriddingAlgorithm.html">GriddingAlgorithm</a></div>
<h1>SAMRAI::mesh::GriddingAlgorithm Class Reference</h1><!-- doxytag: class="SAMRAI::mesh::GriddingAlgorithm" --><!-- doxytag: inherits="SAMRAI::mesh::GriddingAlgorithmStrategy,SAMRAI::tbox::Serializable" -->Class <a class="el" href="classSAMRAI_1_1mesh_1_1GriddingAlgorithm.html">GriddingAlgorithm</a> manages AMR patch hierarchy construction operations in <a class="el" href="namespaceSAMRAI.html">SAMRAI</a>. Specifically, it provides AMR patch hierarchy generation and regridding routines that may be used with a variety of AMR solution algorithms and application codes.  
<a href="#_details">More...</a>
<p>
<code>#include &lt;source/SAMRAI/mesh/GriddingAlgorithm.h&gt;</code>
<p>
<p>Inheritance diagram for SAMRAI::mesh::GriddingAlgorithm:
<p><center><img src="classSAMRAI_1_1mesh_1_1GriddingAlgorithm.png" usemap="#SAMRAI::mesh::GriddingAlgorithm_map" border="0" alt=""></center>
<map name="SAMRAI::mesh::GriddingAlgorithm_map">
<area href="classSAMRAI_1_1mesh_1_1GriddingAlgorithmStrategy.html" alt="SAMRAI::mesh::GriddingAlgorithmStrategy" shape="rect" coords="0,0,249,24">
<area href="classSAMRAI_1_1tbox_1_1Serializable.html" alt="SAMRAI::tbox::Serializable" shape="rect" coords="259,0,508,24">
</map>
<a href="classSAMRAI_1_1mesh_1_1GriddingAlgorithm-members.html">List of all members.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1mesh_1_1GriddingAlgorithm.html#dc6377fd56368ad17dae103901540c17">GriddingAlgorithm</a> (const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchHierarchy.html">hier::PatchHierarchy</a> &gt; &amp;hierarchy, const std::string &amp;object_name, const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Database.html">tbox::Database</a> &gt; &amp;input_db, const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1mesh_1_1TagAndInitializeStrategy.html">TagAndInitializeStrategy</a> &gt; &amp;level_strategy, const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1mesh_1_1BoxGeneratorStrategy.html">BoxGeneratorStrategy</a> &gt; &amp;generator, const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1mesh_1_1LoadBalanceStrategy.html">LoadBalanceStrategy</a> &gt; &amp;balancer, const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1mesh_1_1LoadBalanceStrategy.html">LoadBalanceStrategy</a> &gt; &amp;balancer_zero=boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1mesh_1_1LoadBalanceStrategy.html">LoadBalanceStrategy</a> &gt;())</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The constructor for <a class="el" href="classSAMRAI_1_1mesh_1_1GriddingAlgorithm.html">GriddingAlgorithm</a> configures the gridding algorithm with the patch hierarchy and concrete algorithm strategy objects in the argument list.  <a href="#dc6377fd56368ad17dae103901540c17"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1mesh_1_1GriddingAlgorithm.html#7b3401878060600679ef361620847624">~GriddingAlgorithm</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Destructor.  <a href="#7b3401878060600679ef361620847624"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1mesh_1_1GriddingAlgorithm.html#0dc18630ab497fca0bdfd135bf35d9cb">makeCoarsestLevel</a> (const double level_time)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create or rebalance the coarsest level.  <a href="#0dc18630ab497fca0bdfd135bf35d9cb"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1mesh_1_1GriddingAlgorithm.html#890bae2dd741f14a04160ec5861c9f0a">makeFinerLevel</a> (const int tag_buffer, const bool initial_cycle, const int cycle, const double level_time, const double regrid_start_time=0.0)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Attempt to create a new level in the hierarchy finer than the finest level currently residing in the hierarchy.  <a href="#890bae2dd741f14a04160ec5861c9f0a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1mesh_1_1GriddingAlgorithm.html#d2d95b00ed6bf6b3b600565034ec4b22">regridAllFinerLevels</a> (const int level_number, const std::vector&lt; int &gt; &amp;tag_buffer, const int cycle, const double level_time, const std::vector&lt; double &gt; &amp;regrid_start_time=std::vector&lt; double &gt;(), const bool level_is_coarsest_to_sync=true)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Attempt to regrid each level in the PatchHierarchy that is finer than the specified level.  <a href="#d2d95b00ed6bf6b3b600565034ec4b22"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual boost::shared_ptr&lt;<br>
 <a class="el" href="classSAMRAI_1_1mesh_1_1TagAndInitializeStrategy.html">TagAndInitializeStrategy</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1mesh_1_1GriddingAlgorithm.html#5e3807368fa25c7cafa0bf5f3203dafd">getTagAndInitializeStrategy</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return pointer to level gridding strategy data member.  <a href="#5e3807368fa25c7cafa0bf5f3203dafd"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual boost::shared_ptr&lt;<br>
 <a class="el" href="classSAMRAI_1_1mesh_1_1LoadBalanceStrategy.html">LoadBalanceStrategy</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1mesh_1_1GriddingAlgorithm.html#6e30e25c46601b0c9741cbe24e5c2fdc">getLoadBalanceStrategy</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return pointer to load balance strategy data member.  <a href="#6e30e25c46601b0c9741cbe24e5c2fdc"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual boost::shared_ptr&lt;<br>
 <a class="el" href="classSAMRAI_1_1mesh_1_1LoadBalanceStrategy.html">LoadBalanceStrategy</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1mesh_1_1GriddingAlgorithm.html#63e2f9d894a6b4bf04d7ae396bf7ea67">getLoadBalanceStrategyZero</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return pointer to load balance strategy specialized for balancing level zero.  <a href="#63e2f9d894a6b4bf04d7ae396bf7ea67"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchHierarchy.html">hier::PatchHierarchy</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1mesh_1_1GriddingAlgorithm.html#0659732cbfa3531832074b8e1b116c9b">getPatchHierarchy</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return pointer to PatchHierarchy data member.  <a href="#0659732cbfa3531832074b8e1b116c9b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1mesh_1_1GriddingAlgorithm.html#03626fddf498bb5d5d2a4049f5bf80f2">printClassData</a> (std::ostream &amp;os) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Print all data members of the class instance to given output stream.  <a href="#03626fddf498bb5d5d2a4049f5bf80f2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1mesh_1_1GriddingAlgorithm.html#f6f04d9480fc40e6c74e429c52c8e185">putToRestart</a> (const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Database.html">tbox::Database</a> &gt; &amp;restart_db) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Write object state out to the given restart database.  <a href="#f6f04d9480fc40e6c74e429c52c8e185"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1mesh_1_1GriddingAlgorithm.html#2ee22b4801e5f37e63447dc7490bf8e0">printStatistics</a> (std::ostream &amp;s=<a class="el" href="namespaceSAMRAI_1_1tbox.html#b84041705493761fb17a8127e3a2dca2">tbox::plog</a>) const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">const std::string &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1mesh_1_1GriddingAlgorithm.html#2ae592faf8f7a149ef42970ad83076f3">getObjectName</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the name of this object.  <a href="#2ae592faf8f7a149ef42970ad83076f3"></a><br></td></tr>
</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
Class <a class="el" href="classSAMRAI_1_1mesh_1_1GriddingAlgorithm.html">GriddingAlgorithm</a> manages AMR patch hierarchy construction operations in <a class="el" href="namespaceSAMRAI.html">SAMRAI</a>. Specifically, it provides AMR patch hierarchy generation and regridding routines that may be used with a variety of AMR solution algorithms and application codes. 
<p>
The three main functions provided by this class are:<ul>
<li><b><a class="el" href="classSAMRAI_1_1mesh_1_1GriddingAlgorithm.html#0dc18630ab497fca0bdfd135bf35d9cb">makeCoarsestLevel()</a></b> This routine constructs or repartitions the coarsest hierarchy level (level 0).</li></ul>
<p>
<ul>
<li><b><a class="el" href="classSAMRAI_1_1mesh_1_1GriddingAlgorithm.html#890bae2dd741f14a04160ec5861c9f0a">makeFinerLevel()</a></b> This routine will attempt to add a new finest level to the hierarchy if the maximum number of levels allows it and cells on the current finest level are tagged for refinement.</li></ul>
<p>
<ul>
<li><b><a class="el" href="classSAMRAI_1_1mesh_1_1GriddingAlgorithm.html#d2d95b00ed6bf6b3b600565034ec4b22">regridAllFinerLevels()</a></b> This routine will regrid all levels finer than some specified level based on cells that are tagged for refinement on each level finer than and including the given level. This routine may add a new finest hierarchy level if the maximum number of levels allows it and cells on the current finest level are tagged for refinement. Levels may also be removed from the hierarchy if no cells are tagged.</li></ul>
<p>
These basic AMR operations are used to generate levels in the AMR patch hierarchy at the beginning of a simulation, and regridding collections of levels during an adaptive calculation. More details are found in the comments accompanying each member function below.<p>
Other objects passed to the constructor provide the gridding algorithm with particular operations needed during meshing operations. Operations that tag cells for refinement on a patch level and initialize data on new levels are provided by the <a class="el" href="classSAMRAI_1_1mesh_1_1TagAndInitializeStrategy.html">TagAndInitializeStrategy</a> argument. Operations that cluster tagged cells into a boxes are provided by the <a class="el" href="classSAMRAI_1_1mesh_1_1BoxGeneratorStrategy.html">BoxGeneratorStrategy</a> argument. Routines that load balance patches on a level are provided by the <a class="el" href="classSAMRAI_1_1mesh_1_1LoadBalanceStrategy.html">LoadBalanceStrategy</a> constructor argument.<p>
<b> Input Parameters </b><p>
<b> Definitions: </b><ul>
<li><b>check_overflow_nesting</b> </li></ul>
<p>
<ul>
<li><b>check_proper_nesting</b> </li></ul>
<p>
<ul>
<li><b>check_nonrefined_tags</b> controls how to resolve user-specified tags that violate proper nesting. If a tag violates the nesting requirements, its location in index space will not be refined when creating the finer level. This flag allows the user to determine what to do when this occurs. <br>
 Set to one of these characters: <br>
 <b>'i'</b> - violating tags will be quietly disregarded. <br>
 <b>'w'</b> - violating tags will cause a warning and be disregarded. <br>
 <b>'e'</b> - violating tags will cause an unrecoverable assertion. <br>
 It is fastest to ignore non-nesting tags because no checking has to be done.</li></ul>
<p>
<ul>
<li><b>check_overlapping_patches</b> controls checking for overlapping patches on a new level. <br>
 Set to one of these characters: <br>
 <b>'i'</b> - there is no check for overlapping patches, and they will be quietly disregarded. <br>
 <b>'w'</b> - overlapping patches will cause a warning and be disregarded. <br>
 <b>'e'</b> - violating tags will cause an unrecoverable assertion. <br>
 The check for overlapping patches may be and should be bypassed by applications that can tolerate overlaps. To prevent the creation of levels with overlapping patches, see the PatchHierarchy input flag "allow_patches_smaller_than_minimum_size_to_prevent_overlaps".</li></ul>
<p>
<ul>
<li><b>check_nonnesting_user_boxes</b> controls how user-specified refinement boxes that violate proper nesting are handled. <br>
 Set to one of these characters: <br>
 <b>'i'</b> - nesting violations will be quietly disregarded. <br>
 <b>'w'</b> - nesting violations will cause a warning but the code will continue anyway. <br>
 <b>'e'</b> - nesting violations will cause an unrecoverable assertion <br>
 We highly recommend making nesting violation an error. The code may work anyway, but there are no guarantees.</li></ul>
<p>
<ul>
<li><b>sequentialize_patch_indices</b> whether patch indices will be globally sequentialized. This is not scalable, but is required for writing correct VisIt files. Due to the current VisIt requirement, this is currently true by default. It will evetually be set back to false after we remove the VisIt requirement.</li></ul>
<p>
<ul>
<li><b>enforce_proper_nesting</b> </li></ul>
<p>
<b> Details: </b> <br>
 <table border="1" cellspacing="3" cellpadding="3">
<tr>
<th>parameter </th><th>type </th><th>default </th><th>range </th><th>opt/req </th><th>behavior on restart  </th></tr>
<tr>
<td>check_overflow_nesting </td><td>bool </td><td>FALSE </td><td>TRUE, FALSE </td><td>opt </td><td>Parameter read from restart db may be overridden by input db  </td></tr>
<tr>
<td>check_proper_nesting </td><td>bool </td><td>FALSE </td><td>TRUE, FALSE </td><td>opt </td><td>Parameter read from restart db may be overridden by input db  </td></tr>
<tr>
<td>check_nonrefined_tags </td><td>string </td><td>"WARN" </td><td>"WARN", "IGNORE", "ERROR" </td><td>opt </td><td>Parameter read from restart db may be overridden by input db  </td></tr>
<tr>
<td>check_overlapping_patches </td><td>string </td><td>"IGNORE" </td><td>"WARN", "IGNORE", "ERROR" </td><td>opt </td><td>Parameter read from restart db may be overridden by input db  </td></tr>
<tr>
<td>check_nonnesting_user_boxes </td><td>string </td><td>"ERROR" </td><td>"WARN", "IGNORE", "ERROR" </td><td>opt </td><td>Parameter read from restart db may be overridden by input db  </td></tr>
<tr>
<td>sequentialize_patch_indices </td><td>bool </td><td>TRUE </td><td>TRUE, FALSE </td><td>opt </td><td>Parameter read from restart db may be overridden by input db  </td></tr>
<tr>
<td>enforce_proper_nesting </td><td>bool </td><td>TRUE </td><td>TRUE, FALSE </td><td>opt </td><td>Parameter read from restart db may be overridden by input db  </td></tr>
</table>
<p>
All values read in from a restart database may be overriden by input database values. If no new input database value is given, the restart database value is used.<p>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classSAMRAI_1_1mesh_1_1TagAndInitializeStrategy.html">mesh::TagAndInitializeStrategy</a> <p>
<a class="el" href="classSAMRAI_1_1mesh_1_1LoadBalanceStrategy.html">mesh::LoadBalanceStrategy</a> <p>
<a class="el" href="classSAMRAI_1_1mesh_1_1BoxGeneratorStrategy.html">mesh::BoxGeneratorStrategy</a> </dd></dl>

<p>
<hr><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" name="dc6377fd56368ad17dae103901540c17"></a><!-- doxytag: member="SAMRAI::mesh::GriddingAlgorithm::GriddingAlgorithm" ref="dc6377fd56368ad17dae103901540c17" args="(const boost::shared_ptr&lt; hier::PatchHierarchy &gt; &amp;hierarchy, const std::string &amp;object_name, const boost::shared_ptr&lt; tbox::Database &gt; &amp;input_db, const boost::shared_ptr&lt; TagAndInitializeStrategy &gt; &amp;level_strategy, const boost::shared_ptr&lt; BoxGeneratorStrategy &gt; &amp;generator, const boost::shared_ptr&lt; LoadBalanceStrategy &gt; &amp;balancer, const boost::shared_ptr&lt; LoadBalanceStrategy &gt; &amp;balancer_zero=boost::shared_ptr&lt; LoadBalanceStrategy &gt;())" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SAMRAI::mesh::GriddingAlgorithm::GriddingAlgorithm           </td>
          <td>(</td>
          <td class="paramtype">const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchHierarchy.html">hier::PatchHierarchy</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>hierarchy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>object_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Database.html">tbox::Database</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>input_db</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1mesh_1_1TagAndInitializeStrategy.html">TagAndInitializeStrategy</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>level_strategy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1mesh_1_1BoxGeneratorStrategy.html">BoxGeneratorStrategy</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>generator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1mesh_1_1LoadBalanceStrategy.html">LoadBalanceStrategy</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>balancer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1mesh_1_1LoadBalanceStrategy.html">LoadBalanceStrategy</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>balancer_zero</em> = <code>boost::shared_ptr&lt;&nbsp;<a class="el" href="classSAMRAI_1_1mesh_1_1LoadBalanceStrategy.html">LoadBalanceStrategy</a>&nbsp;&gt;()</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The constructor for <a class="el" href="classSAMRAI_1_1mesh_1_1GriddingAlgorithm.html">GriddingAlgorithm</a> configures the gridding algorithm with the patch hierarchy and concrete algorithm strategy objects in the argument list. 
<p>
Gridding parameters are initialized from values provided in the specified input and in the restart database corresponding to the specified object_name argument.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>hierarchy</em>&nbsp;</td><td>The hierarchy that this <a class="el" href="classSAMRAI_1_1mesh_1_1GriddingAlgorithm.html">GriddingAlgorithm</a> will work on. The pointer is cached. All hierarchy operations will be on this hierarchy.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>object_name</em>&nbsp;</td><td>For registering the object in the restart database.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>input_db</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>level_strategy</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>generator</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>balancer</em>&nbsp;</td><td>Load balancer</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>balancer_zero</em>&nbsp;</td><td>Special load balancer to use for level zero. If omitted, will use <code>balancer</code> instead.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Precondition:</b></dt><dd>hierarchy <p>
!object_name.empty() <p>
tag_init_strategy <p>
generator <p>
balancer </dd></dl>

</div>
</div><p>
<a class="anchor" name="7b3401878060600679ef361620847624"></a><!-- doxytag: member="SAMRAI::mesh::GriddingAlgorithm::~GriddingAlgorithm" ref="7b3401878060600679ef361620847624" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SAMRAI::mesh::GriddingAlgorithm::~GriddingAlgorithm           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Destructor. 
<p>

</div>
</div><p>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="0dc18630ab497fca0bdfd135bf35d9cb"></a><!-- doxytag: member="SAMRAI::mesh::GriddingAlgorithm::makeCoarsestLevel" ref="0dc18630ab497fca0bdfd135bf35d9cb" args="(const double level_time)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::mesh::GriddingAlgorithm::makeCoarsestLevel           </td>
          <td>(</td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>level_time</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Create or rebalance the coarsest level. 
<p>
This is an implementation of interface defined in <a class="el" href="classSAMRAI_1_1mesh_1_1GriddingAlgorithmStrategy.html">GriddingAlgorithmStrategy</a>.<p>
This routine will attempt to construct the coarsest level in the AMR patch hierarchy (i.e., level 0). If level 0 does not already exist, then the domain specification is checked against the constraints of the grid generation procedures. Recall that the domain specification is maintained by the grid geometry object associated with the hierarchy. Generally, an unrecoverable assertion will result if the constraints are not satisfied.<p>
If level 0 already exists in the hierarchy, then the routine will generate a new level zero by re-applying the load balancing procedure to the existing level. Data will be moved from the old level to the new level and the pre-existing level 0 will be discarded. Note that this routine is different than the routine <a class="el" href="classSAMRAI_1_1mesh_1_1GriddingAlgorithm.html#890bae2dd741f14a04160ec5861c9f0a">makeFinerLevel()</a> below, which is used to construct levels finer than level zero. In particular, this routine does not select cells for refinement, whereas the other routine does.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>level_time</em>&nbsp;</td><td>Simulation time.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Precondition:</b></dt><dd>d_hierarchy-&gt;getMaxNumberOfLevels() &gt; 0 </dd></dl>

<p>
Implements <a class="el" href="classSAMRAI_1_1mesh_1_1GriddingAlgorithmStrategy.html#bc3105d7f7328bc1a0b4e99e37924d73">SAMRAI::mesh::GriddingAlgorithmStrategy</a>.
</div>
</div><p>
<a class="anchor" name="890bae2dd741f14a04160ec5861c9f0a"></a><!-- doxytag: member="SAMRAI::mesh::GriddingAlgorithm::makeFinerLevel" ref="890bae2dd741f14a04160ec5861c9f0a" args="(const int tag_buffer, const bool initial_cycle, const int cycle, const double level_time, const double regrid_start_time=0.0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::mesh::GriddingAlgorithm::makeFinerLevel           </td>
          <td>(</td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>tag_buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&nbsp;</td>
          <td class="paramname"> <em>initial_cycle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>cycle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>level_time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>regrid_start_time</em> = <code>0.0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Attempt to create a new level in the hierarchy finer than the finest level currently residing in the hierarchy. 
<p>
This is an implementation of interface method <a class="el" href="classSAMRAI_1_1mesh_1_1GriddingAlgorithmStrategy.html#2308dc7afdfec02156a3ad9daad1426d">GriddingAlgorithmStrategy::makeFinerLevel()</a>.<p>
The tag buffer indicates the number of cells by which cells selected for refinement should be buffered before new finer level boxes are constructed. All tagged cells should be refined except where refinement would violate proper nesting. The buffer is meant to keep phenomena of interest on refined regions of the mesh until adaptive regridding occurs next. Callers of this method should take into account how the simulation may evolve before regridding occurs (e.g., number of timesteps taken) when calculating the tag_buffer.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>tag_buffer</em>&nbsp;</td><td>See above text.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>initial_cycle</em>&nbsp;</td><td>See above text</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>cycle</em>&nbsp;</td><td>See above text.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>level_time</em>&nbsp;</td><td>See above text..</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>regrid_start_time</em>&nbsp;</td><td>The simulation time when the regridding operation began (this parameter is ignored except when using Richardson extrapolation)</td></tr>
  </table>
</dl>
<dl compact><dt><b>Precondition:</b></dt><dd>d_hierarchy <p>
d_hierarchy-&gt;getPatchLevel(d_hierarchy-&gt;getFinestLevelNumber()) <p>
tag_buffer &gt;= 0 </dd></dl>

<p>
Implements <a class="el" href="classSAMRAI_1_1mesh_1_1GriddingAlgorithmStrategy.html#2308dc7afdfec02156a3ad9daad1426d">SAMRAI::mesh::GriddingAlgorithmStrategy</a>.
</div>
</div><p>
<a class="anchor" name="d2d95b00ed6bf6b3b600565034ec4b22"></a><!-- doxytag: member="SAMRAI::mesh::GriddingAlgorithm::regridAllFinerLevels" ref="d2d95b00ed6bf6b3b600565034ec4b22" args="(const int level_number, const std::vector&lt; int &gt; &amp;tag_buffer, const int cycle, const double level_time, const std::vector&lt; double &gt; &amp;regrid_start_time=std::vector&lt; double &gt;(), const bool level_is_coarsest_to_sync=true)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::mesh::GriddingAlgorithm::regridAllFinerLevels           </td>
          <td>(</td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>level_number</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>tag_buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>cycle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>level_time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>regrid_start_time</em> = <code>std::vector&lt;&nbsp;double&nbsp;&gt;()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&nbsp;</td>
          <td class="paramname"> <em>level_is_coarsest_to_sync</em> = <code>true</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Attempt to regrid each level in the PatchHierarchy that is finer than the specified level. 
<p>
This method implements the virtual interface <a class="el" href="classSAMRAI_1_1mesh_1_1GriddingAlgorithmStrategy.html#355e9c2c331a4a012370310d88cf96c2">GriddingAlgorithmStrategy::regridAllFinerLevels()</a>.<p>
Note that the current algorithm permits at most one new finest level to be added to the hierarchy with each invocation of the regridding process. This constraint, though seemingly restrictive makes the process of maintaining properly nested levels much easier.<p>
Note that the current algorithm permits at most one new finest level to be added to the hierarchy with each call to this method. This constraint, though seemingly restrictive makes the process of maintaining properly nested levels much easier.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>level_number</em>&nbsp;</td><td>Coarsest level on which cells will be tagged for refinement</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>tag_buffer</em>&nbsp;</td><td>Size of buffer on each level around tagged cells that will be covered by the next finer level</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>cycle</em>&nbsp;</td><td>Simulaition cycle when regridding occurs</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>level_time</em>&nbsp;</td><td>Simulation time of the level corresponding to level_num when regridding occurs</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>regrid_start_time</em>&nbsp;</td><td>The simulation time when the regridding operation began on each level (this parameter is ignored except when using Richardson extrapolation)</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>level_is_coarsest_to_sync</em>&nbsp;</td><td>Level is the coarsest to sync</td></tr>
  </table>
</dl>
<dl compact><dt><b>Precondition:</b></dt><dd>(level_number &gt;= 0) &amp;&amp; (level_number &lt;= d_hierarchy-&gt;getFinestLevelNumber()) <p>
d_hierarchy-&gt;getPatchLevel(level_number) <p>
tag_buffer.size() &gt;= level_number + 1 <p>
for each member, tb, of tag_buffer, tb &gt;= 0 </dd></dl>

<p>
Implements <a class="el" href="classSAMRAI_1_1mesh_1_1GriddingAlgorithmStrategy.html#355e9c2c331a4a012370310d88cf96c2">SAMRAI::mesh::GriddingAlgorithmStrategy</a>.
</div>
</div><p>
<a class="anchor" name="5e3807368fa25c7cafa0bf5f3203dafd"></a><!-- doxytag: member="SAMRAI::mesh::GriddingAlgorithm::getTagAndInitializeStrategy" ref="5e3807368fa25c7cafa0bf5f3203dafd" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1mesh_1_1TagAndInitializeStrategy.html">TagAndInitializeStrategy</a> &gt; SAMRAI::mesh::GriddingAlgorithm::getTagAndInitializeStrategy           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return pointer to level gridding strategy data member. 
<p>
Access to this member is useful when an integrator implementation needs to know if the error estimator uses time integration.<p>
<dl compact><dt><b>Returns:</b></dt><dd>pointer to <a class="el" href="classSAMRAI_1_1mesh_1_1TagAndInitializeStrategy.html">TagAndInitializeStrategy</a> data member. </dd></dl>

<p>
Implements <a class="el" href="classSAMRAI_1_1mesh_1_1GriddingAlgorithmStrategy.html#9bc169fa1026482c1b24ec63164b9ed0">SAMRAI::mesh::GriddingAlgorithmStrategy</a>.
</div>
</div><p>
<a class="anchor" name="6e30e25c46601b0c9741cbe24e5c2fdc"></a><!-- doxytag: member="SAMRAI::mesh::GriddingAlgorithm::getLoadBalanceStrategy" ref="6e30e25c46601b0c9741cbe24e5c2fdc" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1mesh_1_1LoadBalanceStrategy.html">LoadBalanceStrategy</a> &gt; SAMRAI::mesh::GriddingAlgorithm::getLoadBalanceStrategy           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return pointer to load balance strategy data member. 
<p>

</div>
</div><p>
<a class="anchor" name="63e2f9d894a6b4bf04d7ae396bf7ea67"></a><!-- doxytag: member="SAMRAI::mesh::GriddingAlgorithm::getLoadBalanceStrategyZero" ref="63e2f9d894a6b4bf04d7ae396bf7ea67" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1mesh_1_1LoadBalanceStrategy.html">LoadBalanceStrategy</a> &gt; SAMRAI::mesh::GriddingAlgorithm::getLoadBalanceStrategyZero           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return pointer to load balance strategy specialized for balancing level zero. 
<p>
<dl compact><dt><b>Returns:</b></dt><dd>pointer to load balance strategy specialized for the case where one processor owns all the initial loads. </dd></dl>

</div>
</div><p>
<a class="anchor" name="0659732cbfa3531832074b8e1b116c9b"></a><!-- doxytag: member="SAMRAI::mesh::GriddingAlgorithm::getPatchHierarchy" ref="0659732cbfa3531832074b8e1b116c9b" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchHierarchy.html">hier::PatchHierarchy</a> &gt; SAMRAI::mesh::GriddingAlgorithm::getPatchHierarchy           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return pointer to PatchHierarchy data member. 
<p>

<p>
Implements <a class="el" href="classSAMRAI_1_1mesh_1_1GriddingAlgorithmStrategy.html#33f42480fc65b0f9d03c795c15be691e">SAMRAI::mesh::GriddingAlgorithmStrategy</a>.
</div>
</div><p>
<a class="anchor" name="03626fddf498bb5d5d2a4049f5bf80f2"></a><!-- doxytag: member="SAMRAI::mesh::GriddingAlgorithm::printClassData" ref="03626fddf498bb5d5d2a4049f5bf80f2" args="(std::ostream &amp;os) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::mesh::GriddingAlgorithm::printClassData           </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&nbsp;</td>
          <td class="paramname"> <em>os</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Print all data members of the class instance to given output stream. 
<p>

</div>
</div><p>
<a class="anchor" name="f6f04d9480fc40e6c74e429c52c8e185"></a><!-- doxytag: member="SAMRAI::mesh::GriddingAlgorithm::putToRestart" ref="f6f04d9480fc40e6c74e429c52c8e185" args="(const boost::shared_ptr&lt; tbox::Database &gt; &amp;restart_db) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::mesh::GriddingAlgorithm::putToRestart           </td>
          <td>(</td>
          <td class="paramtype">const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Database.html">tbox::Database</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>restart_db</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Write object state out to the given restart database. 
<p>
<dl compact><dt><b>Precondition:</b></dt><dd>restart_db </dd></dl>

</div>
</div><p>
<a class="anchor" name="2ee22b4801e5f37e63447dc7490bf8e0"></a><!-- doxytag: member="SAMRAI::mesh::GriddingAlgorithm::printStatistics" ref="2ee22b4801e5f37e63447dc7490bf8e0" args="(std::ostream &amp;s=tbox::plog) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::mesh::GriddingAlgorithm::printStatistics           </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&nbsp;</td>
          <td class="paramname"> <em>s</em> = <code><a class="el" href="namespaceSAMRAI_1_1tbox.html#b84041705493761fb17a8127e3a2dca2">tbox::plog</a></code>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="2ae592faf8f7a149ef42970ad83076f3"></a><!-- doxytag: member="SAMRAI::mesh::GriddingAlgorithm::getObjectName" ref="2ae592faf8f7a149ef42970ad83076f3" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::string&amp; SAMRAI::mesh::GriddingAlgorithm::getObjectName           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the name of this object. 
<p>

</div>
</div><p>
<hr>The documentation for this class was generated from the following files:<ul>
<li>source/SAMRAI/mesh/<a class="el" href="GriddingAlgorithm_8h.html">GriddingAlgorithm.h</a><li>source/SAMRAI/mesh/<a class="el" href="GriddingAlgorithm_8C.html">GriddingAlgorithm.C</a></ul>
<hr size="1"><address style="align: right;"><small>Generated on 3 Mar 2015 for SAMRAI by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.7 </small></address>
</body>
</html>
