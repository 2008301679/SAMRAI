<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>SAMRAI: SAMRAI::hier::CoarseFineBoundary Class Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.7 -->
<div class="tabs">
  <ul>
    <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="namespaces.html"><span>Namespaces</span></a></li>
    <li id="current"><a href="annotated.html"><span>Classes</span></a></li>
    <li><a href="files.html"><span>Files</span></a></li>
    <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
  </ul></div>
<div class="tabs">
  <ul>
    <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
    <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
    <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
  </ul></div>
<div class="nav">
<a class="el" href="namespaceSAMRAI.html">SAMRAI</a>::<a class="el" href="namespaceSAMRAI_1_1hier.html">hier</a>::<a class="el" href="classSAMRAI_1_1hier_1_1CoarseFineBoundary.html">CoarseFineBoundary</a></div>
<h1>SAMRAI::hier::CoarseFineBoundary Class Reference</h1><!-- doxytag: class="SAMRAI::hier::CoarseFineBoundary" -->Utility class to construct and maintain a description of the coarse-fine boundary between a patch level and a coarser level.  
<a href="#_details">More...</a>
<p>
<code>#include &lt;source/SAMRAI/hier/CoarseFineBoundary.h&gt;</code>
<p>
<a href="classSAMRAI_1_1hier_1_1CoarseFineBoundary-members.html">List of all members.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1CoarseFineBoundary.html#64ec8f8a525a851feb62368c3a31076d">CoarseFineBoundary</a> (const <a class="el" href="classSAMRAI_1_1tbox_1_1Dimension.html">tbox::Dimension</a> &amp;dim)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Construct a <a class="el" href="classSAMRAI_1_1hier_1_1CoarseFineBoundary.html">CoarseFineBoundary</a> object with no boundary boxes.  <a href="#64ec8f8a525a851feb62368c3a31076d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1CoarseFineBoundary.html#499a50729ada5aca3863fad043933f8e">CoarseFineBoundary</a> (const <a class="el" href="classSAMRAI_1_1hier_1_1CoarseFineBoundary.html">CoarseFineBoundary</a> &amp;rhs)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copy constructor.  <a href="#499a50729ada5aca3863fad043933f8e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1CoarseFineBoundary.html#370e0175daecdf9aca947d162a36ac0e">CoarseFineBoundary</a> (const <a class="el" href="classSAMRAI_1_1hier_1_1PatchHierarchy.html">PatchHierarchy</a> &amp;hierarchy, int level_num, const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;max_ghost_width)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Construct a <a class="el" href="classSAMRAI_1_1hier_1_1CoarseFineBoundary.html">CoarseFineBoundary</a> object for the specified level in the given patch hierarchy.  <a href="#370e0175daecdf9aca947d162a36ac0e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1CoarseFineBoundary.html#03951fdf0602f1c8d2dfaacfb083092e">CoarseFineBoundary</a> (const <a class="el" href="classSAMRAI_1_1hier_1_1PatchLevel.html">PatchLevel</a> &amp;level, const <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">Connector</a> &amp;box_level_to_domain, const <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">Connector</a> &amp;box_level_to_self, const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;max_ghost_width)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Construct a <a class="el" href="classSAMRAI_1_1hier_1_1CoarseFineBoundary.html">CoarseFineBoundary</a> object for a specified level.  <a href="#03951fdf0602f1c8d2dfaacfb083092e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1CoarseFineBoundary.html#1e3bd6c01c6b0b93aecd4845b63f4afb">~CoarseFineBoundary</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Destructor.  <a href="#1e3bd6c01c6b0b93aecd4845b63f4afb"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1CoarseFineBoundary.html#70a60c3ede90030bb5e1615d410ed553">clear</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Clear all boundary data.  <a href="#70a60c3ede90030bb5e1615d410ed553"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1CoarseFineBoundary.html#00e2c57b202a5ee5cffa408971a81af7">printClassData</a> (std::ostream &amp;os) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Print out class data.  <a href="#00e2c57b202a5ee5cffa408971a81af7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classSAMRAI_1_1hier_1_1CoarseFineBoundary.html">CoarseFineBoundary</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1CoarseFineBoundary.html#841e2fe908f9a4bc0d4c6247bb23ecf3">operator=</a> (const <a class="el" href="classSAMRAI_1_1hier_1_1CoarseFineBoundary.html">CoarseFineBoundary</a> &amp;rhs)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Assignment operator.  <a href="#841e2fe908f9a4bc0d4c6247bb23ecf3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">const <a class="el" href="classSAMRAI_1_1tbox_1_1Dimension.html">tbox::Dimension</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1CoarseFineBoundary.html#8a59ca51277f4b6fbf122b3feb39429c">getDim</a> () const </td></tr>

<tr><td colspan="2"><div class="groupHeader">Functions to get the computed coarse-fine boundaries.</div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">const std::vector&lt; <a class="el" href="classSAMRAI_1_1hier_1_1BoundaryBox.html">BoundaryBox</a> &gt; &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1CoarseFineBoundary.html#2d13d1fff050eea163d9bd0bc1c58d98">getBoundaries</a> (const <a class="el" href="classSAMRAI_1_1hier_1_1GlobalId.html">GlobalId</a> &amp;global_id, const int boundary_type, const <a class="el" href="classSAMRAI_1_1hier_1_1BlockId.html">BlockId</a> &amp;block_id=BlockId::zero()) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get a vector of boundary boxes of a given type for a specified patch.  <a href="#2d13d1fff050eea163d9bd0bc1c58d98"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">const std::vector&lt; <a class="el" href="classSAMRAI_1_1hier_1_1BoundaryBox.html">BoundaryBox</a> &gt; &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1CoarseFineBoundary.html#c504a7390c75d900e7271489f5a735b3">getNodeBoundaries</a> (const <a class="el" href="classSAMRAI_1_1hier_1_1GlobalId.html">GlobalId</a> &amp;global_id, const <a class="el" href="classSAMRAI_1_1hier_1_1BlockId.html">BlockId</a> &amp;block_id=BlockId::zero()) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get a vector of node boundary boxes for a specified patch.  <a href="#c504a7390c75d900e7271489f5a735b3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">const std::vector&lt; <a class="el" href="classSAMRAI_1_1hier_1_1BoundaryBox.html">BoundaryBox</a> &gt; &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1CoarseFineBoundary.html#0624bc8c8168f040de52c9eb993e9f19">getEdgeBoundaries</a> (const <a class="el" href="classSAMRAI_1_1hier_1_1GlobalId.html">GlobalId</a> &amp;global_id, const <a class="el" href="classSAMRAI_1_1hier_1_1BlockId.html">BlockId</a> &amp;block_id=BlockId::zero()) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get a vector of edge boundary boxes for a specified patch.  <a href="#0624bc8c8168f040de52c9eb993e9f19"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">const std::vector&lt; <a class="el" href="classSAMRAI_1_1hier_1_1BoundaryBox.html">BoundaryBox</a> &gt; &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1hier_1_1CoarseFineBoundary.html#a79efbf52f36ff4f5e34cac36e34bed1">getFaceBoundaries</a> (const <a class="el" href="classSAMRAI_1_1hier_1_1GlobalId.html">GlobalId</a> &amp;global_id, const <a class="el" href="classSAMRAI_1_1hier_1_1BlockId.html">BlockId</a> &amp;block_id=BlockId::zero()) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get a vector of face boundary boxes for a specified patch.  <a href="#a79efbf52f36ff4f5e34cac36e34bed1"></a><br></td></tr>
</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
Utility class to construct and maintain a description of the coarse-fine boundary between a patch level and a coarser level. 
<p>
A coarse-fine boundary box is a <a class="el" href="classSAMRAI_1_1hier_1_1BoundaryBox.html">BoundaryBox</a> object, but it is generated differently than a typical boundary box maintained by a patch geometry object. A boundary box serving as a coarse-fine boundary box describes part of the boundary of a given patch with its next coarser AMR hierarchy level. It does not intersect any other patch on the same level, nor does it lie on a physical domain boundary, except where the physical boundary is periodic and the appropriate continuation of that boundary is part of a coarser patch level.<p>
The coarse-fine boundary is typically created from two adjacent hierarchy levels, but the description lives on (refers to the index space of) the finer level. Since the coarse-fine boundary describes the boundary to the next coarser level, the coarsest level (level zero) has no coarse-fine boundary.<p>
Each <a class="el" href="classSAMRAI_1_1hier_1_1CoarseFineBoundary.html">CoarseFineBoundary</a> object corresponds to one level, so to represent a entire hierarchy, one would need an array or list of such objects. 
<p>
<hr><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" name="64ec8f8a525a851feb62368c3a31076d"></a><!-- doxytag: member="SAMRAI::hier::CoarseFineBoundary::CoarseFineBoundary" ref="64ec8f8a525a851feb62368c3a31076d" args="(const tbox::Dimension &amp;dim)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SAMRAI::hier::CoarseFineBoundary::CoarseFineBoundary           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1tbox_1_1Dimension.html">tbox::Dimension</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>dim</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Construct a <a class="el" href="classSAMRAI_1_1hier_1_1CoarseFineBoundary.html">CoarseFineBoundary</a> object with no boundary boxes. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>dim</em>&nbsp;</td><td>Dimension </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="499a50729ada5aca3863fad043933f8e"></a><!-- doxytag: member="SAMRAI::hier::CoarseFineBoundary::CoarseFineBoundary" ref="499a50729ada5aca3863fad043933f8e" args="(const CoarseFineBoundary &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SAMRAI::hier::CoarseFineBoundary::CoarseFineBoundary           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1CoarseFineBoundary.html">CoarseFineBoundary</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Copy constructor. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>rhs</em>&nbsp;</td><td></td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="370e0175daecdf9aca947d162a36ac0e"></a><!-- doxytag: member="SAMRAI::hier::CoarseFineBoundary::CoarseFineBoundary" ref="370e0175daecdf9aca947d162a36ac0e" args="(const PatchHierarchy &amp;hierarchy, int level_num, const IntVector &amp;max_ghost_width)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SAMRAI::hier::CoarseFineBoundary::CoarseFineBoundary           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1PatchHierarchy.html">PatchHierarchy</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>hierarchy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>level_num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>max_ghost_width</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Construct a <a class="el" href="classSAMRAI_1_1hier_1_1CoarseFineBoundary.html">CoarseFineBoundary</a> object for the specified level in the given patch hierarchy. 
<p>
<dl compact><dt><b>Note:</b></dt><dd>If level number is zero, the coarse-fine boundary will be empty.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>hierarchy</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>level_num</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>max_ghost_width</em>&nbsp;</td><td>The ghost width determines the extent of the boundary boxes along the level domain boundary, similar to regular domain boundary boxes. Note that as in the case of regular boundary boxes, each box will always be one cell wide in the direction perpendicular to the patch boundary.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Precondition:</b></dt><dd>max_ghost_width &gt; <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a>(max_ghost_width.getDim(), -1) </dd></dl>

</div>
</div><p>
<a class="anchor" name="03951fdf0602f1c8d2dfaacfb083092e"></a><!-- doxytag: member="SAMRAI::hier::CoarseFineBoundary::CoarseFineBoundary" ref="03951fdf0602f1c8d2dfaacfb083092e" args="(const PatchLevel &amp;level, const Connector &amp;box_level_to_domain, const Connector &amp;box_level_to_self, const IntVector &amp;max_ghost_width)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SAMRAI::hier::CoarseFineBoundary::CoarseFineBoundary           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1PatchLevel.html">PatchLevel</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">Connector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>box_level_to_domain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">Connector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>box_level_to_self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>max_ghost_width</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Construct a <a class="el" href="classSAMRAI_1_1hier_1_1CoarseFineBoundary.html">CoarseFineBoundary</a> object for a specified level. 
<p>
The coarse-fine boundary will be computed using the physical domain as the reference coarser level. The physical domain is provided to this method as the 'head' level of the box_level_to_domain <a class="el" href="classSAMRAI_1_1hier_1_1Connector.html">Connector</a>.<p>
<dl compact><dt><b>Note:</b></dt><dd>If the level covers the entire physical domain, the coarse-fine boundary will be empty.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>level</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>box_level_to_domain</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>box_level_to_self</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>max_ghost_width</em>&nbsp;</td><td>The ghost width determines the extent of the boundary boxes along the level domain boundary, similar to regular domain boundary boxes. Note that as in the case of regular boundary boxes, each box will always be one cell wide in the direction perpendicular to the patch boundary.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Precondition:</b></dt><dd>max_ghost_width &gt; <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a>(max_ghost_width.getDim(), -1) </dd></dl>

</div>
</div><p>
<a class="anchor" name="1e3bd6c01c6b0b93aecd4845b63f4afb"></a><!-- doxytag: member="SAMRAI::hier::CoarseFineBoundary::~CoarseFineBoundary" ref="1e3bd6c01c6b0b93aecd4845b63f4afb" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SAMRAI::hier::CoarseFineBoundary::~CoarseFineBoundary           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Destructor. 
<p>

</div>
</div><p>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="70a60c3ede90030bb5e1615d410ed553"></a><!-- doxytag: member="SAMRAI::hier::CoarseFineBoundary::clear" ref="70a60c3ede90030bb5e1615d410ed553" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::hier::CoarseFineBoundary::clear           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Clear all boundary data. 
<p>

</div>
</div><p>
<a class="anchor" name="2d13d1fff050eea163d9bd0bc1c58d98"></a><!-- doxytag: member="SAMRAI::hier::CoarseFineBoundary::getBoundaries" ref="2d13d1fff050eea163d9bd0bc1c58d98" args="(const GlobalId &amp;global_id, const int boundary_type, const BlockId &amp;block_id=BlockId::zero()) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt; <a class="el" href="classSAMRAI_1_1hier_1_1BoundaryBox.html">BoundaryBox</a> &gt; &amp; SAMRAI::hier::CoarseFineBoundary::getBoundaries           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1GlobalId.html">GlobalId</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>global_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>boundary_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1BlockId.html">BlockId</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>block_id</em> = <code>BlockId::zero()</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get a vector of boundary boxes of a given type for a specified patch. 
<p>
The specified patch must exist in the level used to compute the internal state or it is an error.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>global_id</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>boundary_type</em>&nbsp;</td><td>Codimension of boundaries. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>block_id</em>&nbsp;</td><td>Defaults to 0 for the single block case</td></tr>
  </table>
</dl>
<dl compact><dt><b>Precondition:</b></dt><dd>d_initialize[block_id.getBlockValue()] </dd></dl>

</div>
</div><p>
<a class="anchor" name="c504a7390c75d900e7271489f5a735b3"></a><!-- doxytag: member="SAMRAI::hier::CoarseFineBoundary::getNodeBoundaries" ref="c504a7390c75d900e7271489f5a735b3" args="(const GlobalId &amp;global_id, const BlockId &amp;block_id=BlockId::zero()) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;<a class="el" href="classSAMRAI_1_1hier_1_1BoundaryBox.html">BoundaryBox</a>&gt;&amp; SAMRAI::hier::CoarseFineBoundary::getNodeBoundaries           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1GlobalId.html">GlobalId</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>global_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1BlockId.html">BlockId</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>block_id</em> = <code>BlockId::zero()</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get a vector of node boundary boxes for a specified patch. 
<p>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classSAMRAI_1_1hier_1_1BoundaryBox.html">BoundaryBox</a> for more information.</dd></dl>
The specified patch must exist in the level used to compute the internal state or it is an error.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>global_id</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>block_id</em>&nbsp;</td><td>Defaults to 0 for the single block case </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="0624bc8c8168f040de52c9eb993e9f19"></a><!-- doxytag: member="SAMRAI::hier::CoarseFineBoundary::getEdgeBoundaries" ref="0624bc8c8168f040de52c9eb993e9f19" args="(const GlobalId &amp;global_id, const BlockId &amp;block_id=BlockId::zero()) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;<a class="el" href="classSAMRAI_1_1hier_1_1BoundaryBox.html">BoundaryBox</a>&gt;&amp; SAMRAI::hier::CoarseFineBoundary::getEdgeBoundaries           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1GlobalId.html">GlobalId</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>global_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1BlockId.html">BlockId</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>block_id</em> = <code>BlockId::zero()</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get a vector of edge boundary boxes for a specified patch. 
<p>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classSAMRAI_1_1hier_1_1BoundaryBox.html">hier::BoundaryBox</a> for more information.</dd></dl>
Note that edge boxes are only meaningful if the dimension is &gt; 1. The specified patch must exist in the level used to compute the internal state or it is an error.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>global_id</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>block_id</em>&nbsp;</td><td>Defaults to 0 for the single block case</td></tr>
  </table>
</dl>
<dl compact><dt><b>Precondition:</b></dt><dd><a class="el" href="classSAMRAI_1_1hier_1_1CoarseFineBoundary.html#8a59ca51277f4b6fbf122b3feb39429c">getDim()</a>.getValue() &gt;= 2 </dd></dl>

</div>
</div><p>
<a class="anchor" name="a79efbf52f36ff4f5e34cac36e34bed1"></a><!-- doxytag: member="SAMRAI::hier::CoarseFineBoundary::getFaceBoundaries" ref="a79efbf52f36ff4f5e34cac36e34bed1" args="(const GlobalId &amp;global_id, const BlockId &amp;block_id=BlockId::zero()) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;<a class="el" href="classSAMRAI_1_1hier_1_1BoundaryBox.html">BoundaryBox</a>&gt;&amp; SAMRAI::hier::CoarseFineBoundary::getFaceBoundaries           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1GlobalId.html">GlobalId</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>global_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1BlockId.html">BlockId</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>block_id</em> = <code>BlockId::zero()</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get a vector of face boundary boxes for a specified patch. 
<p>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classSAMRAI_1_1hier_1_1BoundaryBox.html">hier::BoundaryBox</a> for more information.</dd></dl>
Note that face boxes are only meaningful if the dimension is &gt; 2. The specified patch must exist in the level used to compute the internal state or it is an error.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>global_id</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>block_id</em>&nbsp;</td><td>Defaults to 0 for the single block case</td></tr>
  </table>
</dl>
<dl compact><dt><b>Precondition:</b></dt><dd><a class="el" href="classSAMRAI_1_1hier_1_1CoarseFineBoundary.html#8a59ca51277f4b6fbf122b3feb39429c">getDim()</a>.getValue() &gt;= 3 </dd></dl>

</div>
</div><p>
<a class="anchor" name="00e2c57b202a5ee5cffa408971a81af7"></a><!-- doxytag: member="SAMRAI::hier::CoarseFineBoundary::printClassData" ref="00e2c57b202a5ee5cffa408971a81af7" args="(std::ostream &amp;os) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::hier::CoarseFineBoundary::printClassData           </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&nbsp;</td>
          <td class="paramname"> <em>os</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Print out class data. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>os</em>&nbsp;</td><td>Output stream </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="841e2fe908f9a4bc0d4c6247bb23ecf3"></a><!-- doxytag: member="SAMRAI::hier::CoarseFineBoundary::operator=" ref="841e2fe908f9a4bc0d4c6247bb23ecf3" args="(const CoarseFineBoundary &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSAMRAI_1_1hier_1_1CoarseFineBoundary.html">CoarseFineBoundary</a>&amp; SAMRAI::hier::CoarseFineBoundary::operator=           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1CoarseFineBoundary.html">CoarseFineBoundary</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Assignment operator. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>rhs</em>&nbsp;</td><td></td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="8a59ca51277f4b6fbf122b3feb39429c"></a><!-- doxytag: member="SAMRAI::hier::CoarseFineBoundary::getDim" ref="8a59ca51277f4b6fbf122b3feb39429c" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classSAMRAI_1_1tbox_1_1Dimension.html">tbox::Dimension</a>&amp; SAMRAI::hier::CoarseFineBoundary::getDim           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<hr>The documentation for this class was generated from the following files:<ul>
<li>source/SAMRAI/hier/<a class="el" href="CoarseFineBoundary_8h.html">CoarseFineBoundary.h</a><li>source/SAMRAI/hier/<a class="el" href="CoarseFineBoundary_8C.html">CoarseFineBoundary.C</a></ul>
<hr size="1"><address style="align: right;"><small>Generated on 5 Jul 2013 for SAMRAI by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.7 </small></address>
</body>
</html>
