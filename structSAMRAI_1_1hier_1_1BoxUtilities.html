<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>SAMRAI: SAMRAI::hier::BoxUtilities Struct Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.7 -->
<div class="tabs">
  <ul>
    <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="namespaces.html"><span>Namespaces</span></a></li>
    <li id="current"><a href="annotated.html"><span>Classes</span></a></li>
    <li><a href="files.html"><span>Files</span></a></li>
    <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
  </ul></div>
<div class="tabs">
  <ul>
    <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
    <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
    <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
  </ul></div>
<div class="nav">
<a class="el" href="namespaceSAMRAI.html">SAMRAI</a>::<a class="el" href="namespaceSAMRAI_1_1hier.html">hier</a>::<a class="el" href="structSAMRAI_1_1hier_1_1BoxUtilities.html">BoxUtilities</a></div>
<h1>SAMRAI::hier::BoxUtilities Struct Reference</h1><!-- doxytag: class="SAMRAI::hier::BoxUtilities" --><code>#include &lt;source/SAMRAI/hier/BoxUtilities.h&gt;</code>
<p>
<a href="structSAMRAI_1_1hier_1_1BoxUtilities-members.html">List of all members.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Static Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSAMRAI_1_1hier_1_1BoxUtilities.html#a76f0f0bd9a88a66ec4350c9a8f3ba98">checkBoxConstraints</a> (const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> &amp;box, const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;min_size, const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;cut_factor, const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;bad_interval, const <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a> &amp;physical_boxes)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSAMRAI_1_1hier_1_1BoxUtilities.html#b848873ced363a81d1084ba8f6b02a56">chopBoxes</a> (<a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a> &amp;boxes, const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;max_size, const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;min_size, const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;cut_factor, const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;bad_interval, const <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a> &amp;physical_boxes)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSAMRAI_1_1hier_1_1BoxUtilities.html#51989ccd450e995070b8f0b5b07e3b3c">chopBox</a> (<a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a> &amp;boxes, const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> &amp;box, const <a class="el" href="classSAMRAI_1_1tbox_1_1Array.html">tbox::Array</a>&lt; std::list&lt; int &gt; &gt; cut_points)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">static bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSAMRAI_1_1hier_1_1BoxUtilities.html#b167369ff453a5d125d54ca9d2a4fe02">extendBoxToDomainBoundary</a> (<a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> &amp;box, const <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a> &amp;domain, const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;ext_ghosts)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">static bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSAMRAI_1_1hier_1_1BoxUtilities.html#1687f6c14ffeeeb81858fda7b4662af0">extendBoxesToDomainBoundary</a> (<a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a> &amp;boxes, const <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a> &amp;domain, const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;ext_ghosts)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSAMRAI_1_1hier_1_1BoxUtilities.html#e4f7d512e71d582b67a9412790a55be1">growBoxesWithinDomain</a> (<a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a> &amp;boxes, const <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a> &amp;domain, const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;min_size)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSAMRAI_1_1hier_1_1BoxUtilities.html#92ad807482ac35ef806cd543a75fa174">growBoxWithinDomain</a> (<a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> &amp;box, const <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a> &amp;local_domain_complement, const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;min_size)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">static bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSAMRAI_1_1hier_1_1BoxUtilities.html#fa2dea7ba976d93efb62312ad698a3eb">findBestCutPointsGivenMax</a> (<a class="el" href="classSAMRAI_1_1tbox_1_1Array.html">tbox::Array</a>&lt; std::list&lt; int &gt; &gt; &amp;cut_points, const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> &amp;box, const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;max_size, const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;min_size, const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;cut_factor)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">static bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSAMRAI_1_1hier_1_1BoxUtilities.html#ba05a88e39b9d1658eaf0d19892e9a70">findBestCutPointsForDirectionGivenMax</a> (const int idir, std::list&lt; int &gt; &amp;cut_points, const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> &amp;box, const int max_size, const int min_size, const int cut_factor)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">static bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSAMRAI_1_1hier_1_1BoxUtilities.html#cc96ccb6fd2ab2acc44c31514ae6d924">findBestCutPointsGivenNumber</a> (<a class="el" href="classSAMRAI_1_1tbox_1_1Array.html">tbox::Array</a>&lt; std::list&lt; int &gt; &gt; &amp;cut_points, const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> &amp;box, const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;number_boxes, const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;min_size, const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;cut_factor)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">static bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSAMRAI_1_1hier_1_1BoxUtilities.html#ea3e85c240385f070989b7ba4e229d4e">findBestCutPointsForDirectionGivenNumber</a> (const int idir, std::list&lt; int &gt; &amp;cut_points, const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> &amp;box, const int num_boxes, const int min_size, const int cut_factor)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">static bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSAMRAI_1_1hier_1_1BoxUtilities.html#6cd08d6fa42d299adfc23ee36dfdb3f9">checkBoxForBadCutPoints</a> (<a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;bad_cut_information, const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> &amp;box, const <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a> &amp;physical_boxes, const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;bad_interval)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">static bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSAMRAI_1_1hier_1_1BoxUtilities.html#5cc81d2c29e441b4b0a1200583197977">checkBoxForBadCutPointsInDirection</a> (const int dir, const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> &amp;box, const <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a> &amp;physical_boxes, const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;bad_interval)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSAMRAI_1_1hier_1_1BoxUtilities.html#38b85860bc7e0f0568178082f8de6a69">findBadCutPoints</a> (<a class="el" href="classSAMRAI_1_1tbox_1_1Array.html">tbox::Array</a>&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Array.html">tbox::Array</a>&lt; bool &gt; &gt; &amp;bad_cuts, const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> &amp;box, const <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a> &amp;physical_boxes, const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;bad_interval)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSAMRAI_1_1hier_1_1BoxUtilities.html#9ab86664ba277fda3ba47a2fc1f09672">findBadCutPointsForDirection</a> (const int dir, <a class="el" href="classSAMRAI_1_1tbox_1_1Array.html">tbox::Array</a>&lt; bool &gt; &amp;bad_cuts, const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> &amp;box, const <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a> &amp;physical_boxes, const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;bad_interval)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSAMRAI_1_1hier_1_1BoxUtilities.html#e35adbda2f14aa683ebb314ce81dedab">fixBadCutPoints</a> (<a class="el" href="classSAMRAI_1_1tbox_1_1Array.html">tbox::Array</a>&lt; std::list&lt; int &gt; &gt; &amp;cuts, const <a class="el" href="classSAMRAI_1_1tbox_1_1Array.html">tbox::Array</a>&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Array.html">tbox::Array</a>&lt; bool &gt; &gt; &amp;bad_cuts, const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> &amp;box, const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;min_size, const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;cut_factor)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSAMRAI_1_1hier_1_1BoxUtilities.html#ec153e1e291c2f1dd0e8bf7623d2479f">fixBadCutPointsForDirection</a> (const int dir, std::list&lt; int &gt; &amp;cuts, const <a class="el" href="classSAMRAI_1_1tbox_1_1Array.html">tbox::Array</a>&lt; bool &gt; &amp;bad_cuts, const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> &amp;box, const int min_size, const int cut_factor)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSAMRAI_1_1hier_1_1BoxUtilities.html#906fce06a805709264e79a62ed13485e">findBadCutPointsForBorderAndDirection</a> (const int id, <a class="el" href="classSAMRAI_1_1tbox_1_1Array.html">tbox::Array</a>&lt; bool &gt; &amp;bad_cuts, const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> &amp;box, const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> &amp;border, const int bad_interval)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSAMRAI_1_1hier_1_1BoxUtilities.html#aae13268acca044c3e64176a924d3933">makeNonOverlappingBoxContainers</a> (<a class="el" href="classSAMRAI_1_1tbox_1_1Array.html">tbox::Array</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a> &gt; &amp;box_list_array, const <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a> &amp;boxes)</td></tr>

</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
Class <a class="el" href="structSAMRAI_1_1hier_1_1BoxUtilities.html">BoxUtilities</a> provides several utility routines for processing boxes or collections of boxes. Many of these operations require information about the location of the input boxes within some region of index space (domain) or are used to compute this sort of information. Often these routines are used in load balancing and communication routines to determine the relationship of a box or set of boxes to some domain boundary, where the domain is specified by a list of box regions.<p>
The following provides an explanation some of the concepts common to many of the functions in this class.<p>
<ul>
<li><b>cut</b> point</li></ul>
<p>
A cut point for a coordinate direction is an integer that specifies the index value of the cell immediately to the right of the boundary along which a box will be cut. For instance, if we have a cut point value of 12 in the y-coordinate direction for box [(0,0,0), (5,15,10)], then the box will be cut into [(0,0,0),(5,11,10)] and [(0,12,0),(5,15,10)]. That is, the box has been cut along the boundary between the y = 11 and y = 12 cells.<p>
<ul>
<li><b>bad</b> cut point If a box is cut at a "bad cut point", the resulting boxes will violate some of the box constraints. For example, a cut point that does not satify the cut factor restriction or violates the bad_interval constraint (see below) is a bad cut point.</li></ul>
<p>
<ul>
<li><b>irregular</b> boundary An irregular boundary results when the domain cannot be described by a single box and the domain is non-convex.</li></ul>
<p>
The following provides an explanation some of the arguments common to many of the functions in this class.<p>
<ul>
<li><b>min_size</b> min_size is a <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> that specifies the minimum allowable box length in each direction. For example, if min_size = (10,4,15), then the minimum box length in the x, y, and z directions are 10, 4, and 15 respectively.</li></ul>
<p>
<ul>
<li><b>max_size</b> max_size is a <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> that specifies the maximum allowable box length in each direction. For example, if max_size = (10,40,50), then the maximum box length in the x, y, and z directions are 10, 40, and 50 respectively.</li></ul>
<p>
It should be noted that the max_size constraint has lower priority than the other constraints. In instances where all constraints cannot be simultaneously satisfied, the max_size constraint is sacrificed.<p>
<ul>
<li><b>cut_factor</b> cut_factor is a <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> that constrains the size of a box to be multiples of the components of the cut_factor. For instance, if cut_factor = (2,4,5), then the x, y, and z directions of a 8 box that satisfies the cut_factor constraint would be multiples of 2, 4, and 5 respectively.</li></ul>
<p>
This constraint is usually enforced with the cut_factor equal to a multiple of the refinement ratio between levels to ensure that if the box is coarsened, the resulting box is aligned with the coarse grid (it is assumed that the boundary of the fine box is aligned with a coarse cell boundary).<p>
<ul>
<li><b>bad_interval</b> bad_interval is a <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> that limits the distance a box can be from the boundary of the box list domain so that the outer boundaries of the box and the box list domain which are perpendicular to the i-th direction are no closer than the i-th component of bad_interval. Another way to think of this is that the boundary of the box list domain in the i-th direction is not allowed to lie strictly within the interior of the box after it has been grown in the i-th direction by the i-th component of bad_interval. For example, if bad_interval = (2,3,4), then the x, y, and z boundaries of the box must be at least 2, 3, and 4 cells away from the x, y, and z boundaries of the box list domain.</li></ul>
<p>
The bad_interval constraint is enforced to avoid the situation where the ghost region for a box resides partially inside and partially outside the box list domain which complicates ghost cell filling. In addition, this constraint avoids complicated issues with respect to the numerical accuracy of the solution.<p>
Typically, bad_interval is based on the maximum ghost cell width over all patch data objects and some coarsen ratio.<p>
Note that all member functions of this class are static. The main intent of the class is to group the functions into one name space. Thus, you should never attempt to instantiate a class of type <a class="el" href="structSAMRAI_1_1hier_1_1BoxUtilities.html">BoxUtilities</a>; simply call the functions as static functions; e.g., BoxUtilities::function(...). These routines are placed here rather than in the box, box list, box array classes to avoid circular dependencies among these classes.<p>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classSAMRAI_1_1hier_1_1Box.html">hier::Box</a> <p>
<a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">hier::BoxContainer</a> </dd></dl>

<p>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="a76f0f0bd9a88a66ec4350c9a8f3ba98"></a><!-- doxytag: member="SAMRAI::hier::BoxUtilities::checkBoxConstraints" ref="a76f0f0bd9a88a66ec4350c9a8f3ba98" args="(const Box &amp;box, const IntVector &amp;min_size, const IntVector &amp;cut_factor, const IntVector &amp;bad_interval, const BoxContainer &amp;physical_boxes)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::hier::BoxUtilities::checkBoxConstraints           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>box</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>min_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>cut_factor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>bad_interval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>physical_boxes</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Check the given box for violation of minimum size, cut factor, and box list domain constraints. If a patch is generated from a box that violates any of these constraints, then some other routine (e.g., ghost cell filling, or inter-patch communication) may fail. Thus, this routine prints an error message describing the violation and executes a program abort.<p>
Arguments:<p>
<ul>
<li><b>box</b> (input) box whose constraints are to be checked</li></ul>
<p>
<ul>
<li><b>min_size</b> (input) minimum allowed box size. See class header for further description.</li></ul>
<p>
<ul>
<li><b>cut_factor</b> (input) See class header for description.</li></ul>
<p>
<ul>
<li><b>bad_interval</b> (input) See class header for description.</li></ul>
<p>
If there is no constraint on the box location within the box list domain, pass in an empty box array for the physical_boxes argument.<p>
<ul>
<li><b>physical_boxes</b> (input) box array representing the index space of box list domain</li></ul>
<p>
<dl compact><dt><b>Precondition:</b></dt><dd>(min_size.getDim() == cut_factor.getDim()) &amp;&amp; (min_size.getDim() == bad_interval.getDim()) <p>
min_size &gt; <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html#75075186e3ca2b549792b84f3f5dcb9b">IntVector::getZero</a>(min_size.getDim()) <p>
cut_factor &gt; <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html#75075186e3ca2b549792b84f3f5dcb9b">IntVector::getZero</a>(min_size.getDim()) <p>
bad_interval &gt;= <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html#75075186e3ca2b549792b84f3f5dcb9b">IntVector::getZero</a>(min_size.getDim()) </dd></dl>

</div>
</div><p>
<a class="anchor" name="b848873ced363a81d1084ba8f6b02a56"></a><!-- doxytag: member="SAMRAI::hier::BoxUtilities::chopBoxes" ref="b848873ced363a81d1084ba8f6b02a56" args="(BoxContainer &amp;boxes, const IntVector &amp;max_size, const IntVector &amp;min_size, const IntVector &amp;cut_factor, const IntVector &amp;bad_interval, const BoxContainer &amp;physical_boxes)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::hier::BoxUtilities::chopBoxes           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>boxes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>max_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>min_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>cut_factor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>bad_interval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>physical_boxes</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Replace each box in the list that is too large with a list of non- overlapping smaller boxes whose union covers the same region of index space as the original box.<p>
Arguments:<p>
<ul>
<li><b>boxes</b> (input) list of boxes to be chopped</li></ul>
<p>
<ul>
<li><b>max_size</b> (input) maximum allowed box size. See class header for further description.</li></ul>
<p>
<ul>
<li><b>min_size</b> (input) minimum allowed box size. See class header for further description.</li></ul>
<p>
<ul>
<li><b>cut_factor</b> (input) See class header for description.</li></ul>
<p>
<ul>
<li><b>bad_interval</b> (input) See class header for description.</li></ul>
<p>
<ul>
<li><b>physical_boxes</b> (input) box array representing the index space of box list domain</li></ul>
<p>
Notes:<p>
<ul>
<li>The resulting boxes will obey the minimum size and cut factor restrictions if the each of the original boxes does.</li></ul>
<p>
<ul>
<li>Any box with side length not equal to a multiple of the cut factor for that direction, will not be chopped along that direction.</li></ul>
<p>
<ul>
<li>The maximum size restriction may be sacrificed if the box cannot be chopped at appropriate points. However, this is generally the case only when the box is adjacent to the box list domain boundary and an irregular boundary configuration restricts the cut locations or if the maximum size is not a multiple of the cut factor.</li></ul>
<p>
<dl compact><dt><b>Precondition:</b></dt><dd>(max_size.getDim() == min_size.getDim()) &amp;&amp; (max_size.getDim() == cut_factor.getDim()) &amp;&amp; (max_size.getDim() == bad_interval.getDim()) <p>
min_size &gt; <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html#75075186e3ca2b549792b84f3f5dcb9b">IntVector::getZero</a>(min_size.getDim()) <p>
max_size &gt;= min_size <p>
cut_factor &gt; <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html#75075186e3ca2b549792b84f3f5dcb9b">IntVector::getZero</a>(min_size.getDim()) <p>
bad_interval &gt;= <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html#75075186e3ca2b549792b84f3f5dcb9b">IntVector::getZero</a>(min_size.getDim()) <p>
!physical_boxes.isEmpty() <p>
!boxes.isOrdered() </dd></dl>

</div>
</div><p>
<a class="anchor" name="51989ccd450e995070b8f0b5b07e3b3c"></a><!-- doxytag: member="SAMRAI::hier::BoxUtilities::chopBox" ref="51989ccd450e995070b8f0b5b07e3b3c" args="(BoxContainer &amp;boxes, const Box &amp;box, const tbox::Array&lt; std::list&lt; int &gt; &gt; cut_points)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::hier::BoxUtilities::chopBox           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>boxes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>box</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1tbox_1_1Array.html">tbox::Array</a>&lt; std::list&lt; int &gt; &gt;&nbsp;</td>
          <td class="paramname"> <em>cut_points</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Chop the box into a collection of boxes according to the collection of cut points specified along each coordinate direction. Cut points that do not reside within the range of box indices are ignored.<p>
Arguments:<p>
<ul>
<li><b>boxes</b> (output) list of boxes into which the "box" argument was chopped</li></ul>
<p>
<ul>
<li><b>box</b> (input) box which is to be chopped</li></ul>
<p>
<ul>
<li><b>cut_points</b> (input) cut_points is an array of integer lists, each of which indicates the indices where the box will be cut in one of the coordinate directions</li></ul>
<p>
Assertion checks:<p>
<ul>
<li>The cut points for each direction must be on the list in increasing order.</li></ul>
<p>
Notes:<p>
<ul>
<li>The "boxes" <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a> is cleared before any box operations are performed. Thus, any boxes on the list when the function is called will be lost.</li></ul>
<p>
<dl compact><dt><b>Precondition:</b></dt><dd>cut_points.getSize() == box.getDim().getValue() </dd></dl>

</div>
</div><p>
<a class="anchor" name="b167369ff453a5d125d54ca9d2a4fe02"></a><!-- doxytag: member="SAMRAI::hier::BoxUtilities::extendBoxToDomainBoundary" ref="b167369ff453a5d125d54ca9d2a4fe02" args="(Box &amp;box, const BoxContainer &amp;domain, const IntVector &amp;ext_ghosts)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SAMRAI::hier::BoxUtilities::extendBoxToDomainBoundary           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>box</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>domain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>ext_ghosts</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Extend the box in the list to domain boundary as needed so that the domain boundary does not intersect the ghost cell region around the box in an inappropriate manner. Intersections that are disallowed are those in which a portion of the domain boundary is parallel to a box face and lies strictly in the interior of the ghost cell box_level adjacent to that face. In other words, we eliminate ghost cell regions residing outside of a given domain and which are narrower than the specified ghost width. The boolean return value is true if the input box was extended to the boundary and thus is changed by the routine. Otherwise, the return value is false.<p>
See description of bad_interval in the class header comments for more details.<p>
Arguments:<p>
<ul>
<li><b>box</b> (input/ouput) box to be extended</li></ul>
<p>
<ul>
<li><b>domain</b> (input) some domain whose interior is the union of boxes in a list</li></ul>
<p>
<ul>
<li><b>ext_ghosts</b> (input) <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> that specifies the size of the desired ghost cell region</li></ul>
<p>
Notes:<p>
<ul>
<li>The ext_ghosts argument often corresponds to the bad_interval argument in many of the other functions in class.</li></ul>
<p>
<ul>
<li>This operation may produce overlap regions among boxes on the list.</li></ul>
<p>
<ul>
<li>There exist some bizarre domain configurations for which it is impossible to grow a box to the boundary and eliminate bad ghost region intersections. This routine will extend each box as far as it can, but will not remedy these degenerate situations in general.</li></ul>
<p>
<dl compact><dt><b>Precondition:</b></dt><dd>!domain.isEmpty() <p>
ext_ghosts &gt;= <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html#75075186e3ca2b549792b84f3f5dcb9b">IntVector::getZero</a>(ext_ghosts.getDim()) </dd></dl>

</div>
</div><p>
<a class="anchor" name="1687f6c14ffeeeb81858fda7b4662af0"></a><!-- doxytag: member="SAMRAI::hier::BoxUtilities::extendBoxesToDomainBoundary" ref="1687f6c14ffeeeb81858fda7b4662af0" args="(BoxContainer &amp;boxes, const BoxContainer &amp;domain, const IntVector &amp;ext_ghosts)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SAMRAI::hier::BoxUtilities::extendBoxesToDomainBoundary           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>boxes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>domain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>ext_ghosts</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Same function as <a class="el" href="structSAMRAI_1_1hier_1_1BoxUtilities.html#b167369ff453a5d125d54ca9d2a4fe02">extendBoxToDomainBoundary()</a> above except that it extends each box in a list of boxes to the domain boundary specified by the box list argument as needed. The boolean return value is true if any box in the input box list was extended to the boundary and thus is changed by the routine. Otherwise, the return value is false.<p>
<dl compact><dt><b>Precondition:</b></dt><dd>!domain.isEmpty() <p>
ext_ghosts &gt;= <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html#75075186e3ca2b549792b84f3f5dcb9b">IntVector::getZero</a>(ext_ghosts.getDim()) </dd></dl>

</div>
</div><p>
<a class="anchor" name="e4f7d512e71d582b67a9412790a55be1"></a><!-- doxytag: member="SAMRAI::hier::BoxUtilities::growBoxesWithinDomain" ref="e4f7d512e71d582b67a9412790a55be1" args="(BoxContainer &amp;boxes, const BoxContainer &amp;domain, const IntVector &amp;min_size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::hier::BoxUtilities::growBoxesWithinDomain           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>boxes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>domain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>min_size</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Grow each box in the list that is smaller than the specified minimum size.<p>
Arguments:<p>
<ul>
<li><b>boxes</b> (input/output) list of boxes to be grown to satisfy the min_size constraint</li></ul>
<p>
<ul>
<li><b>domain</b> (input) list of boxes whose union is some domain</li></ul>
<p>
<ul>
<li><b>min_size</b> (input) minimum allowed box size. See class header for further description.</li></ul>
<p>
Notes:<p>
<ul>
<li>Each box that is grown must remain within the union of the boxes of the given domain.</li></ul>
<p>
<ul>
<li>If the specified domain is an empty box list, then each box will be grown to be as large as the minimum size with no particular restrictions applied.</li></ul>
<p>
<ul>
<li>This operation may produce overlap regions among boxes on list</li></ul>
<p>
<ul>
<li>There exist some bizarre domain configurations for which it is impossible to grow a box sufficiently within the domain.</li></ul>
<p>
For instance if the domain is given by [(0,0),(2,10)], [(0,3),(1,4)], [(0,5),(10,10)] and the box is given by [(4,1),(6,2)] with a minimum size of (4,4), there is no way the box can be grown to the minimum size without have to "cross" the gap in the box list domain.<p>
This routine will grow each box as far as it can, but will not remedy these situations, generally.<p>
<dl compact><dt><b>Precondition:</b></dt><dd>min_size &gt; <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html#75075186e3ca2b549792b84f3f5dcb9b">IntVector::getZero</a>(min_size.getDim()) </dd></dl>

</div>
</div><p>
<a class="anchor" name="92ad807482ac35ef806cd543a75fa174"></a><!-- doxytag: member="SAMRAI::hier::BoxUtilities::growBoxWithinDomain" ref="92ad807482ac35ef806cd543a75fa174" args="(Box &amp;box, const BoxContainer &amp;local_domain_complement, const IntVector &amp;min_size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::hier::BoxUtilities::growBoxWithinDomain           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>box</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>local_domain_complement</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>min_size</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Similar to growBoxesWithinDomain but works on one box at a time and the domain is specified by the complement of local parts of the domain.<p>
<dl compact><dt><b>Precondition:</b></dt><dd>min_size &gt; <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html#75075186e3ca2b549792b84f3f5dcb9b">IntVector::getZero</a>(min_size.getDim()) </dd></dl>

</div>
</div><p>
<a class="anchor" name="fa2dea7ba976d93efb62312ad698a3eb"></a><!-- doxytag: member="SAMRAI::hier::BoxUtilities::findBestCutPointsGivenMax" ref="fa2dea7ba976d93efb62312ad698a3eb" args="(tbox::Array&lt; std::list&lt; int &gt; &gt; &amp;cut_points, const Box &amp;box, const IntVector &amp;max_size, const IntVector &amp;min_size, const IntVector &amp;cut_factor)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SAMRAI::hier::BoxUtilities::findBestCutPointsGivenMax           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1tbox_1_1Array.html">tbox::Array</a>&lt; std::list&lt; int &gt; &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>cut_points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>box</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>max_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>min_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>cut_factor</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Determine whether the box may be chopped according to specified min_size, max_size and cut_factor constraints. For those directions along which the box may be chopped, the cut points are computed. The cut points for the j-th coordinate direction are placed into a list of integers corresponding to the j-th component of the cut_point array.<p>
Return value:<p>
<ul>
<li>true is returned if the box may be chopped along any coordinate direction. Otherwise, false is returned.</li></ul>
<p>
Arguments:<p>
<ul>
<li><b>cut_points</b> (output) array of list of cut points for the box</li></ul>
<p>
<ul>
<li><b>box</b> (input) box to be cut</li></ul>
<p>
<ul>
<li><b>max_size(input)</b> minimum allowed box size. See class header for further description.</li></ul>
<p>
<ul>
<li><b>min_size(input)</b> minimum allowed box size. See class header for further description.</li></ul>
<p>
<ul>
<li><b>cut_factor(input)</b> See class header for description.</li></ul>
<p>
<dl compact><dt><b>Precondition:</b></dt><dd>(max_size.getDim() == min_size.getDim()) &amp;&amp; (max_size.getDim() == cut_factor.getDim()) <p>
min_size &gt; <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html#75075186e3ca2b549792b84f3f5dcb9b">IntVector::getZero</a>(max_size.getDim()) <p>
min_size &lt;= max_size <p>
cut_factor &gt; <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html#75075186e3ca2b549792b84f3f5dcb9b">IntVector::getZero</a>(max_size.getDim()) </dd></dl>

</div>
</div><p>
<a class="anchor" name="ba05a88e39b9d1658eaf0d19892e9a70"></a><!-- doxytag: member="SAMRAI::hier::BoxUtilities::findBestCutPointsForDirectionGivenMax" ref="ba05a88e39b9d1658eaf0d19892e9a70" args="(const int idir, std::list&lt; int &gt; &amp;cut_points, const Box &amp;box, const int max_size, const int min_size, const int cut_factor)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SAMRAI::hier::BoxUtilities::findBestCutPointsForDirectionGivenMax           </td>
          <td>(</td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>idir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::list&lt; int &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>cut_points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>box</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>max_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>min_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>cut_factor</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Determine whether the box may be chopped according to specified min_size, max_size and cut_factor constraints along given coordinate direction. If the box may be chopped, the cut points are computed and placed into a list of integers.<p>
Return value:<p>
<ul>
<li>true is returned if the box may be chopped along the specified coordinate direction. Otherwise, false is returned.</li></ul>
<p>
Arguments:<p>
<ul>
<li><b>idir</b> (input) coordinate direction along which cut points will be computed</li></ul>
<p>
<ul>
<li><b>cut_points</b> (output) list of cut points for the box along the idir coordinate direction</li></ul>
<p>
<ul>
<li><b>box</b> (input) box to be chopped</li></ul>
<p>
<ul>
<li><b>max_size</b> (input) maximum allowed box size in idir coordinate direction.</li></ul>
<p>
<ul>
<li><b>min_size</b> (input) minimum allowed box size in idir coordinate direction.</li></ul>
<p>
<ul>
<li><b>cut_factor</b> (input) See class header for description.</li></ul>
<p>
<dl compact><dt><b>Precondition:</b></dt><dd>!box.empty() <p>
min_size &gt; 0 <p>
max_size &gt;= min_size <p>
cut_factor &gt; 0 </dd></dl>

</div>
</div><p>
<a class="anchor" name="cc96ccb6fd2ab2acc44c31514ae6d924"></a><!-- doxytag: member="SAMRAI::hier::BoxUtilities::findBestCutPointsGivenNumber" ref="cc96ccb6fd2ab2acc44c31514ae6d924" args="(tbox::Array&lt; std::list&lt; int &gt; &gt; &amp;cut_points, const Box &amp;box, const IntVector &amp;number_boxes, const IntVector &amp;min_size, const IntVector &amp;cut_factor)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SAMRAI::hier::BoxUtilities::findBestCutPointsGivenNumber           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1tbox_1_1Array.html">tbox::Array</a>&lt; std::list&lt; int &gt; &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>cut_points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>box</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>number_boxes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>min_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>cut_factor</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Determine whether the box may be chopped into the specified number of boxes along each coordinate direction. For those directions along which the box may be chopped, the cut points are computed. The cut points for the j-th coordinate direction are placed into a list of integers corresponding to the j-th component of the cut_point array.<p>
Return value:<p>
<ul>
<li>true is returned if the box may be chopped along any coordinate direction. Otherwise, false is returned.</li></ul>
<p>
Arguments:<p>
<ul>
<li><b>cut_points</b> (output) array of list of cut points for the box</li></ul>
<p>
<ul>
<li><b>box</b> (input) box to be cut</li></ul>
<p>
<ul>
<li><b>number_boxes</b> (input) the i-th component of number_boxes specifies the desired number of cuts to be made along the i-th coordinate direction.</li></ul>
<p>
<ul>
<li><b>min_size</b> (input) minimum allowed box size. See class header for further description.</li></ul>
<p>
<ul>
<li><b>cut_factor</b> (input) See class header for description.</li></ul>
<p>
Important note: By convention, each integer cut point that is computed corresponds to the cell index to the right of cut point.<p>
<dl compact><dt><b>Precondition:</b></dt><dd>(number_boxes.getDim() == min_size.getDim()) &amp;&amp; (number_boxes.getDim() == cut_factor.getDim()) <p>
!box.empty() <p>
min_size &gt; <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html#75075186e3ca2b549792b84f3f5dcb9b">IntVector::getZero</a>(number_boxes.getDim()) <p>
number_boxes &gt; <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html#75075186e3ca2b549792b84f3f5dcb9b">IntVector::getZero</a>(number_boxes.getDim()) <p>
cut_factor &gt; <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html#75075186e3ca2b549792b84f3f5dcb9b">IntVector::getZero</a>(number_boxes.getDim()) </dd></dl>

</div>
</div><p>
<a class="anchor" name="ea3e85c240385f070989b7ba4e229d4e"></a><!-- doxytag: member="SAMRAI::hier::BoxUtilities::findBestCutPointsForDirectionGivenNumber" ref="ea3e85c240385f070989b7ba4e229d4e" args="(const int idir, std::list&lt; int &gt; &amp;cut_points, const Box &amp;box, const int num_boxes, const int min_size, const int cut_factor)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SAMRAI::hier::BoxUtilities::findBestCutPointsForDirectionGivenNumber           </td>
          <td>(</td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>idir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::list&lt; int &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>cut_points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>box</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>num_boxes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>min_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>cut_factor</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Determine whether the box may be chopped into the specified number of boxes along along given coordinate direction. If the box may be chopped, the cut points are computed and placed into a list of integers.<p>
Return value:<p>
<ul>
<li>true is returned if the box may be chopped along the specified coordinate direction. Otherwise, false is returned.</li></ul>
<p>
Arguments:<p>
<ul>
<li><b>idir</b> (input) coordinate direction along which cut points will be computed</li></ul>
<p>
<ul>
<li><b>cut_points</b> (output) list of cut points for the box along the idir coordinate direction</li></ul>
<p>
<ul>
<li><b>box</b> (input) box to be chopped</li></ul>
<p>
<ul>
<li><b>num_boxes</b> (input) num_boxes specifies the desired number of cuts to be made along the idir coordinate direction.</li></ul>
<p>
<ul>
<li><b>min_size</b> (input) minimum allowed box size in idir coordinate direction.</li></ul>
<p>
<ul>
<li><b>cut_factor</b> (input) See class header for description.</li></ul>
<p>
<dl compact><dt><b>Precondition:</b></dt><dd>min_size &gt; 0 <p>
num_boxes &gt; 0 <p>
cut_factor &gt; 0 </dd></dl>

</div>
</div><p>
<a class="anchor" name="6cd08d6fa42d299adfc23ee36dfdb3f9"></a><!-- doxytag: member="SAMRAI::hier::BoxUtilities::checkBoxForBadCutPoints" ref="6cd08d6fa42d299adfc23ee36dfdb3f9" args="(IntVector &amp;bad_cut_information, const Box &amp;box, const BoxContainer &amp;physical_boxes, const IntVector &amp;bad_interval)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SAMRAI::hier::BoxUtilities::checkBoxForBadCutPoints           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>bad_cut_information</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>box</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>physical_boxes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>bad_interval</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Determine whether box has any bad cut points based on its position within the box list domain. Information about the potentially bad directions is returned in the <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> bad_cut_information. An entry of zero indicates that there are no bad cut points for the box along that coordinate direction. An entry of one indicates that there may be a bad cut point along that direction.<p>
Return value:<p>
<ul>
<li>true is returned if the box may potentially have a bad point along some coordinate direction. Otherwise false is returned.</li></ul>
<p>
Arguments:<p>
<ul>
<li><b>bad_cut_information</b> (output) A value of 0 in the i-th component of bad_cut_information indicates that there are no bad cut points in the i-th coordinate direction.</li></ul>
<p>
<ul>
<li><b>box</b> (input) box to be cut.</li></ul>
<p>
<ul>
<li><b>physical_boxes</b> (input) box array that represents some domain</li></ul>
<p>
<ul>
<li><b>bad_interval</b> (input) See class header for description.</li></ul>
<p>
<dl compact><dt><b>Precondition:</b></dt><dd>(bad_cut_information.getDim() == box.getDim()) &amp;&amp; (bad_cut_information.getDim() == bad_interval.getDim()) <p>
bad_interval &gt;= <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html#75075186e3ca2b549792b84f3f5dcb9b">IntVector::getZero</a>(box.getDim()) </dd></dl>

</div>
</div><p>
<a class="anchor" name="5cc81d2c29e441b4b0a1200583197977"></a><!-- doxytag: member="SAMRAI::hier::BoxUtilities::checkBoxForBadCutPointsInDirection" ref="5cc81d2c29e441b4b0a1200583197977" args="(const int dir, const Box &amp;box, const BoxContainer &amp;physical_boxes, const IntVector &amp;bad_interval)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SAMRAI::hier::BoxUtilities::checkBoxForBadCutPointsInDirection           </td>
          <td>(</td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>dir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>box</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>physical_boxes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>bad_interval</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Determine whether box may have any bad cut points along the specified coordinate direction based on its position within the box array domain.<p>
Return value:<p>
<ul>
<li>true is returned if the box may potentially have a bad point; otherwise false is returned.</li></ul>
<p>
Arguments:<p>
<ul>
<li><b>dir</b> (input) coordinate direction to be checked for bad cut points</li></ul>
<p>
<ul>
<li><b>box</b> (input) box to be cut</li></ul>
<p>
<ul>
<li><b>physical_boxes</b> (input) box array that represents some domain</li></ul>
<p>
<ul>
<li><b>bad_interval</b> (input) See class header for description.</li></ul>
<p>
<dl compact><dt><b>Precondition:</b></dt><dd>box.getDim() == bad_interval.getDim() <p>
!box.empty() <p>
bad_interval &gt;= <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html#75075186e3ca2b549792b84f3f5dcb9b">IntVector::getZero</a>(box.getDim()) </dd></dl>

</div>
</div><p>
<a class="anchor" name="38b85860bc7e0f0568178082f8de6a69"></a><!-- doxytag: member="SAMRAI::hier::BoxUtilities::findBadCutPoints" ref="38b85860bc7e0f0568178082f8de6a69" args="(tbox::Array&lt; tbox::Array&lt; bool &gt; &gt; &amp;bad_cuts, const Box &amp;box, const BoxContainer &amp;physical_boxes, const IntVector &amp;bad_interval)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::hier::BoxUtilities::findBadCutPoints           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1tbox_1_1Array.html">tbox::Array</a>&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Array.html">tbox::Array</a>&lt; bool &gt; &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>bad_cuts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>box</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>physical_boxes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>bad_interval</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Determine bad cut points for box based on the specified box array domain and bad interval.<p>
The cut information is returned as an array (size = dim) of arrays (size = number of cells along edge of box) of boolean values. A false value indicates a good cut point, a true value indicates that the box should not be cut at that point.<p>
Arguments:<p>
<ul>
<li><b>bad_cuts</b> (output) stores an array of boolean arrays that indicates whether a potential cut point is bad. A value of false indicates a good cut point, and a true value indicates a bad cut point.</li></ul>
<p>
<ul>
<li><b>box</b> (input) box to be cut</li></ul>
<p>
<ul>
<li><b>physical_boxes</b> (input) box array that represents some domain</li></ul>
<p>
<ul>
<li><b>bad_interval</b> (input) See class header for description.</li></ul>
<p>
<dl compact><dt><b>Precondition:</b></dt><dd>!box.empty() <p>
bad_cuts.getSize() == box.getDim().getValue() <p>
bad_interval &gt;= <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html#75075186e3ca2b549792b84f3f5dcb9b">IntVector::getZero</a>(box.getDim()) </dd></dl>

</div>
</div><p>
<a class="anchor" name="9ab86664ba277fda3ba47a2fc1f09672"></a><!-- doxytag: member="SAMRAI::hier::BoxUtilities::findBadCutPointsForDirection" ref="9ab86664ba277fda3ba47a2fc1f09672" args="(const int dir, tbox::Array&lt; bool &gt; &amp;bad_cuts, const Box &amp;box, const BoxContainer &amp;physical_boxes, const IntVector &amp;bad_interval)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::hier::BoxUtilities::findBadCutPointsForDirection           </td>
          <td>(</td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>dir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1tbox_1_1Array.html">tbox::Array</a>&lt; bool &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>bad_cuts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>box</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>physical_boxes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>bad_interval</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Find bad cut points for a box given a single coordinate direction. The cut information is returned as an array of boolean values (size = number of cells along specified edge of box). A false value indicates a good cut point, a true value indicates that the box should not be cut at that point.<p>
Arguments:<p>
<ul>
<li><b>dir</b> (input) coordinate direction to be checked for bad cut points</li></ul>
<p>
<ul>
<li><b>bad_cuts</b> (output) boolean arrays whose entries indicates whether a potential cut point is bad.</li></ul>
<p>
<ul>
<li><b>box</b> (input) box to be cut</li></ul>
<p>
<ul>
<li><b>physical_boxes</b> (input) box array that represents some domain</li></ul>
<p>
<ul>
<li><b>bad_interval</b> (input) See class header for description.</li></ul>
<p>
<dl compact><dt><b>Precondition:</b></dt><dd>box.getDim() == bad_interval.getDim() <p>
!box.empty() <p>
bad_interval &gt;= <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html#75075186e3ca2b549792b84f3f5dcb9b">IntVector::getZero</a>(box.getDim()) </dd></dl>

</div>
</div><p>
<a class="anchor" name="e35adbda2f14aa683ebb314ce81dedab"></a><!-- doxytag: member="SAMRAI::hier::BoxUtilities::fixBadCutPoints" ref="e35adbda2f14aa683ebb314ce81dedab" args="(tbox::Array&lt; std::list&lt; int &gt; &gt; &amp;cuts, const tbox::Array&lt; tbox::Array&lt; bool &gt; &gt; &amp;bad_cuts, const Box &amp;box, const IntVector &amp;min_size, const IntVector &amp;cut_factor)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::hier::BoxUtilities::fixBadCutPoints           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1tbox_1_1Array.html">tbox::Array</a>&lt; std::list&lt; int &gt; &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>cuts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1tbox_1_1Array.html">tbox::Array</a>&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Array.html">tbox::Array</a>&lt; bool &gt; &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>bad_cuts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>box</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>min_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">IntVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>cut_factor</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Given a set of potential cut points and a set of bad cut points for a box, adjust the cut points so that they do not coincide with bad cut points. Typically, the cuts are generated using either of the findBestCutPoints...() functions, and the bad cut points are generated using the <a class="el" href="structSAMRAI_1_1hier_1_1BoxUtilities.html#38b85860bc7e0f0568178082f8de6a69">findBadCutPoints()</a> function.<p>
Arguments:<p>
<ul>
<li><b>cuts</b> (input/output) array of integer lists each of which holds a list of cut points for the box. Each list is adjusted so that no cut points coincide with bad cut points</li></ul>
<p>
<ul>
<li><b>bad_cuts</b> (input) array of boolean arrays each of which stores information about which offsets from the lower corner of the box are bad cut points</li></ul>
<p>
<ul>
<li><b>box</b> (input) box to be cut</li></ul>
<p>
<ul>
<li><b>min_size</b> (input) minimum allowed box size. See class header for further details.</li></ul>
<p>
<ul>
<li><b>cut_factor</b> (input) See class header for description.</li></ul>
<p>
Assertion checks:<p>
<ul>
<li>The cut points for each direction must be strictly increasing and all satisfy the cut_factor restriction.</li></ul>
<p>
<dl compact><dt><b>Precondition:</b></dt><dd>(box.getDim() == min_size.getDim()) &amp;&amp; (box.getDim() == cut_factor.getDim()) <p>
cuts.getSize() == box.getDim().getValue() <p>
bad_cuts.getSize() == box.getDim().getValue() <p>
!box.empty() <p>
min_size &gt; <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html#75075186e3ca2b549792b84f3f5dcb9b">IntVector::getZero</a>(box.getDim()) <p>
cut_factor &gt; <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html#75075186e3ca2b549792b84f3f5dcb9b">IntVector::getZero</a>(box.getDim()) <p>
for the ith array in bad_cuts, array.getSize() == box.numberCells(i) </dd></dl>

</div>
</div><p>
<a class="anchor" name="ec153e1e291c2f1dd0e8bf7623d2479f"></a><!-- doxytag: member="SAMRAI::hier::BoxUtilities::fixBadCutPointsForDirection" ref="ec153e1e291c2f1dd0e8bf7623d2479f" args="(const int dir, std::list&lt; int &gt; &amp;cuts, const tbox::Array&lt; bool &gt; &amp;bad_cuts, const Box &amp;box, const int min_size, const int cut_factor)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::hier::BoxUtilities::fixBadCutPointsForDirection           </td>
          <td>(</td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>dir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::list&lt; int &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>cuts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1tbox_1_1Array.html">tbox::Array</a>&lt; bool &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>bad_cuts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>box</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>min_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>cut_factor</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Given a set of potential cut points and a set of bad cut points for a box, adjust the cut points in the specified coordinate direction so that they do not coincide with bad cut points. Typically, the cuts are generated using either of the findBestCutPoints...() functions, and the bad cut points are generated using the <a class="el" href="structSAMRAI_1_1hier_1_1BoxUtilities.html#38b85860bc7e0f0568178082f8de6a69">findBadCutPoints()</a> function.<p>
Arguments:<p>
<ul>
<li><b>dir</b> (input) coordinate direction along which to fix cut points</li></ul>
<p>
<ul>
<li><b>cuts</b> (input/output) list of integers which holds a list of cut points for the box. This list is adjusted so that no cut points coincide with bad cut points.</li></ul>
<p>
<ul>
<li><b>bad_cuts</b> (input) array of booleans which stores information about which offsets from the lower corner of the box are bad cut points</li></ul>
<p>
<ul>
<li><b>box</b> (input) box to be cut</li></ul>
<p>
<ul>
<li><b>min_size</b> (input) minimum allowed box size along specified coordinate direction.</li></ul>
<p>
<ul>
<li><b>cut_factor</b> (input) See class header for description.</li></ul>
<p>
<dl compact><dt><b>Precondition:</b></dt><dd>bad_cuts.getSize() == box.numberCells(dir) <p>
!box.empty() <p>
min_size &gt; 0 <p>
cut_factor &gt; 0 </dd></dl>

</div>
</div><p>
<a class="anchor" name="906fce06a805709264e79a62ed13485e"></a><!-- doxytag: member="SAMRAI::hier::BoxUtilities::findBadCutPointsForBorderAndDirection" ref="906fce06a805709264e79a62ed13485e" args="(const int id, tbox::Array&lt; bool &gt; &amp;bad_cuts, const Box &amp;box, const Box &amp;border, const int bad_interval)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::hier::BoxUtilities::findBadCutPointsForBorderAndDirection           </td>
          <td>(</td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1tbox_1_1Array.html">tbox::Array</a>&lt; bool &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>bad_cuts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>box</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">Box</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>border</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>bad_interval</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This static private member function is called by <a class="el" href="structSAMRAI_1_1hier_1_1BoxUtilities.html#38b85860bc7e0f0568178082f8de6a69">findBadCutPoints()</a>, and the <a class="el" href="structSAMRAI_1_1hier_1_1BoxUtilities.html#9ab86664ba277fda3ba47a2fc1f09672">findBadCutPointsForDirection()</a> member functions. It sets bad cut points near the lower and upper ends of the border box in the given coordinate direction.<p>
<dl compact><dt><b>Precondition:</b></dt><dd>box.getDim() == border.getDim() <p>
(0 &lt;= id) &amp;&amp; (id &lt; box.getDim().getValue()) <p>
bad_cuts.getSize() == box.numberCells(id) <p>
bad_interval &gt;= 0 </dd></dl>

</div>
</div><p>
<a class="anchor" name="aae13268acca044c3e64176a924d3933"></a><!-- doxytag: member="SAMRAI::hier::BoxUtilities::makeNonOverlappingBoxContainers" ref="aae13268acca044c3e64176a924d3933" args="(tbox::Array&lt; BoxContainer &gt; &amp;box_list_array, const BoxContainer &amp;boxes)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::hier::BoxUtilities::makeNonOverlappingBoxContainers           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1tbox_1_1Array.html">tbox::Array</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>box_list_array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1BoxContainer.html">BoxContainer</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>boxes</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Construct an array of box lists so that each list contains a non-overlapping set of boxes covering some portion of the box at the same array location in the box array. The regions of index space formed by composing the union of boxes on each box list are mutually disjoint and the union of all boxes in the box lists exactly covers the union of boxes in the original box array. In other words, this routine partitions the boxes in the "boxes" argument into a set of non-overlapping box collections. If none of the boxes in this box array overlap then each box list in the resulting array has a single box equal to the corresponding box in the box array. This routine is especially useful for determining a unique set of index points given an array of boxes in some index space.<p>
Arguments:<p>
<ul>
<li><b>box_list_array</b> (output) array of box lists which cover mutually exclusive portions of the index space covered by the "boxes" argument</li></ul>
<p>
<ul>
<li><b>boxes</b> (input) an arbitrary box array </li></ul>

</div>
</div><p>
<hr>The documentation for this struct was generated from the following files:<ul>
<li>source/SAMRAI/hier/<a class="el" href="BoxUtilities_8h.html">BoxUtilities.h</a><li>source/SAMRAI/hier/<a class="el" href="BoxUtilities_8C.html">BoxUtilities.C</a></ul>
<hr size="1"><address style="align: right;"><small>Generated on Mon Oct 15 15:43:54 2012 for SAMRAI by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.7 </small></address>
</body>
</html>
