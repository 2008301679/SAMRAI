<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>SAMRAI: SAMRAI::appu::VisItDataWriter Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath"><a class="el" href="namespaceSAMRAI.html">SAMRAI</a>::<a class="el" href="namespaceSAMRAI_1_1appu.html">appu</a>::<a class="el" href="classSAMRAI_1_1appu_1_1VisItDataWriter.html">VisItDataWriter</a>
  </div>
</div>
<div class="contents">
<h1>SAMRAI::appu::VisItDataWriter Class Reference</h1><!-- doxytag: class="SAMRAI::appu::VisItDataWriter" -->
<p>Class <a class="el" href="classSAMRAI_1_1appu_1_1VisItDataWriter.html" title="Class VisItDataWriter is used by SAMRAI-based application codes to generate VisIt...">VisItDataWriter</a> is used by SAMRAI-based application codes to generate VisIt data files. VisIt provides a wide range of visualization and post-processing capabilities. This class supports both cell-centered and node-centered 2D and 3D AMR data where the underlying data type is either double, float, or int. Scalar, vector and 2nd-order tensor variables are supported. This class may be used when the <a class="el" href="namespaceSAMRAI_1_1mesh.html">mesh</a> geometry is managed by a <a class="el" href="classSAMRAI_1_1geom_1_1CartesianGridGeometry.html">geom::CartesianGridGeometry</a> object, or when the <a class="el" href="namespaceSAMRAI_1_1mesh.html">mesh</a> itself is stored in a state variable to allow moving deformed grids.  
<a href="#_details">More...</a></p>

<p><code>#include &lt;source/SAMRAI/appu/VisItDataWriter.h&gt;</code></p>

<p><a href="classSAMRAI_1_1appu_1_1VisItDataWriter-members.html">List of all members.</a></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1appu_1_1VisItDataWriter.html#a446ed46d6dfe9d1e91b77f4d0b07e623">VisItDataWriter</a> (const <a class="el" href="classSAMRAI_1_1tbox_1_1Dimension.html">tbox::Dimension</a> &amp;dim, const std::string &amp;object_name, const std::string &amp;dump_directory_name, int number_procs_per_file=1, bool is_multiblock=false)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The constructor initializes the VisIt data writer to a default state.  <a href="#a446ed46d6dfe9d1e91b77f4d0b07e623"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1appu_1_1VisItDataWriter.html#a0a5c9eefe7375936b608923755cfde9c">~VisItDataWriter</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The destructor for a <a class="el" href="classSAMRAI_1_1appu_1_1VisItDataWriter.html" title="Class VisItDataWriter is used by SAMRAI-based application codes to generate VisIt...">VisItDataWriter</a> object.  <a href="#a0a5c9eefe7375936b608923755cfde9c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1appu_1_1VisItDataWriter.html#a5fc1209fb9491f0e0200c8c1582e8a54">setDefaultDerivedDataWriter</a> (<a class="el" href="classSAMRAI_1_1appu_1_1VisDerivedDataStrategy.html">VisDerivedDataStrategy</a> *default_derived_writer)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This method sets the default data writer to use for derived data.  <a href="#a5fc1209fb9491f0e0200c8c1582e8a54"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1appu_1_1VisItDataWriter.html#a6c98c4d9c88136e523c8f44b662d0c26">setMaterialsDataWriter</a> (<a class="el" href="classSAMRAI_1_1appu_1_1VisMaterialsDataStrategy.html">VisMaterialsDataStrategy</a> *materials_data_writer)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This method sets the data writer to use for materials.  <a href="#a6c98c4d9c88136e523c8f44b662d0c26"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1appu_1_1VisItDataWriter.html#aea9a183d8538e58673e8fd9ea9d4bd18">registerPlotQuantity</a> (const std::string &amp;variable_name, const std::string &amp;variable_type, const int patch_data_index, const int start_depth_index=0, const double scale_factor=1.0, const std::string &amp;variable_centering=&quot;UNKNOWN&quot;)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This method registers a variable with the VisIt data writer.  <a href="#aea9a183d8538e58673e8fd9ea9d4bd18"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1appu_1_1VisItDataWriter.html#ae0e1ca908d4386cee2405d5b62692a76">registerDerivedPlotQuantity</a> (const std::string &amp;variable_name, const std::string &amp;variable_type, <a class="el" href="classSAMRAI_1_1appu_1_1VisDerivedDataStrategy.html">VisDerivedDataStrategy</a> *derived_writer=0, const double scale_factor=1.0, const std::string &amp;variable_centering=&quot;CELL&quot;, const std::string &amp;variable_mix_type=&quot;CLEAN&quot;)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This method registers a derived variable with the VisIt data writer.  <a href="#ae0e1ca908d4386cee2405d5b62692a76"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1appu_1_1VisItDataWriter.html#a073d77fe139d6a5fd6a7b2ff9e5533b4">resetLevelPlotQuantity</a> (const std::string &amp;variable_name, const int level_number, const int patch_data_index, const int start_depth_index=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This method resets the patch_data_index, and/or the depth_index, at a specific level, of a previously registered plot variable.  <a href="#a073d77fe139d6a5fd6a7b2ff9e5533b4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1appu_1_1VisItDataWriter.html#aa38f8fcfc3489f6bfdde1f05606ea43c">registerNodeCoordinates</a> (const int patch_data_index, const int start_depth_index=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This method is used to register node coordinates for deformed structured AMR grids (moving grids).  <a href="#aa38f8fcfc3489f6bfdde1f05606ea43c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1appu_1_1VisItDataWriter.html#a01c0101c10011a41f25bd0bcfb4f5250">registerSingleNodeCoordinate</a> (const int coordinate_number, const int patch_data_index, const int depth_index=0, const double scale_factor=1.0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Same as above method, but allows registration of single coordinate for deformed structured AMR grids (moving grids).  <a href="#a01c0101c10011a41f25bd0bcfb4f5250"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1appu_1_1VisItDataWriter.html#a4b1da68b0f276104f5e5a15b3e05f8a8">registerMaterialNames</a> (const std::vector&lt; std::string &gt; &amp;material_names)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This method registers with the VisIt data writer the names of materials being used in the simulation.  <a href="#a4b1da68b0f276104f5e5a15b3e05f8a8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1appu_1_1VisItDataWriter.html#a58683e422a15f3263bcddc8841796e55">registerSparseMaterialNames</a> (const std::vector&lt; std::string &gt; &amp;material_names)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This method registers with the VisIt data writer the names of materials being used in the simulation.  <a href="#a58683e422a15f3263bcddc8841796e55"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1appu_1_1VisItDataWriter.html#a895152bf4c8af5f0d3d20d43b8f63a4a">registerSpeciesNames</a> (const std::string &amp;material_name, const std::vector&lt; std::string &gt; &amp;species_names)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This method registers the names of the species for a material_name with the VisIt data writer.  <a href="#a895152bf4c8af5f0d3d20d43b8f63a4a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1appu_1_1VisItDataWriter.html#ab9adaa4527f5028337efec539ae137c2">registerVisItExpressions</a> (const std::vector&lt; std::string &gt; &amp;expression_keys, const std::vector&lt; std::string &gt; &amp;expressions, const std::vector&lt; std::string &gt; &amp;expression_types)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This method registers expressions that will be embedded in the VisIt datafiles.  <a href="#ab9adaa4527f5028337efec539ae137c2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1appu_1_1VisItDataWriter.html#abb8563ca251cb8fc5b1e7ae601730eee">writePlotData</a> (const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchHierarchy.html">hier::PatchHierarchy</a> &gt; &amp;hierarchy, int time_step, double simulation_time=0.0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This method causes the VisIt data writer to dump all registered data. The appropriate packing methods will be invoked for material-related data and derived data.  <a href="#abb8563ca251cb8fc5b1e7ae601730eee"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1appu_1_1VisItDataWriter.html#a303784551016695618fbae5e4b89f5bf">setSummaryFilename</a> (std::string &amp;filename)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the name of the summary file.  <a href="#a303784551016695618fbae5e4b89f5bf"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const std::string &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1appu_1_1VisItDataWriter.html#ad90d0b1c6a001b44240cec18fdbc9162">getObjectName</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the object name.  <a href="#ad90d0b1c6a001b44240cec18fdbc9162"></a><br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>Class <a class="el" href="classSAMRAI_1_1appu_1_1VisItDataWriter.html" title="Class VisItDataWriter is used by SAMRAI-based application codes to generate VisIt...">VisItDataWriter</a> is used by SAMRAI-based application codes to generate VisIt data files. VisIt provides a wide range of visualization and post-processing capabilities. This class supports both cell-centered and node-centered 2D and 3D AMR data where the underlying data type is either double, float, or int. Scalar, vector and 2nd-order tensor variables are supported. This class may be used when the <a class="el" href="namespaceSAMRAI_1_1mesh.html">mesh</a> geometry is managed by a <a class="el" href="classSAMRAI_1_1geom_1_1CartesianGridGeometry.html">geom::CartesianGridGeometry</a> object, or when the <a class="el" href="namespaceSAMRAI_1_1mesh.html">mesh</a> itself is stored in a state variable to allow moving deformed grids. </p>
<p>The VisIt data writer (VDW) supports CELL or NODE centered data of data type double, float, and integer. There is support to convert an alternative user-defined type into standard cell or node centered data for visualization purposes. See method descriptions below for more information. The data actually written by the VDW is of type float so data should not exceed the defined MAX_FLT and/or MIN_FLT. An optional scale factor may be supplied for data that exceeds these values.</p>
<p>After creating a VDW object, the data items to be dumped for plotting must be registered with that object. Thereafter, the object can be used to generate a series of visualization dump files during the execution of an application. The dumps will include all data items registered with the VDW.</p>
<p>This class supports the dumping of data that resides on an AMR patch hierarchy at the time the dump file is written, and derived data, data that does not live on the patch hierarchy, but that can be computed from data which does live on the patch hierarchy. Derived data requires the user to implement a method for a concrete class derived from the <a class="el" href="classSAMRAI_1_1appu_1_1VisDerivedDataStrategy.html" title="Class VisDerivedDataStrategy is an abstract base class that defines an interface...">VisDerivedDataStrategy</a> abstract class.</p>
<p>The class also supports writing material and species data. Material is data which indicates for each cell, the fractional amount of a material compound, e.g. "steel", "gas", "copper", etc., contained in that cell. Species are subcomponents of a material, e.g. if the material is "gas", it may have subcomponents such as "nitrogen", "oxygen", etc. To use material data it is necessary for a user to implement the relevant packing methods for a concrete class derived from the <a class="el" href="classSAMRAI_1_1appu_1_1VisMaterialsDataStrategy.html" title="Class VisMaterialsDataStrategy is an abstract base class that defines an interface...">VisMaterialsDataStrategy</a> abstract class.</p>
<p>The VDW requires the compilation of <a class="el" href="namespaceSAMRAI.html">SAMRAI</a> with the HDF5 library.</p>
<p>A brief summary of the basic steps typically involved in using the VDW are:</p>
<ul>
<li>Create a VisIt data writer object, specifying a name for the object and the name of the directory to contain the visit dump files. An optional argument number_procs_per_file, applicable to parallel runs, sets the number of processors that share a common dump file. This can reduce parallel I/O contention. The default value of this arg is 1. If the value specified is greater than the number of processors, then all processors share a single dump file.</li>
</ul>
<ul>
<li>Register hierarchy variable data fields using <a class="el" href="classSAMRAI_1_1appu_1_1VisItDataWriter.html#aea9a183d8538e58673e8fd9ea9d4bd18" title="This method registers a variable with the VisIt data writer.">registerPlotQuantity()</a>. The variables registered may be scalar, vector, or tensor (depth 1, dim, and dim*dim, respectively) which is specified in the argument list. All variables require a string identifier and an index into the patch data array on the AMR hierarchy. Optionally, a start depth index may be supplied to plot a single component of a multi-component field (i.e. a scalar quantity within a vector, or a vector within a tensor). A scale factor may also optionally be specified. Lastly, for user-defined data that is not cell or node type, the proper centering (cell or node) for the data may be supplied.</li>
</ul>
<ul>
<li>If using derived data, set a default user-defined derived data writer using <a class="el" href="classSAMRAI_1_1appu_1_1VisItDataWriter.html#a5fc1209fb9491f0e0200c8c1582e8a54" title="This method sets the default data writer to use for derived data.">setDefaultDerivedDataWriter()</a>. A derived data writer may also optionally be specified in the call to <a class="el" href="classSAMRAI_1_1appu_1_1VisItDataWriter.html#ae0e1ca908d4386cee2405d5b62692a76" title="This method registers a derived variable with the VisIt data writer.">registerDerivedPlotQuantity()</a>; if so, this derived data writer will be used for the variable being registered. If no derived writer is specified in the registration call, the default derived data writer will be used.</li>
</ul>
<ul>
<li>Register derived variable data fields using <a class="el" href="classSAMRAI_1_1appu_1_1VisItDataWriter.html#ae0e1ca908d4386cee2405d5b62692a76" title="This method registers a derived variable with the VisIt data writer.">registerDerivedPlotQuantity()</a>. All derived variables require a string identifier. Optionally, a <a class="el" href="classSAMRAI_1_1appu_1_1VisDerivedDataStrategy.html" title="Class VisDerivedDataStrategy is an abstract base class that defines an interface...">VisDerivedDataStrategy</a> object, a scale factor, and centering and may be specified. By default By default, the data is assumed to be cell-centered.</li>
</ul>
<ul>
<li>The <a class="el" href="classSAMRAI_1_1appu_1_1VisItDataWriter.html#a073d77fe139d6a5fd6a7b2ff9e5533b4" title="This method resets the patch_data_index, and/or the depth_index, at a specific level...">resetLevelPlotQuantity()</a> method is provided for cases when a variable lives at different patch data indices on different levels. Invoking this method redefines the patch data array index for a given variable on a given level that will be written to a visit dump file. Before this method is called, the variable must be registered using <a class="el" href="classSAMRAI_1_1appu_1_1VisItDataWriter.html#aea9a183d8538e58673e8fd9ea9d4bd18" title="This method registers a variable with the VisIt data writer.">registerPlotQuantity()</a> method.</li>
</ul>
<ul>
<li>If using deformed structured AMR grids (moving grids), register the coordinates of the nodes using the <a class="el" href="classSAMRAI_1_1appu_1_1VisItDataWriter.html#aa38f8fcfc3489f6bfdde1f05606ea43c" title="This method is used to register node coordinates for deformed structured AMR grids...">registerNodeCoordinates()</a> method.</li>
</ul>
<ul>
<li>If using materials, set the user-defined data writer for material data using <a class="el" href="classSAMRAI_1_1appu_1_1VisItDataWriter.html#a6c98c4d9c88136e523c8f44b662d0c26" title="This method sets the data writer to use for materials.">setMaterialsDataWriter()</a>. Then register the names of the materials being used with <a class="el" href="classSAMRAI_1_1appu_1_1VisItDataWriter.html#a4b1da68b0f276104f5e5a15b3e05f8a8" title="This method registers with the VisIt data writer the names of materials being used...">registerMaterialNames()</a>.</li>
</ul>
<ul>
<li>If using species of the materials, register the names of the species of each material using the <a class="el" href="classSAMRAI_1_1appu_1_1VisItDataWriter.html#a895152bf4c8af5f0d3d20d43b8f63a4a" title="This method registers the names of the species for a material_name with the VisIt...">registerSpeciesNames()</a> method.</li>
</ul>
<ul>
<li>The writer will generate VisIt dump files when the method <a class="el" href="classSAMRAI_1_1appu_1_1VisItDataWriter.html#abb8563ca251cb8fc5b1e7ae601730eee" title="This method causes the VisIt data writer to dump all registered data. The appropriate...">writePlotData()</a> is called. Minimally, only a hierarchy and the time step number is needed. A simulation time can also be specified which will be included as part of the file information in the dump</li>
</ul>
<ul>
<li>The document "Generating VisIt Visualization Data Files in
      SAMRAI" in the <a class="el" href="namespaceSAMRAI.html">SAMRAI</a> documentation directory (docs/userdocs/VisIt-writer.pdf) gives in-depth details on the use of the VDW and materials, as well as example code fragments showing how the various <a class="el" href="classSAMRAI_1_1appu_1_1VisItDataWriter.html" title="Class VisItDataWriter is used by SAMRAI-based application codes to generate VisIt...">VisItDataWriter</a> methods can be embedded in an application. </li>
</ul>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a446ed46d6dfe9d1e91b77f4d0b07e623"></a><!-- doxytag: member="SAMRAI::appu::VisItDataWriter::VisItDataWriter" ref="a446ed46d6dfe9d1e91b77f4d0b07e623" args="(const tbox::Dimension &amp;dim, const std::string &amp;object_name, const std::string &amp;dump_directory_name, int number_procs_per_file=1, bool is_multiblock=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SAMRAI::appu::VisItDataWriter::VisItDataWriter </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1tbox_1_1Dimension.html">tbox::Dimension</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>dim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>object_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>dump_directory_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>number_procs_per_file</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>is_multiblock</em> = <code>false</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The constructor initializes the VisIt data writer to a default state. </p>
<p>The object_name argument is used primarily for error reporting. The dump_directory_name argument is the name of the directory which will contain the visit dump files. The directory name may include a path. If the dump directory or any intermediate directories in the path do not exist, they will be created. The optional number_procs_per_file argument is applicable to parallel runs and specifies the number of processors that share a common dump file; the default value is 1. If the specified number_procs_per_file is greater than the number of processors, then all processors share a single vis dump file. Reducing the number of files written may reduce parallel I/O contention and thus improve I/O efficiency. The optional argument is_multiblock defaults to false. It must be set to true for problems on multiblock domains, and left false in all other cases.</p>
<p>Before the data writer object can be used for dumping VisIt data, the variables and material-related data (if any) must be registered.</p>
<p>An error results and the program will halt if:</p>
<ul>
<li>the data is not 2D nor 3D, i.e. dim != 2 and dim != 3</li>
<li>when assertion checking is active, the object name string is empty, or the number_procs_per_file is &lt;= 0.</li>
</ul>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dim</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>object_name</em>&nbsp;</td><td>String name for data writer object </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dump_directory_name</em>&nbsp;</td><td>String name for dump directory, which may include a path. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>number_procs_per_file</em>&nbsp;</td><td>Optional integer number processors (&gt;= 1) to share a common dump file; default is 1. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>is_multiblock</em>&nbsp;</td><td>Optional argument should be set to true only only for problems on a multiblock domain.</td></tr>
  </table>
  </dd>
</dl>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>!object_name.empty() </dd>
<dd>
number_procs_per_file &gt; 0 </dd>
<dd>
(dim.getValue() == 2) || (dim.getValue() == 3) </dd></dl>

<p>References <a class="el" href="IntVector_8h_source.html#l00742">SAMRAI::hier::IntVector::getOne()</a>, <a class="el" href="Utilities_8h_source.html#l00110">TBOX_ASSERT</a>, and <a class="el" href="Utilities_8h_source.html#l00060">TBOX_ERROR</a>.</p>

</div>
</div>
<a class="anchor" id="a0a5c9eefe7375936b608923755cfde9c"></a><!-- doxytag: member="SAMRAI::appu::VisItDataWriter::~VisItDataWriter" ref="a0a5c9eefe7375936b608923755cfde9c" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SAMRAI::appu::VisItDataWriter::~VisItDataWriter </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The destructor for a <a class="el" href="classSAMRAI_1_1appu_1_1VisItDataWriter.html" title="Class VisItDataWriter is used by SAMRAI-based application codes to generate VisIt...">VisItDataWriter</a> object. </p>
<p>The destructor for the writer does nothing interesting. </p>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a5fc1209fb9491f0e0200c8c1582e8a54"></a><!-- doxytag: member="SAMRAI::appu::VisItDataWriter::setDefaultDerivedDataWriter" ref="a5fc1209fb9491f0e0200c8c1582e8a54" args="(VisDerivedDataStrategy *default_derived_writer)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::appu::VisItDataWriter::setDefaultDerivedDataWriter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1appu_1_1VisDerivedDataStrategy.html">VisDerivedDataStrategy</a> *&nbsp;</td>
          <td class="paramname"> <em>default_derived_writer</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This method sets the default data writer to use for derived data. </p>
<p>If a non-null derived data writer is supplied by the member function <a class="el" href="classSAMRAI_1_1appu_1_1VisItDataWriter.html#ae0e1ca908d4386cee2405d5b62692a76" title="This method registers a derived variable with the VisIt data writer.">registerDerivedPlotQuantity()</a> it will be used in place of the one given here.</p>
<p>An error results and the program will halt if:</p>
<ul>
<li>assertion checking is active and the default_derived_writer pointer is null.</li>
</ul>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>default_derived_writer</em>&nbsp;</td><td>Pointer to a <a class="el" href="classSAMRAI_1_1appu_1_1VisDerivedDataStrategy.html" title="Class VisDerivedDataStrategy is an abstract base class that defines an interface...">VisDerivedDataStrategy</a> object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>default_derived_writer != 0 </dd></dl>

<p>References <a class="el" href="Utilities_8h_source.html#l00110">TBOX_ASSERT</a>.</p>

</div>
</div>
<a class="anchor" id="a6c98c4d9c88136e523c8f44b662d0c26"></a><!-- doxytag: member="SAMRAI::appu::VisItDataWriter::setMaterialsDataWriter" ref="a6c98c4d9c88136e523c8f44b662d0c26" args="(VisMaterialsDataStrategy *materials_data_writer)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::appu::VisItDataWriter::setMaterialsDataWriter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1appu_1_1VisMaterialsDataStrategy.html">VisMaterialsDataStrategy</a> *&nbsp;</td>
          <td class="paramname"> <em>materials_data_writer</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This method sets the data writer to use for materials. </p>
<p>An error results and the program will halt if:</p>
<ul>
<li>assertion checking is active and the materials_data__writer pointer is null.</li>
</ul>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>materials_data_writer</em>&nbsp;</td><td>Pointer to a <a class="el" href="classSAMRAI_1_1appu_1_1VisMaterialsDataStrategy.html" title="Class VisMaterialsDataStrategy is an abstract base class that defines an interface...">VisMaterialsDataStrategy</a> object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>materials_data_writer != 0 </dd></dl>

<p>References <a class="el" href="Utilities_8h_source.html#l00110">TBOX_ASSERT</a>.</p>

</div>
</div>
<a class="anchor" id="aea9a183d8538e58673e8fd9ea9d4bd18"></a><!-- doxytag: member="SAMRAI::appu::VisItDataWriter::registerPlotQuantity" ref="aea9a183d8538e58673e8fd9ea9d4bd18" args="(const std::string &amp;variable_name, const std::string &amp;variable_type, const int patch_data_index, const int start_depth_index=0, const double scale_factor=1.0, const std::string &amp;variable_centering=&quot;UNKNOWN&quot;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::appu::VisItDataWriter::registerPlotQuantity </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>variable_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>variable_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>patch_data_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>start_depth_index</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>scale_factor</em> = <code>1.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>variable_centering</em> = <code>&quot;UNKNOWN&quot;</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This method registers a variable with the VisIt data writer. </p>
<p>Each plot quantity requires a variable name, which is what VisIt will label the plotted quantity. The variable type is a string specifying either "SCALAR", "VECTOR", or "TENSOR". By default, the dimension of a scalar variable is 1, vector is dim, and tensor is dim*dim. The integer patch data array index and optional depth index indicate where the data may be found on patches in the hierarchy.</p>
<p>A number of optional parameters may be used to further specify characteristics of the plotted variable. The start depth index allows subsets of variables with depth greater than than the supplied type (scalar, vector, tensor) to be specified. For example, a single depth index of a variable with depth greater than one may be registered as a scalar. A scale factor may be specified such that each data value is multiplied by this factor before being written to the file. Finally, Finally, the variable centering may be specified for data that is not standard CELL or NODE centered types. By default, the writer will set the centering according to the type of data in the supplied patch data index. It will revert to the supplied type only if it is unable to determine the type from the index.</p>
<p>Data does not need to exist on all patches or all levels.</p>
<p>An error results and the program will halt if:</p>
<ul>
<li>a variable was previously registered with the same name.</li>
<li>the variable type is not "SCALAR", "VECTOR", or "TENSOR"</li>
<li>the patch data factory referred to by the patch data array index is null.</li>
<li>the start depth index is invalid.</li>
<li>the supplied variable centering is not "CELL" or "NODE".</li>
</ul>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>variable_name</em>&nbsp;</td><td>name of variable. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>variable_type</em>&nbsp;</td><td>"SCALAR", "VECTOR", "TENSOR" </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>patch_data_index</em>&nbsp;</td><td>patch data descriptor id </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>start_depth_index</em>&nbsp;</td><td>(optional) zero by default; may specify starting index if patch_data_id has depth greater than the supplied variable_type </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>scale_factor</em>&nbsp;</td><td>(optional) scale factor for data </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>variable_centering</em>&nbsp;</td><td>(optional) "CELL" or "NODE" - used only when data being registered is not standard cell or node type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>!variable_name.empty() </dd>
<dd>
!variable_type.empty() </dd>
<dd>
patch_data_index &gt;= -1 </dd>
<dd>
start_depth_index &gt;= 0 </dd></dl>

<p>References <a class="el" href="Utilities_8h_source.html#l00110">TBOX_ASSERT</a>, and <a class="el" href="Utilities_8h_source.html#l00060">TBOX_ERROR</a>.</p>

</div>
</div>
<a class="anchor" id="ae0e1ca908d4386cee2405d5b62692a76"></a><!-- doxytag: member="SAMRAI::appu::VisItDataWriter::registerDerivedPlotQuantity" ref="ae0e1ca908d4386cee2405d5b62692a76" args="(const std::string &amp;variable_name, const std::string &amp;variable_type, VisDerivedDataStrategy *derived_writer=0, const double scale_factor=1.0, const std::string &amp;variable_centering=&quot;CELL&quot;, const std::string &amp;variable_mix_type=&quot;CLEAN&quot;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::appu::VisItDataWriter::registerDerivedPlotQuantity </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>variable_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>variable_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1appu_1_1VisDerivedDataStrategy.html">VisDerivedDataStrategy</a> *&nbsp;</td>
          <td class="paramname"> <em>derived_writer</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>scale_factor</em> = <code>1.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>variable_centering</em> = <code>&quot;CELL&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>variable_mix_type</em> = <code>&quot;CLEAN&quot;</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This method registers a derived variable with the VisIt data writer. </p>
<p>Each derived variable requires a variable name, which is what VisIt will label the plotted quantity. The variable type is a string specifying either "SCALAR", "VECTOR", or "TENSOR". By default, the dimension of a scalar variable is 1, vector is dim, and tensor is dim*dim. The derived writer should implement methods defined in the derived data strategy which compute the derived data.</p>
<p>Optional parameters may be used to further define characteristics of the derived variable. A scale factor may be specified such that each data value is multiplied by this factor before being written to the file. The variable centering should specify the variable as "CELL" or "NODE" type (if unspecified, "CELL" is used by default).</p>
<p>An error results and the program will halt if:</p>
<ul>
<li>a variable was previously registered with the same name.</li>
<li>the variable type is not "SCALAR", "VECTOR", or "TENSOR"</li>
<li>the derived_writer is NULL and there is no default derived writer.</li>
<li>the supplied variable centering is not "CELL" or "NODE".</li>
</ul>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>variable_name</em>&nbsp;</td><td>name of variable. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>variable_type</em>&nbsp;</td><td>"SCALAR", "VECTOR", "TENSOR" </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>derived_writer</em>&nbsp;</td><td>(optional) derived data strategy object to use to calculate this derived data - will use default derived data object if not supplied </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>scale_factor</em>&nbsp;</td><td>(optional) scale factor with which to multiply all data values </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>variable_centering</em>&nbsp;</td><td>(optional) centering of derived data - "CELL" or "NODE" </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>variable_mix_type</em>&nbsp;</td><td>(optional) indicate whether or not the mixed material state will be stored, "MIXED", or the default of using cell averages "CLEAN". If "MIXED" then packMixedDerivedDataIntoDoubleBuffer() must be provided.</td></tr>
  </table>
  </dd>
</dl>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>!variable_name.empty() </dd>
<dd>
!variable_type.empty() </dd>
<dd>
(variable_name != "Coords") || ((variable_type == "VECTOR") &amp;&amp; (variable_centering == "NODE")) </dd></dl>

<p>References <a class="el" href="Dimension_8h_source.html#l00133">SAMRAI::tbox::Dimension::getValue()</a>, <a class="el" href="Utilities_8h_source.html#l00110">TBOX_ASSERT</a>, and <a class="el" href="Utilities_8h_source.html#l00060">TBOX_ERROR</a>.</p>

</div>
</div>
<a class="anchor" id="a073d77fe139d6a5fd6a7b2ff9e5533b4"></a><!-- doxytag: member="SAMRAI::appu::VisItDataWriter::resetLevelPlotQuantity" ref="a073d77fe139d6a5fd6a7b2ff9e5533b4" args="(const std::string &amp;variable_name, const int level_number, const int patch_data_index, const int start_depth_index=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::appu::VisItDataWriter::resetLevelPlotQuantity </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>variable_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>level_number</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>patch_data_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>start_depth_index</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This method resets the patch_data_index, and/or the depth_index, at a specific level, of a previously registered plot variable. </p>
<p>The change redefines the patch data object written to the plot file on the specified level to the data at the new patch data array index / depth index. This method is used when a particular variable lives at different patch data slots on different hierarchy levels. For example, suppose a variable lives at a patch data array index on every level except the finest hierarchy level, where it lives at a different index. First, the variable must be registered using <a class="el" href="classSAMRAI_1_1appu_1_1VisItDataWriter.html#aea9a183d8538e58673e8fd9ea9d4bd18" title="This method registers a variable with the VisIt data writer.">registerPlotQuantity()</a>. Second, the patch data index for the finest hierarchy level is reset using this method. When the data is plotted, it will appear on all levels in the hierarchy. The patch data array index must refer to data with the same type (SCALAR, VECTOR, or TENSOR), centering (NODE or CELL), and data type (int, float, double) as the data for which the variable was originally registered.</p>
<p>An error results and the program will halt if:</p>
<ul>
<li>this variable name was not previously registered.</li>
<li>the patch data referred to by the patch data array index is null, or the data type is not the same type as the data which was originally registered.</li>
<li>the depth index is invalid.</li>
</ul>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>variable_name</em>&nbsp;</td><td>name of variable. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>level_number</em>&nbsp;</td><td>level number on which data index is being reset. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>patch_data_index</em>&nbsp;</td><td>new patch data array index. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>start_depth_index</em>&nbsp;</td><td>(optional) argument indicating the new depth index.</td></tr>
  </table>
  </dd>
</dl>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>!variable_name.empty() </dd>
<dd>
level_number &gt;= 0 </dd>
<dd>
patch_data_index &gt;= -1 </dd>
<dd>
start_depth_index &gt;= 0 </dd></dl>

<p>References <a class="el" href="VariableDatabase_8C_source.html#l00044">SAMRAI::hier::VariableDatabase::getDatabase()</a>, <a class="el" href="Utilities_8h_source.html#l00110">TBOX_ASSERT</a>, and <a class="el" href="Utilities_8h_source.html#l00060">TBOX_ERROR</a>.</p>

</div>
</div>
<a class="anchor" id="aa38f8fcfc3489f6bfdde1f05606ea43c"></a><!-- doxytag: member="SAMRAI::appu::VisItDataWriter::registerNodeCoordinates" ref="aa38f8fcfc3489f6bfdde1f05606ea43c" args="(const int patch_data_index, const int start_depth_index=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::appu::VisItDataWriter::registerNodeCoordinates </td>
          <td>(</td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>patch_data_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>start_depth_index</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This method is used to register node coordinates for deformed structured AMR grids (moving grids). </p>
<p>The patch data index must correspond to an dim-dimensional vector that defines the coordinate location ([X,Y] in 2D, [X,Y,Z] in 3D). The data defining the node locations must be node centered.</p>
<p>An error results and the program will halt if:</p>
<ul>
<li>the patch data array index is invalid.</li>
<li>the depth of the patch data index is less than dim.</li>
</ul>
<p>If the nodal coordinates are not in a NodeData object on the hierarchy, you can use <a class="el" href="classSAMRAI_1_1appu_1_1VisItDataWriter.html#ae0e1ca908d4386cee2405d5b62692a76" title="This method registers a derived variable with the VisIt data writer.">registerDerivedPlotQuantity()</a> with the variable name of "Coords", the type of "VECTOR" and the variable_centering of "NODE".</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>patch_data_index</em>&nbsp;</td><td>patch data index of the coordinate data. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>start_depth_index</em>&nbsp;</td><td>(optional) start index for case where coordinate data is a subcomponent of a larger patch data vector</td></tr>
  </table>
  </dd>
</dl>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>patch_data_index &gt;= -1 </dd>
<dd>
start_depth_index &gt;= 0 </dd></dl>

<p>References <a class="el" href="VariableDatabase_8C_source.html#l00044">SAMRAI::hier::VariableDatabase::getDatabase()</a>, <a class="el" href="Dimension_8h_source.html#l00133">SAMRAI::tbox::Dimension::getValue()</a>, <a class="el" href="Utilities_8h_source.html#l00110">TBOX_ASSERT</a>, and <a class="el" href="Utilities_8h_source.html#l00060">TBOX_ERROR</a>.</p>

</div>
</div>
<a class="anchor" id="a01c0101c10011a41f25bd0bcfb4f5250"></a><!-- doxytag: member="SAMRAI::appu::VisItDataWriter::registerSingleNodeCoordinate" ref="a01c0101c10011a41f25bd0bcfb4f5250" args="(const int coordinate_number, const int patch_data_index, const int depth_index=0, const double scale_factor=1.0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::appu::VisItDataWriter::registerSingleNodeCoordinate </td>
          <td>(</td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>coordinate_number</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>patch_data_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>depth_index</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>scale_factor</em> = <code>1.0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Same as above method, but allows registration of single coordinate for deformed structured AMR grids (moving grids). </p>
<p>The coordinate number should be 0, 1, or 2 for X, Y, and Z directions, respectively. The patch data index must either be a scalar, or a vector with an appropriate depth index. A scale factor may be used to scale grid data.</p>
<p>If the nodal coordinates are not in a NodeData object on the hierarchy, you can use <a class="el" href="classSAMRAI_1_1appu_1_1VisItDataWriter.html#ae0e1ca908d4386cee2405d5b62692a76" title="This method registers a derived variable with the VisIt data writer.">registerDerivedPlotQuantity()</a> with the variable name of "Coords", the type of "VECTOR" and the variable_centering of "NODE".</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>coordinate_number</em>&nbsp;</td><td>must be 0 or 1 for 2D, or 0,1,2 for 3D. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>patch_data_index</em>&nbsp;</td><td>patch data index of the coordinate data. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>depth_index</em>&nbsp;</td><td>(optional) index for case where coordinate data is a subcomponent of a larger patch data vector </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>scale_factor</em>&nbsp;</td><td>scale factor with which to multiply coordinate data values</td></tr>
  </table>
  </dd>
</dl>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>(coordinate_number &gt;= 0) &amp;&amp; (coordinate_number &lt; d_dim.getValue()) </dd>
<dd>
patch_data_index &gt;= -1 </dd>
<dd>
depth_index &gt;= 0 </dd></dl>

<p>References <a class="el" href="VariableDatabase_8C_source.html#l00044">SAMRAI::hier::VariableDatabase::getDatabase()</a>, <a class="el" href="Dimension_8h_source.html#l00133">SAMRAI::tbox::Dimension::getValue()</a>, <a class="el" href="Utilities_8h_source.html#l00110">TBOX_ASSERT</a>, and <a class="el" href="Utilities_8h_source.html#l00060">TBOX_ERROR</a>.</p>

</div>
</div>
<a class="anchor" id="a4b1da68b0f276104f5e5a15b3e05f8a8"></a><!-- doxytag: member="SAMRAI::appu::VisItDataWriter::registerMaterialNames" ref="a4b1da68b0f276104f5e5a15b3e05f8a8" args="(const std::vector&lt; std::string &gt; &amp;material_names)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::appu::VisItDataWriter::registerMaterialNames </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>material_names</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This method registers with the VisIt data writer the names of materials being used in the simulation. </p>
<p>When a <a class="el" href="namespaceSAMRAI_1_1mesh.html">mesh</a> has materials defined over it, every cell will contain a fractional amount f (0 &lt;= f &lt;= 1.0) of every material, called a material fraction or volume fraction. The sum of all material fractions for every cell must be 1.0. Since materials are defined over a cell, each materials variable is assumed to be CELL centered.</p>
<p>In order to use materials with VisIt, the application class needs to inherit from <a class="el" href="classSAMRAI_1_1appu_1_1VisMaterialsDataStrategy.html" title="Class VisMaterialsDataStrategy is an abstract base class that defines an interface...">VisMaterialsDataStrategy</a>, an abstract base class which defines an interface for writing out various materials related fields. A concrete object of this strategy must be registered with the VisIt data writer. That concrete object is responsible for providing a concrete implementation of the method packMaterialFractionsIntoDoubleBuffer() which writes out the material fractions for each registered material over a given patch.</p>
<p>VisIt uses the material fractions to calculate interpolated material boundaries in cells with multiple materials. Therefore VisIt can display a material (or materials) as multiple colored contiguous regions. In addition, VisIt can intersect this volume field with a plane and get accurate 2D boundaries within cells. If desired, the material fractions for a material can be treated as a scalar field and the usual scalar field plot tools, such as pseudocolor and contour, can be applied.</p>
<p>Because species are a subset of materials, it is required that the material names be registered before any species names are registered. New materials may not be added during the simulation; that is, this method should only be called once.</p>
<p>An error results and the program will halt if:</p>
<ul>
<li>this method is called more than once.</li>
<li>the new <a class="el" href="classSAMRAI_1_1appu_1_1VisItDataWriter.html#a58683e422a15f3263bcddc8841796e55" title="This method registers with the VisIt data writer the names of materials being used...">registerSparseMaterialNames()</a> method is called</li>
<li>when assertion checking is active, the number of names = 0, or any material name string is empty.</li>
</ul>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>material_names</em>&nbsp;</td><td><a class="el" href="classSAMRAI_1_1tbox_1_1Array.html">tbox::Array</a> of strings: the names of the materials.</td></tr>
  </table>
  </dd>
</dl>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>material_names.size() &gt; 0 </dd>
<dd>
for each member of material_names, mn, !mn.empty() </dd>
<dd>
d_materials_names.size() == 0 </dd></dl>

<p>References <a class="el" href="Utilities_8h_source.html#l00110">TBOX_ASSERT</a>, and <a class="el" href="Utilities_8h_source.html#l00060">TBOX_ERROR</a>.</p>

</div>
</div>
<a class="anchor" id="a58683e422a15f3263bcddc8841796e55"></a><!-- doxytag: member="SAMRAI::appu::VisItDataWriter::registerSparseMaterialNames" ref="a58683e422a15f3263bcddc8841796e55" args="(const std::vector&lt; std::string &gt; &amp;material_names)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::appu::VisItDataWriter::registerSparseMaterialNames </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>material_names</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This method registers with the VisIt data writer the names of materials being used in the simulation. </p>
<p>When a <a class="el" href="namespaceSAMRAI_1_1mesh.html">mesh</a> has materials defined over it, every cell will contain a fractional amount f (0 &lt;= f &lt;= 1.0) of every material, called a material fraction or volume fraction. The sum of all material fractions for every cell must be 1.0. Since materials are defined over a cell, each materials variable is assumed to be CELL centered.</p>
<p>In order to use materials with VisIt, the application class needs to inherit from <a class="el" href="classSAMRAI_1_1appu_1_1VisMaterialsDataStrategy.html" title="Class VisMaterialsDataStrategy is an abstract base class that defines an interface...">VisMaterialsDataStrategy</a>, an abstract base class which defines an interface for writing out various materials related fields. A concrete object of this strategy must be registered with the VisIt data writer. That concrete object is responsible for providing a concrete implementation of the method packMaterialFractionsIntoSparseBuffers() which writes out the material fractions for each registered material over a given patch.</p>
<p>VisIt uses the material fractions to calculate interpolated material boundaries in cells with multiple materials. Therefore VisIt can display a material (or materials) as multiple colored contiguous regions. In addition, VisIt can intersect this volume field with a plane and get accurate 2D boundaries within cells. If desired, the material fractions for a material can be treated as a scalar field and the usual scalar field plot tools, such as pseudocolor and contour, can be applied.</p>
<p>An error results and the program will halt if:</p>
<ul>
<li>this method is called more than once.</li>
<li>the legacy <a class="el" href="classSAMRAI_1_1appu_1_1VisItDataWriter.html#a4b1da68b0f276104f5e5a15b3e05f8a8" title="This method registers with the VisIt data writer the names of materials being used...">registerMaterialNames()</a> method is called</li>
<li>when assertion checking is active, the number of names = 0, or any material name string is empty.</li>
</ul>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>material_names</em>&nbsp;</td><td><a class="el" href="classSAMRAI_1_1tbox_1_1Array.html">tbox::Array</a> of strings: the names of the materials.</td></tr>
  </table>
  </dd>
</dl>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>material_names.size() &gt; 0 </dd>
<dd>
for each member of material_names, mn, !mn.empty() </dd>
<dd>
d_materials_names.size() == 0 </dd></dl>

<p>References <a class="el" href="Utilities_8h_source.html#l00110">TBOX_ASSERT</a>, and <a class="el" href="Utilities_8h_source.html#l00060">TBOX_ERROR</a>.</p>

</div>
</div>
<a class="anchor" id="a895152bf4c8af5f0d3d20d43b8f63a4a"></a><!-- doxytag: member="SAMRAI::appu::VisItDataWriter::registerSpeciesNames" ref="a895152bf4c8af5f0d3d20d43b8f63a4a" args="(const std::string &amp;material_name, const std::vector&lt; std::string &gt; &amp;species_names)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::appu::VisItDataWriter::registerSpeciesNames </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>material_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>species_names</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This method registers the names of the species for a material_name with the VisIt data writer. </p>
<p>Species are subcomponents of a material. For example, a simulation with 4 materials (e.g. "copper", "gold", "liquid" and "gas") may have one of the materials (e.g. "gas") that is composed of multiple species (e.g. "nitrogen" and "helium"). Each species is associated with a particular material, so it is necessary that the "registerMaterialNames()" method is called before this method.</p>
<p>For each species name registered, there is an associated species fraction, which must be between 0 and 1.0 on each cell. The sum of the species fractions for all species of a given material must equal 1.0 in every cell in which that material appears. In VisIt, the species fractions for a species can be treated as a scalar field and the usual scalar plot operations applied to the field to show "concentrations". So, in the example described above, the percentage of nitrogen in the gas can be displayed in a pseudocolor plot.</p>
<p>In order to use species with VisIt, the application class needs to inherit from <a class="el" href="classSAMRAI_1_1appu_1_1VisMaterialsDataStrategy.html" title="Class VisMaterialsDataStrategy is an abstract base class that defines an interface...">VisMaterialsDataStrategy</a>, an abstract base class which defines an interface for writing out species related fields. A concrete object of the materials data strategy class is responsible for providing an implementation of the method packSpeciesFractionsIntoDoubleBuffer() to write out the species fractions field for each registered species over a given patch.</p>
<p>An error results and the program will halt if:</p>
<ul>
<li>this method is called before <a class="el" href="classSAMRAI_1_1appu_1_1VisItDataWriter.html#a4b1da68b0f276104f5e5a15b3e05f8a8" title="This method registers with the VisIt data writer the names of materials being used...">registerMaterialNames()</a> is called.</li>
<li>the supplied material name is not in the list of materials supplied in the <a class="el" href="classSAMRAI_1_1appu_1_1VisItDataWriter.html#a4b1da68b0f276104f5e5a15b3e05f8a8" title="This method registers with the VisIt data writer the names of materials being used...">registerMaterialNames()</a> method.</li>
<li>the method is called more than once for a given material</li>
<li>when assertion checking is active, the number of names = 0, or any name string is empty.</li>
</ul>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>material_name</em>&nbsp;</td><td>String name of the material whose species names are being registered. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>species_names</em>&nbsp;</td><td><a class="el" href="classSAMRAI_1_1tbox_1_1Array.html">tbox::Array</a> of strings: the names of the species for material_name.</td></tr>
  </table>
  </dd>
</dl>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>!material_name.empty() </dd>
<dd>
species_names.size() &gt; 0 </dd>
<dd>
d_materials_names.size() &gt; 0 </dd></dl>

<p>References <a class="el" href="Utilities_8h_source.html#l00110">TBOX_ASSERT</a>, and <a class="el" href="Utilities_8h_source.html#l00060">TBOX_ERROR</a>.</p>

</div>
</div>
<a class="anchor" id="ab9adaa4527f5028337efec539ae137c2"></a><!-- doxytag: member="SAMRAI::appu::VisItDataWriter::registerVisItExpressions" ref="ab9adaa4527f5028337efec539ae137c2" args="(const std::vector&lt; std::string &gt; &amp;expression_keys, const std::vector&lt; std::string &gt; &amp;expressions, const std::vector&lt; std::string &gt; &amp;expression_types)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::appu::VisItDataWriter::registerVisItExpressions </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>expression_keys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>expressions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>expression_types</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This method registers expressions that will be embedded in the VisIt datafiles. </p>
<p>The three Arrays of strings define the names (or keys) of the expressions, the expressions, and the types of the expressions (scalar, vector, tensor). For more information on defining VisIt expressions see the VisItUsersManual. </p>

</div>
</div>
<a class="anchor" id="abb8563ca251cb8fc5b1e7ae601730eee"></a><!-- doxytag: member="SAMRAI::appu::VisItDataWriter::writePlotData" ref="abb8563ca251cb8fc5b1e7ae601730eee" args="(const boost::shared_ptr&lt; hier::PatchHierarchy &gt; &amp;hierarchy, int time_step, double simulation_time=0.0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::appu::VisItDataWriter::writePlotData </td>
          <td>(</td>
          <td class="paramtype">const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchHierarchy.html">hier::PatchHierarchy</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>hierarchy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>time_step</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>simulation_time</em> = <code>0.0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This method causes the VisIt data writer to dump all registered data. The appropriate packing methods will be invoked for material-related data and derived data. </p>
<p>The time step number is used as a file name extension for the dump files. It must be non-negative and greater than the previous time step, if any. A simulation time may be provided as an optional argument. If this time is not specified, a default value of zero is used. The simulation time can be accessed in VisIt's "File Information" dialog box.</p>
<p>An error results and the program will halt if:</p>
<ul>
<li>materials have been registered, but <a class="el" href="classSAMRAI_1_1appu_1_1VisItDataWriter.html#a6c98c4d9c88136e523c8f44b662d0c26" title="This method sets the data writer to use for materials.">setMaterialsDataWriter()</a> has not been called.</li>
<li>the time step number is &lt;= the previous time step number.</li>
<li>when assertion checking is active, the hierarchy pointer is null, the time step is &lt; 0, or the dump directory name string is empty,</li>
</ul>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hierarchy</em>&nbsp;</td><td>A pointer to the patch hierarchy on which the data to be plotted is defined. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>time_step</em>&nbsp;</td><td>Non-negative integer value specifying the current time step number. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>simulation_time</em>&nbsp;</td><td>Optional argument specifying the double precision simulation time. Default is 0.0.</td></tr>
  </table>
  </dd>
</dl>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>hierarchy </dd>
<dd>
time_step_number &gt;= 0 </dd>
<dd>
!d_top_level_directory_name.empty() </dd></dl>

<p>References <a class="el" href="Utilities_8h_source.html#l00110">TBOX_ASSERT</a>, and <a class="el" href="Utilities_8h_source.html#l00060">TBOX_ERROR</a>.</p>

</div>
</div>
<a class="anchor" id="a303784551016695618fbae5e4b89f5bf"></a><!-- doxytag: member="SAMRAI::appu::VisItDataWriter::setSummaryFilename" ref="a303784551016695618fbae5e4b89f5bf" args="(std::string &amp;filename)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::appu::VisItDataWriter::setSummaryFilename </td>
          <td>(</td>
          <td class="paramtype">std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>filename</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set the name of the summary file. </p>
<p>This sets the summary file written at each step of the simulation which describes the data contained in the visit files written by each MPI process. The supplied string is appended with ".samrai" so the actual name of the file will be "&lt;filename&gt;.samrai". If no alternative name is supplied, by default the summary file used is "summary.samrai".</p>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>!filename.empty() </dd></dl>

<p>References <a class="el" href="Utilities_8h_source.html#l00110">TBOX_ASSERT</a>.</p>

</div>
</div>
<a class="anchor" id="ad90d0b1c6a001b44240cec18fdbc9162"></a><!-- doxytag: member="SAMRAI::appu::VisItDataWriter::getObjectName" ref="ad90d0b1c6a001b44240cec18fdbc9162" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::string&amp; SAMRAI::appu::VisItDataWriter::getObjectName </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the object name. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>The object name. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>source/SAMRAI/appu/<a class="el" href="VisItDataWriter_8h.html">VisItDataWriter.h</a></li>
<li>source/SAMRAI/appu/<a class="el" href="VisItDataWriter_8C.html">VisItDataWriter.C</a></li>
</ul>
</div>
<hr size="1"/><address style="text-align: right;"><small>Generated on 26 Jun 2014 for SAMRAI by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.1 </small></address>
</body>
</html>
