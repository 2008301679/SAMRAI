<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>SAMRAI: SAMRAI::appu::VisDerivedDataStrategy Class Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.7 -->
<div class="tabs">
  <ul>
    <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="namespaces.html"><span>Namespaces</span></a></li>
    <li id="current"><a href="annotated.html"><span>Classes</span></a></li>
    <li><a href="files.html"><span>Files</span></a></li>
    <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
  </ul></div>
<div class="tabs">
  <ul>
    <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
    <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
    <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
  </ul></div>
<div class="nav">
<a class="el" href="namespaceSAMRAI.html">SAMRAI</a>::<a class="el" href="namespaceSAMRAI_1_1appu.html">appu</a>::<a class="el" href="classSAMRAI_1_1appu_1_1VisDerivedDataStrategy.html">VisDerivedDataStrategy</a></div>
<h1>SAMRAI::appu::VisDerivedDataStrategy Class Reference</h1><!-- doxytag: class="SAMRAI::appu::VisDerivedDataStrategy" -->Class <a class="el" href="classSAMRAI_1_1appu_1_1VisDerivedDataStrategy.html">VisDerivedDataStrategy</a> is an abstract base class that defines an interface allowing an <a class="el" href="classSAMRAI_1_1appu_1_1VisItDataWriter.html">VisItDataWriter</a> object to generate plot files that contain "derived" quantities; that is, data that does not reside on the hierarchy, but which is derived from data that does reside on the hierarchy. The derived data may be scalar, vector, or tensor, and cell-centered or node-centered. A concrete object of this type must be registered with the data writer if any derived variable is registered with the data writer. The registration of the concrete strategy object may be done independently using the method setDefaultDerivedDataWriter() from the relevant DataWriter class, or the concrete strategy object may be registered concurrently with the derived variable using the method registerDerivedPlotScalar/Vector/Tensor().  
<a href="#_details">More...</a>
<p>
<code>#include &lt;source/SAMRAI/appu/VisDerivedDataStrategy.h&gt;</code>
<p>
<a href="classSAMRAI_1_1appu_1_1VisDerivedDataStrategy-members.html">List of all members.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1appu_1_1VisDerivedDataStrategy.html#7a76f1cc6335c3ede2a513a07c8abdc4">VisDerivedDataStrategy</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Default constructor for <a class="el" href="classSAMRAI_1_1appu_1_1VisDerivedDataStrategy.html">VisDerivedDataStrategy</a>.  <a href="#7a76f1cc6335c3ede2a513a07c8abdc4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1appu_1_1VisDerivedDataStrategy.html#50f67bf4ee4cf6b86b514a92c5c9cf98">~VisDerivedDataStrategy</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Destructor for <a class="el" href="classSAMRAI_1_1appu_1_1VisDerivedDataStrategy.html">VisDerivedDataStrategy</a>.  <a href="#50f67bf4ee4cf6b86b514a92c5c9cf98"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1appu_1_1VisDerivedDataStrategy.html#86eb0cb786918c3683d54b96844b08c3">packDerivedDataIntoDoubleBuffer</a> (double *buffer, const <a class="el" href="classSAMRAI_1_1hier_1_1Patch.html">hier::Patch</a> &amp;patch, const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">hier::Box</a> &amp;region, const std::string &amp;variable_name, int depth_index, double simulation_time=0.0) const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This function calculates and packs derived cell-centered data to a 1D double precision buffer. In the case of the VisIt data writer, node-centered data may also be used. It is called once for each component of multicomponent data.  <a href="#86eb0cb786918c3683d54b96844b08c3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1appu_1_1VisDerivedDataStrategy.html#45083218cdd8220f0894d5337b33cc58">packMixedDerivedDataIntoDoubleBuffer</a> (double *buffer, std::vector&lt; double &gt; &amp;mixbuffer, const <a class="el" href="classSAMRAI_1_1hier_1_1Patch.html">hier::Patch</a> &amp;patch, const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">hier::Box</a> &amp;region, const std::string &amp;variable_name, int depth_index) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This function calculates and packs derived cell-centered data to a 1D double precision buffer. It also packs material state varaibles for component materials in mixed zones for accurate visualization of mixed zones. In the case of the VisIt data writer, node-centered data may also be used. It is called once for each component of multicomponent data.  <a href="#45083218cdd8220f0894d5337b33cc58"></a><br></td></tr>
</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
Class <a class="el" href="classSAMRAI_1_1appu_1_1VisDerivedDataStrategy.html">VisDerivedDataStrategy</a> is an abstract base class that defines an interface allowing an <a class="el" href="classSAMRAI_1_1appu_1_1VisItDataWriter.html">VisItDataWriter</a> object to generate plot files that contain "derived" quantities; that is, data that does not reside on the hierarchy, but which is derived from data that does reside on the hierarchy. The derived data may be scalar, vector, or tensor, and cell-centered or node-centered. A concrete object of this type must be registered with the data writer if any derived variable is registered with the data writer. The registration of the concrete strategy object may be done independently using the method setDefaultDerivedDataWriter() from the relevant DataWriter class, or the concrete strategy object may be registered concurrently with the derived variable using the method registerDerivedPlotScalar/Vector/Tensor(). 
<p>
The concrete strategy object is responsible for supplying an implementation of the function <a class="el" href="classSAMRAI_1_1appu_1_1VisDerivedDataStrategy.html#86eb0cb786918c3683d54b96844b08c3">packDerivedDataIntoDoubleBuffer()</a> which calculates the derived data and writes it into the double precision buffer passed in to it.<p>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classSAMRAI_1_1appu_1_1VisItDataWriter.html">appu::VisItDataWriter</a> </dd></dl>

<p>
<hr><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" name="7a76f1cc6335c3ede2a513a07c8abdc4"></a><!-- doxytag: member="SAMRAI::appu::VisDerivedDataStrategy::VisDerivedDataStrategy" ref="7a76f1cc6335c3ede2a513a07c8abdc4" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SAMRAI::appu::VisDerivedDataStrategy::VisDerivedDataStrategy           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Default constructor for <a class="el" href="classSAMRAI_1_1appu_1_1VisDerivedDataStrategy.html">VisDerivedDataStrategy</a>. 
<p>

</div>
</div><p>
<a class="anchor" name="50f67bf4ee4cf6b86b514a92c5c9cf98"></a><!-- doxytag: member="SAMRAI::appu::VisDerivedDataStrategy::~VisDerivedDataStrategy" ref="50f67bf4ee4cf6b86b514a92c5c9cf98" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SAMRAI::appu::VisDerivedDataStrategy::~VisDerivedDataStrategy           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Destructor for <a class="el" href="classSAMRAI_1_1appu_1_1VisDerivedDataStrategy.html">VisDerivedDataStrategy</a>. 
<p>

</div>
</div><p>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="86eb0cb786918c3683d54b96844b08c3"></a><!-- doxytag: member="SAMRAI::appu::VisDerivedDataStrategy::packDerivedDataIntoDoubleBuffer" ref="86eb0cb786918c3683d54b96844b08c3" args="(double *buffer, const hier::Patch &amp;patch, const hier::Box &amp;region, const std::string &amp;variable_name, int depth_index, double simulation_time=0.0) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool SAMRAI::appu::VisDerivedDataStrategy::packDerivedDataIntoDoubleBuffer           </td>
          <td>(</td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1Patch.html">hier::Patch</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>patch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">hier::Box</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>region</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>variable_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>depth_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>simulation_time</em> = <code>0.0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function calculates and packs derived cell-centered data to a 1D double precision buffer. In the case of the VisIt data writer, node-centered data may also be used. It is called once for each component of multicomponent data. 
<p>
The buffer will be already allocated. This routine is needed to construct data values that are not stored on the hierarchy, but which may be important to visualize. The data to be packed corresponds to the plot variable that the user has registered with the data writer using registerDerivedPlotScalar/Vector/Tensor() with the std::string "variable_name". The data to be packed is derived from the data that lives on the given patch. The box describes the patch region over which to pack the data. It is assumed that all data needed to compute the derived quantity exists on the given patch.<p>
The method <a class="el" href="classSAMRAI_1_1appu_1_1VisDerivedDataStrategy.html#86eb0cb786918c3683d54b96844b08c3">packDerivedDataIntoDoubleBuffer()</a> will be called DIM times for vector data, and DIM*DIM times for tensor data, with the integer "depth_index" argument indicating the particular component of vector to be packed. For scalar values, the depth_index will be 0.<p>
This routine must include ghost data if the ghost_cell_width parameter was set when the derived data was registered. The data must be packed into the buffer in column major order, the ordering used by <a class="el" href="namespaceSAMRAI.html">SAMRAI</a>, i.e. (f(x_0,y_0,z_0), f(x_1,y_0,z_0), f(x_2,y_0,z_0), ...). If the derived data was registered as node-centered, a buffer of node-centered data is expected. Derived data need not be defined on all patches. It is the responsibility of this routine to determine if data exists on the patch and set the return value of of this routine appropriately: true if the data exists on the patch, false otherwise.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>buffer</em>&nbsp;</td><td>Double precision array into which derived data is packed. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>patch</em>&nbsp;</td><td><a class="el" href="classSAMRAI_1_1hier_1_1Patch.html">hier::Patch</a> on which to calculate and pack derived data. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>region</em>&nbsp;</td><td><a class="el" href="classSAMRAI_1_1hier_1_1Box.html">hier::Box</a> region over which to pack data. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>variable_name</em>&nbsp;</td><td>Name identifier for the derived variable as registered in registerDerivedPlotScalar/Vector/Tensor(). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>depth_index</em>&nbsp;</td><td>For scalar quantities index will be zero. For vector data, index varies between 0 and DIM-1. For tensor data, index varies from 0 (DIM*DIM)-1. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>simulation_time</em>&nbsp;</td><td>Optional argument specifying the double precision simulation time. Default is 0.0. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Boolean value indicating if derived data defined on this patch. </dd></dl>

</div>
</div><p>
<a class="anchor" name="45083218cdd8220f0894d5337b33cc58"></a><!-- doxytag: member="SAMRAI::appu::VisDerivedDataStrategy::packMixedDerivedDataIntoDoubleBuffer" ref="45083218cdd8220f0894d5337b33cc58" args="(double *buffer, std::vector&lt; double &gt; &amp;mixbuffer, const hier::Patch &amp;patch, const hier::Box &amp;region, const std::string &amp;variable_name, int depth_index) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SAMRAI::appu::VisDerivedDataStrategy::packMixedDerivedDataIntoDoubleBuffer           </td>
          <td>(</td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>mixbuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1Patch.html">hier::Patch</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>patch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">hier::Box</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>region</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>variable_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>depth_index</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function calculates and packs derived cell-centered data to a 1D double precision buffer. It also packs material state varaibles for component materials in mixed zones for accurate visualization of mixed zones. In the case of the VisIt data writer, node-centered data may also be used. It is called once for each component of multicomponent data. 
<p>
The buffer will be already allocated and an empty vector will be provided. This routine is needed to construct data values that are not stored on the hierarchy, but which may be important to visualize. The data to be packed corresponds to the plot variable that the user has registered with the data writer using registerDerivedPlotScalar/Vector/Tensor() with the string "variable_name". The data to be packed is derived from the data that lives on the given patch. The box describes the patch region over which&gt; * to pack the data. It is assumed that all data needed to compute the derived quantity exists on the given patch.<p>
The method <a class="el" href="classSAMRAI_1_1appu_1_1VisDerivedDataStrategy.html#45083218cdd8220f0894d5337b33cc58">packMixedDerivedDataIntoDoubleBuffer()</a> will be called DIM times for vector data, and DIM*DIM times for tensor data, with the integer "depth_index" argument indicating the particular component of vector to be packed. For scalar values, the depth_index will be 0.<p>
This routine must include ghost data if the ghost_cell_width parameter was set when the derived data was registered. The data must be packed into the buffer in column major order, the ordering used by <a class="el" href="namespaceSAMRAI.html">SAMRAI</a>, i.e. (f(x_0,y_0,z_0), f(x_1,y_0,z_0), f(x_2,y_0,z_0), ...). If the derived data was registered as node-centered, a buffer of node-centered data is expected. Derived data need not be defined on all patches. It is the responsibility of this routine to determine if data exists on the patch and set the return value of of this routine appropriately: true if the data exists on the patch, false otherwise.<p>
Mixed data should be packed in a sparse manner (i.e., only for cells that are mixed) in the same column major order and following the ordering of materials specified when registerMaterialNames() or registerSparseMaterialNames() was called.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>buffer</em>&nbsp;</td><td>Double precision array into which derived data is packed. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>mixbuffer</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>patch</em>&nbsp;</td><td><a class="el" href="classSAMRAI_1_1hier_1_1Patch.html">hier::Patch</a> on which to calculate and pack derived data. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>region</em>&nbsp;</td><td><a class="el" href="classSAMRAI_1_1hier_1_1Box.html">hier::Box</a> region over which to pack data. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>variable_name</em>&nbsp;</td><td>Name identifier for the derived variable as registered in registerDerivedPlotScalar/Vector/Tensor(). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>depth_index</em>&nbsp;</td><td>For scalar quantities index will be zero. For vector data, index varies between 0 and DIM-1. For tensor data, index varies from 0 (DIM*DIM)-1. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Boolean value indicating if derived data defined on this patch. </dd></dl>

</div>
</div><p>
<hr>The documentation for this class was generated from the following files:<ul>
<li>source/SAMRAI/appu/<a class="el" href="VisDerivedDataStrategy_8h.html">VisDerivedDataStrategy.h</a><li>source/SAMRAI/appu/<a class="el" href="VisDerivedDataStrategy_8C.html">VisDerivedDataStrategy.C</a></ul>
<hr size="1"><address style="align: right;"><small>Generated on 3 Mar 2015 for SAMRAI by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.7 </small></address>
</body>
</html>
