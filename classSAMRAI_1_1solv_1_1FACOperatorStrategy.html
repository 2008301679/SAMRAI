<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>SAMRAI: SAMRAI::solv::FACOperatorStrategy Class Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.7 -->
<div class="tabs">
  <ul>
    <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="namespaces.html"><span>Namespaces</span></a></li>
    <li id="current"><a href="annotated.html"><span>Classes</span></a></li>
    <li><a href="files.html"><span>Files</span></a></li>
    <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
  </ul></div>
<div class="tabs">
  <ul>
    <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
    <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
    <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
  </ul></div>
<div class="nav">
<a class="el" href="namespaceSAMRAI.html">SAMRAI</a>::<a class="el" href="namespaceSAMRAI_1_1solv.html">solv</a>::<a class="el" href="classSAMRAI_1_1solv_1_1FACOperatorStrategy.html">FACOperatorStrategy</a></div>
<h1>SAMRAI::solv::FACOperatorStrategy Class Reference</h1><!-- doxytag: class="SAMRAI::solv::FACOperatorStrategy" -->Defines a Strategy pattern interface to problem-specific operations needed to implement the FAC preconditioner algorithm.  
<a href="#_details">More...</a>
<p>
<code>#include &lt;source/SAMRAI/solv/FACOperatorStrategy.h&gt;</code>
<p>
<p>Inheritance diagram for SAMRAI::solv::FACOperatorStrategy:
<p><center><img src="classSAMRAI_1_1solv_1_1FACOperatorStrategy.png" usemap="#SAMRAI::solv::FACOperatorStrategy_map" border="0" alt=""></center>
<map name="SAMRAI::solv::FACOperatorStrategy_map">
<area href="classSAMRAI_1_1solv_1_1CellPoissonFACOps.html" alt="SAMRAI::solv::CellPoissonFACOps" shape="rect" coords="0,56,219,80">
</map>
<a href="classSAMRAI_1_1solv_1_1FACOperatorStrategy-members.html">List of all members.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1FACOperatorStrategy.html#dfeec8b88ff2587a6673a71031338b20">FACOperatorStrategy</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Empty constructor.  <a href="#dfeec8b88ff2587a6673a71031338b20"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1FACOperatorStrategy.html#e60cb0c7e6819078738665aac8eada15">~FACOperatorStrategy</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Virtual destructor.  <a href="#e60cb0c7e6819078738665aac8eada15"></a><br></td></tr>
<tr><td colspan="2"><div class="groupHeader">Operator-dependent virtual methods</div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1FACOperatorStrategy.html#5030937d907996a88c7190d87e2fd89e">restrictSolution</a> (const <a class="el" href="classSAMRAI_1_1solv_1_1SAMRAIVectorReal.html">SAMRAIVectorReal</a>&lt; double &gt; &amp;source, <a class="el" href="classSAMRAI_1_1solv_1_1SAMRAIVectorReal.html">SAMRAIVectorReal</a>&lt; double &gt; &amp;dest, int dest_ln)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Restrict the solution quantity to the specified level from the next finer level.  <a href="#5030937d907996a88c7190d87e2fd89e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1FACOperatorStrategy.html#39ad805a6e850d759239166842d02be7">restrictResidual</a> (const <a class="el" href="classSAMRAI_1_1solv_1_1SAMRAIVectorReal.html">SAMRAIVectorReal</a>&lt; double &gt; &amp;source, <a class="el" href="classSAMRAI_1_1solv_1_1SAMRAIVectorReal.html">SAMRAIVectorReal</a>&lt; double &gt; &amp;dest, int dest_ln)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Restrict the residual quantity to the specified level from the next finer level.  <a href="#39ad805a6e850d759239166842d02be7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1FACOperatorStrategy.html#23e9def6e2f18a274a0636820e96f17a">prolongErrorAndCorrect</a> (const <a class="el" href="classSAMRAI_1_1solv_1_1SAMRAIVectorReal.html">SAMRAIVectorReal</a>&lt; double &gt; &amp;source, <a class="el" href="classSAMRAI_1_1solv_1_1SAMRAIVectorReal.html">SAMRAIVectorReal</a>&lt; double &gt; &amp;dest, int dest_ln)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Prolong the error quantity to the specified level from the next coarser level and apply the correction to the fine-level error.  <a href="#23e9def6e2f18a274a0636820e96f17a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1FACOperatorStrategy.html#efd99edc26ae9390c63a4f67d03fe280">smoothError</a> (<a class="el" href="classSAMRAI_1_1solv_1_1SAMRAIVectorReal.html">SAMRAIVectorReal</a>&lt; double &gt; &amp;error, const <a class="el" href="classSAMRAI_1_1solv_1_1SAMRAIVectorReal.html">SAMRAIVectorReal</a>&lt; double &gt; &amp;residual, int ln, int num_sweeps)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Perform a given number of relaxations on the error.  <a href="#efd99edc26ae9390c63a4f67d03fe280"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1FACOperatorStrategy.html#2a1b36e8d09e7639541c5bb05e3d33f9">solveCoarsestLevel</a> (<a class="el" href="classSAMRAI_1_1solv_1_1SAMRAIVectorReal.html">SAMRAIVectorReal</a>&lt; double &gt; &amp;error, const <a class="el" href="classSAMRAI_1_1solv_1_1SAMRAIVectorReal.html">SAMRAIVectorReal</a>&lt; double &gt; &amp;residual, int coarsest_ln)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Solve the residual equation Ae=r on the coarsest level in the FAC iteration.  <a href="#2a1b36e8d09e7639541c5bb05e3d33f9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1FACOperatorStrategy.html#6c5f405d18477a61e41e62d4d68af5c8">computeCompositeResidualOnLevel</a> (<a class="el" href="classSAMRAI_1_1solv_1_1SAMRAIVectorReal.html">SAMRAIVectorReal</a>&lt; double &gt; &amp;residual, const <a class="el" href="classSAMRAI_1_1solv_1_1SAMRAIVectorReal.html">SAMRAIVectorReal</a>&lt; double &gt; &amp;solution, const <a class="el" href="classSAMRAI_1_1solv_1_1SAMRAIVectorReal.html">SAMRAIVectorReal</a>&lt; double &gt; &amp;rhs, int ln, bool error_equation_indicator)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute composite grid residual on a single level.  <a href="#6c5f405d18477a61e41e62d4d68af5c8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1FACOperatorStrategy.html#bc03df2bcd01320f9d482aee213a684a">computeResidualNorm</a> (const <a class="el" href="classSAMRAI_1_1solv_1_1SAMRAIVectorReal.html">SAMRAIVectorReal</a>&lt; double &gt; &amp;residual, int fine_ln, int coarse_ln)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute the norm of the residual quantity.  <a href="#bc03df2bcd01320f9d482aee213a684a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1FACOperatorStrategy.html#8bbf9cd1d5417272cfaa20c68f8f90d4">postprocessOneCycle</a> (int fac_cycle_num, const <a class="el" href="classSAMRAI_1_1solv_1_1SAMRAIVectorReal.html">SAMRAIVectorReal</a>&lt; double &gt; &amp;current_soln, const <a class="el" href="classSAMRAI_1_1solv_1_1SAMRAIVectorReal.html">SAMRAIVectorReal</a>&lt; double &gt; &amp;residual)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Regular call back routine to be called after each FAC cycle.  <a href="#8bbf9cd1d5417272cfaa20c68f8f90d4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1FACOperatorStrategy.html#dfa77ec960a1855561aa7bfe7fe3ae4c">initializeOperatorState</a> (const <a class="el" href="classSAMRAI_1_1solv_1_1SAMRAIVectorReal.html">SAMRAIVectorReal</a>&lt; double &gt; &amp;solution, const <a class="el" href="classSAMRAI_1_1solv_1_1SAMRAIVectorReal.html">SAMRAIVectorReal</a>&lt; double &gt; &amp;rhs)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute hierarchy-dependent data if any is required.  <a href="#dfa77ec960a1855561aa7bfe7fe3ae4c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1solv_1_1FACOperatorStrategy.html#b1a9e2eef933ee70d5aed9e7a0274a1a">deallocateOperatorState</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Remove all hierarchy-dependent data.  <a href="#b1a9e2eef933ee70d5aed9e7a0274a1a"></a><br></td></tr>
</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
Defines a Strategy pattern interface to problem-specific operations needed to implement the FAC preconditioner algorithm. 
<p>
The <a class="el" href="classSAMRAI_1_1solv_1_1FACPreconditioner.html">FACPreconditioner</a> constructor accepts a concrete implementation of this interface and calls the concrete implementations of the virtual functions declared herein during the solution process.<p>
All vector arguments in these interfaces are guaranteed to be either the vectors given to in <a class="el" href="classSAMRAI_1_1solv_1_1FACPreconditioner.html#77e53855e38169cdc9e9ebdd256c15c1">FACPreconditioner::solveSystem()</a> or <a class="el" href="classSAMRAI_1_1solv_1_1FACPreconditioner.html#144d6bbf397572a9dde823a1dbe38762">FACPreconditioner::initializeSolverState()</a> or vectors cloned from them.<p>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classSAMRAI_1_1solv_1_1FACPreconditioner.html">solv::FACPreconditioner</a> </dd></dl>

<p>
<hr><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" name="dfeec8b88ff2587a6673a71031338b20"></a><!-- doxytag: member="SAMRAI::solv::FACOperatorStrategy::FACOperatorStrategy" ref="dfeec8b88ff2587a6673a71031338b20" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SAMRAI::solv::FACOperatorStrategy::FACOperatorStrategy           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Empty constructor. 
<p>

</div>
</div><p>
<a class="anchor" name="e60cb0c7e6819078738665aac8eada15"></a><!-- doxytag: member="SAMRAI::solv::FACOperatorStrategy::~FACOperatorStrategy" ref="e60cb0c7e6819078738665aac8eada15" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SAMRAI::solv::FACOperatorStrategy::~FACOperatorStrategy           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Virtual destructor. 
<p>

</div>
</div><p>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="5030937d907996a88c7190d87e2fd89e"></a><!-- doxytag: member="SAMRAI::solv::FACOperatorStrategy::restrictSolution" ref="5030937d907996a88c7190d87e2fd89e" args="(const SAMRAIVectorReal&lt; double &gt; &amp;source, SAMRAIVectorReal&lt; double &gt; &amp;dest, int dest_ln)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void SAMRAI::solv::FACOperatorStrategy::restrictSolution           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1solv_1_1SAMRAIVectorReal.html">SAMRAIVectorReal</a>&lt; double &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1solv_1_1SAMRAIVectorReal.html">SAMRAIVectorReal</a>&lt; double &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>dest_ln</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Restrict the solution quantity to the specified level from the next finer level. 
<p>
Restrict the residual data to level dest_ln in the destination vector d, from level dest_ln+1 in the source vector s.<p>
Can assume:<ol type=1>
<li>dest_ln is not the finest level in the range being solved.</li><li>corresponding solution has been computed on level dest_ln+1.</li><li>the source and destination residual vectors (s and d) may or may not be the same. (This function must work in either case.)</li></ol>
<p>
Upon return from this function, the solution on the refined region of the coarse level will represent the coarsened version of the fine solution in a manner that is consistent with the linear system approximation on the composite grid. This function must not change the solution values anywhere except on level dest_ln of the destination vector.<p>
The source and destination vectors may be the same.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>source</em>&nbsp;</td><td>source solution </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dest</em>&nbsp;</td><td>destination solution </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dest_ln</em>&nbsp;</td><td>destination level number </td></tr>
  </table>
</dl>

<p>
Implemented in <a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonFACOps.html#519af350efc4c727346d102c9de49c3a">SAMRAI::solv::CellPoissonFACOps</a>.
</div>
</div><p>
<a class="anchor" name="39ad805a6e850d759239166842d02be7"></a><!-- doxytag: member="SAMRAI::solv::FACOperatorStrategy::restrictResidual" ref="39ad805a6e850d759239166842d02be7" args="(const SAMRAIVectorReal&lt; double &gt; &amp;source, SAMRAIVectorReal&lt; double &gt; &amp;dest, int dest_ln)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void SAMRAI::solv::FACOperatorStrategy::restrictResidual           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1solv_1_1SAMRAIVectorReal.html">SAMRAIVectorReal</a>&lt; double &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1solv_1_1SAMRAIVectorReal.html">SAMRAIVectorReal</a>&lt; double &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>dest_ln</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Restrict the residual quantity to the specified level from the next finer level. 
<p>
Restrict the residual data to level dest_ln in the destination vector d, from level dest_ln+1 in the source vector s.<p>
Can assume:<ol type=1>
<li>dest_ln is not the finest level in the range being solved.</li><li>correspnding residual has been computed on level dest_ln+1.</li><li>the source and destination residual vectors (s and d) may or may not be the same. (This function must work in either case.)</li></ol>
<p>
Upon return from this function, the residual on the refined region of the coarse level will represent the coarsened version of the fine residual in a manner that is consistent with the linear system approximation on the composite grid. This function must not change the residual values anywhere except on level dest_ln of the destination vector.<p>
The source and destination vectors may be the same.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>source</em>&nbsp;</td><td>source residual </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dest</em>&nbsp;</td><td>destination residual </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dest_ln</em>&nbsp;</td><td>destination level number </td></tr>
  </table>
</dl>

<p>
Implemented in <a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonFACOps.html#9a76c90308783470ee687e9a68777681">SAMRAI::solv::CellPoissonFACOps</a>.
</div>
</div><p>
<a class="anchor" name="23e9def6e2f18a274a0636820e96f17a"></a><!-- doxytag: member="SAMRAI::solv::FACOperatorStrategy::prolongErrorAndCorrect" ref="23e9def6e2f18a274a0636820e96f17a" args="(const SAMRAIVectorReal&lt; double &gt; &amp;source, SAMRAIVectorReal&lt; double &gt; &amp;dest, int dest_ln)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void SAMRAI::solv::FACOperatorStrategy::prolongErrorAndCorrect           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1solv_1_1SAMRAIVectorReal.html">SAMRAIVectorReal</a>&lt; double &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1solv_1_1SAMRAIVectorReal.html">SAMRAIVectorReal</a>&lt; double &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>dest_ln</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Prolong the error quantity to the specified level from the next coarser level and apply the correction to the fine-level error. 
<p>
On the part of the coarse level that does <em>not</em> overlap the fine level, the error is the corection to Au=f.<p>
On the part of the coarse level that <em>does</em> overlap the fine level, the error is the corection to Ae=r of the fine level.<p>
This function should apply the coarse-level correction to the fine level, that is <p class="formulaDsp">
<img class="formulaDsp" alt="\[ e^{fine} \leftarrow e^{fine} + I^{fine}_{coarse} e^{coarse} \]" src="form_58.png">
<p>
<p>
<b>Note:</b> You probably have to store the refined error in a temporary location before adding it to the current error.<p>
The array of boundary information contains a description of the coarse-fine level boundary for each patch on the level; the boundary information for patch N is obtained as the N-th element in the array, coarse_fine_boundary[N].<p>
Upon return from this function, the error on the fine level must represent the correction to the solution on that level. Also, this function must not change the error values on the coarse level.<p>
The source and destination vectors may be the same.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>source</em>&nbsp;</td><td>source error vector </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dest</em>&nbsp;</td><td>destination error vector </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dest_ln</em>&nbsp;</td><td>destination level number of data transfer </td></tr>
  </table>
</dl>

<p>
Implemented in <a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonFACOps.html#039613b32f29f73b7f2e12f9d14080ac">SAMRAI::solv::CellPoissonFACOps</a>.
</div>
</div><p>
<a class="anchor" name="efd99edc26ae9390c63a4f67d03fe280"></a><!-- doxytag: member="SAMRAI::solv::FACOperatorStrategy::smoothError" ref="efd99edc26ae9390c63a4f67d03fe280" args="(SAMRAIVectorReal&lt; double &gt; &amp;error, const SAMRAIVectorReal&lt; double &gt; &amp;residual, int ln, int num_sweeps)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void SAMRAI::solv::FACOperatorStrategy::smoothError           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1solv_1_1SAMRAIVectorReal.html">SAMRAIVectorReal</a>&lt; double &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>error</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1solv_1_1SAMRAIVectorReal.html">SAMRAIVectorReal</a>&lt; double &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>residual</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>ln</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>num_sweeps</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Perform a given number of relaxations on the error. 
<p>
Relax the residual equation Ae=r by applying the given number of smoothing sweeps on the specified level. The relaxation may ignore the possible existence of finer levels on a given level.<p>
The array of boundary information contains a description of the coarse-fine level boundary for each patch on the level; the boundary information for patch N is obtained as the N-th element in the array, coarse_fine_boundary[N].<p>
May assume:<ul>
<li>If intermediate data from level l+1 is needed (for example, to match flux at coarse-fine boundaries), that data is already computed and stored on level l+1.</li><li>The error in the next finer level has been computed and stored there.</li></ul>
<p>
Steps for each iteration.<ol type=1>
<li>Fill ghost boundaries</li><li>Compute intermediate data (if needed) and coarsen intermediate data stored in level l+1 (if needed).</li><li>Perform relaxation step (update e toward a better approximation).</li></ol>
<p>
Final step before leaving function.<ul>
<li>If needed, compute and store intermediate data for next coarser level l-1.</li></ul>
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>error</em>&nbsp;</td><td>error vector </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>residual</em>&nbsp;</td><td>residual vector </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ln</em>&nbsp;</td><td>level number </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>num_sweeps</em>&nbsp;</td><td>number of sweeps </td></tr>
  </table>
</dl>

<p>
Implemented in <a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonFACOps.html#83625dda387afc4b50a9359967990b96">SAMRAI::solv::CellPoissonFACOps</a>.
</div>
</div><p>
<a class="anchor" name="2a1b36e8d09e7639541c5bb05e3d33f9"></a><!-- doxytag: member="SAMRAI::solv::FACOperatorStrategy::solveCoarsestLevel" ref="2a1b36e8d09e7639541c5bb05e3d33f9" args="(SAMRAIVectorReal&lt; double &gt; &amp;error, const SAMRAIVectorReal&lt; double &gt; &amp;residual, int coarsest_ln)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int SAMRAI::solv::FACOperatorStrategy::solveCoarsestLevel           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1solv_1_1SAMRAIVectorReal.html">SAMRAIVectorReal</a>&lt; double &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>error</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1solv_1_1SAMRAIVectorReal.html">SAMRAIVectorReal</a>&lt; double &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>residual</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>coarsest_ln</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Solve the residual equation Ae=r on the coarsest level in the FAC iteration. 
<p>
Here e is the given error quantity and r is the given residual quantity. The array of boundary information contains a description of the coarse-fine level boundary for each patch on the level; the boundary information for patch N is obtained as the N-th element in the array, coarse_fine_boundary[N].<p>
This routine must fill boundary values for given solution quantity on all patches on the specified level before the solve is performed.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>error</em>&nbsp;</td><td>error vector </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>residual</em>&nbsp;</td><td>residual vector </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>coarsest_ln</em>&nbsp;</td><td>coarsest level number </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>0 if solver converged to specified level, nonzero otherwise. </dd></dl>

<p>
Implemented in <a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonFACOps.html#f0def579f9a4ffa10dd39f89a4b63245">SAMRAI::solv::CellPoissonFACOps</a>.
</div>
</div><p>
<a class="anchor" name="6c5f405d18477a61e41e62d4d68af5c8"></a><!-- doxytag: member="SAMRAI::solv::FACOperatorStrategy::computeCompositeResidualOnLevel" ref="6c5f405d18477a61e41e62d4d68af5c8" args="(SAMRAIVectorReal&lt; double &gt; &amp;residual, const SAMRAIVectorReal&lt; double &gt; &amp;solution, const SAMRAIVectorReal&lt; double &gt; &amp;rhs, int ln, bool error_equation_indicator)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void SAMRAI::solv::FACOperatorStrategy::computeCompositeResidualOnLevel           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1solv_1_1SAMRAIVectorReal.html">SAMRAIVectorReal</a>&lt; double &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>residual</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1solv_1_1SAMRAIVectorReal.html">SAMRAIVectorReal</a>&lt; double &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>solution</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1solv_1_1SAMRAIVectorReal.html">SAMRAIVectorReal</a>&lt; double &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>ln</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>error_equation_indicator</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Compute composite grid residual on a single level. 
<p>
For the specified level number ln, compute the <em>composite</em> residual r=f-Au, where f is the right hand side and u is the solution. Note that the composite residual is not a one-level residual. It must take into account the composite grid stencil around the coarse-fine grid interface.<p>
May assume:<ul>
<li>Composite residual on next finer level l+1, has been computed already.</li><li>If any intermediately computed data is needed from level l+1, it has been done and stored on that level.</li><li>Residual computations for the original equation and the error equations will not be intermingled within one FAC cycle.</li></ul>
<p>
Steps:<ol type=1>
<li>Fill boundary ghosts.</li><li>If needed, coarsen intermediate data from level l+1.</li><li>Compute residual <img class="formulaInl" alt="$ r^l \leftarrow f - A u^l $" src="form_59.png">.</li></ol>
<p>
Final step before leaving function:<ul>
<li>If any intermediately computed data is needed in at level l-1, it must be computed and stored before leaving this function.</li></ul>
<p>
<b>Important:</b> Do not restrict residual from finer levels. (However, you must write the function <a class="el" href="classSAMRAI_1_1solv_1_1FACOperatorStrategy.html#39ad805a6e850d759239166842d02be7">restrictResidual()</a> to do this.)<p>
<b>Important:</b> This function must also work when the right-hand-side and the residual are identical. In that case, it should effectively do <img class="formulaInl" alt="$ r \leftarrow r - A u $" src="form_60.png">.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>residual</em>&nbsp;</td><td>residual vector </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>solution</em>&nbsp;</td><td>solution vector </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>rhs</em>&nbsp;</td><td>source (right hand side) vector </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ln</em>&nbsp;</td><td>level number </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>error_equation_indicator</em>&nbsp;</td><td>flag stating whether u is an error vector or a solution vector </td></tr>
  </table>
</dl>

<p>
Implemented in <a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonFACOps.html#82e1606b80843a097c4d99763a41e232">SAMRAI::solv::CellPoissonFACOps</a>.
</div>
</div><p>
<a class="anchor" name="bc03df2bcd01320f9d482aee213a684a"></a><!-- doxytag: member="SAMRAI::solv::FACOperatorStrategy::computeResidualNorm" ref="bc03df2bcd01320f9d482aee213a684a" args="(const SAMRAIVectorReal&lt; double &gt; &amp;residual, int fine_ln, int coarse_ln)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual double SAMRAI::solv::FACOperatorStrategy::computeResidualNorm           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1solv_1_1SAMRAIVectorReal.html">SAMRAIVectorReal</a>&lt; double &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>residual</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>fine_ln</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>coarse_ln</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Compute the norm of the residual quantity. 
<p>
Compute norm of the given residual on the given range of hierarchy levels. The residual vector is computed already and you should <b>not</b> change it. The only purpose of this function to allow you to choose how to define the norm.<p>
The norm value is used during the FAC iteration to determine convergence of the composite grid linear system.<p>
Residual values that lie under a finer level should not be counted.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>residual</em>&nbsp;</td><td>residual vector </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>fine_ln</em>&nbsp;</td><td>finest level number </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>coarse_ln</em>&nbsp;</td><td>coarsest level number</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>norm value of residual vector, which should be non-negative </dd></dl>

<p>
Implemented in <a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonFACOps.html#b2091fb3e4e044ffdbf773918abcf9b7">SAMRAI::solv::CellPoissonFACOps</a>.
</div>
</div><p>
<a class="anchor" name="8bbf9cd1d5417272cfaa20c68f8f90d4"></a><!-- doxytag: member="SAMRAI::solv::FACOperatorStrategy::postprocessOneCycle" ref="8bbf9cd1d5417272cfaa20c68f8f90d4" args="(int fac_cycle_num, const SAMRAIVectorReal&lt; double &gt; &amp;current_soln, const SAMRAIVectorReal&lt; double &gt; &amp;residual)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void SAMRAI::solv::FACOperatorStrategy::postprocessOneCycle           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>fac_cycle_num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1solv_1_1SAMRAIVectorReal.html">SAMRAIVectorReal</a>&lt; double &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>current_soln</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1solv_1_1SAMRAIVectorReal.html">SAMRAIVectorReal</a>&lt; double &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>residual</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Regular call back routine to be called after each FAC cycle. 
<p>
This function is called after each FAC cycle. It allows you to monitor the progress and do other things. You should <em>not</em> modify the solution vector in the argument.<p>
The default implementation does nothing.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>fac_cycle_num</em>&nbsp;</td><td>FAC cycle number completed </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>current_soln</em>&nbsp;</td><td>current solution </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>residual</em>&nbsp;</td><td>residual based on the current solution </td></tr>
  </table>
</dl>

<p>
Implemented in <a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonFACOps.html#554bf193dfb039a95c9a6e7f9af40d77">SAMRAI::solv::CellPoissonFACOps</a>.
</div>
</div><p>
<a class="anchor" name="dfa77ec960a1855561aa7bfe7fe3ae4c"></a><!-- doxytag: member="SAMRAI::solv::FACOperatorStrategy::initializeOperatorState" ref="dfa77ec960a1855561aa7bfe7fe3ae4c" args="(const SAMRAIVectorReal&lt; double &gt; &amp;solution, const SAMRAIVectorReal&lt; double &gt; &amp;rhs)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void SAMRAI::solv::FACOperatorStrategy::initializeOperatorState           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1solv_1_1SAMRAIVectorReal.html">SAMRAIVectorReal</a>&lt; double &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>solution</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1solv_1_1SAMRAIVectorReal.html">SAMRAIVectorReal</a>&lt; double &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Compute hierarchy-dependent data if any is required. 
<p>
This function is called when the hierarchy configuration changes. If you maintain any hierarchy-dependent data in your implementation (for example, caching communication schedules or computing coarse-fine boundaries), use this function to update that data.<p>
If you do not maintain such data, this function may be empty.<p>
Note that although the vector arguments given to other methods in this class may not necessarily be the same as those given to this method, there will be similarities, including:<ul>
<li>hierarchy configuration (hierarchy pointer and level range)</li><li>number, type and alignment of vector component data</li><li>ghost cell width of data in the solution (or solution-like) vector</li></ul>
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>solution</em>&nbsp;</td><td>solution vector u </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>rhs</em>&nbsp;</td><td>right hand side vector f</td></tr>
  </table>
</dl>
The default implementation does nothing. 
<p>
Implemented in <a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonFACOps.html#2da31e44d1cf2f54f7a941b6623fd7be">SAMRAI::solv::CellPoissonFACOps</a>.
</div>
</div><p>
<a class="anchor" name="b1a9e2eef933ee70d5aed9e7a0274a1a"></a><!-- doxytag: member="SAMRAI::solv::FACOperatorStrategy::deallocateOperatorState" ref="b1a9e2eef933ee70d5aed9e7a0274a1a" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::solv::FACOperatorStrategy::deallocateOperatorState           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Remove all hierarchy-dependent data. 
<p>
Remove all hierarchy-dependent data set by <a class="el" href="classSAMRAI_1_1solv_1_1FACOperatorStrategy.html#dfa77ec960a1855561aa7bfe7fe3ae4c">initializeOperatorState()</a>.<p>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classSAMRAI_1_1solv_1_1FACOperatorStrategy.html#dfa77ec960a1855561aa7bfe7fe3ae4c">initializeOperatorState</a> </dd></dl>

<p>
Reimplemented in <a class="el" href="classSAMRAI_1_1solv_1_1CellPoissonFACOps.html#f48e45974c427278215ae11ee7bba734">SAMRAI::solv::CellPoissonFACOps</a>.
</div>
</div><p>
<hr>The documentation for this class was generated from the following files:<ul>
<li>source/SAMRAI/solv/<a class="el" href="FACOperatorStrategy_8h.html">FACOperatorStrategy.h</a><li>source/SAMRAI/solv/<a class="el" href="FACOperatorStrategy_8C.html">FACOperatorStrategy.C</a></ul>
<hr size="1"><address style="align: right;"><small>Generated on 16 Jan 2013 for SAMRAI by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.7 </small></address>
</body>
</html>
