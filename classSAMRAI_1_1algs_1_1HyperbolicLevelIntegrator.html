<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>SAMRAI: SAMRAI::algs::HyperbolicLevelIntegrator Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath"><a class="el" href="namespaceSAMRAI.html">SAMRAI</a>::<a class="el" href="namespaceSAMRAI_1_1algs.html">algs</a>::<a class="el" href="classSAMRAI_1_1algs_1_1HyperbolicLevelIntegrator.html">HyperbolicLevelIntegrator</a>
  </div>
</div>
<div class="contents">
<h1>SAMRAI::algs::HyperbolicLevelIntegrator Class Reference</h1><!-- doxytag: class="SAMRAI::algs::HyperbolicLevelIntegrator" --><!-- doxytag: inherits="SAMRAI::algs::TimeRefinementLevelStrategy,SAMRAI::mesh::StandardTagAndInitStrategy,SAMRAI::tbox::Serializable" -->
<p><code>#include &lt;source/SAMRAI/algs/HyperbolicLevelIntegrator.h&gt;</code></p>
<div class="dynheader">
Inheritance diagram for SAMRAI::algs::HyperbolicLevelIntegrator:</div>
<div class="dynsection">
 <div class="center">
  <img src="classSAMRAI_1_1algs_1_1HyperbolicLevelIntegrator.gif" usemap="#SAMRAI::algs::HyperbolicLevelIntegrator_map" alt=""/>
  <map id="SAMRAI::algs::HyperbolicLevelIntegrator_map" name="SAMRAI::algs::HyperbolicLevelIntegrator_map">
<area href="classSAMRAI_1_1algs_1_1TimeRefinementLevelStrategy.html" alt="SAMRAI::algs::TimeRefinementLevelStrategy" shape="rect" coords="0,0,261,24"/>
<area href="classSAMRAI_1_1mesh_1_1StandardTagAndInitStrategy.html" alt="SAMRAI::mesh::StandardTagAndInitStrategy" shape="rect" coords="271,0,532,24"/>
<area href="classSAMRAI_1_1tbox_1_1Serializable.html" alt="SAMRAI::tbox::Serializable" shape="rect" coords="542,0,803,24"/>
</map>
 </div>
</div>

<p><a href="classSAMRAI_1_1algs_1_1HyperbolicLevelIntegrator-members.html">List of all members.</a></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Public Types</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1algs_1_1HyperbolicLevelIntegrator.html#a2b942773b6adae963741add627777f4d">HYP_VAR_TYPE</a> { <br/>
&nbsp;&nbsp;<a class="el" href="classSAMRAI_1_1algs_1_1HyperbolicLevelIntegrator.html#a2b942773b6adae963741add627777f4da0b702e61e735252458e0c19132477cf0">TIME_DEP</a> =  0, 
<a class="el" href="classSAMRAI_1_1algs_1_1HyperbolicLevelIntegrator.html#a2b942773b6adae963741add627777f4da6c92d0f502c292eca993115478274f35">INPUT</a> =  1, 
<a class="el" href="classSAMRAI_1_1algs_1_1HyperbolicLevelIntegrator.html#a2b942773b6adae963741add627777f4da6fa7dc8650ffdf0ad4c2fb9d426648e8">NO_FILL</a> =  2, 
<a class="el" href="classSAMRAI_1_1algs_1_1HyperbolicLevelIntegrator.html#a2b942773b6adae963741add627777f4da2d61c4a197489f17c392916db2c2e3ee">FLUX</a> =  3, 
<br/>
&nbsp;&nbsp;<a class="el" href="classSAMRAI_1_1algs_1_1HyperbolicLevelIntegrator.html#a2b942773b6adae963741add627777f4da8069329391cb780b2b5d76e73cfbf42f">TEMPORARY</a> =  4
<br/>
 }</td></tr>
<tr><td colspan="2"><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1algs_1_1HyperbolicLevelIntegrator.html#a13661b7333ec765370f96a685fcbcacf">HyperbolicLevelIntegrator</a> (const std::string &amp;object_name, const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Database.html">tbox::Database</a> &gt; &amp;input_db, <a class="el" href="classSAMRAI_1_1algs_1_1HyperbolicPatchStrategy.html">HyperbolicPatchStrategy</a> *patch_strategy, bool use_time_refinement=true)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1algs_1_1HyperbolicLevelIntegrator.html#aee597348695b9547fe23da382eba4fef">~HyperbolicLevelIntegrator</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1algs_1_1HyperbolicLevelIntegrator.html#a4064636b14a01ecea1d8955cb55ca37d">initializeLevelIntegrator</a> (const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1mesh_1_1GriddingAlgorithmStrategy.html">mesh::GriddingAlgorithmStrategy</a> &gt; &amp;gridding_alg_strategy)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1algs_1_1HyperbolicLevelIntegrator.html#ac933568dd0b8224b3bbd8bc1e7f8e912">getLevelDt</a> (const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchLevel.html">hier::PatchLevel</a> &gt; &amp;level, const double dt_time, const bool initial_time)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1algs_1_1HyperbolicLevelIntegrator.html#a4c97ede99c6fb8dad26a6fcfb14e697d">getMaxFinerLevelDt</a> (const int finer_level_number, const double coarse_dt, const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a> &amp;ratio_to_coarser)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1algs_1_1HyperbolicLevelIntegrator.html#adbc2c374748ac0bf3a1a2fb07405f12e">advanceLevel</a> (const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchLevel.html">hier::PatchLevel</a> &gt; &amp;level, const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchHierarchy.html">hier::PatchHierarchy</a> &gt; &amp;hierarchy, const double current_time, const double new_time, const bool first_step, const bool last_step, const bool regrid_advance=false)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1algs_1_1HyperbolicLevelIntegrator.html#a942fe38b617a8415e112d831e98023cb">standardLevelSynchronization</a> (const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchHierarchy.html">hier::PatchHierarchy</a> &gt; &amp;hierarchy, const int coarsest_level, const int finest_level, const double sync_time, const std::vector&lt; double &gt; &amp;old_times)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1algs_1_1HyperbolicLevelIntegrator.html#a04ac7a58562ba68f4e8ff7f1134b9100">standardLevelSynchronization</a> (const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchHierarchy.html">hier::PatchHierarchy</a> &gt; &amp;hierarchy, const int coarsest_level, const int finest_level, const double sync_time, const double old_time)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1algs_1_1HyperbolicLevelIntegrator.html#a945fc46f1f747c7cd5b7dac733c031b6">synchronizeNewLevels</a> (const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchHierarchy.html">hier::PatchHierarchy</a> &gt; &amp;hierarchy, const int coarsest_level, const int finest_level, const double sync_time, const bool initial_time)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1algs_1_1HyperbolicLevelIntegrator.html#a16caf57e64b65c96a79e9586ad7c7afd">resetTimeDependentData</a> (const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchLevel.html">hier::PatchLevel</a> &gt; &amp;level, const double new_time, const bool can_be_refined)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1algs_1_1HyperbolicLevelIntegrator.html#a7cb2ba4233d041889d30005154e08527">resetDataToPreadvanceState</a> (const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchLevel.html">hier::PatchLevel</a> &gt; &amp;level)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1algs_1_1HyperbolicLevelIntegrator.html#a392e88cf1fae4ef9f5fc09cbfc30cc8e">initializeLevelData</a> (const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchHierarchy.html">hier::PatchHierarchy</a> &gt; &amp;hierarchy, const int level_number, const double init_data_time, const bool can_be_refined, const bool initial_time, const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchLevel.html">hier::PatchLevel</a> &gt; &amp;old_level=boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchLevel.html">hier::PatchLevel</a> &gt;(), const bool allocate_data=true)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1algs_1_1HyperbolicLevelIntegrator.html#a537371effd1221180c639dd54f0ef057">resetHierarchyConfiguration</a> (const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchHierarchy.html">hier::PatchHierarchy</a> &gt; &amp;hierarchy, const int coarsest_level, const int finest_level)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1algs_1_1HyperbolicLevelIntegrator.html#a7f88cdceb7bc9afb7d33c2f117f8c68c">applyGradientDetector</a> (const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchHierarchy.html">hier::PatchHierarchy</a> &gt; &amp;hierarchy, const int level_number, const double error_data_time, const int tag_index, const bool initial_time, const bool uses_richardson_extrapolation_too)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1algs_1_1HyperbolicLevelIntegrator.html#a9207e0ee3cdf883f12fb7ea2809f96b7">applyRichardsonExtrapolation</a> (const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchLevel.html">hier::PatchLevel</a> &gt; &amp;level, const double error_data_time, const int tag_index, const double deltat, const int error_coarsen_ratio, const bool initial_time, const bool uses_gradient_detector_too)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1algs_1_1HyperbolicLevelIntegrator.html#acca15f011e7ce423fc574ee26ad56320">coarsenDataForRichardsonExtrapolation</a> (const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchHierarchy.html">hier::PatchHierarchy</a> &gt; &amp;hierarchy, const int level_number, const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchLevel.html">hier::PatchLevel</a> &gt; &amp;coarse_level, const double coarsen_data_time, const bool before_advance)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1algs_1_1HyperbolicLevelIntegrator.html#abdcab6c4fa5e46ca902202d98246b40a">registerVariable</a> (const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1hier_1_1Variable.html">hier::Variable</a> &gt; &amp;var, const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a> ghosts, const <a class="el" href="classSAMRAI_1_1algs_1_1HyperbolicLevelIntegrator.html#a2b942773b6adae963741add627777f4d">HYP_VAR_TYPE</a> h_v_type, const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1hier_1_1BaseGridGeometry.html">hier::BaseGridGeometry</a> &gt; &amp;transfer_geom, const std::string &amp;coarsen_name=std::string(), const std::string &amp;refine_name=std::string())</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1algs_1_1HyperbolicLevelIntegrator.html#afc904e9bd24a00f5964b2a3b89aa88e2">printClassData</a> (std::ostream &amp;os) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1algs_1_1HyperbolicLevelIntegrator.html#a22b1b8c229365790d6b7751e6e79b79d">putToRestart</a> (const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Database.html">tbox::Database</a> &gt; &amp;restart_db) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">boost::shared_ptr<br class="typebreak"/>
&lt; <a class="el" href="classSAMRAI_1_1hier_1_1VariableContext.html">hier::VariableContext</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1algs_1_1HyperbolicLevelIntegrator.html#a28ed6af341fdcaa7b6b056e33a524799">getCurrentContext</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">boost::shared_ptr<br class="typebreak"/>
&lt; <a class="el" href="classSAMRAI_1_1hier_1_1VariableContext.html">hier::VariableContext</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1algs_1_1HyperbolicLevelIntegrator.html#aa11e245e1a4c1909d18a64e71c42143b">getNewContext</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">boost::shared_ptr<br class="typebreak"/>
&lt; <a class="el" href="classSAMRAI_1_1hier_1_1VariableContext.html">hier::VariableContext</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1algs_1_1HyperbolicLevelIntegrator.html#aa59d005a38235327999883496fbea095">getOldContext</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">boost::shared_ptr<br class="typebreak"/>
&lt; <a class="el" href="classSAMRAI_1_1hier_1_1VariableContext.html">hier::VariableContext</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1algs_1_1HyperbolicLevelIntegrator.html#a4736fe87631feaa1c234b55ced8cfd36">getScratchContext</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">boost::shared_ptr<br class="typebreak"/>
&lt; <a class="el" href="classSAMRAI_1_1hier_1_1VariableContext.html">hier::VariableContext</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1algs_1_1HyperbolicLevelIntegrator.html#a1d894e17b709a2ec6ef4ca167842f10c">getPlotContext</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1algs_1_1HyperbolicLevelIntegrator.html#aeca1cb61d5d5e5f9ce5dd15175b9b50c">usingRefinedTimestepping</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1algs_1_1HyperbolicLevelIntegrator.html#ab0fc6774d81a203fc1189d5af578a24d">printStatistics</a> (std::ostream &amp;s=<a class="el" href="namespaceSAMRAI_1_1tbox.html#ab84041705493761fb17a8127e3a2dca2">tbox::plog</a>) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const std::string &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1algs_1_1HyperbolicLevelIntegrator.html#a58c4336cc6c7ff408ac7ce79908c872a">getObjectName</a> () const </td></tr>
<tr><td colspan="2"><h2>Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1algs_1_1HyperbolicLevelIntegrator.html#a08f5b907893bd76e0f843f7287438e47">getFromInput</a> (const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Database.html">tbox::Database</a> &gt; &amp;input_db, bool is_from_restart)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1algs_1_1HyperbolicLevelIntegrator.html#a054e224c8f4f4de88e6697b9c5d6f1a1">getFromRestart</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1algs_1_1HyperbolicLevelIntegrator.html#ad039dcd0eccf7c4ead3ad12ade6ea5c3">preprocessFluxData</a> (const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchLevel.html">hier::PatchLevel</a> &gt; &amp;level, const double cur_time, const double new_time, const bool regrid_advance, const bool first_step, const bool last_step)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1algs_1_1HyperbolicLevelIntegrator.html#a8cb0540f8a8d68b52ce85c9daa3f450a">postprocessFluxData</a> (const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchLevel.html">hier::PatchLevel</a> &gt; &amp;level, const bool regrid_advance, const bool first_step, const bool last_step)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1algs_1_1HyperbolicLevelIntegrator.html#a49a106085a3a1ed06d0c5664bce5483e">copyTimeDependentData</a> (const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchLevel.html">hier::PatchLevel</a> &gt; &amp;level, const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1hier_1_1VariableContext.html">hier::VariableContext</a> &gt; &amp;src_context, const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1hier_1_1VariableContext.html">hier::VariableContext</a> &gt; &amp;dst_context)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1algs_1_1HyperbolicLevelIntegrator.html#a2ee358683ba0b8bee7998bc2514b8083">synchronizeLevelWithCoarser</a> (const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchLevel.html">hier::PatchLevel</a> &gt; &amp;fine, const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchLevel.html">hier::PatchLevel</a> &gt; &amp;coarse, const double sync_time, const double coarse_sim_time)</td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>Class <a class="el" href="classSAMRAI_1_1algs_1_1HyperbolicLevelIntegrator.html">HyperbolicLevelIntegrator</a> provides routines needed to integrate a system of hyperbolic conservation laws on a structured AMR patch hierarchy using local time refinement. The routines include initializing a level, advance a level, and synchronize levels in a time-dependent AMR application. The AMR timestepping algorithm that cycles through the patch levels and calls these routines is provided by the <a class="el" href="classSAMRAI_1_1algs_1_1TimeRefinementIntegrator.html">TimeRefinementIntegrator</a> class. Together, that hierarchy integration class and this single level integration class produce the common AMR algorithm due to Berger, Colella and Oliger (see e.g., Berger and Colella, J. Comp. Phys. (82)1:64-84, 1989). The operations performed on single patches on each level are implemented in the user-defined, problem-specific class derived from the abstract base class <a class="el" href="classSAMRAI_1_1algs_1_1HyperbolicPatchStrategy.html">HyperbolicPatchStrategy</a>.</p>
<p>It is important to note that the variable contexts used by the concrete patch strategy subclass must be consistent with those defined in this class which manages the data for the variables.</p>
<p>This class is derived from the abstract base class <a class="el" href="classSAMRAI_1_1algs_1_1TimeRefinementLevelStrategy.html">TimeRefinementLevelStrategy</a>, which defines routines needed by the time refinement integrator. There is an argument in the constructor that determines whether this class will be used by the time refinement integrator for refined timestepping or synchronized timestepping. The routines overloaded in <a class="el" href="classSAMRAI_1_1algs_1_1TimeRefinementLevelStrategy.html">TimeRefinementLevelStrategy</a> are: <a class="el" href="classSAMRAI_1_1algs_1_1HyperbolicLevelIntegrator.html#a4064636b14a01ecea1d8955cb55ca37d">initializeLevelIntegrator()</a>, <a class="el" href="classSAMRAI_1_1algs_1_1HyperbolicLevelIntegrator.html#ac933568dd0b8224b3bbd8bc1e7f8e912">getLevelDt()</a>, <a class="el" href="classSAMRAI_1_1algs_1_1HyperbolicLevelIntegrator.html#a4c97ede99c6fb8dad26a6fcfb14e697d">getMaxFinerLevelDt()</a>, <a class="el" href="classSAMRAI_1_1algs_1_1HyperbolicLevelIntegrator.html#adbc2c374748ac0bf3a1a2fb07405f12e">advanceLevel()</a>, <a class="el" href="classSAMRAI_1_1algs_1_1HyperbolicLevelIntegrator.html#a942fe38b617a8415e112d831e98023cb">standardLevelSynchronization()</a>, <a class="el" href="classSAMRAI_1_1algs_1_1HyperbolicLevelIntegrator.html#a945fc46f1f747c7cd5b7dac733c031b6">synchronizeNewLevels()</a>, <a class="el" href="classSAMRAI_1_1algs_1_1HyperbolicLevelIntegrator.html#a16caf57e64b65c96a79e9586ad7c7afd">resetTimeDependentData()</a>, and <a class="el" href="classSAMRAI_1_1algs_1_1HyperbolicLevelIntegrator.html#a7cb2ba4233d041889d30005154e08527">resetDataToPreadvanceState()</a>. This class is also derived from <a class="el" href="classSAMRAI_1_1mesh_1_1StandardTagAndInitStrategy.html">mesh::StandardTagAndInitStrategy</a>, which defines routines needed by the gridding algorithm classes. The routines overloaded in <a class="el" href="classSAMRAI_1_1mesh_1_1StandardTagAndInitStrategy.html">mesh::StandardTagAndInitStrategy</a> are: <a class="el" href="classSAMRAI_1_1algs_1_1HyperbolicLevelIntegrator.html#a392e88cf1fae4ef9f5fc09cbfc30cc8e">initializeLevelData()</a>, <a class="el" href="classSAMRAI_1_1algs_1_1HyperbolicLevelIntegrator.html#a537371effd1221180c639dd54f0ef057">resetHierarchyConfiguration()</a>, <a class="el" href="classSAMRAI_1_1algs_1_1HyperbolicLevelIntegrator.html#a7f88cdceb7bc9afb7d33c2f117f8c68c">applyGradientDetector()</a>, <a class="el" href="classSAMRAI_1_1algs_1_1HyperbolicLevelIntegrator.html#a9207e0ee3cdf883f12fb7ea2809f96b7">applyRichardsonExtrapolation()</a>, and <a class="el" href="classSAMRAI_1_1algs_1_1HyperbolicLevelIntegrator.html#acca15f011e7ce423fc574ee26ad56320">coarsenDataForRichardsonExtrapolation()</a>.</p>
<p><b> Input Parameters </b></p>
<p><b> Definitions: </b></p>
<ul>
<li><b>cfl</b> the CFL factor used for timestep selection (dt used = CFL * max dt)</li>
</ul>
<ul>
<li><b>cfl_init</b> the CFL factor used for initial timestep</li>
</ul>
<ul>
<li><b>lag_dt_computation</b> indicates whether dt is based on current solution or solution from previous step (possible optimization in communication for characteristic analysis)</li>
</ul>
<ul>
<li><b>use_ghosts_to_compute_dt</b> indicates whether ghost data must be filled before timestep is computed on each patch (possible communication optimization)</li>
</ul>
<p>Note that when continuing from restart, the input parameters in the input database override all values read in from the restart database.</p>
<p><b> Details: </b> <br/>
 </p>
<table border="1" cellspacing="3" cellpadding="3">
<tr>
<th><p>parameter </p>
</th><th><p>type </p>
</th><th><p>default </p>
</th><th><p>range </p>
</th><th><p>opt/req </p>
</th><th><p>behavior on restart  </p>
</th></tr>
<tr>
<td><p>cfl </p>
</td><td><p>double </p>
</td><td><p>none </p>
</td><td><p>any double </p>
</td><td><p>req </p>
</td><td><p>Parameter read from restart db may be overridden by input db  </p>
</td></tr>
<tr>
<td><p>cfl_init </p>
</td><td><p>double </p>
</td><td><p>none </p>
</td><td><p>any double </p>
</td><td><p>req </p>
</td><td><p>Parameter read from restart db may be overridden by input db  </p>
</td></tr>
<tr>
<td><p>lag_dt_computation </p>
</td><td><p>bool </p>
</td><td><p>TRUE </p>
</td><td><p>TRUE, FALSE </p>
</td><td><p>opt </p>
</td><td><p>Parameter read from restart db may be overridden by input db  </p>
</td></tr>
<tr>
<td><p>use_ghosts_to_compute_dt </p>
</td><td><p>bool </p>
</td><td><p>FALSE </p>
</td><td><p>TRUE, FALSE </p>
</td><td><p>opt </p>
</td><td><p>Parameter read from restart db may be overridden by input db  </p>
</td></tr>
</table>
<p>A sample input file entry might look like:</p>
<div class="fragment"><pre class="fragment">    cfl = 0.9
    cfl_init = 0.9
    lag_dt_computation = FALSE
    use_ghosts_to_compute_dt = TRUE
</pre></div><dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classSAMRAI_1_1algs_1_1TimeRefinementIntegrator.html">algs::TimeRefinementIntegrator</a> </dd>
<dd>
<a class="el" href="classSAMRAI_1_1mesh_1_1StandardTagAndInitStrategy.html">mesh::StandardTagAndInitStrategy</a> </dd>
<dd>
<a class="el" href="classSAMRAI_1_1algs_1_1HyperbolicPatchStrategy.html">algs::HyperbolicPatchStrategy</a> </dd></dl>
<hr/><h2>Member Enumeration Documentation</h2>
<a class="anchor" id="a2b942773b6adae963741add627777f4d"></a><!-- doxytag: member="SAMRAI::algs::HyperbolicLevelIntegrator::HYP_VAR_TYPE" ref="a2b942773b6adae963741add627777f4d" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classSAMRAI_1_1algs_1_1HyperbolicLevelIntegrator.html#a2b942773b6adae963741add627777f4d">SAMRAI::algs::HyperbolicLevelIntegrator::HYP_VAR_TYPE</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Enumerated type for the different ways in which variable storage can be manipulated by the level integration algorithm. See registerVariable(...) function for more details.</p>
<ul>
<li><b>TIME_DEP</b> {Data that changes in time and needs more than one time level to be stored.}</li>
<li><b>INPUT</b> {Data that is set once and do not change during the ghosts are never re-filled outside of user-defined routines.}</li>
<li><b>FLUX</b> {Face-centered double values used in conservative difference and synchronization (i.e., refluxing) process. A corresponding variable to store flux integral information is created for each FLUX variable.}</li>
<li><b>TEMPORARY</b> {Accessory values intended to live only for computation on a single patch (i.e., they cannot be assumed to exist between patch routine function calls.)} </li>
</ul>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="a2b942773b6adae963741add627777f4da0b702e61e735252458e0c19132477cf0"></a><!-- doxytag: member="TIME_DEP" ref="a2b942773b6adae963741add627777f4da0b702e61e735252458e0c19132477cf0" args="" -->TIME_DEP</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a2b942773b6adae963741add627777f4da6c92d0f502c292eca993115478274f35"></a><!-- doxytag: member="INPUT" ref="a2b942773b6adae963741add627777f4da6c92d0f502c292eca993115478274f35" args="" -->INPUT</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a2b942773b6adae963741add627777f4da6fa7dc8650ffdf0ad4c2fb9d426648e8"></a><!-- doxytag: member="NO_FILL" ref="a2b942773b6adae963741add627777f4da6fa7dc8650ffdf0ad4c2fb9d426648e8" args="" -->NO_FILL</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a2b942773b6adae963741add627777f4da2d61c4a197489f17c392916db2c2e3ee"></a><!-- doxytag: member="FLUX" ref="a2b942773b6adae963741add627777f4da2d61c4a197489f17c392916db2c2e3ee" args="" -->FLUX</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a2b942773b6adae963741add627777f4da8069329391cb780b2b5d76e73cfbf42f"></a><!-- doxytag: member="TEMPORARY" ref="a2b942773b6adae963741add627777f4da8069329391cb780b2b5d76e73cfbf42f" args="" -->TEMPORARY</em>&nbsp;</td><td>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a13661b7333ec765370f96a685fcbcacf"></a><!-- doxytag: member="SAMRAI::algs::HyperbolicLevelIntegrator::HyperbolicLevelIntegrator" ref="a13661b7333ec765370f96a685fcbcacf" args="(const std::string &amp;object_name, const boost::shared_ptr&lt; tbox::Database &gt; &amp;input_db, HyperbolicPatchStrategy *patch_strategy, bool use_time_refinement=true)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SAMRAI::algs::HyperbolicLevelIntegrator::HyperbolicLevelIntegrator </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>object_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Database.html">tbox::Database</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>input_db</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSAMRAI_1_1algs_1_1HyperbolicPatchStrategy.html">HyperbolicPatchStrategy</a> *&nbsp;</td>
          <td class="paramname"> <em>patch_strategy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>use_time_refinement</em> = <code>true</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Constructor for <a class="el" href="classSAMRAI_1_1algs_1_1HyperbolicLevelIntegrator.html">HyperbolicLevelIntegrator</a> initializes integration parameters to default values and constructs standard communication algorithms. Other data members are read in from the specified input database or the restart database corresponding to the specified object_name. This class is used by the time refinement integrator for refined timestepping when the use_time_refinement argument is true, and for synchronized timestepping when the boolean is false.</p>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>!object_name.empty() </dd>
<dd>
patch_strategy != 0 </dd></dl>

</div>
</div>
<a class="anchor" id="aee597348695b9547fe23da382eba4fef"></a><!-- doxytag: member="SAMRAI::algs::HyperbolicLevelIntegrator::~HyperbolicLevelIntegrator" ref="aee597348695b9547fe23da382eba4fef" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual SAMRAI::algs::HyperbolicLevelIntegrator::~HyperbolicLevelIntegrator </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>The destructor for <a class="el" href="classSAMRAI_1_1algs_1_1HyperbolicLevelIntegrator.html">HyperbolicLevelIntegrator</a> unregisters the integrator object with the restart manager. </p>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a4064636b14a01ecea1d8955cb55ca37d"></a><!-- doxytag: member="SAMRAI::algs::HyperbolicLevelIntegrator::initializeLevelIntegrator" ref="a4064636b14a01ecea1d8955cb55ca37d" args="(const boost::shared_ptr&lt; mesh::GriddingAlgorithmStrategy &gt; &amp;gridding_alg_strategy)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void SAMRAI::algs::HyperbolicLevelIntegrator::initializeLevelIntegrator </td>
          <td>(</td>
          <td class="paramtype">const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1mesh_1_1GriddingAlgorithmStrategy.html">mesh::GriddingAlgorithmStrategy</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>gridding_alg_strategy</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Initialize level integrator by by setting the number of time levels of data needed based on specifications of the gridding algorithm.</p>
<p>This routine also invokes variable registration in the patch strategy.</p>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>gridding_alg_strategy is actually a boost::dynamic_pointer_cast&lt;mesh::GriddingAlgorithm&gt; </dd></dl>

<p>Implements <a class="el" href="classSAMRAI_1_1algs_1_1TimeRefinementLevelStrategy.html#a68a38b14bf6e50ac2b0dccf4be02867a">SAMRAI::algs::TimeRefinementLevelStrategy</a>.</p>

</div>
</div>
<a class="anchor" id="ac933568dd0b8224b3bbd8bc1e7f8e912"></a><!-- doxytag: member="SAMRAI::algs::HyperbolicLevelIntegrator::getLevelDt" ref="ac933568dd0b8224b3bbd8bc1e7f8e912" args="(const boost::shared_ptr&lt; hier::PatchLevel &gt; &amp;level, const double dt_time, const bool initial_time)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual double SAMRAI::algs::HyperbolicLevelIntegrator::getLevelDt </td>
          <td>(</td>
          <td class="paramtype">const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchLevel.html">hier::PatchLevel</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>dt_time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&nbsp;</td>
          <td class="paramname"> <em>initial_time</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Determine time increment to advance data on level and return that value. The double dt_time argument is the simulation time when the routine is called. The initial_time boolean is true if this routine is called during hierarchy initialization (i.e., at the initial simulation time). Otherwise, it is false. The recompute_dt option specifies whether to compute the timestep using the current level data or to return the value stored by the time integrator. The default true setting means the timestep will be computed if no value is supplied.</p>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>level </dd></dl>

<p>Reimplemented from <a class="el" href="classSAMRAI_1_1mesh_1_1StandardTagAndInitStrategy.html#a3e10caf7f929cf1349af983fd41a47af">SAMRAI::mesh::StandardTagAndInitStrategy</a>.</p>

</div>
</div>
<a class="anchor" id="a4c97ede99c6fb8dad26a6fcfb14e697d"></a><!-- doxytag: member="SAMRAI::algs::HyperbolicLevelIntegrator::getMaxFinerLevelDt" ref="a4c97ede99c6fb8dad26a6fcfb14e697d" args="(const int finer_level_number, const double coarse_dt, const hier::IntVector &amp;ratio_to_coarser)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual double SAMRAI::algs::HyperbolicLevelIntegrator::getMaxFinerLevelDt </td>
          <td>(</td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>finer_level_number</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>coarse_dt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>ratio_to_coarser</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the maximum allowable time increment for the level with the specified level number based on the time increment for the next coarser level and the <a class="el" href="namespaceSAMRAI_1_1mesh.html">mesh</a> refinement ratio between the two levels. For the common explicit integration methods for hyperbolic conservation laws (constrained by a CFL limit), the fine time increment is typically the coarse increment divided by the refinement ratio.</p>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>each component of ratio_to_coarser is &gt; 0 </dd></dl>

<p>Implements <a class="el" href="classSAMRAI_1_1algs_1_1TimeRefinementLevelStrategy.html#a727adc3cb8ea6e8cdfcad8f36728d76f">SAMRAI::algs::TimeRefinementLevelStrategy</a>.</p>

</div>
</div>
<a class="anchor" id="adbc2c374748ac0bf3a1a2fb07405f12e"></a><!-- doxytag: member="SAMRAI::algs::HyperbolicLevelIntegrator::advanceLevel" ref="adbc2c374748ac0bf3a1a2fb07405f12e" args="(const boost::shared_ptr&lt; hier::PatchLevel &gt; &amp;level, const boost::shared_ptr&lt; hier::PatchHierarchy &gt; &amp;hierarchy, const double current_time, const double new_time, const bool first_step, const bool last_step, const bool regrid_advance=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual double SAMRAI::algs::HyperbolicLevelIntegrator::advanceLevel </td>
          <td>(</td>
          <td class="paramtype">const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchLevel.html">hier::PatchLevel</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchHierarchy.html">hier::PatchHierarchy</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>hierarchy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>current_time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>new_time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&nbsp;</td>
          <td class="paramname"> <em>first_step</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&nbsp;</td>
          <td class="paramname"> <em>last_step</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&nbsp;</td>
          <td class="paramname"> <em>regrid_advance</em> = <code>false</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Integrate data on all patches on the given patch level from current time (current_time) to new time (new_time). This routine is used to advance the solution on each level in the hierarchy and during time-dependent regridding procedures, such as Richardson extrapolation. The boolean arguments are used to determine the state of the algorithm and the data when the advance routine is called. The first_step and last_step indicate whether the step is the first or last in the current timestep sequence on the level. Typically, the current timestep sequence means each step on the level between advance steps on a coarser level in the hierarchy, if one exists. The regrid_advance value is true when the advance is called as part of a time-dependent regridding procedure. Usually when this happens, the results of the colution advance will be discarded. So, for example, when this is true flux information is not maintained and flux integrals are not updated. The final boolean argument indicates whether or not the level resides in the hierarchy. For example, during time-dependent regridding, such as Richardson extrapolation, a temporary level that is not in the hierarchy is created and advanced. Then, a communication schedule must be generated for the level before the advance begins.</p>
<p>This routine is called at two different points during time integration: during the regular time advance sequence, and possibly at the initial simulation time. The second call advances the solution on a coarser level ahead in time to provide time-dependent boundary values for some finer level when time-dependent regridding is used. In the first case, the values of the boolean flags are:</p>
<ul>
<li><b>first_step</b> = true for first step in level time step sequence; else, false.</li>
<li><b>last_step</b> = true for last step in level time step sequence; else, false.</li>
<li><b>regrid_advance</b> = false.</li>
</ul>
<p>In the second case, the values of the boolean flags are:</p>
<ul>
<li><b>first_step</b> = true.</li>
<li><b>last_step</b> = false.</li>
<li><b>regrid_advance</b> = true.</li>
</ul>
<p>When time-dependent regridding (i.e., Richardson extrapolation) is used, the routine is called from two different points in addition to those described above: to advance a temporary level that is coarser than the hierarchy level on which error estimation is performed, and to advance the hierarchy level itself. In the first case, the values of the boolean flags are:</p>
<ul>
<li><b>first_step</b> = true.</li>
<li><b>last_step</b> = true.</li>
<li><b>regrid_advance</b> = true.</li>
</ul>
<p>In the second case, the values of the boolean flags are:</p>
<ul>
<li><b>first_step</b> (when regridding during time integration sequence) = true when the level is not coarsest level to synchronize immediately before the regridding process; else, false. (when generating initial hierarchy construction) = true, even though there may be multiple advance steps.</li>
<li><b>last_step</b> = true when the advance is the last in the Richardson extrapolation step sequence; else false.</li>
<li><b>regrid_advance</b> = true.</li>
</ul>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>level </dd>
<dd>
hierarchy </dd>
<dd>
current_time &lt;= new_time </dd>
<dd>
level-&gt;getDim() == hierarchy-&gt;getDim() </dd></dl>

<p>Reimplemented from <a class="el" href="classSAMRAI_1_1mesh_1_1StandardTagAndInitStrategy.html#a842a6d80aab2762a9a9cbca11cd64be3">SAMRAI::mesh::StandardTagAndInitStrategy</a>.</p>

</div>
</div>
<a class="anchor" id="a942fe38b617a8415e112d831e98023cb"></a><!-- doxytag: member="SAMRAI::algs::HyperbolicLevelIntegrator::standardLevelSynchronization" ref="a942fe38b617a8415e112d831e98023cb" args="(const boost::shared_ptr&lt; hier::PatchHierarchy &gt; &amp;hierarchy, const int coarsest_level, const int finest_level, const double sync_time, const std::vector&lt; double &gt; &amp;old_times)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void SAMRAI::algs::HyperbolicLevelIntegrator::standardLevelSynchronization </td>
          <td>(</td>
          <td class="paramtype">const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchHierarchy.html">hier::PatchHierarchy</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>hierarchy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>coarsest_level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>finest_level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>sync_time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>old_times</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Synchronize data between given patch levels in patch hierarchy according to the standard hyperbolic AMR flux correction algorithm. This routine synchronizes data between two levels at a time from the level with index finest_level down to the level with index coarsest_level. The array of old time values are used in the re-integration of the time-dependent data.</p>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>hierarchy </dd>
<dd>
(coarsest_level &gt;= 0) &amp;&amp; (coarsest_level &lt; finest_level) &amp;&amp; (finest_level &lt;= hierarchy-&gt;getFinestLevelNumber()) </dd>
<dd>
old_times.size() &gt;= finest_level </dd>
<dd>
for each i in [coarsest_level, finest_level) hierarchy-&gt;getPatchLevel(i) &amp;&amp; sync_time &gt;= old_times[i] </dd>
<dd>
hierarchy-&gt;getPatchLevel(finest_level) </dd></dl>

<p>Implements <a class="el" href="classSAMRAI_1_1algs_1_1TimeRefinementLevelStrategy.html#ae6d3f49891af6ed7faba1989eece648b">SAMRAI::algs::TimeRefinementLevelStrategy</a>.</p>

</div>
</div>
<a class="anchor" id="a04ac7a58562ba68f4e8ff7f1134b9100"></a><!-- doxytag: member="SAMRAI::algs::HyperbolicLevelIntegrator::standardLevelSynchronization" ref="a04ac7a58562ba68f4e8ff7f1134b9100" args="(const boost::shared_ptr&lt; hier::PatchHierarchy &gt; &amp;hierarchy, const int coarsest_level, const int finest_level, const double sync_time, const double old_time)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void SAMRAI::algs::HyperbolicLevelIntegrator::standardLevelSynchronization </td>
          <td>(</td>
          <td class="paramtype">const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchHierarchy.html">hier::PatchHierarchy</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>hierarchy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>coarsest_level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>finest_level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>sync_time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>old_time</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This overloaded version of standardLevelSynchronization implements a routine used for synchronized timestepping. Only a single value for the old time is needed, since all levels would have the same old time.</p>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>hierarchy </dd>
<dd>
(coarsest_level &gt;= 0) &amp;&amp; (coarsest_level &lt; finest_level) &amp;&amp; (finest_level &lt;= hierarchy-&gt;getFinestLevelNumber()) </dd>
<dd>
for each i in [coarsest_level, finest_level) hierarchy-&gt;getPatchLevel(i) </dd>
<dd>
sync_time &gt;= old_time </dd>
<dd>
hierarchy-&gt;getPatchLevel(finest_level) </dd></dl>

</div>
</div>
<a class="anchor" id="a945fc46f1f747c7cd5b7dac733c031b6"></a><!-- doxytag: member="SAMRAI::algs::HyperbolicLevelIntegrator::synchronizeNewLevels" ref="a945fc46f1f747c7cd5b7dac733c031b6" args="(const boost::shared_ptr&lt; hier::PatchHierarchy &gt; &amp;hierarchy, const int coarsest_level, const int finest_level, const double sync_time, const bool initial_time)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void SAMRAI::algs::HyperbolicLevelIntegrator::synchronizeNewLevels </td>
          <td>(</td>
          <td class="paramtype">const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchHierarchy.html">hier::PatchHierarchy</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>hierarchy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>coarsest_level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>finest_level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>sync_time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&nbsp;</td>
          <td class="paramname"> <em>initial_time</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Coarsen current solution data from finest hierarchy level specified down through the coarsest hierarchy level specified, if initial_time is true. In this case, the hierarchy is being constructed at the initial simulation time, After data is coarsened, the application- specific initialization routine is called to set data before that solution is further coarsened to the next coarser level in the hierarchy. This operation makes the solution consistent between coarser levels and finer levels that did not exist when the coarse levels where created and initialized originally.</p>
<p>When initial_time is false, this routine does nothing since the standard hyperbolic AMR algorithm for conservation laws requires no data synchronization after regridding beyond interpolation of data from coarser levels in the hierarchy in some conservative fashion.</p>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>hierarchy </dd>
<dd>
(coarsest_level &gt;= 0) &amp;&amp; (coarsest_level &lt; finest_level) &amp;&amp; (finest_level &lt;= hierarchy-&gt;getFinestLevelNumber()) </dd>
<dd>
for each i in [coarsest_level, finest_level] hierarchy-&gt;getPatchLevel(i) </dd></dl>

<p>Implements <a class="el" href="classSAMRAI_1_1algs_1_1TimeRefinementLevelStrategy.html#a880c587cd06cecfd3f1839241244a523">SAMRAI::algs::TimeRefinementLevelStrategy</a>.</p>

</div>
</div>
<a class="anchor" id="a16caf57e64b65c96a79e9586ad7c7afd"></a><!-- doxytag: member="SAMRAI::algs::HyperbolicLevelIntegrator::resetTimeDependentData" ref="a16caf57e64b65c96a79e9586ad7c7afd" args="(const boost::shared_ptr&lt; hier::PatchLevel &gt; &amp;level, const double new_time, const bool can_be_refined)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void SAMRAI::algs::HyperbolicLevelIntegrator::resetTimeDependentData </td>
          <td>(</td>
          <td class="paramtype">const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchLevel.html">hier::PatchLevel</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>new_time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&nbsp;</td>
          <td class="paramname"> <em>can_be_refined</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Resets time-dependent data storage and update time for patch level.</p>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>level </dd></dl>

<p>Reimplemented from <a class="el" href="classSAMRAI_1_1mesh_1_1StandardTagAndInitStrategy.html#a64ffdbc5e045072c85a585ec46c24d36">SAMRAI::mesh::StandardTagAndInitStrategy</a>.</p>

</div>
</div>
<a class="anchor" id="a7cb2ba4233d041889d30005154e08527"></a><!-- doxytag: member="SAMRAI::algs::HyperbolicLevelIntegrator::resetDataToPreadvanceState" ref="a7cb2ba4233d041889d30005154e08527" args="(const boost::shared_ptr&lt; hier::PatchLevel &gt; &amp;level)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void SAMRAI::algs::HyperbolicLevelIntegrator::resetDataToPreadvanceState </td>
          <td>(</td>
          <td class="paramtype">const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchLevel.html">hier::PatchLevel</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>level</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Deallocate all new simulation data on the given level. This may be necessary during regridding, or setting up levels initially.</p>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>level </dd></dl>

<p>Reimplemented from <a class="el" href="classSAMRAI_1_1mesh_1_1StandardTagAndInitStrategy.html#ac4e1369e40bd23ce2b1eceb95f2d2c49">SAMRAI::mesh::StandardTagAndInitStrategy</a>.</p>

</div>
</div>
<a class="anchor" id="a392e88cf1fae4ef9f5fc09cbfc30cc8e"></a><!-- doxytag: member="SAMRAI::algs::HyperbolicLevelIntegrator::initializeLevelData" ref="a392e88cf1fae4ef9f5fc09cbfc30cc8e" args="(const boost::shared_ptr&lt; hier::PatchHierarchy &gt; &amp;hierarchy, const int level_number, const double init_data_time, const bool can_be_refined, const bool initial_time, const boost::shared_ptr&lt; hier::PatchLevel &gt; &amp;old_level=boost::shared_ptr&lt; hier::PatchLevel &gt;(), const bool allocate_data=true)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void SAMRAI::algs::HyperbolicLevelIntegrator::initializeLevelData </td>
          <td>(</td>
          <td class="paramtype">const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchHierarchy.html">hier::PatchHierarchy</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>hierarchy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>level_number</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>init_data_time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&nbsp;</td>
          <td class="paramname"> <em>can_be_refined</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&nbsp;</td>
          <td class="paramname"> <em>initial_time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchLevel.html">hier::PatchLevel</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>old_level</em> = <code>boost::shared_ptr&lt;&nbsp;<a class="el" href="classSAMRAI_1_1hier_1_1PatchLevel.html">hier::PatchLevel</a>&nbsp;&gt;()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&nbsp;</td>
          <td class="paramname"> <em>allocate_data</em> = <code>true</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Initialize data on a new level after it is inserted into an AMR patch hierarchy by the gridding algorithm. The level number indicates that of the new level. The old_level pointer corresponds to the level that resided in the hierarchy before the level with the specified number was introduced. If the pointer is null, there was no level in the hierarchy prior to the call and the level data is set based on the user routines and the simulation time. Otherwise, the specified level replaces the old level and the new level receives data from the old level appropriately before it is destroyed.</p>
<p>Typically, when data is set, it is interpolated from coarser levels in the hierarchy. If the data is to be set, the level number must match that of the old level, if non-null. If the old level is non-null, then data is copied from the old level to the new level on regions of intersection between those levels before interpolation occurs. Then, user-supplied patch routines are called to further initialize the data if needed. The boolean argument initial_time is passed into the user's routines.</p>
<p>The boolean argument initial_time indicates whether the level is being introduced for the first time (i.e., at initialization time), or after some regrid process during the calculation beyond the initial hierarchy construction. This information is provided since the initialization of the data on a patch may be different in each of those circumstances. The can_be_refined boolean argument indicates whether the level is the finest level allowed in the hierarchy. This may or may not affect the data initialization process depending on the problem.</p>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>hierarchy </dd>
<dd>
(level_number &gt;= 0) &amp;&amp; (level_number &lt;= hierarchy-&gt;getFinestLevelNumber()) </dd>
<dd>
!old_level || (level_number == old_level-&gt;getLevelNumber()) </dd>
<dd>
hierarchy-&gt;getPatchLevel(level_number)) </dd></dl>

<p>Implements <a class="el" href="classSAMRAI_1_1mesh_1_1StandardTagAndInitStrategy.html#acc3f40925b2fe51dbd5742b2a24b2471">SAMRAI::mesh::StandardTagAndInitStrategy</a>.</p>

</div>
</div>
<a class="anchor" id="a537371effd1221180c639dd54f0ef057"></a><!-- doxytag: member="SAMRAI::algs::HyperbolicLevelIntegrator::resetHierarchyConfiguration" ref="a537371effd1221180c639dd54f0ef057" args="(const boost::shared_ptr&lt; hier::PatchHierarchy &gt; &amp;hierarchy, const int coarsest_level, const int finest_level)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void SAMRAI::algs::HyperbolicLevelIntegrator::resetHierarchyConfiguration </td>
          <td>(</td>
          <td class="paramtype">const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchHierarchy.html">hier::PatchHierarchy</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>hierarchy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>coarsest_level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>finest_level</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Reset cached communication schedules after the hierarchy has changed (due to regidding, for example) and the data has been initialized on the new levels. The intent is that the cost of data movement on the hierarchy will be amortized across multiple communication cycles, if possible. The level numbers indicate the range of levels in the hierarchy that have changed. However, this routine updates communication schedules every level finer than and including that indexed by the coarsest level number given.</p>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>hierarchy </dd>
<dd>
(coarsest_level &gt;= 0) &amp;&amp; (coarsest_level &lt;= finest_level) &amp;&amp; (finest_level &lt;= hierarchy-&gt;getFinestLevelNumber()) </dd>
<dd>
for all i &lt;= finest_level hierarchy-&gt;getPatchLevel(i) is non-NULL </dd></dl>

<p>Implements <a class="el" href="classSAMRAI_1_1mesh_1_1StandardTagAndInitStrategy.html#a13d73fc9054fdc7830ebd81c372a2492">SAMRAI::mesh::StandardTagAndInitStrategy</a>.</p>

</div>
</div>
<a class="anchor" id="a7f88cdceb7bc9afb7d33c2f117f8c68c"></a><!-- doxytag: member="SAMRAI::algs::HyperbolicLevelIntegrator::applyGradientDetector" ref="a7f88cdceb7bc9afb7d33c2f117f8c68c" args="(const boost::shared_ptr&lt; hier::PatchHierarchy &gt; &amp;hierarchy, const int level_number, const double error_data_time, const int tag_index, const bool initial_time, const bool uses_richardson_extrapolation_too)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void SAMRAI::algs::HyperbolicLevelIntegrator::applyGradientDetector </td>
          <td>(</td>
          <td class="paramtype">const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchHierarchy.html">hier::PatchHierarchy</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>hierarchy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>level_number</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>error_data_time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>tag_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&nbsp;</td>
          <td class="paramname"> <em>initial_time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&nbsp;</td>
          <td class="paramname"> <em>uses_richardson_extrapolation_too</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Set integer tags to "one" in cells where refinement of the given level should occur according to some user-supplied gradient criteria. The double time argument is the regrid time. The integer "tag_index" argument is the patch descriptor index of the cell-centered integer tag array on each patch in the hierarchy. The boolean argument initial_time indicates whether the level is being subject to refinement at the initial simulation time. If it is false, then the error estimation process is being invoked at some later time after the AMR hierarchy was initially constructed. The boolean argument uses_richardson_extrapolation_too is true when Richardson extrapolation error estimation is used in addition to the gradient detector, and false otherwise. This argument helps the user to manage multiple regridding criteria. This information is passed along to the user's patch tagging routines since the application of the gradient detector may be different in each case.</p>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>hierarchy </dd>
<dd>
(level_number &gt;= 0) &amp;&amp; (level_number &lt;= hierarchy-&gt;getFinestLevelNumber()) </dd>
<dd>
hierarchy-&gt;getPatchLevel(level_number) </dd></dl>

<p>Reimplemented from <a class="el" href="classSAMRAI_1_1mesh_1_1StandardTagAndInitStrategy.html#a3f9be742dabb8dfc770ba0f8a6f8d30c">SAMRAI::mesh::StandardTagAndInitStrategy</a>.</p>

</div>
</div>
<a class="anchor" id="a9207e0ee3cdf883f12fb7ea2809f96b7"></a><!-- doxytag: member="SAMRAI::algs::HyperbolicLevelIntegrator::applyRichardsonExtrapolation" ref="a9207e0ee3cdf883f12fb7ea2809f96b7" args="(const boost::shared_ptr&lt; hier::PatchLevel &gt; &amp;level, const double error_data_time, const int tag_index, const double deltat, const int error_coarsen_ratio, const bool initial_time, const bool uses_gradient_detector_too)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void SAMRAI::algs::HyperbolicLevelIntegrator::applyRichardsonExtrapolation </td>
          <td>(</td>
          <td class="paramtype">const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchLevel.html">hier::PatchLevel</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>error_data_time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>tag_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>deltat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>error_coarsen_ratio</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&nbsp;</td>
          <td class="paramname"> <em>initial_time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&nbsp;</td>
          <td class="paramname"> <em>uses_gradient_detector_too</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Set integer tags to "one" where refinement onf the given level should occur according to some user-supplied Richardson extrapolation criteria. The "error_data_time" argument is the regrid time. The "deltat" argument is the time increment to advance the solution on the level to be refined. Note that that level is finer than the level in the argument list, in general. The ratio between the argument level and the actual hierarchy level is given by the integer "coarsen ratio".</p>
<p>The integer "tag_index" argument is the patch descriptor index of the cell-centered integer tag array on each patch in the hierarchy.</p>
<p>The boolean argument initial_time indicates whether the level is being subject to refinement at the initial simulation time. If it is false, then the error estimation process is being invoked at some later time after the AMR hierarchy was initially constructed. Typically, this information is passed to the user's patch tagging routines since the application of the Richardson extrapolation process may be different in each case.</p>
<p>The boolean uses_gradient_detector_too is true when a gradient detector procedure is used in addition to Richardson extrapolation, and false otherwise. This argument helps the user to manage multiple regridding criteria.</p>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>level </dd></dl>

<p>Reimplemented from <a class="el" href="classSAMRAI_1_1mesh_1_1StandardTagAndInitStrategy.html#a637f74455a84fbe39d2318f7a378d65e">SAMRAI::mesh::StandardTagAndInitStrategy</a>.</p>

</div>
</div>
<a class="anchor" id="acca15f011e7ce423fc574ee26ad56320"></a><!-- doxytag: member="SAMRAI::algs::HyperbolicLevelIntegrator::coarsenDataForRichardsonExtrapolation" ref="acca15f011e7ce423fc574ee26ad56320" args="(const boost::shared_ptr&lt; hier::PatchHierarchy &gt; &amp;hierarchy, const int level_number, const boost::shared_ptr&lt; hier::PatchLevel &gt; &amp;coarse_level, const double coarsen_data_time, const bool before_advance)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void SAMRAI::algs::HyperbolicLevelIntegrator::coarsenDataForRichardsonExtrapolation </td>
          <td>(</td>
          <td class="paramtype">const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchHierarchy.html">hier::PatchHierarchy</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>hierarchy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>level_number</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchLevel.html">hier::PatchLevel</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>coarse_level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>coarsen_data_time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&nbsp;</td>
          <td class="paramname"> <em>before_advance</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Coarsen solution data from level to coarse_level for Richardson extrapolation. Note that this routine will be called twice during the Richardson extrapolation error estimation process. The before_advance boolean argument indicates whether data is set on the coarse level by coarsening the "old" time level solution (i.e., before it has been advanced) or by coarsening the "new" solution on the fine level (i.e., after it has been advanced).</p>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>hierarchy </dd>
<dd>
(level_number &gt;= 0) &amp;&amp; (level_number &lt;= hierarchy-&gt;getFinestLevelNumber()) </dd>
<dd>
(hierarchy-&gt;getPatchLevel(level_number) </dd>
<dd>
coarse_level </dd>
<dd>
hierarchy-&gt;getDim() == coarse_level-&gt;getDim() </dd></dl>

<p>Reimplemented from <a class="el" href="classSAMRAI_1_1mesh_1_1StandardTagAndInitStrategy.html#ac7bfba6ff925d93abec9d5c48a876d8e">SAMRAI::mesh::StandardTagAndInitStrategy</a>.</p>

</div>
</div>
<a class="anchor" id="abdcab6c4fa5e46ca902202d98246b40a"></a><!-- doxytag: member="SAMRAI::algs::HyperbolicLevelIntegrator::registerVariable" ref="abdcab6c4fa5e46ca902202d98246b40a" args="(const boost::shared_ptr&lt; hier::Variable &gt; &amp;var, const hier::IntVector ghosts, const HYP_VAR_TYPE h_v_type, const boost::shared_ptr&lt; hier::BaseGridGeometry &gt; &amp;transfer_geom, const std::string &amp;coarsen_name=std::string(), const std::string &amp;refine_name=std::string())" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void SAMRAI::algs::HyperbolicLevelIntegrator::registerVariable </td>
          <td>(</td>
          <td class="paramtype">const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1hier_1_1Variable.html">hier::Variable</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>var</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a>&nbsp;</td>
          <td class="paramname"> <em>ghosts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSAMRAI_1_1algs_1_1HyperbolicLevelIntegrator.html#a2b942773b6adae963741add627777f4d">HYP_VAR_TYPE</a>&nbsp;</td>
          <td class="paramname"> <em>h_v_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1hier_1_1BaseGridGeometry.html">hier::BaseGridGeometry</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>transfer_geom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>coarsen_name</em> = <code>std::string()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>refine_name</em> = <code>std::string()</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Register a variable with the hyperbolic integration algorithm. The variable type must be one of the options defined by the enumerated type defined above. Typically, this routine is called from the hyperbolic patch model when the variable registration process is invoked by calling the function <a class="el" href="classSAMRAI_1_1algs_1_1HyperbolicLevelIntegrator.html#a4064636b14a01ecea1d8955cb55ca37d">initializeLevelIntegrator()</a> above. In fact, that function should be called before this routine is called.</p>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>var </dd>
<dd>
transfer_geom </dd>
<dd>
ghosts.getDim() == var-&gt;getDim() </dd></dl>

</div>
</div>
<a class="anchor" id="afc904e9bd24a00f5964b2a3b89aa88e2"></a><!-- doxytag: member="SAMRAI::algs::HyperbolicLevelIntegrator::printClassData" ref="afc904e9bd24a00f5964b2a3b89aa88e2" args="(std::ostream &amp;os) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void SAMRAI::algs::HyperbolicLevelIntegrator::printClassData </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&nbsp;</td>
          <td class="paramname"> <em>os</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Print class data representation for hyperbolic level integrator object. </p>

</div>
</div>
<a class="anchor" id="a22b1b8c229365790d6b7751e6e79b79d"></a><!-- doxytag: member="SAMRAI::algs::HyperbolicLevelIntegrator::putToRestart" ref="a22b1b8c229365790d6b7751e6e79b79d" args="(const boost::shared_ptr&lt; tbox::Database &gt; &amp;restart_db) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void SAMRAI::algs::HyperbolicLevelIntegrator::putToRestart </td>
          <td>(</td>
          <td class="paramtype">const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Database.html">tbox::Database</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>restart_db</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Write out object state to the given restart database.</p>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>restart_db </dd></dl>

</div>
</div>
<a class="anchor" id="a28ed6af341fdcaa7b6b056e33a524799"></a><!-- doxytag: member="SAMRAI::algs::HyperbolicLevelIntegrator::getCurrentContext" ref="a28ed6af341fdcaa7b6b056e33a524799" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::shared_ptr&lt;<a class="el" href="classSAMRAI_1_1hier_1_1VariableContext.html">hier::VariableContext</a>&gt; SAMRAI::algs::HyperbolicLevelIntegrator::getCurrentContext </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return pointer to "current" variable context used by integrator. Current data corresponds to state data at the beginning of a timestep, or when a new level is initialized. </p>

</div>
</div>
<a class="anchor" id="aa11e245e1a4c1909d18a64e71c42143b"></a><!-- doxytag: member="SAMRAI::algs::HyperbolicLevelIntegrator::getNewContext" ref="aa11e245e1a4c1909d18a64e71c42143b" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::shared_ptr&lt;<a class="el" href="classSAMRAI_1_1hier_1_1VariableContext.html">hier::VariableContext</a>&gt; SAMRAI::algs::HyperbolicLevelIntegrator::getNewContext </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return pointer to "new" variable context used by integrator. New data corresponds to advanced state data at the end of a timestep. The data is one timestep later than the "current" data. </p>

</div>
</div>
<a class="anchor" id="aa59d005a38235327999883496fbea095"></a><!-- doxytag: member="SAMRAI::algs::HyperbolicLevelIntegrator::getOldContext" ref="aa59d005a38235327999883496fbea095" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::shared_ptr&lt;<a class="el" href="classSAMRAI_1_1hier_1_1VariableContext.html">hier::VariableContext</a>&gt; SAMRAI::algs::HyperbolicLevelIntegrator::getOldContext </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return pointer to "old" variable context used by integrator. Old data corresponds to an extra time level of state data used for Richardson extrapolation error estimation. The data is one timestep earlier than the "current" data.</p>
<p>Note that only in certain cases when using time-dependent error estimation, such as Richardson extrapolation, is the returned pointer will non-null. See contructor for more information. </p>

</div>
</div>
<a class="anchor" id="a4736fe87631feaa1c234b55ced8cfd36"></a><!-- doxytag: member="SAMRAI::algs::HyperbolicLevelIntegrator::getScratchContext" ref="a4736fe87631feaa1c234b55ced8cfd36" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::shared_ptr&lt;<a class="el" href="classSAMRAI_1_1hier_1_1VariableContext.html">hier::VariableContext</a>&gt; SAMRAI::algs::HyperbolicLevelIntegrator::getScratchContext </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return pointer to "scratch" variable context used by integrator. Scratch data typically corresponds to storage that user-routines in the concrete <a class="el" href="classSAMRAI_1_1algs_1_1HyperbolicPatchStrategy.html">HyperbolicPatchStrategy</a> object manipulate; in particular, scratch data contains ghost cells. </p>

</div>
</div>
<a class="anchor" id="a1d894e17b709a2ec6ef4ca167842f10c"></a><!-- doxytag: member="SAMRAI::algs::HyperbolicLevelIntegrator::getPlotContext" ref="a1d894e17b709a2ec6ef4ca167842f10c" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::shared_ptr&lt;<a class="el" href="classSAMRAI_1_1hier_1_1VariableContext.html">hier::VariableContext</a>&gt; SAMRAI::algs::HyperbolicLevelIntegrator::getPlotContext </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return pointer to variable context used for plotting. This context corresponds to the data storage that should be written to plot files. Typically, this is the same as the "current" context. </p>

</div>
</div>
<a class="anchor" id="aeca1cb61d5d5e5f9ce5dd15175b9b50c"></a><!-- doxytag: member="SAMRAI::algs::HyperbolicLevelIntegrator::usingRefinedTimestepping" ref="aeca1cb61d5d5e5f9ce5dd15175b9b50c" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SAMRAI::algs::HyperbolicLevelIntegrator::usingRefinedTimestepping </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return true if this class has been constructed to use refined timestepping and false if it has been constructed to use synchronized timestepping. </p>

<p>Implements <a class="el" href="classSAMRAI_1_1algs_1_1TimeRefinementLevelStrategy.html#a9ca6bd9cace490319f43f955dac7444f">SAMRAI::algs::TimeRefinementLevelStrategy</a>.</p>

</div>
</div>
<a class="anchor" id="ab0fc6774d81a203fc1189d5af578a24d"></a><!-- doxytag: member="SAMRAI::algs::HyperbolicLevelIntegrator::printStatistics" ref="ab0fc6774d81a203fc1189d5af578a24d" args="(std::ostream &amp;s=tbox::plog) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAMRAI::algs::HyperbolicLevelIntegrator::printStatistics </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&nbsp;</td>
          <td class="paramname"> <em>s</em> = <code><a class="el" href="namespaceSAMRAI_1_1tbox.html#ab84041705493761fb17a8127e3a2dca2">tbox::plog</a></code></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a58c4336cc6c7ff408ac7ce79908c872a"></a><!-- doxytag: member="SAMRAI::algs::HyperbolicLevelIntegrator::getObjectName" ref="a58c4336cc6c7ff408ac7ce79908c872a" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::string&amp; SAMRAI::algs::HyperbolicLevelIntegrator::getObjectName </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns the object name. </p>

</div>
</div>
<a class="anchor" id="a08f5b907893bd76e0f843f7287438e47"></a><!-- doxytag: member="SAMRAI::algs::HyperbolicLevelIntegrator::getFromInput" ref="a08f5b907893bd76e0f843f7287438e47" args="(const boost::shared_ptr&lt; tbox::Database &gt; &amp;input_db, bool is_from_restart)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void SAMRAI::algs::HyperbolicLevelIntegrator::getFromInput </td>
          <td>(</td>
          <td class="paramtype">const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Database.html">tbox::Database</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>input_db</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>is_from_restart</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Read values, indicated above, from given input database. The boolean argument is_from_restart should be set to true if the simulation is beginning from restart. Otherwise it should be set to false.</p>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>is_from_restart || input_db </dd></dl>

</div>
</div>
<a class="anchor" id="a054e224c8f4f4de88e6697b9c5d6f1a1"></a><!-- doxytag: member="SAMRAI::algs::HyperbolicLevelIntegrator::getFromRestart" ref="a054e224c8f4f4de88e6697b9c5d6f1a1" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void SAMRAI::algs::HyperbolicLevelIntegrator::getFromRestart </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Read object state from the restart file and initialize class data members. The database from which the restart data is read is determined by the object_name specified in the constructor.</p>
<p>Unrecoverable Errors:</p>
<ul>
<li>The database corresponding to object_name is not found in the restart file.</li>
</ul>
<ul>
<li>The class version number and restart version number do not match. </li>
</ul>

</div>
</div>
<a class="anchor" id="ad039dcd0eccf7c4ead3ad12ade6ea5c3"></a><!-- doxytag: member="SAMRAI::algs::HyperbolicLevelIntegrator::preprocessFluxData" ref="ad039dcd0eccf7c4ead3ad12ade6ea5c3" args="(const boost::shared_ptr&lt; hier::PatchLevel &gt; &amp;level, const double cur_time, const double new_time, const bool regrid_advance, const bool first_step, const bool last_step)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void SAMRAI::algs::HyperbolicLevelIntegrator::preprocessFluxData </td>
          <td>(</td>
          <td class="paramtype">const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchLevel.html">hier::PatchLevel</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>cur_time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>new_time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&nbsp;</td>
          <td class="paramname"> <em>regrid_advance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&nbsp;</td>
          <td class="paramname"> <em>first_step</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&nbsp;</td>
          <td class="paramname"> <em>last_step</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a8cb0540f8a8d68b52ce85c9daa3f450a"></a><!-- doxytag: member="SAMRAI::algs::HyperbolicLevelIntegrator::postprocessFluxData" ref="a8cb0540f8a8d68b52ce85c9daa3f450a" args="(const boost::shared_ptr&lt; hier::PatchLevel &gt; &amp;level, const bool regrid_advance, const bool first_step, const bool last_step)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void SAMRAI::algs::HyperbolicLevelIntegrator::postprocessFluxData </td>
          <td>(</td>
          <td class="paramtype">const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchLevel.html">hier::PatchLevel</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&nbsp;</td>
          <td class="paramname"> <em>regrid_advance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&nbsp;</td>
          <td class="paramname"> <em>first_step</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&nbsp;</td>
          <td class="paramname"> <em>last_step</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a49a106085a3a1ed06d0c5664bce5483e"></a><!-- doxytag: member="SAMRAI::algs::HyperbolicLevelIntegrator::copyTimeDependentData" ref="a49a106085a3a1ed06d0c5664bce5483e" args="(const boost::shared_ptr&lt; hier::PatchLevel &gt; &amp;level, const boost::shared_ptr&lt; hier::VariableContext &gt; &amp;src_context, const boost::shared_ptr&lt; hier::VariableContext &gt; &amp;dst_context)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void SAMRAI::algs::HyperbolicLevelIntegrator::copyTimeDependentData </td>
          <td>(</td>
          <td class="paramtype">const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchLevel.html">hier::PatchLevel</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1hier_1_1VariableContext.html">hier::VariableContext</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>src_context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1hier_1_1VariableContext.html">hier::VariableContext</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>dst_context</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a2ee358683ba0b8bee7998bc2514b8083"></a><!-- doxytag: member="SAMRAI::algs::HyperbolicLevelIntegrator::synchronizeLevelWithCoarser" ref="a2ee358683ba0b8bee7998bc2514b8083" args="(const boost::shared_ptr&lt; hier::PatchLevel &gt; &amp;fine, const boost::shared_ptr&lt; hier::PatchLevel &gt; &amp;coarse, const double sync_time, const double coarse_sim_time)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void SAMRAI::algs::HyperbolicLevelIntegrator::synchronizeLevelWithCoarser </td>
          <td>(</td>
          <td class="paramtype">const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchLevel.html">hier::PatchLevel</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>fine</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const boost::shared_ptr&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchLevel.html">hier::PatchLevel</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>coarse</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>sync_time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>coarse_sim_time</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Apply the standard AMR hyperbolic flux synchronization process preserve conservation properties in the solution between the fine level and the coarse level. The sync_time argument indicates the time at which the solution on the two levels is being synchronized. The variable coarse_sim_time indicates the previous simulation time on the coarse level (recall the conservative difference will be repeated on the coarse level during the synchronization process). After the synchronization, the flux and flux integral data storage is reset on the levels.</p>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>fine_level </dd>
<dd>
coarse_level </dd>
<dd>
coarse_level-&gt;getLevelNumber() == (fine_level-&gt;getLevelNumber()-1)) </dd>
<dd>
fine_level-&gt;getDim() == coarse_level-&gt;getDim() </dd>
<dd>
sync_time &gt; coarse_sim_time </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>source/SAMRAI/algs/<a class="el" href="HyperbolicLevelIntegrator_8h.html">HyperbolicLevelIntegrator.h</a></li>
</ul>
</div>
<hr size="1"/><address style="text-align: right;"><small>Generated on 26 Jun 2014 for SAMRAI by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.1 </small></address>
</body>
</html>
