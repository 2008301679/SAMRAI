<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>SAMRAI: SAMRAI::appu::EmbeddedBoundaryGeometry&lt; DIM &gt; Class Template Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.2 -->
<div class="qindex"><a class="qindex" href="main.html">Main&nbsp;Page</a> | <a class="qindex" href="namespaces.html">Namespace List</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="namespacemembers.html">Namespace&nbsp;Members</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a> | <a class="qindex" href="globals.html">File&nbsp;Members</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a></div>
<div class="nav">
<a class="el" href="namespaceSAMRAI.html">SAMRAI</a>::<a class="el" href="namespaceSAMRAI_1_1appu.html">appu</a>::<a class="el" href="classSAMRAI_1_1appu_1_1EmbeddedBoundaryGeometry.html">EmbeddedBoundaryGeometry</a></div>
<h1>SAMRAI::appu::EmbeddedBoundaryGeometry&lt; DIM &gt; Class Template Reference</h1>Class <a class="el" href="classSAMRAI_1_1appu_1_1EmbeddedBoundaryGeometry.html">EmbeddedBoundaryGeometry</a> provides embedded boundary mesh construction, storage, and management on an AMR hierarchy.  
<a href="#_details">More...</a>
<p>
<code>#include &lt;source/apputils/embedded_boundary/EmbeddedBoundaryGeometry.h&gt;</code>
<p>
Inheritance diagram for SAMRAI::appu::EmbeddedBoundaryGeometry&lt; DIM &gt;:<p><center><img src="classSAMRAI_1_1appu_1_1EmbeddedBoundaryGeometry__inherit__graph.png" border="0" usemap="#SAMRAI_1_1appu_1_1EmbeddedBoundaryGeometry_3_01DIM_01_4__inherit__map" alt="Inheritance graph"></center>
<map name="SAMRAI_1_1appu_1_1EmbeddedBoundaryGeometry_3_01DIM_01_4__inherit__map">
<area href="classSAMRAI_1_1appu_1_1VisMaterialsDataStrategy.html" shape="rect" coords="8,84,322,108" alt="">
<area href="classSAMRAI_1_1xfer_1_1RefinePatchStrategy.html" shape="rect" coords="346,84,626,108" alt="">
<area href="classSAMRAI_1_1tbox_1_1Serializable.html" shape="rect" coords="650,84,832,108" alt="">
<area href="classtbox_1_1DescribedClass.html" shape="rect" coords="684,9,798,33" alt="">
</map>
<center><font size="2">[<a target="top" href="graph_legend.html">legend</a>]</font></center><a href="classSAMRAI_1_1appu_1_1EmbeddedBoundaryGeometry-members.html">List of all members.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Types</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1appu_1_1EmbeddedBoundaryGeometry.html#w8">CELL_TYPE</a> { <a class="el" href="classSAMRAI_1_1appu_1_1EmbeddedBoundaryGeometry.html#w8w0">SOLID</a> =  EmbeddedBoundaryDefines::SOLID, 
<a class="el" href="classSAMRAI_1_1appu_1_1EmbeddedBoundaryGeometry.html#w8w1">CUT</a> =  EmbeddedBoundaryDefines::CUT, 
<a class="el" href="classSAMRAI_1_1appu_1_1EmbeddedBoundaryGeometry.html#w8w2">BORDER</a> =  EmbeddedBoundaryDefines::BORDER, 
<a class="el" href="classSAMRAI_1_1appu_1_1EmbeddedBoundaryGeometry.html#w8w3">FLOW</a> =  EmbeddedBoundaryDefines::FLOW
 }</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1appu_1_1EmbeddedBoundaryGeometry.html#w9">NODE_TYPE</a> { <a class="el" href="classSAMRAI_1_1appu_1_1EmbeddedBoundaryGeometry.html#w9w4">OUTSIDE</a> =  EmbeddedBoundaryDefines::OUTSIDE, 
<a class="el" href="classSAMRAI_1_1appu_1_1EmbeddedBoundaryGeometry.html#w9w5">INSIDE</a> =  EmbeddedBoundaryDefines::INSIDE, 
<a class="el" href="classSAMRAI_1_1appu_1_1EmbeddedBoundaryGeometry.html#w9w6">BOUNDARY</a> =  EmbeddedBoundaryDefines::BOUNDARY, 
<a class="el" href="classSAMRAI_1_1appu_1_1EmbeddedBoundaryGeometry.html#w9w7">ONBOUNDARY</a> =  EmbeddedBoundaryDefines::ONBOUNDARY
 }</td></tr>

<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1appu_1_1EmbeddedBoundaryGeometry.html#a0">EmbeddedBoundaryGeometry</a> (const string &amp;object_name, <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Database.html">tbox::Database</a> &gt; input_db=(0), const <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1geom_1_1CartesianGridGeometry.html">geom::CartesianGridGeometry</a>&lt; DIM &gt; &gt; grid_geom=(0), const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a>&lt; DIM &gt; &amp;nghosts=<a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a>&lt; DIM &gt;(0))</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1appu_1_1EmbeddedBoundaryGeometry.html#a1">~EmbeddedBoundaryGeometry</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1appu_1_1EmbeddedBoundaryGeometry.html#a2">buildEmbeddedBoundaryOnLevel</a> (const <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchLevel.html">hier::PatchLevel</a>&lt; DIM &gt; &gt; level, const <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchHierarchy.html">hier::PatchHierarchy</a>&lt; DIM &gt; &gt; hierarchy=(0), const <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchLevel.html">hier::PatchLevel</a>&lt; DIM &gt; &gt; old_level=(0))</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1appu_1_1EmbeddedBoundaryGeometry.html#a3">tagInsideOutsideNodesOnLevel</a> (const <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchLevel.html">hier::PatchLevel</a>&lt; DIM &gt; &gt; level)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1appu_1_1EmbeddedBoundaryGeometry.html#a4">registerVisItDataWriter</a> (<a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1appu_1_1VisItDataWriter.html">appu::VisItDataWriter</a>&lt; DIM &gt; &gt; visit_writer)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1appu_1_1EmbeddedBoundaryGeometry.html#a5">getCellFlagDataId</a> () const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1appu_1_1EmbeddedBoundaryGeometry.html#a6">getCellVolumeDataId</a> () const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1appu_1_1EmbeddedBoundaryGeometry.html#a7">getIndexCutCellDataId</a> () const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1appu_1_1EmbeddedBoundaryGeometry.html#a8">getNodeInsideOutsideDataId</a> () const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1appu_1_1EmbeddedBoundaryGeometry.html#a9">computeTotalVolumeOnLevel</a> (const <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchLevel.html">hier::PatchLevel</a>&lt; DIM &gt; &gt; level)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1appu_1_1EmbeddedBoundaryGeometry.html#a10">setGridGeometry</a> (const <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1geom_1_1CartesianGridGeometry.html">geom::CartesianGridGeometry</a>&lt; DIM &gt; &gt; grid_geom)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1appu_1_1EmbeddedBoundaryGeometry.html#a11">writeLevelEmbeddedBoundaryDataToFile</a> (const <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchLevel.html">hier::PatchLevel</a>&lt; DIM &gt; &gt; level, const string &amp;dirname) const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1appu_1_1EmbeddedBoundaryGeometry.html#a12">packMaterialFractionsIntoDoubleBuffer</a> (double *dbuffer, const <a class="el" href="classSAMRAI_1_1hier_1_1Patch.html">hier::Patch</a>&lt; DIM &gt; &amp;patch, const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">hier::Box</a>&lt; DIM &gt; &amp;region, const string &amp;material_name)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1appu_1_1EmbeddedBoundaryGeometry.html#a13">setPhysicalBoundaryConditions</a> (<a class="el" href="classSAMRAI_1_1hier_1_1Patch.html">hier::Patch</a>&lt; DIM &gt; &amp;patch, const double fill_time, const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a>&lt; DIM &gt; &amp;ghost_width_to_fill)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1appu_1_1EmbeddedBoundaryGeometry.html#a14">preprocessRefine</a> (<a class="el" href="classSAMRAI_1_1hier_1_1Patch.html">hier::Patch</a>&lt; DIM &gt; &amp;fine, const <a class="el" href="classSAMRAI_1_1hier_1_1Patch.html">hier::Patch</a>&lt; DIM &gt; &amp;coarse, const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">hier::Box</a>&lt; DIM &gt; &amp;fine_box, const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a>&lt; DIM &gt; &amp;ratio)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1appu_1_1EmbeddedBoundaryGeometry.html#a15">postprocessRefine</a> (<a class="el" href="classSAMRAI_1_1hier_1_1Patch.html">hier::Patch</a>&lt; DIM &gt; &amp;fine, const <a class="el" href="classSAMRAI_1_1hier_1_1Patch.html">hier::Patch</a>&lt; DIM &gt; &amp;coarse, const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">hier::Box</a>&lt; DIM &gt; &amp;fine_box, const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a>&lt; DIM &gt; &amp;ratio)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a>&lt; DIM &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1appu_1_1EmbeddedBoundaryGeometry.html#a16">getRefineOpStencilWidth</a> () const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSAMRAI_1_1appu_1_1EmbeddedBoundaryGeometry.html#a17">putToDatabase</a> (<a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Database.html">tbox::Database</a> &gt; db)</td></tr>

</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
<h3>template&lt;int DIM&gt;<br>
 class SAMRAI::appu::EmbeddedBoundaryGeometry&lt; DIM &gt;</h3>

Class <a class="el" href="classSAMRAI_1_1appu_1_1EmbeddedBoundaryGeometry.html">EmbeddedBoundaryGeometry</a> provides embedded boundary mesh construction, storage, and management on an AMR hierarchy. 
<p>
The embedded boundary may be constructed from a set of analytic shapes supplied through input. The following outlines the steps required:<p>
1. Construct an <a class="el" href="classSAMRAI_1_1appu_1_1EmbeddedBoundaryGeometry.html">EmbeddedBoundaryGeometry</a> object, supplying the input file that contains the shape entries, a pointer to the Cartesian grid geometry, and the desired number of ghosts to be used in defining the embedded boundary:<p>
<div class="fragment"><pre class="fragment"> *    EmbeddedBoundaryGeometry* eb_geom = 
 *       new EmbeddedBoundaryGeometry("EmbeddedBoundaryGeometry",
 *                                     input_db-&gt;getDatabase("EBdryGeometry"),
 *                                     grid_geometry,
 *                                     nghosts);
 *    </pre></div><p>
Note: The cart_grid_geometry argument is optional and may be supplied later using the "setGridGeometry()" method. However, it must be set before the "buildEmbeddedBoundaryOnLevel()" is called. The nghosts argument is also optional and is set to zero by default.<p>
2. Build the embedded boundary on the levels of the hierarchy:<p>
<div class="fragment"><pre class="fragment"> *    Pointer&lt;PatchLevel&lt;NDIM&gt; &gt; level = hierarchy-&gt;getPatchLevel(ln);
 *    eb_geom-&gt;buildEmbeddedBoundaryOnLevel(level);
 *    </pre></div><p>
Note: It is also possible to pass in a hierarchy and an old level as arguments. If supplied, this information can be used to accelerate construction of the boundary on the supplied level.<p>
3. Access information about the embedded boundary from patches:<p>
<ul>
<li>The "cell flag" identifies whether a cell is cut, solid, or flow</li><li>The "node flag" identifies nodes as inside, outside, boundary (first node just inside solid boundary), or on-boundary (within a specified distance from the solid boundary).</li><li>The "volume fraction" will be 0.0 for solid cells, 1.0 for flow cells, and somewhere in-between for cut cells</li><li>The list of "cut cells" holds information about the normal, face areas, etc. on specific cells that are cut.</li></ul>
<p>
<div class="fragment"><pre class="fragment"> *    int cell_flag_index = eb_geom-&gt;getCellFlagDataId();  
 *    int node_flag_index = eb_geom-&gt;getNodeInsideOutsideDataId();  
 *    int vol_frac_index = eb_geom-&gt;getCellVolumeDataId();  
 *    int cut_cell_index = eb_geom-&gt;getIndexCutCellDataId();
 *
 *    tbox::Pointer&lt;CellData&lt;NDIM,int&gt; &gt; cell_flag_data = 
 *        patch-&gt;getPatchData(cell_flag_index); 
 *    tbox::Pointer&lt;NodeData&lt;NDIM,int&gt; &gt; node_flag_data = 
 *        patch-&gt;getPatchData(node_flag_index); 
 *    tbox::Pointer&lt;CellData&lt;NDIM,double&gt; &gt; vol_frac_data = 
 *        patch-&gt;getPatchData(vol_frac_index); 
 *    tbox::Pointer&lt;IndexData&lt;NDIM,CutCell&gt; &gt; cut_cell_data = 
 *        patch-&gt;getPatchData(cut_cell_index); 
 *    </pre></div><p>
Input parameters specify the list of shapes to be used to construct the boundary, the desired accuracy of the volume and area fraction computation, and information about whether write constructed embedded boundary information to file, or read from file.<p>
Required input keys and data types: NONE<p>
Optional input keys, data types, and defaults:<p>
-<b>verbose</b> boolean specifying whether to output information about the embedded boundary, such as the number of cut cells, the error in the volume calculation, etc. to the log file. If no value is supplied in input, the default is TRUE.<p>
-<b>max_subdivides</b> integer specifying the number of cell subdivides when computing the volume and area fractions. The larger the number of subdivides, the more accurate the fraction calculation will be, but the calculation will also be more expensive. If no value is supplied in input, a default of 0 is used.<p>
-<b>read_from_file</b> bool specifying whether to read the embedded boundary from file. If true, it will read flag, volume fraction, and cut cell information describing the embedded boundary from the specified HDF "dirname" (specified below). If no value is supplied, the default is FALSE.<p>
-<b>write_to_file</b> bool specifying whether to write the embedded boundary to the specified HDF "dirname" (specified below). If true, it will write flag, volume fraction, and cut cell information computed while building the embedded boundary to the specified HDF "dirname" (specified below). If no value is supplied, the default is FALSE.<p>
-<b>dirname</b> string specifying the name of the HDF directory to read/write embedded boundary information. Used with the "read_from_file" and "write_to_file" options.<p>
-<b>compute_areas_and_normal</b> bool specifying whether to compute areas and normal information. Some applications only need the volume fraction so it is not necessary to invoke the extra cost of computing the areas and normal. If no value is supplied, the default is TRUE.<p>
-<b>compute_cutcell_index_data</b> bool specifying whether to compute a list of cut cells. If false, it will compute the cell flag and volume fraction information but will not create and store the list of <a class="el" href="classSAMRAI_1_1appu_1_1CutCell.html">CutCell</a> data structs. If no value is supplied, the default is TRUE.<p>
-<b>compute_boundary_node_data</b> bool specifying whether to mark nodes that are just inside the geometry as BOUNDARY nodes, and to compute the centroid of the wetted cut area (i.e. the "front area") of the cut cells. This information may be needed for node-based finite difference or finite element computations of the embedded boundary. If no value is supplied, the default is TRUE.<p>
-<b>use_recursive_algs</b> bool specifying whether to use a recursive algorithm to compute volume and area fractions. If true, it volume and area fractions are computed by recursively subdividing the cell until the max number of subdivides is reached. If false, it will apply the max subdivides to divide the cell into a (potentially large) array of subcells. Algorithmically, the recursive algorithm has fewer operations but the non-recursive algorithm may be more computationally efficient because it can do array-based operations. If no value is supplied, the default is TRUE.<p>
-<b>Shapes</b> sub-database that specifies information about the analytic shapes used to construct an embedded boundary. See the <a class="el" href="classSAMRAI_1_1appu_1_1EmbeddedBoundaryShapeSphere.html">EmbeddedBoundaryShapeSphere</a> and <a class="el" href="classSAMRAI_1_1appu_1_1EmbeddedBoundaryShapePolygon.html">EmbeddedBoundaryShapePolygon</a> class headers for information on the inputs required.<p>
-<b>CubesPatchInterface</b> sub-database for the Cubes interface, a cut-cell mesh generator from NASA Ames. See the CubesPatchInterface class header for information about the required inputs.<p>
The following represents a sample input entry:<p>
<div class="fragment"><pre class="fragment"> *  EmbeddedBoundaryGeometry{
 *     max_subdivides = 2
 *     read_from_file  = FALSE 
 *     write_to_file   = FALSE
 *     dirname         = "eb_grid"
 *     compute_areas_and_normal   = TRUE 
 *     compute_boundary_node_data = FALSE
 *     use_recursive_algs         = FALSE 
 *
 *     Shapes {
 *        Shape1 {
 *           type = "POLYGON"    
 *           vertices {
 *              v1 = 1.0 , 1.0
 *              v2 = 1.5 , .5 
 *              v3 = 2.0 , 1.75 
 *              v4 = 1.5 , 4.5
 *              v5 = .5 , 2.0 
 *           }
 *           height = 5.0 // only used for 3D 
 *        }
 *        Shape2 {
 *           type = "SPHERE"    
 *           center = 65., 50.
 *           radius = 20.     
 *        }
 *     }
 *  }
 *  </pre></div><p>
Note: Each shape has its own specific set of inputs. See the individual shapes for information about input requirements.<p>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classSAMRAI_1_1appu_1_1EmbeddedBoundaryShapeSphere.html">appu::EmbeddedBoundaryShapeSphere</a> <p>
<a class="el" href="classSAMRAI_1_1appu_1_1EmbeddedBoundaryShapePolygon.html">appu::EmbeddedBoundaryShapePolygon</a> <p>
appu::CubesPatchInterface <p>
appu::ElevenPatchInterface <p>
<a class="el" href="classSAMRAI_1_1appu_1_1CutCell.html">appu::CutCell</a> </dd></dl>

<p>
<hr><h2>Member Enumeration Documentation</h2>
<a class="anchor" name="w8" doxytag="SAMRAI::appu::EmbeddedBoundaryGeometry::CELL_TYPE"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="mdPrefix" colspan="4">
template&lt;int DIM&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top">enum <a class="el" href="classSAMRAI_1_1appu_1_1EmbeddedBoundaryGeometry.html#w8">SAMRAI::appu::EmbeddedBoundaryGeometry::CELL_TYPE</a>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Enumerated type for the different cell classifications.<p>
<ul>
<li><b>SOLID</b> {Cell is located in the "solid" region.}</li><li><b>CUT</b> {Cell is cut, meaning a <a class="el" href="classSAMRAI_1_1appu_1_1CutCell.html">CutCell</a> data structure will be maintained at this cell.}</li><li><b>BORDER</b> {Cell neighbors a cut cell, in the "flow" region.}</li><li><b>FLOW</b> {Cell is located in the "flow" region.} </li></ul>
<dl compact><dt><b>Enumeration values: </b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" name="w8w0" doxytag="SOLID"></a>SOLID</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" name="w8w1" doxytag="CUT"></a>CUT</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" name="w8w2" doxytag="BORDER"></a>BORDER</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" name="w8w3" doxytag="FLOW"></a>FLOW</em>&nbsp;</td><td>
</td></tr>
</table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="w9" doxytag="SAMRAI::appu::EmbeddedBoundaryGeometry::NODE_TYPE"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="mdPrefix" colspan="4">
template&lt;int DIM&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top">enum <a class="el" href="classSAMRAI_1_1appu_1_1EmbeddedBoundaryGeometry.html#w9">SAMRAI::appu::EmbeddedBoundaryGeometry::NODE_TYPE</a>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Enumerated type for inside/outside node classification.<p>
<ul>
<li><b>INSIDE</b> {Node is located "inside" the prescribed geometry.}</li><li><b>OUTSIDE</b> {Node is outside the geometry.}</li><li><b>BOUNDARY</b> {Node is on the boundary of the geometry. That is it is the first one "inside" the geometry.}</li><li><b>ONBOUNDARY</b> {Node is located exactly on the boundary of the geometry (used to avoid divide-by-zero problems) in numerical operations at embedded boundary.} </li></ul>
<dl compact><dt><b>Enumeration values: </b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" name="w9w4" doxytag="OUTSIDE"></a>OUTSIDE</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" name="w9w5" doxytag="INSIDE"></a>INSIDE</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" name="w9w6" doxytag="BOUNDARY"></a>BOUNDARY</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" name="w9w7" doxytag="ONBOUNDARY"></a>ONBOUNDARY</em>&nbsp;</td><td>
</td></tr>
</table>
</dl>
    </td>
  </tr>
</table>
<hr><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" name="a0" doxytag="SAMRAI::appu::EmbeddedBoundaryGeometry::EmbeddedBoundaryGeometry"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="mdPrefix" colspan="4">
template&lt;int DIM&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="classSAMRAI_1_1appu_1_1EmbeddedBoundaryGeometry.html">SAMRAI::appu::EmbeddedBoundaryGeometry</a>&lt; DIM &gt;::<a class="el" href="classSAMRAI_1_1appu_1_1EmbeddedBoundaryGeometry.html">EmbeddedBoundaryGeometry</a>           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const string &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>object_name</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Database.html">tbox::Database</a> &gt;&nbsp;</td>
          <td class="mdname" nowrap> <em>input_db</em> = <code>(0)</code>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1geom_1_1CartesianGridGeometry.html">geom::CartesianGridGeometry</a>&lt; DIM &gt; &gt;&nbsp;</td>
          <td class="mdname" nowrap> <em>grid_geom</em> = <code>(0)</code>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a>&lt; DIM &gt; &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>nghosts</em> = <code><a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a>&lt;&nbsp;DIM&nbsp;&gt;(0)</code></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Constructor sets default values and reads data from input.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>object_name</em>&nbsp;</td><td>Name of object. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>input_db</em>&nbsp;</td><td>Input database. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>grid_geom</em>&nbsp;</td><td>The grid geometry (<a class="el" href="solv__cartesianrobinbchelper3d_8f.html#a8">e.g</a>. cartesian) used in the problem. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nghosts</em>&nbsp;</td><td>Number of ghosts used to hold the embedded boundary. If not supplied, defaults to 0.</td></tr>
  </table>
</dl>
The grid_geom and nghosts may be NULL if the embedded boundary information is to be supplied by a file, either by restart or by other input such as CART3D. If the embedded boundary is to be constructed using analytic shapes in <a class="el" href="namespaceSAMRAI.html">SAMRAI</a>, the input_db and and grid_geom arguments must be supplied and may not be NULL.     </td>
  </tr>
</table>
<a class="anchor" name="a1" doxytag="SAMRAI::appu::EmbeddedBoundaryGeometry::~EmbeddedBoundaryGeometry"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="mdPrefix" colspan="4">
template&lt;int DIM&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="classSAMRAI_1_1appu_1_1EmbeddedBoundaryGeometry.html">SAMRAI::appu::EmbeddedBoundaryGeometry</a>&lt; DIM &gt;::~<a class="el" href="classSAMRAI_1_1appu_1_1EmbeddedBoundaryGeometry.html">EmbeddedBoundaryGeometry</a>&lt; DIM &gt;           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Destructor deallocates data describing and unregisters the object with the restart manager if previously registered.     </td>
  </tr>
</table>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="a2" doxytag="SAMRAI::appu::EmbeddedBoundaryGeometry::buildEmbeddedBoundaryOnLevel"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="mdPrefix" colspan="4">
template&lt;int DIM&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top">void <a class="el" href="classSAMRAI_1_1appu_1_1EmbeddedBoundaryGeometry.html">SAMRAI::appu::EmbeddedBoundaryGeometry</a>&lt; DIM &gt;::buildEmbeddedBoundaryOnLevel           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchLevel.html">hier::PatchLevel</a>&lt; DIM &gt; &gt;&nbsp;</td>
          <td class="mdname" nowrap> <em>level</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchHierarchy.html">hier::PatchHierarchy</a>&lt; DIM &gt; &gt;&nbsp;</td>
          <td class="mdname" nowrap> <em>hierarchy</em> = <code>(0)</code>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchLevel.html">hier::PatchLevel</a>&lt; DIM &gt; &gt;&nbsp;</td>
          <td class="mdname" nowrap> <em>old_level</em> = <code>(0)</code></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Build an embedded boundary by forming the set of cut cells, extend them to appropriately apply the physical boundary conditions, and lastly compute the surrounding volumes for mass correction.<p>
Depending on the arguments supplied, this method may be used in one of two ways. The first, taking only the level as an argument, performs an exhaustive search of all cells on the level to find the cut cells and classify the cells as inside or outside. The second, taking as additional arguments a hierarchy, coarser_level, and possibly old_level, performs the same function but uses the information on the coarser and old levels to narrow the search for cut cells, making it considerably faster. Generally, the first method is used for the coarsest level only and the second is used for all subsequent finer levels.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>level</em>&nbsp;</td><td>Patch level on which embedded boundary is to be constructed. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>hierarchy</em>&nbsp;</td><td>Patch hierarchy of the level. Required if the level supplied in the first argument is in the hierarchy and is not the coarsest level. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>old_level</em>&nbsp;</td><td>Patch level which holds "old" embedded boundary data (not required). Use this if regridding and you have an embedded boundary at the old level to speed construction of the boundary on the new level. </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a3" doxytag="SAMRAI::appu::EmbeddedBoundaryGeometry::tagInsideOutsideNodesOnLevel"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="mdPrefix" colspan="4">
template&lt;int DIM&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top">void <a class="el" href="classSAMRAI_1_1appu_1_1EmbeddedBoundaryGeometry.html">SAMRAI::appu::EmbeddedBoundaryGeometry</a>&lt; DIM &gt;::tagInsideOutsideNodesOnLevel           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchLevel.html">hier::PatchLevel</a>&lt; DIM &gt; &gt;&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>level</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Tag nodes as being inside or outside the geometry. Some applications only require this knowledge and do not use need the volume/area fraction information for cut cells.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>level</em>&nbsp;</td><td>Patch level where tagging takes place. </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a4" doxytag="SAMRAI::appu::EmbeddedBoundaryGeometry::registerVisItDataWriter"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="mdPrefix" colspan="4">
template&lt;int DIM&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top">void <a class="el" href="classSAMRAI_1_1appu_1_1EmbeddedBoundaryGeometry.html">SAMRAI::appu::EmbeddedBoundaryGeometry</a>&lt; DIM &gt;::registerVisItDataWriter           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1appu_1_1VisItDataWriter.html">appu::VisItDataWriter</a>&lt; DIM &gt; &gt;&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>visit_writer</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Register a VisIt data writer so this class will write plot files that may be postprocessed with the VisIt visualization tool.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>visit_writer</em>&nbsp;</td><td>VisIt data writer </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a5" doxytag="SAMRAI::appu::EmbeddedBoundaryGeometry::getCellFlagDataId"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="mdPrefix" colspan="4">
template&lt;int DIM&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top">int <a class="el" href="classSAMRAI_1_1appu_1_1EmbeddedBoundaryGeometry.html">SAMRAI::appu::EmbeddedBoundaryGeometry</a>&lt; DIM &gt;::getCellFlagDataId           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const</td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Return the descriptor index for the CellData&lt;DIM,int&gt; patch data that holds the integer flag at each cell, identifying it as being solid, cut, boundary, or flow.     </td>
  </tr>
</table>
<a class="anchor" name="a6" doxytag="SAMRAI::appu::EmbeddedBoundaryGeometry::getCellVolumeDataId"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="mdPrefix" colspan="4">
template&lt;int DIM&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top">int <a class="el" href="classSAMRAI_1_1appu_1_1EmbeddedBoundaryGeometry.html">SAMRAI::appu::EmbeddedBoundaryGeometry</a>&lt; DIM &gt;::getCellVolumeDataId           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const</td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Return the descriptor index for the CellData&lt;DIM,double&gt; patch data that holds the cell volume fraction.     </td>
  </tr>
</table>
<a class="anchor" name="a7" doxytag="SAMRAI::appu::EmbeddedBoundaryGeometry::getIndexCutCellDataId"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="mdPrefix" colspan="4">
template&lt;int DIM&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top">int <a class="el" href="classSAMRAI_1_1appu_1_1EmbeddedBoundaryGeometry.html">SAMRAI::appu::EmbeddedBoundaryGeometry</a>&lt; DIM &gt;::getIndexCutCellDataId           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const</td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Return the descriptor index for the IndexData&lt;DIM,CutCell&gt; patch data that holds the list of embedded boundary cells on the patch.     </td>
  </tr>
</table>
<a class="anchor" name="a8" doxytag="SAMRAI::appu::EmbeddedBoundaryGeometry::getNodeInsideOutsideDataId"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="mdPrefix" colspan="4">
template&lt;int DIM&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top">int <a class="el" href="classSAMRAI_1_1appu_1_1EmbeddedBoundaryGeometry.html">SAMRAI::appu::EmbeddedBoundaryGeometry</a>&lt; DIM &gt;::getNodeInsideOutsideDataId           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const</td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Return the descriptor index for the NodeData&lt;DIM,int&gt; patch data that specifies a cell as being inside or outside the geometry.     </td>
  </tr>
</table>
<a class="anchor" name="a9" doxytag="SAMRAI::appu::EmbeddedBoundaryGeometry::computeTotalVolumeOnLevel"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="mdPrefix" colspan="4">
template&lt;int DIM&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top">double <a class="el" href="classSAMRAI_1_1appu_1_1EmbeddedBoundaryGeometry.html">SAMRAI::appu::EmbeddedBoundaryGeometry</a>&lt; DIM &gt;::computeTotalVolumeOnLevel           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchLevel.html">hier::PatchLevel</a>&lt; DIM &gt; &gt;&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>level</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Compute the total volume, which is the sum of the volume fractions, on the supplied level.     </td>
  </tr>
</table>
<a class="anchor" name="a10" doxytag="SAMRAI::appu::EmbeddedBoundaryGeometry::setGridGeometry"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="mdPrefix" colspan="4">
template&lt;int DIM&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top">void <a class="el" href="classSAMRAI_1_1appu_1_1EmbeddedBoundaryGeometry.html">SAMRAI::appu::EmbeddedBoundaryGeometry</a>&lt; DIM &gt;::setGridGeometry           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1geom_1_1CartesianGridGeometry.html">geom::CartesianGridGeometry</a>&lt; DIM &gt; &gt;&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>grid_geom</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Set the grid geometry, if it was not supplied when the object was constructed.     </td>
  </tr>
</table>
<a class="anchor" name="a11" doxytag="SAMRAI::appu::EmbeddedBoundaryGeometry::writeLevelEmbeddedBoundaryDataToFile"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="mdPrefix" colspan="4">
template&lt;int DIM&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top">void <a class="el" href="classSAMRAI_1_1appu_1_1EmbeddedBoundaryGeometry.html">SAMRAI::appu::EmbeddedBoundaryGeometry</a>&lt; DIM &gt;::writeLevelEmbeddedBoundaryDataToFile           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const <a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1hier_1_1PatchLevel.html">hier::PatchLevel</a>&lt; DIM &gt; &gt;&nbsp;</td>
          <td class="mdname" nowrap> <em>level</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const string &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>dirname</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"> const</td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Write embedded boundary information - cell flag and cut cell information - to supplied directory. Files of the form "ebmesh-l&lt;ln&gt;-p&lt;pid&gt;.hdf", where ln is the level number and pid is the processor number, will be written to the directory.     </td>
  </tr>
</table>
<a class="anchor" name="a12" doxytag="SAMRAI::appu::EmbeddedBoundaryGeometry::packMaterialFractionsIntoDoubleBuffer"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="mdPrefix" colspan="4">
template&lt;int DIM&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top">int <a class="el" href="classSAMRAI_1_1appu_1_1EmbeddedBoundaryGeometry.html">SAMRAI::appu::EmbeddedBoundaryGeometry</a>&lt; DIM &gt;::packMaterialFractionsIntoDoubleBuffer           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">double *&nbsp;</td>
          <td class="mdname" nowrap> <em>dbuffer</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const <a class="el" href="classSAMRAI_1_1hier_1_1Patch.html">hier::Patch</a>&lt; DIM &gt; &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>patch</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">hier::Box</a>&lt; DIM &gt; &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>region</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const string &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>material_name</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Put volume data located on the patch into the double buffer over the specified region.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dbuffer</em>&nbsp;</td><td>double buffer into which materials data is packed. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>patch</em>&nbsp;</td><td>supplied patch on which materials data is defined </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>region</em>&nbsp;</td><td>region over which data is packed </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>material_name</em>&nbsp;</td><td>name of the material </td></tr>
  </table>
</dl>

<p>
Reimplemented from <a class="el" href="classSAMRAI_1_1appu_1_1VisMaterialsDataStrategy.html#a2">SAMRAI::appu::VisMaterialsDataStrategy&lt; DIM &gt;</a>.    </td>
  </tr>
</table>
<a class="anchor" name="a13" doxytag="SAMRAI::appu::EmbeddedBoundaryGeometry::setPhysicalBoundaryConditions"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="mdPrefix" colspan="4">
template&lt;int DIM&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top">void <a class="el" href="classSAMRAI_1_1appu_1_1EmbeddedBoundaryGeometry.html">SAMRAI::appu::EmbeddedBoundaryGeometry</a>&lt; DIM &gt;::setPhysicalBoundaryConditions           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="classSAMRAI_1_1hier_1_1Patch.html">hier::Patch</a>&lt; DIM &gt; &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>patch</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const double&nbsp;</td>
          <td class="mdname" nowrap> <em>fill_time</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a>&lt; DIM &gt; &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>ghost_width_to_fill</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Set the data in ghost cells corresponding to physical boundary conditions. Specific boundary conditions are determined by information specified in input file and numerical routines. 
<p>
Implements <a class="el" href="classSAMRAI_1_1xfer_1_1RefinePatchStrategy.html#a2">SAMRAI::xfer::RefinePatchStrategy&lt; DIM &gt;</a>.    </td>
  </tr>
</table>
<a class="anchor" name="a14" doxytag="SAMRAI::appu::EmbeddedBoundaryGeometry::preprocessRefine"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="mdPrefix" colspan="4">
template&lt;int DIM&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top">virtual void <a class="el" href="classSAMRAI_1_1appu_1_1EmbeddedBoundaryGeometry.html">SAMRAI::appu::EmbeddedBoundaryGeometry</a>&lt; DIM &gt;::preprocessRefine           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="classSAMRAI_1_1hier_1_1Patch.html">hier::Patch</a>&lt; DIM &gt; &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>fine</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const <a class="el" href="classSAMRAI_1_1hier_1_1Patch.html">hier::Patch</a>&lt; DIM &gt; &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>coarse</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">hier::Box</a>&lt; DIM &gt; &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>fine_box</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a>&lt; DIM &gt; &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>ratio</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inline, virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Perform user-defined refining operations. This member function is called before the other refining operators. For this class, no preprocessing is needed for the refine operators so it is setup to do nothing. 
<p>
Implements <a class="el" href="classSAMRAI_1_1xfer_1_1RefinePatchStrategy.html#a4">SAMRAI::xfer::RefinePatchStrategy&lt; DIM &gt;</a>.    </td>
  </tr>
</table>
<a class="anchor" name="a15" doxytag="SAMRAI::appu::EmbeddedBoundaryGeometry::postprocessRefine"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="mdPrefix" colspan="4">
template&lt;int DIM&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top">void <a class="el" href="classSAMRAI_1_1appu_1_1EmbeddedBoundaryGeometry.html">SAMRAI::appu::EmbeddedBoundaryGeometry</a>&lt; DIM &gt;::postprocessRefine           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="classSAMRAI_1_1hier_1_1Patch.html">hier::Patch</a>&lt; DIM &gt; &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>fine</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const <a class="el" href="classSAMRAI_1_1hier_1_1Patch.html">hier::Patch</a>&lt; DIM &gt; &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>coarse</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const <a class="el" href="classSAMRAI_1_1hier_1_1Box.html">hier::Box</a>&lt; DIM &gt; &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>fine_box</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const <a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a>&lt; DIM &gt; &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>ratio</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Postprocess data after the refinement operator is applied. For the embedded boundary data, refining involves two steps; First, refine the "flag" data, which will designate on the fine level where the boundary exists; Second, on each fine cell that is flagged to possibly contain the boundary, go through and determine whether the cell is indeed cut by the boundary and adjust the volume, flag, and boundary cell data on the fine level as necessary. This method invokes step 2 of this refine operation. 
<p>
Implements <a class="el" href="classSAMRAI_1_1xfer_1_1RefinePatchStrategy.html#a5">SAMRAI::xfer::RefinePatchStrategy&lt; DIM &gt;</a>.    </td>
  </tr>
</table>
<a class="anchor" name="a16" doxytag="SAMRAI::appu::EmbeddedBoundaryGeometry::getRefineOpStencilWidth"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="mdPrefix" colspan="4">
template&lt;int DIM&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="classSAMRAI_1_1hier_1_1IntVector.html">hier::IntVector</a>&lt; DIM &gt; <a class="el" href="classSAMRAI_1_1appu_1_1EmbeddedBoundaryGeometry.html">SAMRAI::appu::EmbeddedBoundaryGeometry</a>&lt; DIM &gt;::getRefineOpStencilWidth           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const<code> [virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Return maximum stencil width needed for user-defined data interpolation operations. Default is to return zero, assuming no user-defined operations provided. 
<p>
Implements <a class="el" href="classSAMRAI_1_1xfer_1_1RefinePatchStrategy.html#a3">SAMRAI::xfer::RefinePatchStrategy&lt; DIM &gt;</a>.    </td>
  </tr>
</table>
<a class="anchor" name="a17" doxytag="SAMRAI::appu::EmbeddedBoundaryGeometry::putToDatabase"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="mdPrefix" colspan="4">
template&lt;int DIM&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top">void <a class="el" href="classSAMRAI_1_1appu_1_1EmbeddedBoundaryGeometry.html">SAMRAI::appu::EmbeddedBoundaryGeometry</a>&lt; DIM &gt;::putToDatabase           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="classSAMRAI_1_1tbox_1_1Pointer.html">tbox::Pointer</a>&lt; <a class="el" href="classSAMRAI_1_1tbox_1_1Database.html">tbox::Database</a> &gt;&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>db</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
The following routine:<p>
<a class="el" href="classSAMRAI_1_1appu_1_1EmbeddedBoundaryGeometry.html#a17">putToDatabase()</a><p>
is a concrete implementation of a function declared in the <a class="el" href="classSAMRAI_1_1tbox_1_1Serializable.html">tbox::Serializable</a> abstract base class.     </td>
  </tr>
</table>
<hr>The documentation for this class was generated from the following files:<ul>
<li>source/apputils/embedded_boundary/<a class="el" href="EmbeddedBoundaryGeometry_8h.html">EmbeddedBoundaryGeometry.h</a><li>source/apputils/embedded_boundary/<a class="el" href="EmbeddedBoundaryGeometry_8C.html">EmbeddedBoundaryGeometry.C</a></ul>
<hr size="1"><address style="align: right;"><small>Generated on Fri Dec 2 11:23:30 2005 for SAMRAI by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.2 </small></address>
</body>
</html>
